; 
; Copyright (c) 2015, RISC OS Open Ltd
; All rights reserved.
; 
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met: 
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
; 
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Proc
        GET     Hdr:OSMisc

PVirt   SETA    PVSys

        AREA    |RW$$Code|, CODE, PIC

        EXPORT  handler_install
        EXPORT  handler_remove
        IMPORT  handler_do

_PVirt  SETS    "ZP_PVirt"
        ASSERT  PVSys != 1
 [ PVSys > 1
PVSys   SETA    2
        PVJumpTable
 ]

handler_install
        Entry
        ; Store C handler pointer
        STR     r0, handler_ptr
        ; Get relocation offsets
        SUB     r0, sl, #540
        LDMIA   r0, {r1-r2}
        ADR     r0, reloc_offsets
        STMIA   r0, {r1-r2}

        InitPVOps

        ; Install handler
        ; IRQs off for safety!
        pvMRS   r2, CPSR
        ORR     r3, r2, #I32_bit
        pvMSR   CPSR_c, r3

        MOV     r0, #256+4
        ADR     r1, handler_stub
        SWI     XOS_ClaimProcessorVector
        STRVC   r1, old_handler
        pvMSR   CPSR_c, r2
        MOVVC   r0, #0
        EXIT

handler_remove
        Entry
        MOV     r0, #4
        LDR     r1, old_handler
        ADR     r2, handler_stub
        SWI     XOS_ClaimProcessorVector
        MOVVC   r0, #0
        EXIT

; Note that we assume that we're running from RAM and so don't need to copy this
; stub to workspace (Lack of READONLY flag will ensure that we get copied to RAM
; by the cmhg module init code on startup)

old_handler
        DCD     0
reloc_offsets
        DCD     0
        DCD     0
handler_ptr
        DCD     0

handler_stub    ROUT
        ; Get a work register
        STR     lr, [sp, #-12]!
        ; Check DFAR lies within zero page
      [ PVirt > 1
        STR     r0, [sp, #-4]!
        BL      $_PVirt._GetVCPU
        LDR     lr, [r0, #vcpu_DFAR]
        LDR     r0, [sp], #4
      |
        MRC     p15, 0, lr, c6, c0, 0
      ]
        CMP     lr, #&4000
        LDRHS   lr, [sp], #12
        LDRHS   pc, old_handler
        ; Looks like we might have some work to do. Save the abort context and
        ; call the full handler.
        STR     lr, [sp, #8]
        pvMRS   lr, SPSR
        STR     lr, [sp, #4]
        ; Keep things simple and only deal with USR32 & SVC32 modes, ARM mode, FIQs enabled
        AND     lr, lr, #M32_bits+T32_bit+F32_bit
        TEQ     lr, #USR32_mode
        TEQNE   lr, #SVC32_mode
        LDRNE   lr, [sp], #12
        LDRNE   pc, old_handler
        SUB     sp, sp, #15*4
      [ PVirt > 1
        STMIA   sp, {r0-r12}
        MOV     r3, lr
        BL      $_PVirt._GetVCPU
        LDR     r1, [r0, #vcpu_r13_usr]
        LDR     r2, [r0, #vcpu_r14_usr]
        STR     r1, [sp, #13*4]
        STR     r2, [sp, #14*4]
        MOV     lr, r3
      |
        STMIA   sp, {r0-r14}^
      ]
        MOV     r0, sp
        ; Grab SVC r13/r14 if necessary
        TEQ     lr, #SVC32_mode
        BNE     %FT10
        pvMSR   CPSR_c, #SVC32_mode+I32_bit
        STR     r13, [r0, #13*4]
        STR     r14, [r0, #14*4]
        pvMSR   CPSR_c, #ABT32_mode+I32_bit
10
        ; Set up C environment. CMHG veneer could perhaps be used here, except
        ; that it will try to switch to SVC mode and I don't want to assume that
        ; the SVC stack is in a sane state.
        ADR     r1, reloc_offsets
        MOV     sl, sp, LSR #20
        LDMIA   r1, {r1-r2}
        MOV     sl, sl, LSL #20
        LDMIA   sl, {r4-r5}
        MOV     fp, #0
        STMIA   sl, {r1-r2}
        ADD     sl, sl, #540
        ; Grab system control register
      [ PVirt > 1
        MOV     r1, #(1<<22) ; FIXME
      |
        MRC     p15, 0, r1, c1, c0, 0
      ]
        ; Call main handler
        MOV     lr, pc
        LDR     pc, handler_ptr
        ; Restore poked stack
        SUB     sl, sl, #540
        STMIA   sl, {r4-r5}
        ; Restore context. Only the main integer registers should have changed,
        ; and if we're expecting to pass on the abort the live DFAR/DFSR
        ; shouldn't have been clobbered
        LDR     r1, [sp, #16*4] ; Get original SPSR
        MOV     r14, r0
        pvMSR   SPSR_cxsf, r1
        TST     r1, #3 ; SVC mode?
        BNE     %FT50
        ; USR mode
      [ PVirt > 1
        BL      $_PVirt._GetVCPU
        LDR     r1, [sp, #13*4]
        LDR     r2, [sp, #14*4]
        STR     r1, [r0, #vcpu_r13_usr]
        STR     r2, [r0, #vcpu_r14_usr]
        LDMIA   sp, {r0-r12}
      |
        LDMIA   sp, {r0-r14}^
      ]
        NOP     ; Required for pre-ARMv6
        ADD     sp, sp, #15*4
        ; Return code was 1 if handled, 0 if we should pass on
        TEQ     r14, #0
        LDR     r14, [sp], #12
        MOVS_PC_LR NE
        LDR     pc, old_handler
50
        ; SVC mode
        MOV     r0, sp
        pvMSR   CPSR_c, #SVC32_mode+I32_bit
        LDMIA   r0, {r0-r14}
        pvMSR   CPSR_c, #ABT32_mode+I32_bit
        ADD     sp, sp, #15*4
        ; Return code was 1 if handled, 0 if we should pass on
        TEQ     r14, #0
        LDR     r14, [sp], #12
        MOVS_PC_LR NE
        LDR     pc, old_handler

        END
