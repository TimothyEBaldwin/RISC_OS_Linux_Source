REM This source code in this file is licensed to You by Castle Technology
REM Limited ("Castle") and its licensors on contractual terms and conditions
REM ("Licence") which entitle you freely to modify and/or to distribute this
REM source code subject to Your compliance with the terms of the Licence.
REM 
REM This source code has been made available to You without any warranties
REM whatsoever. Consequently, Your use, modification and distribution of this
REM source code is entirely at Your own risk and neither Castle, its licensors
REM nor any other person who has contributed to this source code shall be
REM liable to You for any loss or damage which You may suffer as a result of
REM Your use, modification or distribution of this source code.
REM 
REM Full details of Your rights and obligations are set out in the Licence.
REM You should have received a copy of the Licence with this source code file.
REM If You have not received a copy, the text of the Licence is available
REM online at www.castle-technology.co.uk/riscosbaselicence.htm
REM 
REM >VFPLib
REM ***************************************
REM ** RISC OS BASIC VFP Support Library **
REM **       (C)2011 TBA Software        **
REM **          By Alan Peters           **
REM ***************************************

REM ************************
REM ** Initialise VFP Lib **
REM ************************
REM called by host program when library is loaded

DEF PROCinitVFPLib
  vfpdebug%=0
  PROCvfp_setuplookup
ENDPROC

REM ***********************
REM **                   **
REM ** Set-up the Lookup **
REM **                   **
REM ***********************

DEF PROCvfp_setuplookup

  vfplookup%=0                         : REM current lookup number
  vfplookupsize%=512                   : REM maximum number of lookups
  DIM vfppattern$(vfplookupsize%)      : REM instruction pattern
  DIM vfpencoding$(vfplookupsize%)     : REM encoding name
  DIM vfpdtfilter$(vfplookupsize%)     : REM data-type filter
  DIM vfpalign$(vfplookupsize%)        : REM allowed alignment list
  DIM vfpparam$(vfplookupsize%)        : REM extra 'op' parameters

  vfpenc%=0                            : REM current encoding number
  vfpencsize%=256                      : REM maximum number of encodings
  DIM vfpversion$(vfpencsize%)         : REM applicable versions string ("2"=VFPv2,"3"=VFPv3,"S"=SIMD)
  DIM vfpencname$(vfpencsize%)         : REM encoding name
  DIM vfpbitpattern$(vfpencsize%)      : REM 32bit pattern for assembly
  DIM vfpopcmode$(vfpencsize%)         : REM opcmode list (used in certain complex instructions)

  vfpop%=0                             : REM current op number
  vfpopsize%=64                        : REM maximum number of ops per instruction
  DIM vfpop$(vfpopsize%)               : REM op name
  DIM vfpopval$(vfpopsize%)            : REM op value string  (used for debugging)
  DIM vfpopval%(vfpopsize%)            : REM op value integer (the value actually used)
  DIM vfpopinc%(vfpopsize%)            : REM op inc counter   (used for incremental register lists as next register number)

  REM ********************************
  REM ** Create Syntax Lookup Table **
  REM ********************************
  REM used to match the format of the string supplied to a particular encoding and generate a set of parameters (ops)
  REM <syntax>,<encoding name>,<datatype filter>,<align list>,<params>
  REM syntax          - syntax string for a particular version of the instruction
  REM                 - {}~  surrounds optional items - the optional ~ means the option repeats which is used for register lists
  REM                 - | is used within an optional to create an alternative option - one of the alternatives must be hit
  REM                 - <> surrounds system opcodes - these generate op's (variables) for use in the later encoding bitstring evaluation
  REM                      c       = condition code
  REM                      dt      = data type depending on instruction  - I8/I16/I32/I64, S8/S16/S32/S64, U8/U16/U32/U64 or F32
  REM                      size    = data size for certain SIMD operations - 8/16/32/64
  REM                                NB - for dt/size the following ops are created:
  REM                                     size  = %00,%01,%10,%11 where the data-type size is 8/16/32/64
  REM                                     size1 = size - 1
  REM                                     imm3  = %001,%010,%100 where the data-type size is 8/16/32
  REM                                     U     = 1 if unsigned otherwise 0
  REM                                     F     = 1 if float (F32) otherwise 0
  REM                      Sn      = FP32 single precision register with name 'n'
  REM                                creates op Vn = encoded register number
  REM                      Dn      = FP64 double precision register with name 'n' , op Q=0 set
  REM                                creates op Vn = encoded register number
  REM                      Dn[x]y  = FP64 double precision register with name 'n', scalar offset x within register based on data-type <dt>
  REM                                y is an optional register number limit in hex (0-F),
  REM                                creates op x containing the scalar offset
  REM                      (...)   = surrounds register list (translated to {} to match with instruction)
  REM                      Dn+a    = Double register with a constant offset 'a' from the first register in the list eg <Dn>,<Dn+2>,<Dn+4>
  REM                      Sn+a    = Single register with a constant offset 'a' from the first register in the list
  REM                      Dn+?    = Double register with incremental offset - used to create repeating loop inside {}~
  REM                      Qn      = SIMD register with name 'n' - op Q=1 set
  REM                                creates op Vn = encoded register number
  REM                      Rn-     = ARM core register with name 'N'
  REM                                - is optional - follows a register to indicate the right hand sign of a range eg: <Rt>{-<Rt->)}
  REM                      @       = set alignment (used to validate alignement of pointers in hardware)
  REM                      !       = optional writeback flag
  REM                      #-n     = absolute amount
  REM                                - = optional negate flag (negates the number specified)
  REM                                n = the number of bits for the immdiate 1-8
  REM                                    alternatively n can be set to one of the following:
  REM                                    c = encode to 8-bit immediate constant using data type/opcmode rules
  REM                                    d = 6-bit constant between 1 and <size>
  REM                                    e = 6-bit constant between 1 and <size>/2
  REM                                    f = 4-bit constant between 1 (or 0 iff <size>==16) and <size>
  REM                                    g = 6-bit constant between 0 and <size>-1
  REM                                    h = 6-bit constant between 1 and <size>-1
  REM                         sx   = s = optional shift flag
  REM                                    when specified x is the number of bits to shift the number left
  REM                      #+-n    = special version for register offsets from -1020 to +1020 word aligned
  REM                      lbl     = label - expression version of #+-10 relative to R15
  REM
  REM                 - other chars must be matched exactly with the input string
  REM encoding name   - name to match in encoding table - locates the appropriate bitstring, rules, and version data
  REM datatype filter - list of valid data-types - used when <dt> is in the syntax for SIMD
  REM                 - also used to specify the maximum number of registers when a register list is in use VPUSH/VPOP/VLDM/VSTM
  REM align list      - alignment list - list of available alignments and encodings, starts with ? if per data-type split by |
  REM                                    each alignment is nxe where n is alignment and e is bit encoding eg 128x11
  REM                                    examples -  64x01,128x10,256x11    - all three options for all data-types
  REM                                             - ?64x01|128x10|256x11    - 64 for first data-type, 128 2nd, 256 3rd
  REM params          - list of optional parameters - these are added to the 'op' variable table for use in the encoding bitstring evaluation
  REM                                               - bp_ prefixes a bitstring
  REM                                               - bp_? prefixes a bistring with a value per data-type (sequenced as per datatype filter)
  REM                                               - bitstrings contain 0, 1 or an op name followed by bit numbers (0-F) inside [], eg 1010Vn[3210]

  REM VDIV
  PROCvfp_addlookup("VDIV{<c>}.<dt> <Sd>,<Sn>,<Sm>"    ,"VDIV A1"                               ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VDIV{<c>}.<dt> <Dd>,<Dn>,<Dm>"    ,"VDIV A1"                               ,"F64"                   ,"" ,"")

  REM VSQRT
  PROCvfp_addlookup("VSQRT{<c>}.<dt> <Dd>,<Dm>"        ,"VSQRT A1"                              ,"F64"                   ,"" ,"")
  PROCvfp_addlookup("VSQRT{<c>}.<dt> <Sd>,<Sm>"        ,"VSQRT A1"                              ,"F32"                   ,"" ,"")

  REM VAND/VBIC
  PROCvfp_addlookup("VAND.<dt> <Qd>,<#-32>"            ,"VBIC (immediate) A1"                   ,"I8,I16,I32,I64,F32"    ,"" ,"")
  PROCvfp_addlookup("VAND.<dt> <Dd>,<#-32>"            ,"VBIC (immediate) A1"                   ,"I8,I16,I32,I64,F32"    ,"" ,"")
  PROCvfp_addlookup("VBIC.<dt> <Qd>,<#32>"             ,"VBIC (immediate) A1"                   ,"I8,I16,I32,I64,F32"    ,"" ,"")
  PROCvfp_addlookup("VBIC.<dt> <Dd>,<#32>"             ,"VBIC (immediate) A1"                   ,"I8,I16,I32,I64,F32"    ,"" ,"")

  PROCvfp_addlookup("VAND{.<size>} <Qd>,<Qn>,<Qm>"     ,"VBIC (register) A1"                    ,"ALL"                   ,"" ,"op=0")
  PROCvfp_addlookup("VAND{.<size>} <Dd>,<Dn>,<Dm>"     ,"VBIC (register) A1"                    ,"ALL"                   ,"" ,"op=0")
  PROCvfp_addlookup("VBIC{.<size>} <Qd>,<Qn>,<Qm>"     ,"VBIC (register) A1"                    ,"ALL"                   ,"" ,"op=1")
  PROCvfp_addlookup("VBIC{.<size>} <Dd>,<Dn>,<Dm>"     ,"VBIC (register) A1"                    ,"ALL"                   ,"" ,"op=1")

  PROCvfp_addlookup("VORR{.<dt>} <Qd>,<#32>"           ,"VORR (immediate) A1"                   ,"I16,I32"               ,"" ,"")
  PROCvfp_addlookup("VORR{.<dt>} <Dd>,<#32>"           ,"VORR (immediate) A1"                   ,"I16,I32"               ,"" ,"")
  PROCvfp_addlookup("VORN{.<dt>} <Qd>,<#-32>"          ,"VORR (immediate) A1"                   ,"I16,I32"               ,"" ,"")
  PROCvfp_addlookup("VORN{.<dt>} <Dd>,<#-32>"          ,"VORR (immediate) A1"                   ,"I16,I32"               ,"" ,"")

  PROCvfp_addlookup("VORR{.<size>} <Qd>,<Qn>,<Qm>"     ,"VORR (register) A1"                    ,"ALL"                   ,"" ,"op=0")
  PROCvfp_addlookup("VORR{.<size>} <Dd>,<Dn>,<Dm>"     ,"VORR (register) A1"                    ,"ALL"                   ,"" ,"op=0")
  PROCvfp_addlookup("VORN{.<size>} <Qd>,<Qn>,<Qm>"     ,"VORR (register) A1"                    ,"ALL"                   ,"" ,"op=1")
  PROCvfp_addlookup("VORN{.<size>} <Dd>,<Dn>,<Dm>"     ,"VORR (register) A1"                    ,"ALL"                   ,"" ,"op=1")

  PROCvfp_addlookup("VTST.<size> <Qd>,<Qn>,<Qm>"       ,"VTST A1"                               ,"8,16,32"               ,"" ,"")
  PROCvfp_addlookup("VTST.<size> <Dd>,<Dn>,<Dm>"       ,"VTST A1"                               ,"8,16,32"               ,"" ,"")

  REM VMUL/VMLA/VMLAL,VMLS,VMLSL
  PROCvfp_addlookup("VMUL.<dt> <Qd>,<Qn>,<Qm>"         ,"VMUL (floating-point) A1"              ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VMUL.<dt> <Dd>,<Dn>,<Dm>"         ,"VMUL (floating-point) A1"              ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VMUL{<c>}.<dt> <Dd>,<Dn>,<Dm>"    ,"VMUL (floating-point) A2"              ,"F64"                   ,"" ,"")
  PROCvfp_addlookup("VMUL{<c>}.<dt> <Sd>,<Sn>,<Sm>"    ,"VMUL (floating-point) A2"              ,"F32"                   ,"" ,"")

  PROCvfp_addlookup("VMLA.<dt> <Qd>,<Qn>,<Qm>"         ,"VMLA,VMLAL,VMLS,VMLSL (integer) A1"    ,"I8,I16,I32"            ,"" ,"op=0")
  PROCvfp_addlookup("VMLA.<dt> <Dd>,<Dn>,<Dm>"         ,"VMLA,VMLAL,VMLS,VMLSL (integer) A1"    ,"I8,I16,I32"            ,"" ,"op=0")
  PROCvfp_addlookup("VMLAL.<dt> <Qd>,<Dn>,<Dm>"        ,"VMLA,VMLAL,VMLS,VMLSL (integer) A2"    ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=0")

  PROCvfp_addlookup("VMLS.<dt> <Qd>,<Qn>,<Qm>"         ,"VMLA,VMLAL,VMLS,VMLSL (integer) A1"    ,"I8,I16,I32"            ,"" ,"op=1")
  PROCvfp_addlookup("VMLS.<dt> <Dd>,<Dn>,<Dm>"         ,"VMLA,VMLAL,VMLS,VMLSL (integer) A1"    ,"I8,I16,I32"            ,"" ,"op=1")
  PROCvfp_addlookup("VMLSL.<dt> <Qd>,<Dn>,<Dm>"        ,"VMLA,VMLAL,VMLS,VMLSL (integer) A2"    ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=1")

  PROCvfp_addlookup("VMUL.<dt> <Qd>,<Qn>,<Dm[x]7>"     ,"VMUL,VMULL (by scalar) A1"             ,"I16"                   ,"" ,"Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VMUL.<dt> <Qd>,<Qn>,<Dm[x]F>"     ,"VMUL,VMULL (by scalar) A1"             ,"I32,F32"               ,"" ,"Vmx=bp_x[0]Vm[3210]")
  PROCvfp_addlookup("VMUL.<dt> <Dd>,<Dn>,<Dm[x]7>"     ,"VMUL,VMULL (by scalar) A1"             ,"I16"                   ,"" ,"Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VMUL.<dt> <Dd>,<Dn>,<Dm[x]F>"     ,"VMUL,VMULL (by scalar) A1"             ,"I32,F32"               ,"" ,"Vmx=bp_x[0]Vm[3210]")

  PROCvfp_addlookup("VMULL.<dt> <Qd>,<Dn>,<Dm[x]7>"    ,"VMUL,VMULL (by scalar) A2"             ,"S16,U16"               ,"" ,"Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VMULL.<dt> <Qd>,<Dn>,<Dm[x]F>"    ,"VMUL,VMULL (by scalar) A2"             ,"S32,U32"               ,"" ,"Vmx=bp_x[0]Vm[3210]")

  PROCvfp_addlookup("VMUL.<dt> <Qd>,<Qn>,<Qm>"         ,"VMUL,VMULL (by integer and poly) A1"   ,"I8,I16,I32"            ,"" ,"op=0")
  PROCvfp_addlookup("VMUL.<dt> <Qd>,<Qn>,<Qm>"         ,"VMUL,VMULL (by integer and poly) A1"   ,"P8"                    ,"" ,"op=1,size=%00,U=0")
  PROCvfp_addlookup("VMUL.<dt> <Dd>,<Dn>,<Dm>"         ,"VMUL,VMULL (by integer and poly) A1"   ,"I8,I16,I32"            ,"" ,"op=0")
  PROCvfp_addlookup("VMUL.<dt> <Dd>,<Dn>,<Dm>"         ,"VMUL,VMULL (by integer and poly) A1"   ,"P8"                    ,"" ,"op=1,size=%00,U=0")
  PROCvfp_addlookup("VMULL.<dt> <Qd>,<Dn>,<Dm>"        ,"VMUL,VMULL (by integer and poly) A2"   ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=0")
  PROCvfp_addlookup("VMULL.<dt> <Qd>,<Dn>,<Dm>"        ,"VMUL,VMULL (by integer and poly) A2"   ,"P8"                    ,"" ,"op=1,size=%00,U=0")

  REM VADD/VSUB
  PROCvfp_addlookup("VADD.<dt> <Qd>,<Qn>,<Qm>"         ,"VADD (integer) A1"                     ,"I8,I16,I32,I64"        ,"" ,"")
  PROCvfp_addlookup("VADD.<dt> <Dd>,<Dn>,<Dm>"         ,"VADD (integer) A1"                     ,"I8,I16,I32,I64"        ,"" ,"")

  PROCvfp_addlookup("VADDHN.<dt> <Dd>,<Qn>,<Qm>"       ,"VADDHN A1"                             ,"I16,I32,I64"           ,"" ,"")
  PROCvfp_addlookup("VADDL.<dt> <Qd>,<Dn>,<Dm>"        ,"VADDL,VADDW A1"                        ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=0")
  PROCvfp_addlookup("VADDW.<dt> <Qd>,<Qn>,<Dm>"        ,"VADDL,VADDW A1"                        ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=1")

  PROCvfp_addlookup("VADD.<dt> <Qd>,<Qn>,<Qm>"         ,"VADD (floating-point) A1"              ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VADD.<dt> <Dd>,<Dn>,<Dm>"         ,"VADD (floating-point) A1"              ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VADD{<c>}.<dt> <Dd>,<Dn>,<Dm>"    ,"VADD (floating-point) A2"              ,"F64"                   ,"" ,"")
  PROCvfp_addlookup("VADD{<c>}.<dt> <Sd>,<Sn>,<Sm>"    ,"VADD (floating-point) A2"              ,"F32"                   ,"" ,"")

  PROCvfp_addlookup("VSUB.<dt> <Qd>,<Qn>,<Qm>"         ,"VSUB (floating-point) A1"              ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VSUB.<dt> <Dd>,<Dn>,<Dm>"         ,"VSUB (floating-point) A1"              ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VSUB{<c>}.<dt> <Dd>,<Dn>,<Dm>"    ,"VSUB (floating-point) A2"              ,"F64"                   ,"" ,"")
  PROCvfp_addlookup("VSUB{<c>}.<dt> <Sd>,<Sn>,<Sm>"    ,"VSUB (floating-point) A2"              ,"F32"                   ,"" ,"")

  REM VABS
  PROCvfp_addlookup("VABS.<dt> <Qd>,<Qm>"              ,"VABS A1"                               ,"S8,S16,S32,F32"        ,"" ,"")
  PROCvfp_addlookup("VABS.<dt> <Dd>,<Dm>"              ,"VABS A1"                               ,"S8,S16,S32,F32"        ,"" ,"")
  PROCvfp_addlookup("VABS{<c>}.<dt> <Dd>,<Dm>"         ,"VABS A2"                               ,"F64"                   ,"" ,"")
  PROCvfp_addlookup("VABS{<c>}.<dt> <Sd>,<Sm>"         ,"VABS A2"                               ,"F32"                   ,"" ,"")

  REM VMOVL/VMOVN - these appear first as VMOV LN option must be eliminated first
  PROCvfp_addlookup("VMOVL{<c>}.<dt> <Qd>,<Dm>"        ,"VMOVL A1"                              ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VMOVN{<c>}.<dt> <Dd>,<Qm>"        ,"VMOVN A1"                              ,"I16,I32,I64"           ,"" ,"")

  REM VMOV immediate A1 - note 64bit immediates must be in a string
  PROCvfp_addlookup("VMOV{<c>}{.<dt>} <Qd>,<#32>"      ,"VMOV (immediate) A1"                   ,"I8,I16,I32,I64,F32"    ,"" ,"")
  PROCvfp_addlookup("VMOV{<c>}{.<dt>} <Dd>,<#32>"      ,"VMOV (immediate) A1"                   ,"I8,I16,I32,I64,F32"    ,"" ,"")

  REM VMOV immediate A2
  PROCvfp_addlookup("VMOV{<c>}.<dt> <Dd>,<#32>"         ,"VMOV (immediate) A2"                   ,"F64"                   ,"" ,"")
  PROCvfp_addlookup("VMOV{<c>}.<dt> <Sd>,<#32>"         ,"VMOV (immediate) A2"                   ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VMOV{<c>}.<dt> <Dd>,<Dm>"         ,"VMOV (register) A2"                    ,"F64"                   ,"" ,"")
  PROCvfp_addlookup("VMOV{<c>}.<dt> <Sd>,<Sm>"         ,"VMOV (register) A2"                    ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VMOV{<c>}{.<size>} <Qd>,<Qm>"     ,"VMOV (register) A1"                    ,"ALL"                   ,"" ,"")
  PROCvfp_addlookup("VMOV{<c>}{.<size>} <Dd>,<Dm>"     ,"VMOV (register) A1"                    ,"ALL"                   ,"" ,"")

  REM VMOV - non ARM register first
  REM the order of these is imperative to allow "bad register" errors for ARM core registers
  PROCvfp_addlookup("VMOV{<c>}.<size> <Dd[x]>,<Rt>"    ,"VMOV (ARM core to scalar) A1"          ,"8,16,32"               ,"" ,"opc=?bp_1x[210]|bp_0x[10]|bp_0x[0]00")
  PROCvfp_addlookup("VMOV{<c>} <Sm>,<Sn>,<Rt>,<Ru>"    ,"VMOV (two ARM core and two single) A1" ,""                      ,"" ,"op=0")
  PROCvfp_addlookup("VMOV{<c>} <Sn>,<Rt>"              ,"VMOV (ARM core and single) A1"         ,""                      ,"" ,"op=0")
  PROCvfp_addlookup("VMOV{<c>} <Dm>,<Rt>,<Ru>"         ,"VMOV (two ARM core and doubleword) A1" ,""                      ,"" ,"op=0")
  REM VMOV - ARM register(s) first
  REM page 959 of ARM - encoding of opc is assumed same as above with U=unsigned
  PROCvfp_addlookup("VMOV{<c>}.<dt> <Rt>,<Dn[x]>"      ,"VMOV (scalar to ARM core) A1"          ,"S8"                    ,"" ,"opc=bp_1x[210]")
  PROCvfp_addlookup("VMOV{<c>}.<dt> <Rt>,<Dn[x]>"      ,"VMOV (scalar to ARM core) A1"          ,"S16"                   ,"" ,"opc=bp_0x[10]1")
  PROCvfp_addlookup("VMOV{<c>}.<dt> <Rt>,<Dn[x]>"      ,"VMOV (scalar to ARM core) A1"          ,"U8"                    ,"" ,"opc=bp_1x[210]")
  PROCvfp_addlookup("VMOV{<c>}.<dt> <Rt>,<Dn[x]>"      ,"VMOV (scalar to ARM core) A1"          ,"U16"                   ,"" ,"opc=bp_0x[10]1")
  PROCvfp_addlookup("VMOV{<c>}.<size> <Rt>,<Dn[x]>"    ,"VMOV (scalar to ARM core) A1"          ,"32"                    ,"" ,"U=0,opc=bp_0x[0]00")
  PROCvfp_addlookup("VMOV{<c>} <Rt>,<Sn>"              ,"VMOV (ARM core and single) A1"         ,""                      ,"" ,"op=1")
  REM Sn ideally requires some validation as it must be Sm+1 (ignored in encoding)
  PROCvfp_addlookup("VMOV{<c>} <Rt>,<Ru>,<Sm>,<Sn>"    ,"VMOV (two ARM core and two single) A1" ,""                      ,"" ,"op=1")
  PROCvfp_addlookup("VMOV{<c>} <Rt>,<Ru>,<Dm>"         ,"VMOV (two ARM core and doubleword) A1" ,""                      ,"" ,"op=1")

  REM VMVN
  PROCvfp_addlookup("VMVN{.<size>} <Qd>,<Qm>"          ,"VMVN (register) A1"                    ,"ALL"                   ,"" ,"size=%00")
  PROCvfp_addlookup("VMVN{.<size>} <Dd>,<Dm>"          ,"VMVN (register) A1"                    ,"ALL"                   ,"" ,"size=%00")
  PROCvfp_addlookup("VMVN{.<dt>} <Qd>,<#32>"           ,"VMVN (immediate) A1"                   ,"I16,I32"               ,"" ,"")
  PROCvfp_addlookup("VMVN{.<dt>} <Dd>,<#32>"           ,"VMVN (immediate) A1"                   ,"I16,I32"               ,"", "")

  REM VMSR/VMRS - special versions must go first
  PROCvfp_addlookup("VMSR{<c>} <spec>,APSR_nzcv"       ,"VMSR A1"                               ,""                      ,"" ,"Rt=%1111")
  PROCvfp_addlookup("VMSR{<c>} <spec>,APSR_f"          ,"VMSR A1"                               ,""                      ,"" ,"Rt=%1111")
  PROCvfp_addlookup("VMRS{<c>} APSR_nzcv,<spec>"       ,"VMRS A1"                               ,""                      ,"" ,"Rt=%1111")
  PROCvfp_addlookup("VMRS{<c>} APSR_f,<spec>"          ,"VMRS A1"                               ,""                      ,"" ,"Rt=%1111")
  REM VMSR/VMRS - ARM core versions must go last to allow bad register error for <expr>
  PROCvfp_addlookup("VMSR{<c>} <spec>,<Rt>"            ,"VMSR A1"                               ,""                      ,"" ,"")
  PROCvfp_addlookup("VMRS{<c>} <Rt>,<spec>"            ,"VMRS A1"                               ,""                      ,"" ,"")

  REM VCMP/VCMPE
  PROCvfp_addlookup("VCMP{<c>}.<dt> <Dd>,<Dm>"          ,"VCMP,VCMPE A1"                        ,"F64"                   ,"" ,"E=0")
  PROCvfp_addlookup("VCMPE{<c>}.<dt> <Dd>,<Dm>"         ,"VCMP,VCMPE A1"                        ,"F64"                   ,"" ,"E=1")
  PROCvfp_addlookup("VCMP{<c>}.<dt> <Sd>,<Sm>"          ,"VCMP,VCMPE A1"                        ,"F32"                   ,"" ,"E=0")
  PROCvfp_addlookup("VCMPE{<c>}.<dt> <Sd>,<Sm>"         ,"VCMP,VCMPE A1"                        ,"F32"                   ,"" ,"E=1")

  PROCvfp_addlookup("VCMP{<c>}.<dt> <Dd>,#0{.0}"        ,"VCMP,VCMPE A2"                        ,"F64"                   ,"" ,"E=0")
  PROCvfp_addlookup("VCMPE{<c>}.<dt> <Dd>,#0{.0}"       ,"VCMP,VCMPE A2"                        ,"F64"                   ,"" ,"E=1")
  PROCvfp_addlookup("VCMP{<c>}.<dt> <Sd>,#0{.0}"        ,"VCMP,VCMPE A2"                        ,"F32"                   ,"" ,"E=0")
  PROCvfp_addlookup("VCMPE{<c>}.<dt> <Sd>,#0{.0}"       ,"VCMP,VCMPE A2"                        ,"F32"                   ,"" ,"E=1")

  REM VCEQ/VCGE/VCGT/VCLE/VCLT
  PROCvfp_addlookup("VCEQ.<dt> <Qd>,<Qn>,<Qm>"         ,"VCEQ (register) A1"                    ,"I8,I16,I32"            ,"" ,"")
  PROCvfp_addlookup("VCEQ.<dt> <Dd>,<Dn>,<Dm>"         ,"VCEQ (register) A1"                    ,"I8,I16,I32"            ,"" ,"")
  PROCvfp_addlookup("VCEQ.<dt> <Qd>,<Qn>,<Qm>"         ,"VCEQ (register) A2"                    ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VCEQ.<dt> <Dd>,<Dn>,<Dm>"         ,"VCEQ (register) A2"                    ,"F32"                   ,"" ,"")

  PROCvfp_addlookup("VCGE.<dt> <Qd>,<Qn>,<Qm>"         ,"VCGE (register) A1"                    ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VCGE.<dt> <Dd>,<Dn>,<Dm>"         ,"VCGE (register) A1"                    ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VCGE.<dt> <Qd>,<Qn>,<Qm>"         ,"VCGE (register) A2"                    ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VCGE.<dt> <Dd>,<Dn>,<Dm>"         ,"VCGE (register) A2"                    ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VCGT.<dt> <Qd>,<Qn>,<Qm>"         ,"VCGT (register) A1"                    ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VCGT.<dt> <Dd>,<Dn>,<Dm>"         ,"VCGT (register) A1"                    ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VCGT.<dt> <Qd>,<Qn>,<Qm>"         ,"VCGT (register) A2"                    ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VCGT.<dt> <Dd>,<Dn>,<Dm>"         ,"VCGT (register) A2"                    ,"F32"                   ,"" ,"")

  REM these two are pseudo instructions with registers swapped over
  PROCvfp_addlookup("VCLE.<dt> <Qd>,<Qm>,<Qn>"         ,"VCGE (register) A1"                    ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VCLE.<dt> <Dd>,<Dm>,<Dn>"         ,"VCGE (register) A1"                    ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VCLE.<dt> <Qd>,<Qm>,<Qn>"         ,"VCGE (register) A2"                    ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VCLE.<dt> <Dd>,<Dm>,<Dn>"         ,"VCGE (register) A2"                    ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VCLT.<dt> <Qd>,<Qm>,<Qn>"         ,"VCGT (register) A1"                    ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VCLT.<dt> <Dd>,<Dm>,<Dn>"         ,"VCGT (register) A1"                    ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VCLT.<dt> <Qd>,<Qm>,<Qn>"         ,"VCGT (register) A2"                    ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VCLT.<dt> <Dd>,<Dm>,<Dn>"         ,"VCGT (register) A2"                    ,"F32"                   ,"" ,"")

  PROCvfp_addlookup("VCEQ.<dt> <Qd>,<Qm>,#0"           ,"VCEQ (immediate #0) A1"                ,"I8,I16,I32,F32"        ,"" ,"")
  PROCvfp_addlookup("VCEQ.<dt> <Dd>,<Dm>,#0"           ,"VCEQ (immediate #0) A1"                ,"I8,I16,I32,F32"        ,"" ,"")
  PROCvfp_addlookup("VCGE.<dt> <Qd>,<Qm>,#0"           ,"VCGE (immediate #0) A1"                ,"S8,S16,S32,F32"        ,"" ,"")
  PROCvfp_addlookup("VCGE.<dt> <Dd>,<Dm>,#0"           ,"VCGE (immediate #0) A1"                ,"S8,S16,S32,F32"        ,"" ,"")
  PROCvfp_addlookup("VCGT.<dt> <Qd>,<Qm>,#0"           ,"VCGT (immediate #0) A1"                ,"S8,S16,S32,F32"        ,"" ,"")
  PROCvfp_addlookup("VCGT.<dt> <Dd>,<Dm>,#0"           ,"VCGT (immediate #0) A1"                ,"S8,S16,S32,F32"        ,"" ,"")
  PROCvfp_addlookup("VCLE.<dt> <Qd>,<Qm>,#0"           ,"VCLE (immediate #0) A1"                ,"S8,S16,S32,F32"        ,"" ,"")
  PROCvfp_addlookup("VCLE.<dt> <Dd>,<Dm>,#0"           ,"VCLE (immediate #0) A1"                ,"S8,S16,S32,F32"        ,"" ,"")
  PROCvfp_addlookup("VCLT.<dt> <Qd>,<Qm>,#0"           ,"VCLT (immediate #0) A1"                ,"S8,S16,S32,F32"        ,"" ,"")
  PROCvfp_addlookup("VCLT.<dt> <Dd>,<Dm>,#0"           ,"VCLT (immediate #0) A1"                ,"S8,S16,S32,F32"        ,"" ,"")

  REM VFP convert
  PROCvfp_addlookup("VCVT{<c>}.S32.<dt> <Sd>,<Dm>"     ,"VCVT,VCVTR (float and integer,VFP) A1" ,"F64"                   ,"" ,"opc2=%101,op=1")
  PROCvfp_addlookup("VCVT{<c>}.S32.<dt> <Sd>,<Sm>"     ,"VCVT,VCVTR (float and integer,VFP) A1" ,"F32"                   ,"" ,"opc2=%101,op=1")
  PROCvfp_addlookup("VCVTR{<c>}.S32.<dt> <Sd>,<Dm>"    ,"VCVT,VCVTR (float and integer,VFP) A1" ,"F64"                   ,"" ,"opc2=%101,op=0")
  PROCvfp_addlookup("VCVTR{<c>}.S32.<dt> <Sd>,<Sm>"    ,"VCVT,VCVTR (float and integer,VFP) A1" ,"F32"                   ,"" ,"opc2=%101,op=0")

  PROCvfp_addlookup("VCVT{<c>}.U32.<dt> <Sd>,<Dm>"     ,"VCVT,VCVTR (float and integer,VFP) A1" ,"F64"                   ,"" ,"opc2=%100,op=1")
  PROCvfp_addlookup("VCVT{<c>}.U32.<dt> <Sd>,<Sm>"     ,"VCVT,VCVTR (float and integer,VFP) A1" ,"F32"                   ,"" ,"opc2=%100,op=1")
  PROCvfp_addlookup("VCVTR{<c>}.U32.<dt> <Sd>,<Dm>"    ,"VCVT,VCVTR (float and integer,VFP) A1" ,"F64"                   ,"" ,"opc2=%100,op=0")
  PROCvfp_addlookup("VCVTR{<c>}.U32.<dt> <Sd>,<Sm>"    ,"VCVT,VCVTR (float and integer,VFP) A1" ,"F32"                   ,"" ,"opc2=%100,op=0")

  PROCvfp_addlookup("VCVT{<c>}.<dt>.S32 <Dd>,<Sm>"     ,"VCVT,VCVTR (float and integer,VFP) A1" ,"F64"                   ,"" ,"opc2=%000,op=1")
  PROCvfp_addlookup("VCVT{<c>}.<dt>.U32 <Dd>,<Sm>"     ,"VCVT,VCVTR (float and integer,VFP) A1" ,"F64"                   ,"" ,"opc2=%000,op=0")
  PROCvfp_addlookup("VCVT{<c>}.<dt>.S32 <Sd>,<Sm>"     ,"VCVT,VCVTR (float and integer,VFP) A1" ,"F32"                   ,"" ,"opc2=%000,op=1")
  PROCvfp_addlookup("VCVT{<c>}.<dt>.U32 <Sd>,<Sm>"     ,"VCVT,VCVTR (float and integer,VFP) A1" ,"F32"                   ,"" ,"opc2=%000,op=0")

  PROCvfp_addlookup("VCVT{<c>}.F64.<dt> <Dd>,<Sm>"     ,"VCVT (double and single) A1"           ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VCVT{<c>}.D.<dt> <Dd>,<Sm>"       ,"VCVT (double and single) A1"           ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VCVT{<c>}.F32.<dt> <Sd>,<Dm>"     ,"VCVT (double and single) A1"           ,"F64"                   ,"" ,"")
  PROCvfp_addlookup("VCVT{<c>}.F.<dt> <Sd>,<Dm>"       ,"VCVT (double and single) A1"           ,"F64"                   ,"" ,"")

  PROCvfp_addlookup("VCVT.<dt>.F32 <Qd>,<Qm>,<#c>"     ,"VCVT (float and fixed,SIMD) A1"        ,"S32,U32"               ,"" ,"op=1")
  PROCvfp_addlookup("VCVT.<dt>.F32 <Dd>,<Dm>,<#c>"     ,"VCVT (float and fixed,SIMD) A1"        ,"S32,U32"               ,"" ,"op=1")
  PROCvfp_addlookup("VCVT.<dt>.F <Qd>,<Qm>,<#c>"       ,"VCVT (float and fixed,SIMD) A1"        ,"S32,U32"               ,"" ,"op=1")
  PROCvfp_addlookup("VCVT.<dt>.F <Dd>,<Dm>,<#c>"       ,"VCVT (float and fixed,SIMD) A1"        ,"S32,U32"               ,"" ,"op=1")
  PROCvfp_addlookup("VCVT.F32.<dt> <Qd>,<Qm>,<#c>"     ,"VCVT (float and fixed,SIMD) A1"        ,"S32,U32"               ,"" ,"op=0,U=0")
  PROCvfp_addlookup("VCVT.F32.<dt> <Dd>,<Dm>,<#c>"     ,"VCVT (float and fixed,SIMD) A1"        ,"S32,U32"               ,"" ,"op=0,U=0")
  PROCvfp_addlookup("VCVT.F.<dt> <Qd>,<Qm>,<#c>"       ,"VCVT (float and fixed,SIMD) A1"        ,"S32,U32"               ,"" ,"op=0,U=0")
  PROCvfp_addlookup("VCVT.F.<dt> <Dd>,<Dm>,<#c>"       ,"VCVT (float and fixed,SIMD) A1"        ,"S32,U32"               ,"" ,"op=0,U=0")

  PROCvfp_addlookup("VCVT{<c>}.F64.<dt> <Dd>,<#f>"     ,"VCVT (float and fixed,VFP) A1"         ,"S16,U16,S32,U32"       ,"" ,"op=0,sf=1,sx=bp_size[1]")
  PROCvfp_addlookup("VCVT{<c>}.D.<dt> <Dd>,<#f>"       ,"VCVT (float and fixed,VFP) A1"         ,"S16,U16,S32,U32"       ,"" ,"op=0,sf=1,sx=bp_size[1]")
  PROCvfp_addlookup("VCVT{<c>}.F32.<dt> <Sd>,<#f>"     ,"VCVT (float and fixed,VFP) A1"         ,"S16,U16,S32,U32"       ,"" ,"op=0,sf=0,sx=bp_size[1]")
  PROCvfp_addlookup("VCVT{<c>}.F.<dt> <Sd>,<#f>"       ,"VCVT (float and fixed,VFP) A1"         ,"S16,U16,S32,U32"       ,"" ,"op=0,sf=0,sx=bp_size[1]")

  PROCvfp_addlookup("VCVT{<c>}.<dt>.F64 <Dd>,<#f>"     ,"VCVT (float and fixed,VFP) A1"         ,"S16,U16,S32,U32"       ,"" ,"op=1,sf=1,sx=bp_size[1]")
  PROCvfp_addlookup("VCVT{<c>}.<dt>.D <Dd>,<#f>"       ,"VCVT (float and fixed,VFP) A1"         ,"S16,U16,S32,U32"       ,"" ,"op=1,sf=1,sx=bp_size[1]")
  PROCvfp_addlookup("VCVT{<c>}.<dt>.F32 <Sd>,<#f>"     ,"VCVT (float and fixed,VFP) A1"         ,"S16,U16,S32,U32"       ,"" ,"op=1,sf=0,sx=bp_size[1]")
  PROCvfp_addlookup("VCVT{<c>}.<dt>.F <Sd>,<#f>"       ,"VCVT (float and fixed,VFP) A1"         ,"S16,U16,S32,U32"       ,"" ,"op=1,sf=0,sx=bp_size[1]")

  PROCvfp_addlookup("VCVT.S32.<dt> <Qd>,<Qm>"          ,"VCVT (float and integer,SIMD) A1"      ,"F32"                   ,"" ,"op=%10,size=%10")
  PROCvfp_addlookup("VCVT.S32.<dt> <Dd>,<Dm>"          ,"VCVT (float and integer,SIMD) A1"      ,"F32"                   ,"" ,"op=%10,size=%10")
  PROCvfp_addlookup("VCVT.U32.<dt> <Qd>,<Qm>"          ,"VCVT (float and integer,SIMD) A1"      ,"F32"                   ,"" ,"op=%11,size=%10")
  PROCvfp_addlookup("VCVT.U32.<dt> <Dd>,<Dm>"          ,"VCVT (float and integer,SIMD) A1"      ,"F32"                   ,"" ,"op=%11,size=%10")

  PROCvfp_addlookup("VCVT.<dt>.S32 <Qd>,<Qm>"          ,"VCVT (float and integer,SIMD) A1"      ,"F32"                   ,"" ,"op=%00,size=%10")
  PROCvfp_addlookup("VCVT.<dt>.S32 <Dd>,<Dm>"          ,"VCVT (float and integer,SIMD) A1"      ,"F32"                   ,"" ,"op=%00,size=%10")
  PROCvfp_addlookup("VCVT.<dt>.U32 <Qd>,<Qm>"          ,"VCVT (float and integer,SIMD) A1"      ,"F32"                   ,"" ,"op=%00,size=%10")
  PROCvfp_addlookup("VCVT.<dt>.U32 <Dd>,<Dm>"          ,"VCVT (float and integer,SIMD) A1"      ,"F32"                   ,"" ,"op=%01,size=%10")

  REM VLD/VST
  PROCvfp_addlookup("VLD1.<size> (<Dd>),[<Rn>{<@>}]<!>{,<Rm>}"                                      ,"VLD (multiple) A1"   ,"8,16,32,64" ,"64x01"                   ,"type=%0111")
  PROCvfp_addlookup("VLD1.<size> (<Dd>{,|-}<Dd+1>),[<Rn>{<@>}]<!>{,<Rm>}"                           ,"VLD (multiple) A1"   ,"8,16,32,64" ,"64x01,128x10"            ,"type=%1010")
  PROCvfp_addlookup("VLD1.<size> (<Dd>{,<Dd+1>,|-}<Dd+2>),[<Rn>{<@>}]<!>{,<Rm>}"                    ,"VLD (multiple) A1"   ,"8,16,32,64" ,"64x01"                   ,"type=%0110")
  PROCvfp_addlookup("VLD1.<size> (<Dd>{,<Dd+1>,<Dd+2>,|-}<Dd+3>),[<Rn>{<@>}]<!>{,<Rm>}"             ,"VLD (multiple) A1"   ,"8,16,32,64" ,"64x01,128x10,256x11"     ,"type=%0010")
  PROCvfp_addlookup("VST1.<size> (<Dd>),[<Rn>{<@>}]<!>{,<Rm>}"                                      ,"VST (multiple) A1"   ,"8,16,32,64" ,"64x01"                   ,"type=%0111")
  PROCvfp_addlookup("VST1.<size> (<Dd>{,|-}<Dd+1>),[<Rn>{<@>}]<!>{,<Rm>}"                           ,"VST (multiple) A1"   ,"8,16,32,64" ,"64x01,128x10"            ,"type=%1010")
  PROCvfp_addlookup("VST1.<size> (<Dd>{,<Dd+1>,|-}<Dd+2>),[<Rn>{<@>}]<!>{,<Rm>}"                    ,"VST (multiple) A1"   ,"8,16,32,64" ,"64x01"                   ,"type=%0110")
  PROCvfp_addlookup("VST1.<size> (<Dd>{,<Dd+1>,<Dd+2>,|-}<Dd+3>),[<Rn>{<@>}]<!>{,<Rm>}"             ,"VST (multiple) A1"   ,"8,16,32,64" ,"64x01,128x10,256x11"     ,"type=%0010")

  PROCvfp_addlookup("VLD2.<size> (<Dd>{,|-}<Dd+1>),[<Rn>{<@>}]<!>{,<Rm>}"                           ,"VLD (multiple) A1"   ,"8,16,32"    ,"64x01,128x10"            ,"type=%1000")
  PROCvfp_addlookup("VLD2.<size> (<Dd>,<Dd+2>),[<Rn>{<@>}]<!>{,<Rm>}"                               ,"VLD (multiple) A1"   ,"8,16,32"    ,"64x01,128x10"            ,"type=%1001")
  PROCvfp_addlookup("VLD2.<size> (<Dd>{,<Dd+1>,<Dd+2>,|-}<Dd+3>),[<Rn>{<@>}]<!>{,<Rm>}"             ,"VLD (multiple) A1"   ,"8,16,32"    ,"64x01,128x10,256x11"     ,"type=%0011")
  PROCvfp_addlookup("VST2.<size> (<Dd>{,|-}<Dd+1>),[<Rn>{<@>}]<!>{,<Rm>}"                           ,"VST (multiple) A1"   ,"8,16,32"    ,"64x01,128x10"            ,"type=%1000")
  PROCvfp_addlookup("VST2.<size> (<Dd>,<Dd+2>),[<Rn>{<@>}]<!>{,<Rm>}"                               ,"VST (multiple) A1"   ,"8,16,32"    ,"64x01,128x10"            ,"type=%1001")
  PROCvfp_addlookup("VST2.<size> (<Dd>{,<Dd+1>,<Dd+2>,|-}<Dd+3>),[<Rn>{<@>}]<!>{,<Rm>}"             ,"VST (multiple) A1"   ,"8,16,32"    ,"64x01,128x10,256x11"     ,"type=%0011")

  PROCvfp_addlookup("VLD3.<size> (<Dd>{,<Dd+1>,|-}<Dd+2>),[<Rn>{<@>}]<!>{,<Rm>}"                    ,"VLD (multiple) A1"   ,"8,16,32"    ,"64x01"                   ,"type=%0100")
  PROCvfp_addlookup("VLD3.<size> (<Dd>,<Dd+2>,<Dd+4>),[<Rn>{<@>}]<!>{,<Rm>}"                        ,"VLD (multiple) A1"   ,"8,16,32"    ,"64x01"                   ,"type=%0101")
  PROCvfp_addlookup("VST3.<size> (<Dd>{,<Dd+1>,|-}<Dd+2>),[<Rn>{<@>}]<!>{,<Rm>}"                    ,"VST (multiple) A1"   ,"8,16,32"    ,"64x01"                   ,"type=%0100")
  PROCvfp_addlookup("VST3.<size> (<Dd>,<Dd+2>,<Dd+4>),[<Rn>{<@>}]<!>{,<Rm>}"                        ,"VST (multiple) A1"   ,"8,16,32"    ,"64x01"                   ,"type=%0101")

  PROCvfp_addlookup("VLD4.<size> (<Dd>{,<Dd+1>,<Dd+2>,|-}<Dd+3>),[<Rn>{<@>}]<!>{,<Rm>}"             ,"VLD (multiple) A1"   ,"8,16,32"    ,"64x01,128x10,256x11"     ,"type=%0000")
  PROCvfp_addlookup("VLD4.<size> (<Dd>,<Dd+2>,<Dd+4>,<Dd+6>),[<Rn>{<@>}]<!>{,<Rm>}"                 ,"VLD (multiple) A1"   ,"8,16,32"    ,"64x01,128x10,256x11"     ,"type=%0001")
  PROCvfp_addlookup("VST4.<size> (<Dd>{,<Dd+1>,<Dd+2>,|-}<Dd+3>),[<Rn>{<@>}]<!>{,<Rm>}"             ,"VST (multiple) A1"   ,"8,16,32"    ,"64x01,128x10,256x11"     ,"type=%0000")
  PROCvfp_addlookup("VST4.<size> (<Dd>,<Dd+2>,<Dd+4>,<Dd+6>),[<Rn>{<@>}]<!>{,<Rm>}"                 ,"VST (multiple) A1"   ,"8,16,32"    ,"64x01,128x10,256x11"     ,"type=%0001")

  PROCvfp_addlookup("VLD1.<size> (<Dd[x]>),[<Rn>{<@>}]<!>{,<Rm>}"                                   ,"VLD (single one) A1" ,"8,16,32"    ,"?8x00|16x01|32x011"      ,"op=%00,ia=?bp_x[210]0|bp_x[10]align[10]|bp_x[0]align[210]")
  PROCvfp_addlookup("VST1.<size> (<Dd[x]>),[<Rn>{<@>}]<!>{,<Rm>}"                                   ,"VST (single one) A1" ,"8,16,32"    ,"?8x00|16x01|32x011"      ,"op=%00,ia=?bp_x[210]0|bp_x[10]align[10]|bp_x[0]align[210]")

  PROCvfp_addlookup("VLD2.<size> (<Dd[x]>{,|-}<Dd+1[x]>),[<Rn>{<@>}]<!>{,<Rm>}"                     ,"VLD (single one) A1" ,"8,16,32"    ,"?16x1|32x1|64x1"         ,"op=%01,ia=?bp_x[210]align[0]|bp_x[10]0align[0]|bp_x[0]0align[10]")
  PROCvfp_addlookup("VST2.<size> (<Dd[x]>{,|-}<Dd+1[x]>),[<Rn>{<@>}]<!>{,<Rm>}"                     ,"VST (single one) A1" ,"8,16,32"    ,"?16x1|32x1|64x1"         ,"op=%01,ia=?bp_x[210]align[0]|bp_x[10]0align[0]|bp_x[0]0align[10]")
  PROCvfp_addlookup("VLD2.<size> (<Dd[x]>,<Dd+2[x]>),[<Rn>{<@>}]<!>{,<Rm>}"                         ,"VLD (single one) A1" ,"16,32"      ,"?32x1|64x1"              ,"op=%01,ia=?bp_x[10]1align[0]|bp_x[0]1align[10]")
  PROCvfp_addlookup("VST2.<size> (<Dd[x]>,<Dd+2[x]>),[<Rn>{<@>}]<!>{,<Rm>}"                         ,"VST (single one) A1" ,"16,32"      ,"?32x1|64x1"              ,"op=%01,ia=?bp_x[10]1align[0]|bp_x[0]1align[10]")

  PROCvfp_addlookup("VLD3.<size> (<Dd[x]>{,<Dd+1[x]>,|-}<Dd+2[x]>),[<Rn>]<!>{,<Rm>}"                ,"VLD (single one) A1" ,"8,16,32"    ,""                        ,"op=%10,ia=?bp_x[210]0|bp_x[10]00|bp_x[0]000")
  PROCvfp_addlookup("VST3.<size> (<Dd[x]>{,<Dd+1[x]>,|-}<Dd+2[x]>),[<Rn>]<!>{,<Rm>}"                ,"VST (single one) A1" ,"8,16,32"    ,""                        ,"op=%10,ia=?bp_x[210]0|bp_x[10]00|bp_x[0]000")
  PROCvfp_addlookup("VLD3.<size> (<Dd[x]>,<Dd+2[x]>,<Dd+4[x]>),[<Rn>]<!>{,<Rm>}"                    ,"VLD (single one) A1" ,"16,32"      ,""                        ,"op=%10,ia=?bp_x[10]10|bp_x[0]100")
  PROCvfp_addlookup("VST3.<size> (<Dd[x]>,<Dd+2[x]>,<Dd+4[x]>),[<Rn>]<!>{,<Rm>}"                    ,"VST (single one) A1" ,"16,32"      ,""                        ,"op=%10,ia=?bp_x[10]10|bp_x[0]100")

  PROCvfp_addlookup("VLD4.<size> (<Dd[x]>{,<Dd+1[x]>,<Dd+2[x]>,|-}<Dd+3[x]>),[<Rn>{<@>}]<!>{,<Rm>}" ,"VLD (single one) A1" ,"8,16,32"    ,"?32x1|64x1|64x01,128x10" ,"op=%11,ia=?bp_x[210]align[0]|bp_x[10]0align[0]|bp_x[0]0align[10]")
  PROCvfp_addlookup("VST4.<size> (<Dd[x]>{,<Dd+1[x]>,<Dd+2[x]>,|-}<Dd+3[x]>),[<Rn>{<@>}]<!>{,<Rm>}" ,"VST (single one) A1" ,"8,16,32"    ,"?32x1|64x1|64x01,128x10" ,"op=%11,ia=?bp_x[210]align[0]|bp_x[10]0align[0]|bp_x[0]0align[10]")
  PROCvfp_addlookup("VLD4.<size> (<Dd[x]>,<Dd+2[x]>,<Dd+4[x]>,<Dd+6[x]>),[<Rn>{<@>}]<!>{,<Rm>}"     ,"VLD (single one) A1" ,"16,32"      ,"?64x1|64x01,128x10"      ,"op=%11,ia=?bp_x[10]1align[0]|bp_x[0]1align[10]")
  PROCvfp_addlookup("VST4.<size> (<Dd[x]>,<Dd+2[x]>,<Dd+4[x]>,<Dd+6[x]>),[<Rn>{<@>}]<!>{,<Rm>}"     ,"VST (single one) A1" ,"16,32"      ,"?64x1|64x01,128x10"      ,"op=%11,ia=?bp_x[10]1align[0]|bp_x[0]1align[10]")

  REM single to all lanes variations - only applicable for loading
  PROCvfp_addlookup("VLD1.<size> (<Dd[]>),[<Rn>{<@>}]<!>{,<Rm>}"                                    ,"VLD (single all) A1" ,"8,16,32"    ,"?|16x1|32x1"             ,"op=%00,a=bp_align[0],T=0")
  PROCvfp_addlookup("VLD1.<size> (<Dd[]>{,|-}<Dd+1[]>),[<Rn>{<@>}]<!>{,<Rm>}"                       ,"VLD (single all) A1" ,"8,16,32"    ,"?|16x1|32x1"             ,"op=%00,a=bp_align[0],T=1")

  PROCvfp_addlookup("VLD2.<size> (<Dd[]>{,|-}<Dd+1[]>),[<Rn>{<@>}]<!>{,<Rm>}"                       ,"VLD (single all) A1" ,"8,16,32"    ,"?16x1|32x1|64x1"         ,"op=%01,a=bp_align[0],T=0")
  PROCvfp_addlookup("VLD2.<size> (<Dd[]>,<Dd+2[]>),[<Rn>{<@>}]<!>{,<Rm>}"                           ,"VLD (single all) A1" ,"8,16,32"    ,"?16x1|32x1|64x1"         ,"op=%01,a=bp_align[0],T=1")

  PROCvfp_addlookup("VLD3.<size> (<Dd[]>{,<Dd+1[]>,|-}<Dd+2[]>),[<Rn>]<!>{,<Rm>}"                   ,"VLD (single all) A1" ,"8,16,32"    ,""                        ,"op=%10,a=0,T=0")
  PROCvfp_addlookup("VLD3.<size> (<Dd[]>,<Dd+2[]>,<Dd+4[]>),[<Rn>}]<!>{,<Rm>}"                      ,"VLD (single all) A1" ,"8,16,32"    ,""                        ,"op=%10,a=0,T=1")

  PROCvfp_addlookup("VLD4.<size> (<Dd[]>{,<Dd+1[]>,<Dd+2[]>,|-}<Dd+3[]>),[<Rn>@128]<!>{,<Rm>}"      ,"VLD (single all) A1" ,"32"         ,""                        ,"op=%11,a=1,size=%11,T=0")
  PROCvfp_addlookup("VLD4.<size> (<Dd[]>{,<Dd+1[]>,<Dd+2[]>,|-}<Dd+3[]>),[<Rn>{<@>}]<!>{,<Rm>}"     ,"VLD (single all) A1" ,"8,16,32"    ,"?32x1|64x1|"             ,"op=%11,a=bp_align[0],T=0")
  PROCvfp_addlookup("VLD4.<size> (<Dd[]>,<Dd+2[]>,<Dd+4[]>,<Dd+6[]>),[<Rn>@128]<!>{,<Rm>}"          ,"VLD (single all) A1" ,"32"         ,""                        ,"op=%11,a=1,size=%11,T=1")
  PROCvfp_addlookup("VLD4.<size> (<Dd[]>,<Dd+2[]>,<Dd+4[]>,<Dd+6[]>),[<Rn>{<@>}]<!>{,<Rm>}"         ,"VLD (single all) A1" ,"8,16,32"    ,"?32x1|64x1|"             ,"op=%11,a=bp_align[0],T=1")

  REM VLDM/VSTM
  PROCvfp_addlookup("VLDMIA{<c>}{.64} <Rn><!>,(<Dd>{-<Dd->}{,<Dd+?>}~)"                         ,"VLDM A1,A2"          ,"16"         ,"" ,"op=1,P=0,U=1")
  PROCvfp_addlookup("VLDMDB{<c>}{.64} <Rn>!,(<Dd>{-<Dd->}{,<Dd+?>}~)"                           ,"VLDM A1,A2"          ,"16"         ,"" ,"op=1,P=1,U=0,W=1")
  PROCvfp_addlookup("VLDMIA{<c>}{.32} <Rn><!>,(<Sd>{-<Sd->}{,<Sd+?>}~)"                         ,"VLDM A1,A2"          ,"32"         ,"" ,"op=0,P=0,U=1")
  PROCvfp_addlookup("VLDMDB{<c>}{.32} <Rn>!,(<Sd>{-<Sd->}{,<Sd+?>}~)"                           ,"VLDM A1,A2"          ,"32"         ,"" ,"op=0,P=1,U=0,W=1")

  PROCvfp_addlookup("VSTMIA{<c>}{.64} <Rn><!>,(<Dd>{-<Dd->}{,<Dd+?>}~)"                         ,"VSTM A1,A2"          ,"16"         ,"" ,"op=1,P=0,U=1")
  PROCvfp_addlookup("VSTMDB{<c>}{.64} <Rn>!,(<Dd>{-<Dd->}{,<Dd+?>}~)"                           ,"VSTM A1,A2"          ,"16"         ,"" ,"op=1,P=1,U=0,W=1")
  PROCvfp_addlookup("VSTMIA{<c>}{.32} <Rn><!>,(<Sd>{-<Sd->}{,<Sd+?>}~)"                         ,"VSTM A1,A2"          ,"32"         ,"" ,"op=0,P=0,U=1")
  PROCvfp_addlookup("VSTMDB{<c>}{.32} <Rn>!,(<Sd>{-<Sd->}{,<Sd+?>}~)"                           ,"VSTM A1,A2"          ,"32"         ,"" ,"op=0,P=1,U=0,W=1")

  REM VPUSH/VPOP
  PROCvfp_addlookup("VPUSH{<c>} (<Dd>{-<Dd->}{,<Dd+?>}~)"                                       ,"VPUSH A1,A2"         ,"16"         ,"" ,"sz=1")
  PROCvfp_addlookup("VPUSH{<c>} (<Sd>{-<Sd->}{,<Sd+?>}~)"                                       ,"VPUSH A1,A2"         ,"16"         ,"" ,"sz=0")

  PROCvfp_addlookup("VPOP{<c>} (<Dd>{-<Dd->}{,<Dd+?>}~)"                                        ,"VPOP A1,A2"          ,"16"         ,"" ,"sz=1")
  PROCvfp_addlookup("VPOP{<c>} (<Sd>{-<Sd->}{,<Sd+?>}~)"                                        ,"VPOP A1,A2"          ,"16"         ,"" ,"sz=0")

  REM VLDR/VSTR
  PROCvfp_addlookup("VLDR{<c>} <Dd>,[<Rn>{,<#+-10>}]"                                           ,"VLDR A1,A2"          ,""           ,"" ,"op=1")
  PROCvfp_addlookup("VLDR{<c>} <Dd>,<lbl>"                                                      ,"VLDR A1,A2"          ,""           ,"" ,"op=1")
  PROCvfp_addlookup("VLDR{<c>} <Sd>,[<Rn>{,<#+-10>}]"                                           ,"VLDR A1,A2"          ,""           ,"" ,"op=0")
  PROCvfp_addlookup("VLDR{<c>} <Sd>,<lbl>"                                                      ,"VLDR A1,A2"          ,""           ,"" ,"op=0")

  PROCvfp_addlookup("VSTR{<c>} <Dd>,[<Rn>{,<#+-10>}]"                                           ,"VSTR A1,A2"          ,""           ,"" ,"op=1")
  PROCvfp_addlookup("VSTR{<c>} <Dd>,<lbl>"                                                      ,"VSTR A1,A2"          ,""           ,"" ,"op=1")
  PROCvfp_addlookup("VSTR{<c>} <Sd>,[<Rn>{,<#+-10>}]"                                           ,"VSTR A1,A2"          ,""           ,"" ,"op=0")
  PROCvfp_addlookup("VSTR{<c>} <Sd>,<lbl>"                                                      ,"VSTR A1,A2"          ,""           ,"" ,"op=0")

  REM other SIMD instructions
  PROCvfp_addlookup("VABA.<dt> <Qd>,<Qn>,<Qm>"         ,"VABA,VABAL A1"                         ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VABA.<dt> <Dd>,<Dn>,<Dm>"         ,"VABA,VABAL A1"                         ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VABAL.<dt> <Qd>,<Dn>,<Dm>"        ,"VABA,VABAL A2"                         ,"S8,S16,S32,U8,U16,U32" ,"" ,"")

  PROCvfp_addlookup("VABD.<dt> <Qd>,<Qn>,<Qm>"         ,"VABD,VABDL (integer) A1"               ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VABD.<dt> <Dd>,<Dn>,<Dm>"         ,"VABD,VABDL (integer) A1"               ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VABDL.<dt> <Qd>,<Dn>,<Dm>"        ,"VABD,VABDL (integer) A2"               ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VABD.<dt> <Qd>,<Qn>,<Qm>"         ,"VABD,VABDL (floating-point) A1"        ,"F32"                   ,"" ,"")
  PROCvfp_addlookup("VABD.<dt> <Dd>,<Dn>,<Dm>"         ,"VABD,VABDL (floating-point) A1"        ,"F32"                   ,"" ,"")

  PROCvfp_addlookup("VACGE.<dt> <Qd>,<Qn>,<Qm>"        ,"VACGE,VACGT A1"                        ,"F32"                   ,"" ,"op=0")
  PROCvfp_addlookup("VACGE.<dt> <Dd>,<Dn>,<Dm>"        ,"VACGE,VACGT A1"                        ,"F32"                   ,"" ,"op=0")
  PROCvfp_addlookup("VACGT.<dt> <Qd>,<Qn>,<Qm>"        ,"VACGE,VACGT A1"                        ,"F32"                   ,"" ,"op=1")
  PROCvfp_addlookup("VACGT.<dt> <Dd>,<Dn>,<Dm>"        ,"VACGE,VACGT A1"                        ,"F32"                   ,"" ,"op=1")
  PROCvfp_addlookup("VACLE.<dt> <Qd>,<Qm>,<Qn>"        ,"VACGE,VACGT A1"                        ,"F32"                   ,"" ,"op=0")
  PROCvfp_addlookup("VACLE.<dt> <Dd>,<Dm>,<Dn>"        ,"VACGE,VACGT A1"                        ,"F32"                   ,"" ,"op=0")
  PROCvfp_addlookup("VACLT.<dt> <Qd>,<Qm>,<Qn>"        ,"VACGE,VACGT A1"                        ,"F32"                   ,"" ,"op=1")
  PROCvfp_addlookup("VACLT.<dt> <Dd>,<Dm>,<Dn>"        ,"VACGE,VACGT A1"                        ,"F32"                   ,"" ,"op=1")

  PROCvfp_addlookup("VBIF{.<size>} <Qd>,<Qn>,<Qm>"     ,"VBIF,VBIT,VBSL A1"                     ,"ALL"                   ,"" ,"op=%11")
  PROCvfp_addlookup("VBIF{.<size>} <Dd>,<Dn>,<Dm>"     ,"VBIF,VBIT,VBSL A1"                     ,"ALL"                   ,"" ,"op=%11")
  PROCvfp_addlookup("VBIT{.<size>} <Qd>,<Qn>,<Qm>"     ,"VBIF,VBIT,VBSL A1"                     ,"ALL"                   ,"" ,"op=%10")
  PROCvfp_addlookup("VBIT{.<size>} <Dd>,<Dn>,<Dm>"     ,"VBIF,VBIT,VBSL A1"                     ,"ALL"                   ,"" ,"op=%10")
  PROCvfp_addlookup("VBSL{.<size>} <Qd>,<Qn>,<Qm>"     ,"VBIF,VBIT,VBSL A1"                     ,"ALL"                   ,"" ,"op=%01")
  PROCvfp_addlookup("VBSL{.<size>} <Dd>,<Dn>,<Dm>"     ,"VBIF,VBIT,VBSL A1"                     ,"ALL"                   ,"" ,"op=%01")

  PROCvfp_addlookup("VCLS.<dt> <Qd>,<Qm>"              ,"VCLS A1"                               ,"S8,S16,S32"            ,"" ,"")
  PROCvfp_addlookup("VCLS.<dt> <Dd>,<Dm>"              ,"VCLS A1"                               ,"S8,S16,S32"            ,"" ,"")
  PROCvfp_addlookup("VCLZ.<dt> <Qd>,<Qm>"              ,"VCLZ A1"                               ,"I8,I16,I32"            ,"" ,"")
  PROCvfp_addlookup("VCLZ.<dt> <Dd>,<Dm>"              ,"VCLZ A1"                               ,"I8,I16,I32"            ,"" ,"")
  PROCvfp_addlookup("VCNT.<size> <Qd>,<Qm>"            ,"VCNT A1"                               ,"8"                     ,"" ,"")
  PROCvfp_addlookup("VCNT.<size> <Dd>,<Dm>"            ,"VCNT A1"                               ,"8"                     ,"" ,"")

  PROCvfp_addlookup("VDUP.<size> <Qd>,<Dm[x]>"        ,"VDUP (scalar) A1"                       ,"8,16,32"               ,"" ,"imm4=?bp_x[210]1|bp_x[10]10|bp_x[0]100")
  PROCvfp_addlookup("VDUP.<size> <Dd>,<Dm[x]>"        ,"VDUP (scalar) A1"                       ,"8,16,32"               ,"" ,"imm4=?bp_x[210]1|bp_x[10]10|bp_x[0]100")
  PROCvfp_addlookup("VDUP{<c>}.<size> <Qd>,<Rt>"      ,"VDUP (ARM core) A1"                     ,"8,16,32"               ,"" ,"")
  PROCvfp_addlookup("VDUP{<c>}.<size> <Dd>,<Rt>"      ,"VDUP (ARM core) A1"                     ,"8,16,32"               ,"" ,"")

  PROCvfp_addlookup("VDUP.<size> <Qd>,<Dm[x]>"        ,"VDUP (scalar) A1"                       ,"8,16,32"               ,"" ,"imm4=?bp_x[210]1|bp_x[10]10|bp_x[0]100")
  PROCvfp_addlookup("VDUP.<size> <Dd>,<Dm[x]>"        ,"VDUP (scalar) A1"                       ,"8,16,32"               ,"" ,"imm4=?bp_x[210]1|bp_x[10]10|bp_x[0]100")
  PROCvfp_addlookup("VDUP{<c>}.<size> <Qd>,<Rt>"      ,"VDUP (ARM core) A1"                     ,"8,16,32"               ,"" ,"")
  PROCvfp_addlookup("VDUP{<c>}.<size> <Dd>,<Rt>"      ,"VDUP (ARM core) A1"                     ,"8,16,32"               ,"" ,"")

  PROCvfp_addlookup("VEOR{.<size>} <Qd>,<Qn>,<Qm>"    ,"VEOR A1"                                ,"ALL"                   ,"" ,"")
  PROCvfp_addlookup("VEOR{.<size>} <Dd>,<Dn>,<Dm>"    ,"VEOR A1"                                ,"ALL"                   ,"" ,"")

  PROCvfp_addlookup("VEXT.<size> <Qd>,<Qn>,<Qm>,<#4>"   ,"VEXT A1"                              ,"8"                     ,"" ,"")
  PROCvfp_addlookup("VEXT.<size> <Dd>,<Dn>,<Dm>,<#3>"   ,"VEXT A1"                              ,"8"                     ,"" ,"")
  PROCvfp_addlookup("VEXT.<size> <Qd>,<Qn>,<Qm>,<#3s1>" ,"VEXT A1"                              ,"16"                    ,"" ,"")
  PROCvfp_addlookup("VEXT.<size> <Dd>,<Dn>,<Dm>,<#2s1>" ,"VEXT A1"                              ,"16"                    ,"" ,"")
  PROCvfp_addlookup("VEXT.<size> <Qd>,<Qn>,<Qm>,<#2s2>" ,"VEXT A1"                              ,"32"                    ,"" ,"")
  PROCvfp_addlookup("VEXT.<size> <Dd>,<Dn>,<Dm>,<#1s2>" ,"VEXT A1"                              ,"32"                    ,"" ,"")
  PROCvfp_addlookup("VEXT.<size> <Qd>,<Qn>,<Qm>,<#1s3>" ,"VEXT A1"                              ,"64"                    ,"" ,"")

  PROCvfp_addlookup("VHADD.<dt> <Qd>,<Qn>,<Qm>"       ,"VHADD,VHSUB A1"                         ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=0")
  PROCvfp_addlookup("VHADD.<dt> <Dd>,<Dn>,<Dm>"       ,"VHADD,VHSUB A1"                         ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=0")
  PROCvfp_addlookup("VHSUB.<dt> <Qd>,<Qn>,<Qm>"       ,"VHADD,VHSUB A1"                         ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=1")
  PROCvfp_addlookup("VHSUB.<dt> <Dd>,<Dn>,<Dm>"       ,"VHADD,VHSUB A1"                         ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=1")

  PROCvfp_addlookup("VMAX.<dt> <Qd>,<Qn>,<Qm>"        ,"VMAX,VMIN (integer) A1"                 ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=0")
  PROCvfp_addlookup("VMAX.<dt> <Dd>,<Dn>,<Dm>"        ,"VMAX,VMIN (integer) A1"                 ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=0")
  PROCvfp_addlookup("VMIN.<dt> <Qd>,<Qn>,<Qm>"        ,"VMAX,VMIN (integer) A1"                 ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=1")
  PROCvfp_addlookup("VMIN.<dt> <Dd>,<Dn>,<Dm>"        ,"VMAX,VMIN (integer) A1"                 ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=1")
  PROCvfp_addlookup("VMAX.<dt> <Qd>,<Qn>,<Qm>"        ,"VMAX,VMIN (floating-point) A1"          ,"F32"                   ,"" ,"op=0")
  PROCvfp_addlookup("VMAX.<dt> <Dd>,<Dn>,<Dm>"        ,"VMAX,VMIN (floating-point) A1"          ,"F32"                   ,"" ,"op=0")
  PROCvfp_addlookup("VMIN.<dt> <Qd>,<Qn>,<Qm>"        ,"VMAX,VMIN (floating-point) A1"          ,"F32"                   ,"" ,"op=1")
  PROCvfp_addlookup("VMIN.<dt> <Dd>,<Dn>,<Dm>"        ,"VMAX,VMIN (floating-point) A1"          ,"F32"                   ,"" ,"op=1")

  PROCvfp_addlookup("VMLA.<dt> <Qd>,<Qn>,<Qm>"        ,"VMLA,VMLS (floating-point) A1"          ,"F32"                   ,"" ,"op=0")
  PROCvfp_addlookup("VMLA.<dt> <Dd>,<Dn>,<Dm>"        ,"VMLA,VMLS (floating-point) A1"          ,"F32"                   ,"" ,"op=0")
  PROCvfp_addlookup("VMLA{<c>}.<dt> <Dd>,<Dn>,<Dm>"   ,"VMLA,VMLS (floating-point) A2"          ,"F64"                   ,"" ,"op=0")
  PROCvfp_addlookup("VMLA{<c>}.<dt> <Sd>,<Sn>,<Sm>"   ,"VMLA,VMLS (floating-point) A2"          ,"F32"                   ,"" ,"op=0")

  PROCvfp_addlookup("VMLS.<dt> <Qd>,<Qn>,<Qm>"        ,"VMLA,VMLS (floating-point) A1"          ,"F32"                   ,"" ,"op=1")
  PROCvfp_addlookup("VMLS.<dt> <Dd>,<Dn>,<Dm>"        ,"VMLA,VMLS (floating-point) A1"          ,"F32"                   ,"" ,"op=1")
  PROCvfp_addlookup("VMLS{<c>}.<dt> <Dd>,<Dn>,<Dm>"   ,"VMLA,VMLS (floating-point) A2"          ,"F64"                   ,"" ,"op=1")
  PROCvfp_addlookup("VMLS{<c>}.<dt> <Sd>,<Sn>,<Sm>"   ,"VMLA,VMLS (floating-point) A2"          ,"F32"                   ,"" ,"op=1")

  PROCvfp_addlookup("VMLA.<dt> <Qd>,<Qn>,<Dm[x]7>"    ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A1"   ,"I16"                   ,"" ,"op=0,Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VMLA.<dt> <Qd>,<Qn>,<Dm[x]F>"    ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A1"   ,"I32,F32"               ,"" ,"op=0,Vmx=bp_x[0]Vm[3210]")
  PROCvfp_addlookup("VMLA.<dt> <Dd>,<Dn>,<Dm[x]7>"    ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A1"   ,"I16"                   ,"" ,"op=0,Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VMLA.<dt> <Dd>,<Dn>,<Dm[x]F>"    ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A1"   ,"I32,F32"               ,"" ,"op=0,Vmx=bp_x[0]Vm[3210]")
  PROCvfp_addlookup("VMLAL.<dt> <Qd>,<Dn>,<Dm[x]7>"   ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A2"   ,"S16,U16"               ,"" ,"op=0,Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VMLAL.<dt> <Qd>,<Dn>,<Dm[x]F>"   ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A2"   ,"S32,U32"               ,"" ,"op=0,Vmx=bp_x[0]Vm[3210]")

  PROCvfp_addlookup("VMLS.<dt> <Qd>,<Qn>,<Dm[x]7>"    ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A1"   ,"I16"                   ,"" ,"op=1,Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VMLS.<dt> <Qd>,<Qn>,<Dm[x]F>"    ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A1"   ,"I32,F32"               ,"" ,"op=1,Vmx=bp_x[0]Vm[3210]")
  PROCvfp_addlookup("VMLS.<dt> <Dd>,<Dn>,<Dm[x]7>"    ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A1"   ,"I16"                   ,"" ,"op=1,Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VMLS.<dt> <Dd>,<Dn>,<Dm[x]F>"    ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A1"   ,"I32,F32"               ,"" ,"op=1,Vmx=bp_x[0]Vm[3210]")
  PROCvfp_addlookup("VMLSL.<dt> <Qd>,<Dn>,<Dm[x]7>"   ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A2"   ,"S16,U16"               ,"" ,"op=1,Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VMLSL.<dt> <Qd>,<Dn>,<Dm[x]F>"   ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A2"   ,"S32,U32"               ,"" ,"op=1,Vmx=bp_x[0]Vm[3210]")

  PROCvfp_addlookup("VNMLA{<c>}.<dt> <Dd>,<Dn>,<Dm>"  ,"VNMLA,VNMLS,VNMUL A1"                   ,"F64"                   ,"" ,"op=1")
  PROCvfp_addlookup("VNMLA{<c>}.<dt> <Sd>,<Sn>,<Sm>"  ,"VNMLA,VNMLS,VNMUL A1"                   ,"F32"                   ,"" ,"op=1")
  PROCvfp_addlookup("VNMLS{<c>}.<dt> <Dd>,<Dn>,<Dm>"  ,"VNMLA,VNMLS,VNMUL A1"                   ,"F64"                   ,"" ,"op=0")
  PROCvfp_addlookup("VNMLS{<c>}.<dt> <Sd>,<Sn>,<Sm>"  ,"VNMLA,VNMLS,VNMUL A1"                   ,"F32"                   ,"" ,"op=0")
  PROCvfp_addlookup("VNMUL{<c>}.<dt> <Dd>,<Dn>,<Dm>"  ,"VNMLA,VNMLS,VNMUL A2"                   ,"F64"                   ,"" ,"")
  PROCvfp_addlookup("VNMUL{<c>}.<dt> <Sd>,<Sn>,<Sm>"  ,"VNMLA,VNMLS,VNMUL A2"                   ,"F32"                   ,"" ,"")

  PROCvfp_addlookup("VNEG.<dt> <Qd>,<Qm>"             ,"VNEG A1"                                ,"S8,S16,S32,F32"        ,"" ,"")
  PROCvfp_addlookup("VNEG.<dt> <Dd>,<Dm>"             ,"VNEG A1"                                ,"S8,S16,S32,F32"        ,"" ,"")
  PROCvfp_addlookup("VNEG{<c>}.<dt> <Dd>,<Dm>"        ,"VNEG A2"                                ,"F64"                   ,"" ,"")
  PROCvfp_addlookup("VNEG{<c>}.<dt> <Sd>,<Sm>"        ,"VNEG A2"                                ,"F32"                   ,"" ,"")

  PROCvfp_addlookup("VPADAL.<dt> <Qd>,<Qm>"           ,"VPADAL A1"                              ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VPADAL.<dt> <Dd>,<Dm>"           ,"VPADAL A1"                              ,"S8,S16,S32,U8,U16,U32" ,"" ,"")

  PROCvfp_addlookup("VPADD.<dt> <Dd>,<Dn>,<Dm>"       ,"VPADD A1"                               ,"I8,I16,I32"            ,"" ,"")
  PROCvfp_addlookup("VPADD.<dt> <Dd>,<Dn>,<Dm>"       ,"VPADD A2"                               ,"F32"                   ,"" ,"")

  PROCvfp_addlookup("VPADDL.<dt> <Qd>,<Qm>"           ,"VPADDL A1"                              ,"S8,S16,S32,U8,U16,U32" ,"" ,"")
  PROCvfp_addlookup("VPADDL.<dt> <Dd>,<Dm>"           ,"VPADDL A1"                              ,"S8,S16,S32,U8,U16,U32" ,"" ,"")

  PROCvfp_addlookup("VPMAX.<dt> <Dd>,<Dn>,<Dm>"       ,"VPMAX,VPMIN (integer) A1"               ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=0")
  PROCvfp_addlookup("VPMIN.<dt> <Dd>,<Dn>,<Dm>"       ,"VPMAX,VPMIN (integer) A1"               ,"S8,S16,S32,U8,U16,U32" ,"" ,"op=1")
  PROCvfp_addlookup("VPMAX.<dt> <Dd>,<Dn>,<Dm>"       ,"VPMAX,VPMIN (floating-point) A1"        ,"F32"                   ,"" ,"op=0")
  PROCvfp_addlookup("VPMIN.<dt> <Dd>,<Dn>,<Dm>"       ,"VPMAX,VPMIN (floating-point) A1"        ,"F32"                   ,"" ,"op=1")

  REM VQ saturating instructions

  PROCvfp_addlookup("VQABS.<dt> <Qd>,<Qm>"            ,"VQABS A1"                               ,"S8,S16,S32"                     ,"" , "")
  PROCvfp_addlookup("VQABS.<dt> <Dd>,<Dm>"            ,"VQABS A1"                               ,"S8,S16,S32"                     ,"" , "")

  PROCvfp_addlookup("VQADD.<dt> <Qd>,<Qn>,<Qm>"       ,"VQADD A1"                               ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" , "")
  PROCvfp_addlookup("VQADD.<dt> <Dd>,<Dn>,<Dm>"       ,"VQADD A1"                               ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" , "")

  PROCvfp_addlookup("VQDMLAL.<dt> <Qd>,<Dn>,<Dm>"     ,"VQDMLAL,VQDMLSL A1"                     ,"S16,S32"                        ,"" ,"op=0")
  PROCvfp_addlookup("VQDMLAL.<dt> <Qd>,<Dn>,<Dm[x]7>" ,"VQDMLAL,VQDMLSL A2"                     ,"S16"                            ,"" ,"op=0,Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VQDMLAL.<dt> <Qd>,<Dn>,<Dm[x]F>" ,"VQDMLAL,VQDMLSL A2"                     ,"S32"                            ,"" ,"op=0,Vmx=bp_x[0]Vm[3210]")
  PROCvfp_addlookup("VQDMLSL.<dt> <Qd>,<Dn>,<Dm>"     ,"VQDMLAL,VQDMLSL A1"                     ,"S16,S32"                        ,"" ,"op=1")
  PROCvfp_addlookup("VQDMLSL.<dt> <Qd>,<Dn>,<Dm[x]7>" ,"VQDMLAL,VQDMLSL A2"                     ,"S16"                            ,"" ,"op=1,Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VQDMLSL.<dt> <Qd>,<Dn>,<Dm[x]F>" ,"VQDMLAL,VQDMLSL A2"                     ,"S32"                            ,"" ,"op=1,Vmx=bp_x[0]Vm[3210]")

  PROCvfp_addlookup("VQDMULH.<dt> <Qd>,<Qn>,<Qm>"     ,"VQDMULH A1"                             ,"S16,S32"                        ,"" ,"")
  PROCvfp_addlookup("VQDMULH.<dt> <Dd>,<Dn>,<Dm>"     ,"VQDMULH A1"                             ,"S16,S32"                        ,"" ,"")
  PROCvfp_addlookup("VQDMULH.<dt> <Qd>,<Qn>,<Dm[x]>"  ,"VQDMULH A2"                             ,"S16"                            ,"" ,"Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VQDMULH.<dt> <Qd>,<Qn>,<Dm[x]>"  ,"VQDMULH A2"                             ,"S32"                            ,"" ,"Vmx=bp_x[0]Vm[3210]")
  PROCvfp_addlookup("VQDMULH.<dt> <Dd>,<Dn>,<Dm[x]>"  ,"VQDMULH A2"                             ,"S16"                            ,"" ,"Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VQDMULH.<dt> <Dd>,<Dn>,<Dm[x]>"  ,"VQDMULH A2"                             ,"S32"                            ,"" ,"Vmx=bp_x[0]Vm[3210]")

  PROCvfp_addlookup("VQDMULL.<dt> <Qd>,<Dn>,<Dm>"     ,"VQDMULL A1"                             ,"S16,S32"                        ,"" ,"")
  PROCvfp_addlookup("VQDMULL.<dt> <Qd>,<Dn>,<Dm[x]>"  ,"VQDMULL A2"                             ,"S16"                            ,"" ,"Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VQDMULL.<dt> <Qd>,<Dn>,<Dm[x]>"  ,"VQDMULL A2"                             ,"S32"                            ,"" ,"Vmx=bp_x[0]Vm[3210]")

  PROCvfp_addlookup("VQMOVN.<dt> <Dd>,<Qm>"           ,"VQMOVN,VQMOVUN A1"                      ,"S16,S32,S64"                    ,"" ,"op=%10")
  PROCvfp_addlookup("VQMOVN.<dt> <Dd>,<Qm>"           ,"VQMOVN,VQMOVUN A1"                      ,"U16,U32,U64"                    ,"" ,"op=%11")
  PROCvfp_addlookup("VQMOVUN.<dt> <Dd>,<Qm>"          ,"VQMOVN,VQMOVUN A1"                      ,"S16,S32,S64"                    ,"" ,"op=%01")

  PROCvfp_addlookup("VQNEG.<dt> <Qd>,<Qm>"            ,"VQNEG A1"                               ,"S8,S16,S32"                     ,"" ,"")
  PROCvfp_addlookup("VQNEG.<dt> <Dd>,<Dm>"            ,"VQNEG A1"                               ,"S8,S16,S32"                     ,"" ,"")

  PROCvfp_addlookup("VQRDMULH.<dt> <Qd>,<Qn>,<Qm>"    ,"VQRDMULH A1"                            ,"S16,S32"                        ,"" ,"")
  PROCvfp_addlookup("VQRDMULH.<dt> <Dd>,<Dn>,<Dm>"    ,"VQRDMULH A1"                            ,"S16,S32"                        ,"" ,"")
  PROCvfp_addlookup("VQRDMULH.<dt> <Qd>,<Qn>,<Dm[x]>" ,"VQRDMULH A2"                            ,"S16"                            ,"" ,"Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VQRDMULH.<dt> <Qd>,<Qn>,<Dm[x]>" ,"VQRDMULH A2"                            ,"S32"                            ,"" ,"Vmx=bp_x[0]Vm[3210]")
  PROCvfp_addlookup("VQRDMULH.<dt> <Dd>,<Dn>,<Dm[x]>" ,"VQRDMULH A2"                            ,"S16"                            ,"" ,"Vmx=bp_x[10]Vm[210]")
  PROCvfp_addlookup("VQRDMULH.<dt> <Dd>,<Dn>,<Dm[x]>" ,"VQRDMULH A2"                            ,"S32"                            ,"" ,"Vmx=bp_x[0]Vm[3210]")

  PROCvfp_addlookup("VQRSHL.<dt> <Qd>,<Qm>,<Qn>"      ,"VQRSHL A1"                              ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")
  PROCvfp_addlookup("VQRSHL.<dt> <Dd>,<Dm>,<Dn>"      ,"VQRSHL A1"                              ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")

  REM these are narrowing, so number of bits is halved from what you might expect
  PROCvfp_addlookup("VQRSHRN.<dt> <Dd>,<Qm>,<#e>"     ,"VQRSHRN,VQRSHRUN A1"                    ,"S16,S32,S64,U16,U32,U64"        ,"" ,"op=1")
  PROCvfp_addlookup("VQRSHRUN.<dt> <Dd>,<Qm>,<#e>"    ,"VQRSHRN,VQRSHRUN A1"                    ,"S16,S32,S64"                    ,"" ,"U=1,op=0")
  PROCvfp_addlookup("VQSHRN.<dt> <Dd>,<Qm>,<#e>"      ,"VQSHRN,VQSHRUN A1"                      ,"S16,S32,S64,U16,U32,U64"        ,"" ,"op=1")
  PROCvfp_addlookup("VQSHRUN.<dt> <Dd>,<Qm>,<#e>"     ,"VQSHRN,VQSHRUN A1"                      ,"S16,S32,S64"                    ,"" ,"U=1,op=0")

  PROCvfp_addlookup("VQSHL.<dt> <Qd>,<Qm>,<Qn>"       ,"VQSHL (register) A1"                    ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")
  PROCvfp_addlookup("VQSHL.<dt> <Dd>,<Dm>,<Dn>"       ,"VQSHL (register) A1"                    ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")

  PROCvfp_addlookup("VQSHL.<dt> <Qd>,<Qm>,<#g>"       ,"VQSHL,VQSHLU (immediate) A1"            ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"op=1")
  PROCvfp_addlookup("VQSHL.<dt> <Dd>,<Dm>,<#g>"       ,"VQSHL,VQSHLU (immediate) A1"            ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"op=1")
  PROCvfp_addlookup("VQSHLU.<dt> <Qd>,<Qm>,<#g>"      ,"VQSHL,VQSHLU (immediate) A1"            ,"S8,S16,S32,S64"                 ,"" ,"U=1,op=0")
  PROCvfp_addlookup("VQSHLU.<dt> <Dd>,<Dm>,<#g>"      ,"VQSHL,VQSHLU (immediate) A1"            ,"S8,S16,S32,S64"                 ,"" ,"U=1,op=0")

  PROCvfp_addlookup("VQSUB.<dt> <Qd>,<Qn>,<Qm>"       ,"VQSUB A1"                               ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")
  PROCvfp_addlookup("VQSUB.<dt> <Dd>,<Dn>,<Dm>"       ,"VQSUB A1"                               ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")

  REM NB - needs to use <size1> as encoded with size 16 = %00
  PROCvfp_addlookup("VRADDHN.<dt> <Dd>,<Qn>,<Qm>"     ,"VRADDHN A1"                             ,"I16,I32,I64"                    ,"" ,"")
  PROCvfp_addlookup("VRSUBHN.<dt> <Dd>,<Qn>,<Qm>"     ,"VRSUBHN A1"                             ,"I16,I32,I64"                    ,"" ,"")
  PROCvfp_addlookup("VSUBHN.<dt> <Dd>,<Qn>,<Qm>"      ,"VSUBHN (integer) A1"                    ,"I16,I32,I64"                    ,"" ,"")

  PROCvfp_addlookup("VRECPE.<dt> <Qd>,<Qm>"           ,"VRECPE A1"                              ,"U32,F32"                        ,"" ,"")
  PROCvfp_addlookup("VRECPE.<dt> <Dd>,<Dm>"           ,"VRECPE A1"                              ,"U32,F32"                        ,"" ,"")
  PROCvfp_addlookup("VRECPS.<dt> <Qd>,<Qn>,<Qm>"      ,"VRECPS A1"                              ,"F32"                            ,"" ,"")
  PROCvfp_addlookup("VRECPS.<dt> <Dd>,<Dn>,<Dm>"      ,"VRECPS A1"                              ,"F32"                            ,"" ,"")

  PROCvfp_addlookup("VREV16.<size> <Qd>,<Qm>"         ,"VREV A1"                                ,"8"                              ,"" ,"op=%10")
  PROCvfp_addlookup("VREV16.<size> <Dd>,<Dm>"         ,"VREV A1"                                ,"8"                              ,"" ,"op=%10")
  PROCvfp_addlookup("VREV32.<size> <Qd>,<Qm>"         ,"VREV A1"                                ,"8,16"                           ,"" ,"op=%01")
  PROCvfp_addlookup("VREV32.<size> <Dd>,<Dm>"         ,"VREV A1"                                ,"8,16"                           ,"" ,"op=%01")
  PROCvfp_addlookup("VREV64.<size> <Qd>,<Qm>"         ,"VREV A1"                                ,"8,16,32"                        ,"" ,"op=%00")
  PROCvfp_addlookup("VREV64.<size> <Dd>,<Dm>"         ,"VREV A1"                                ,"8,16,32"                        ,"" ,"op=%00")

  PROCvfp_addlookup("VRHADD.<dt> <Qd>,<Qn>,<Qm>"      ,"VRHADD A1"                              ,"S8,S16,S32,U8,U16,U32"          ,"" ,"")
  PROCvfp_addlookup("VRHADD.<dt> <Dd>,<Dn>,<Dm>"      ,"VRHADD A1"                              ,"S8,S16,S32,U8,U16,U32"          ,"" ,"")

  PROCvfp_addlookup("VRSHL.<dt> <Qd>,<Qn>,<Qm>"       ,"VRSHL A1"                               ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")
  PROCvfp_addlookup("VRSHL.<dt> <Dd>,<Dn>,<Dm>"       ,"VRSHL A1"                               ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")
  PROCvfp_addlookup("VRSHR.<dt> <Qd>,<Qm>,<#d>"       ,"VRSHR A1"                               ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")
  PROCvfp_addlookup("VRSHR.<dt> <Dd>,<Dm>,<#d>"       ,"VRSHR A1"                               ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")

  PROCvfp_addlookup("VRSHRN.<size> <Dd>,<Qm>,<#e>"    ,"VRSHRN A1"                              ,"16,32,64"                       ,"" ,"")

  PROCvfp_addlookup("VRSQRTE.<dt> <Qd>,<Qm>"          ,"VRSQRTE A1"                             ,"U32,F32"                        ,"" ,"")
  PROCvfp_addlookup("VRSQRTE.<dt> <Dd>,<Dm>"          ,"VRSQRTE A1"                             ,"U32,F32"                        ,"" ,"")

  PROCvfp_addlookup("VRSQRTS.<dt> <Qd>,<Qn>,<Qm>"     ,"VRSQRTS A1"                             ,"F32"                            ,"" ,"")
  PROCvfp_addlookup("VRSQRTS.<dt> <Dd>,<Dn>,<Dm>"     ,"VRSQRTS A1"                             ,"F32"                            ,"" ,"")

  PROCvfp_addlookup("VRSRA.<dt> <Qd>,<Qm>,<#d>"       ,"VRSRA A1"                               ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")
  PROCvfp_addlookup("VRSRA.<dt> <Dd>,<Dm>,<#d>"       ,"VRSRA A1"                               ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")

  PROCvfp_addlookup("VSHL.<dt> <Qd>,<Qm>,<#g>"        ,"VSHL (immediate) A1"                    ,"I8,I16,I32,I64"                 ,"" ,"")
  PROCvfp_addlookup("VSHL.<dt> <Dd>,<Dm>,<#g>"        ,"VSHL (immediate) A1"                    ,"I8,I16,I32,I64"                 ,"" ,"")
  PROCvfp_addlookup("VSHL.<dt> <Qd>,<Qm>,<Qn>"        ,"VSHL (register) A1"                     ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")
  PROCvfp_addlookup("VSHL.<dt> <Dd>,<Dm>,<Dn>"        ,"VSHL (register) A1"                     ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")

  REM next 3 are deliberately immdiate constants - A2 encoding is used when dtsize=shiftsize
  PROCvfp_addlookup("VSHLL.<dt> <Qd>,<Dm>,#8"         ,"VSHLL A2"                               ,"I8"                             ,"" ,"")
  PROCvfp_addlookup("VSHLL.<dt> <Qd>,<Dm>,#16"        ,"VSHLL A2"                               ,"I16"                            ,"" ,"")
  PROCvfp_addlookup("VSHLL.<dt> <Qd>,<Dm>,#32"        ,"VSHLL A2"                               ,"I32"                            ,"" ,"")
  PROCvfp_addlookup("VSHLL.<dt> <Qd>,<Dm>,<#h>"       ,"VSHLL A1"                               ,"S8,S16,S32,U8,U16,U32"          ,"" ,"")

  PROCvfp_addlookup("VSHR.<dt> <Qd>,<Qm>,<#d>"        ,"VSHR A1"                                ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")
  PROCvfp_addlookup("VSHR.<dt> <Dd>,<Dm>,<#d>"        ,"VSHR A1"                                ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")
  PROCvfp_addlookup("VSHRN.<dt> <Dd>,<Qm>,<#e>"       ,"VSHRN A1"                               ,"I16,I32,I64"                    ,"" ,"")

  PROCvfp_addlookup("VSLI.<size> <Qd>,<Qm>,<#g>"      ,"VSLI A1"                                ,"8,16,32,64"                     ,"" ,"")
  PROCvfp_addlookup("VSLI.<size> <Dd>,<Dm>,<#g>"      ,"VSLI A1"                                ,"8,16,32,64"                     ,"" ,"")
  PROCvfp_addlookup("VSRA.<dt> <Qd>,<Qm>,<#d>"        ,"VSRA A1"                                ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")
  PROCvfp_addlookup("VSRA.<dt> <Dd>,<Dm>,<#d>"        ,"VSRA A1"                                ,"S8,S16,S32,S64,U8,U16,U32,U64"  ,"" ,"")
  PROCvfp_addlookup("VSRI.<size> <Qd>,<Qm>,<#d>"      ,"VSRI A1"                                ,"8,16,32,64"                     ,"" ,"")
  PROCvfp_addlookup("VSRI.<size> <Dd>,<Dm>,<#d>"      ,"VSRI A1"                                ,"8,16,32,64"                     ,"" ,"")

  PROCvfp_addlookup("VSUB.<dt> <Qd>,<Qn>,<Qm>"        ,"VSUB (integer) A1"                      ,"I8,I16,I32,I64"                 ,"" ,"")
  PROCvfp_addlookup("VSUB.<dt> <Dd>,<Dn>,<Dm>"        ,"VSUB (integer) A1"                      ,"I8,I16,I32,I64"                 ,"" ,"")

  PROCvfp_addlookup("VSUBL.<dt> <Qd>,<Dn>,<Dm>"       ,"VSUBL,VSUBW A1"                         ,"S8,S16,S32,U8,U16,U32"          ,"" ,"op=0")
  PROCvfp_addlookup("VSUBW.<dt> <Qd>,<Qn>,<Dm>"       ,"VSUBL,VSUBW A1"                         ,"S8,S16,S32,U8,U16,U32"          ,"" ,"op=1")

  PROCvfp_addlookup("VSWP{.<size>} <Qd>,<Qm>"         ,"VSWP A1"                                ,"ALL"                            ,"" ,"size=%00")
  PROCvfp_addlookup("VSWP{.<size>} <Dd>,<Dm>"         ,"VSWP A1"                                ,"ALL"                            ,"" ,"size=%00")

  PROCvfp_addlookup("VTBL.<size> <Dd>,(<Dn>),<Dm>"                            ,"VTBL,VTBX A1"   ,"8"                              ,"" ,"op=0,len=%00")
  PROCvfp_addlookup("VTBL.<size> <Dd>,(<Dn>{,|-}<Dn+1>),<Dm>"                 ,"VTBL,VTBX A1"   ,"8"                              ,"" ,"op=0,len=%01")
  PROCvfp_addlookup("VTBL.<size> <Dd>,(<Dn>{,<Dn+1>,|-}<Dn+2>),<Dm>"          ,"VTBL,VTBX A1"   ,"8"                              ,"" ,"op=0,len=%10")
  PROCvfp_addlookup("VTBL.<size> <Dd>,(<Dn>{,<Dn+1>,<Dn+2>,|-}<Dn+3>),<Dm>"   ,"VTBL,VTBX A1"   ,"8"                              ,"" ,"op=0,len=%11")
  PROCvfp_addlookup("VTBX.<size> <Dd>,(<Dn>),<Dm>"                            ,"VTBL,VTBX A1"   ,"8"                              ,"" ,"op=1,len=%00")
  PROCvfp_addlookup("VTBX.<size> <Dd>,(<Dn>{,|-}<Dn+1>),<Dm>"                 ,"VTBL,VTBX A1"   ,"8"                              ,"" ,"op=1,len=%01")
  PROCvfp_addlookup("VTBX.<size> <Dd>,(<Dn>{,<Dn+1>,|-}<Dn+2>),<Dm>"          ,"VTBL,VTBX A1"   ,"8"                              ,"" ,"op=1,len=%10")
  PROCvfp_addlookup("VTBX.<size> <Dd>,(<Dn>{,<Dn+1>,<Dn+2>,|-}<Dn+3>),<Dm>"   ,"VTBL,VTBX A1"   ,"8"                              ,"" ,"op=1,len=%11")

  PROCvfp_addlookup("VTRN.<size> <Qd>,<Qm>"           ,"VTRN A1"                                ,"8,16,32"                        ,"" ,"")
  PROCvfp_addlookup("VTRN.<size> <Dd>,<Dm>"           ,"VTRN A1"                                ,"8,16,32"                        ,"" ,"")

  PROCvfp_addlookup("VUZP.<size> <Qd>,<Qm>"           ,"VUZP A1"                                ,"8,16,32"                        ,"" ,"")
  PROCvfp_addlookup("VUZP.<size> <Dd>,<Dm>"           ,"VUZP A1"                                ,"8,16,32"                        ,"" ,"")
  PROCvfp_addlookup("VZIP.<size> <Qd>,<Qm>"           ,"VZIP A1"                                ,"8,16,32"                        ,"" ,"")
  PROCvfp_addlookup("VZIP.<size> <Dd>,<Dm>"           ,"VZIP A1"                                ,"8,16,32"                        ,"" ,"")

  REM VFPv4/ASIMDv2
  PROCvfp_addlookup("VFMA.<dt> <Qd>,<Qn>,<Qm>"        ,"VFMA,VFMS A1"                           ,"F32"                            ,"" ,"op=0,Q=1,sz=0")
  PROCvfp_addlookup("VFMS.<dt> <Qd>,<Qn>,<Qm>"        ,"VFMA,VFMS A1"                           ,"F32"                            ,"" ,"op=1,Q=1,sz=0")
  PROCvfp_addlookup("VFMA.<dt> <Dd>,<Dn>,<Dm>"        ,"VFMA,VFMS A1"                           ,"F32"                            ,"" ,"op=0,Q=0,sz=0")
  PROCvfp_addlookup("VFMS.<dt> <Dd>,<Dn>,<Dm>"        ,"VFMA,VFMS A1"                           ,"F32"                            ,"" ,"op=1,Q=0,sz=0")
  PROCvfp_addlookup("VFMA{<c>}.<dt> <Sd>,<Sn>,<Sm>"   ,"VFMA,VFMS A2"                           ,"F32"                            ,"" ,"op=0,sz=0")
  PROCvfp_addlookup("VFMS{<c>}.<dt> <Sd>,<Sn>,<Sm>"   ,"VFMA,VFMS A2"                           ,"F32"                            ,"" ,"op=1,sz=0")
  PROCvfp_addlookup("VFMA{<c>}.<dt> <Dd>,<Dn>,<Dm>"   ,"VFMA,VFMS A2"                           ,"F64"                            ,"" ,"op=0,sz=1")
  PROCvfp_addlookup("VFMS{<c>}.<dt> <Dd>,<Dn>,<Dm>"   ,"VFMA,VFMS A2"                           ,"F64"                            ,"" ,"op=1,sz=1")

  PROCvfp_addlookup("VFNMA{<c>}.<dt> <Sd>,<Sn>,<Sm>"  ,"VFNMA,VFNMS A1"                         ,"F32"                            ,"" ,"op=0,sz=0")
  PROCvfp_addlookup("VFNMS{<c>}.<dt> <Sd>,<Sn>,<Sm>"  ,"VFNMA,VFNMS A1"                         ,"F32"                            ,"" ,"op=1,sz=0")
  PROCvfp_addlookup("VFNMA{<c>}.<dt> <Dd>,<Dn>,<Dm>"  ,"VFNMA,VFNMS A1"                         ,"F64"                            ,"" ,"op=0,sz=1")
  PROCvfp_addlookup("VFNMS{<c>}.<dt> <Dd>,<Dn>,<Dm>"  ,"VFNMA,VFNMS A1"                         ,"F64"                            ,"" ,"op=1,sz=1")

  REM **********************************
  REM ** Create Encoding Lookup Table **
  REM **********************************
  REM <version>,<encoding name>,<bitpattern>,<rules>
  REM version       - indicates supported VFP versions - 2 for VFPv2, 3 for VFPv3, 4 for VFPv4, S for SIMDv1, $ for SIMDv2
  REM encoding name - used to find the encoding from the lookup entry matching the syntax
  REM bitpattern    - contains 32 bits from right to left - 0,1,or op[bitlist]
  REM                                                     - op is a variable from the syntax, extra parms, or system fields
  REM                                                     -    system fields:
  REM                                                     -      imm - immediate value
  REM                                                     -      imn - (0-imm) immediate value
  REM                                                     - bit list is a list of bit numbers from 0-F
  REM opcmode       - list of valid opcmode bitstring constants (used for validating the bitstring generated by immediate values)

  REM ** VFP **
  PROCvfp_addencoding("234"   ,"VABS A2"                                 ,"cond[3210]11101Vd[4]110000Vd[3210]101sz[0]11Vm[4]0Vm[3210]"                   ,"")
  PROCvfp_addencoding("234"   ,"VADD (floating-point) A2"                ,"cond[3210]11100Vd[4]11Vn[3210]Vd[3210]101sz[0]Vn[4]0Vm[4]0Vm[3210]"           ,"")
  PROCvfp_addencoding("234"   ,"VCMP,VCMPE A1"                           ,"cond[3210]11101Vd[4]110100Vd[3210]101sz[0]E[0]1Vm[4]0Vm[3210]"                ,"")
  PROCvfp_addencoding("234"   ,"VCMP,VCMPE A2"                           ,"cond[3210]11101Vd[4]110101Vd[3210]101sz[0]E[0]1000000"                        ,"")
  PROCvfp_addencoding("234"   ,"VCVT,VCVTR (float and integer,VFP) A1"   ,"cond[3210]11101Vd[4]111opc2[210]Vd[3210]101sz[0]op[0]1Vm[4]0Vm[3210]"         ,"")
  PROCvfp_addencoding("234"   ,"VCVT (double and single) A1"             ,"cond[3210]11101Vd[4]110111Vd[3210]101sz[0]11Vm[4]0Vm[3210]"                   ,"")
  PROCvfp_addencoding("34"    ,"VCVT (float and fixed,VFP) A1"           ,"cond[3210]11101Vd[4]111op[0]1U[0]Vd[3210]101sf[0]sx[0]1imm4[0]0imm4[4321]"    ,"")
  PROCvfp_addencoding("234S$" ,"VLDM A1,A2"                              ,"cond[3210]110P[0]U[0]Vd[4]W[0]1Vn[3210]Vd[3210]101op[0]regcount[76543210]"    ,"")
  PROCvfp_addencoding("234S$" ,"VLDR A1,A2"                              ,"cond[3210]1101U[0]Vd[4]01Vn[3210]Vd[3210]101op[0]imm[76543210]"               ,"")
  PROCvfp_addencoding("234"   ,"VMUL (floating-point) A2"                ,"cond[3210]11100Vd[4]10Vn[3210]Vd[3210]101sz[0]Vn[4]0Vm[4]0Vm[3210]"           ,"")
  PROCvfp_addencoding("234"   ,"VMLA,VMLS (floating-point) A2"           ,"cond[3210]11100Vd[4]00Vn[3210]Vd[3210]101sz[0]Vn[4]op[0]Vm[4]0Vm[3210]"       ,"")
  PROCvfp_addencoding("234"   ,"VDIV A1"                                 ,"cond[3210]11101Vd[4]00Vn[3210]Vd[3210]101sz[0]Vn[4]0Vm[4]0Vm[3210]"           ,"")
  PROCvfp_addencoding("234"   ,"VSQRT A1"                                ,"cond[3210]11101Vd[4]110001Vd[3210]101sz[0]11Vm[4]0Vm[3210]"                   ,"")
  PROCvfp_addencoding("234"   ,"VMOV (ARM core and single) A1"           ,"cond[3210]1110000op[0]Vn[3210]Rt[3210]1010Vn[4]0010000"                       ,"")
  PROCvfp_addencoding("234"   ,"VMOV (two ARM core and two single) A1"   ,"cond[3210]1100010op[0]Ru[3210]Rt[3210]101000Vm[4]1Vm[3210]"                   ,"")
  PROCvfp_addencoding("234S$" ,"VMOV (two ARM core and doubleword) A1"   ,"cond[3210]1100010op[0]Ru[3210]Rt[3210]101100Vm[4]1Vm[3210]"                   ,"")
  PROCvfp_addencoding("234S$" ,"VMOV (ARM core to scalar) A1"            ,"cond[3210]11100opc[32]0Vd[3210]Rt[3210]1011Vd[4]opc[10]10000"                 ,"")
  PROCvfp_addencoding("234S$" ,"VMOV (scalar to ARM core) A1"            ,"cond[3210]1110U[0]opc[32]1Vn[3210]Rt[3210]1011Vn[4]opc[10]10000"              ,"")
  PROCvfp_addencoding("34"    ,"VMOV (immediate) A2"                     ,"cond[3210]11101Vd[4]11imm[7654]Vd[3210]101sz[0]0000imm[3210]"                 ,"")
  PROCvfp_addencoding("234"   ,"VMOV (register) A2"                      ,"cond[3210]11101Vd[4]110000Vd[3210]101sz[0]01Vm[4]0Vm[3210]"                   ,"")
  PROCvfp_addencoding("234S$" ,"VMSR A1"                                 ,"cond[3210]11101110spec[3210]Rt[3210]101000010000"                             ,"")
  PROCvfp_addencoding("234S$" ,"VMRS A1"                                 ,"cond[3210]11101111spec[3210]Rt[3210]101000010000"                             ,"")
  PROCvfp_addencoding("234"   ,"VNEG A2"                                 ,"cond[3210]11101Vd[4]110001Vd[3210]101sz[0]01Vm[4]0Vm[3210]"                   ,"")
  PROCvfp_addencoding("234"   ,"VNMLA,VNMLS,VNMUL A1"                    ,"cond[3210]11100Vd[4]01Vn[3210]Vd[3210]101sz[0]Vn[4]op[0]Vm[4]0Vm[3210]"       ,"")
  PROCvfp_addencoding("234"   ,"VNMLA,VNMLS,VNMUL A2"                    ,"cond[3210]11100Vd[4]10Vn[3210]Vd[3210]101sz[0]Vn[4]1Vm[4]0Vm[3210]"           ,"")
  PROCvfp_addencoding("234S$" ,"VPOP A1,A2"                              ,"cond[3210]11001Vd[4]111101Vd[3210]101sz[0]regcount[76543210]"                 ,"")
  PROCvfp_addencoding("234S$" ,"VPOP A1,A2"                              ,"cond[3210]11001Vd[4]111101Vd[3210]101sz[0]regcount[76543210]"                 ,"")
  PROCvfp_addencoding("234S$" ,"VPUSH A1,A2"                             ,"cond[3210]11010Vd[4]101101Vd[3210]101sz[0]regcount[76543210]"                 ,"")
  PROCvfp_addencoding("234S$" ,"VPUSH A1,A2"                             ,"cond[3210]11010Vd[4]101101Vd[3210]101sz[0]regcount[76543210]"                 ,"")
  PROCvfp_addencoding("234S$" ,"VSTM A1,A2"                              ,"cond[3210]110P[0]U[0]Vd[4]W[0]0Vn[3210]Vd[3210]101op[0]regcount[76543210]"    ,"")
  PROCvfp_addencoding("234"   ,"VSUB (floating-point) A2"                ,"cond[3210]11100Vd[4]11Vn[3210]Vd[3210]101sz[0]Vn[4]1Vm[4]0Vm[3210]"           ,"")
  PROCvfp_addencoding("234S$" ,"VSTR A1,A2"                              ,"cond[3210]1101U[0]Vd[4]00Vn[3210]Vd[3210]101op[0]imm[76543210]"               ,"")
  PROCvfp_addencoding("4"     ,"VFMA,VFMS A2"                            ,"cond[3210]11101Vd[4]10Vn[3210]Vd[3210]101sz[0]Vn[4]op[0]Vm[4]0Vm[3210]"       ,"")
  PROCvfp_addencoding("4"     ,"VFNMA,VFNMS A1"                          ,"cond[3210]11101Vd[4]01Vn[3210]Vd[3210]101sz[0]Vn[4]op[0]Vm[4]0Vm[3210]"       ,"")

  REM ** SIMD **
  PROCvfp_addencoding("S$"  ,"VABA,VABAL A1"                           ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]0111Vn[4]Q[0]Vm[4]1Vm[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VABA,VABAL A2"                           ,"1111001U[0]1Vd[4]size[10]Vn[3210]Vd[3210]0101Vn[4]0Vm[4]0Vm[3210]"            ,"")
  PROCvfp_addencoding("S$"  ,"VABD,VABDL (integer) A1"                 ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]0111Vn[4]Q[0]Vm[4]0Vm[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VABD,VABDL (integer) A2"                 ,"1111001U[0]1Vd[4]size[10]Vn[3210]Vd[3210]0111Vn[4]0Vm[4]0Vm[3210]"            ,"")
  PROCvfp_addencoding("S$"  ,"VABD,VABDL (floating-point) A1"          ,"111100110Vd[4]1sz[0]Vn[3210]Vd[3210]1101Vn[4]Q[0]Vm[4]0Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VABS A1"                                 ,"111100111Vd[4]11size[10]01Vd[3210]0F[0]110Q[0]Vm[4]0Vm[3210]"                 ,"")
  PROCvfp_addencoding("S$"  ,"VADD (integer) A1"                       ,"111100100Vd[4]size[10]Vn[3210]Vd[3210]1000Vn[4]Q[0]Vm[4]0Vm[3210]"            ,"")
  PROCvfp_addencoding("S$"  ,"VADDHN A1"                               ,"111100101Vd[4]size1[10]Vn[3210]Vd[3210]0100Vn[4]0Vm[4]0Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VADDL,VADDW A1"                          ,"1111001U[0]1Vd[4]size[10]Vn[3210]Vd[3210]000op[0]Vn[4]0Vm[4]0Vm[3210]"        ,"")
  PROCvfp_addencoding("S$"  ,"VADD (floating-point) A1"                ,"111100100Vd[4]0sz[0]Vn[3210]Vd[3210]1101Vn[4]Q[0]Vm[4]0Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VACGE,VACGT A1"                          ,"111100110Vd[4]op[0]sz[0]Vn[3210]Vd[3210]1110Vn[4]Q[0]Vm[4]1Vm[3210]"          ,"")
  PROCvfp_addencoding("S$"  ,"VBIC (immediate) A1"                     ,"1111001imm[7]1Vd[4]000imm[654]Vd[3210]opcmode[3210]0Q[0]11imm[3210]"          ,"10xx1,110x1")
  PROCvfp_addencoding("S$"  ,"VBIC (register) A1"                      ,"111100100Vd[4]0op[0]Vn[3210]Vd[3210]0001Vn[4]Q[0]Vm[4]1Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VBIF,VBIT,VBSL A1"                       ,"111100110Vd[4]op[10]Vn[3210]Vd[3210]0001Vn[4]Q[0]Vm[4]1Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VCEQ (register) A1"                      ,"111100110Vd[4]size[10]Vn[3210]Vd[3210]1000Vn[4]Q[0]Vm[4]1Vm[3210]"            ,"")
  PROCvfp_addencoding("S$"  ,"VCGE (register) A1"                      ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]0011Vn[4]Q[0]Vm[4]1Vm[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VCGT (register) A1"                      ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]0011Vn[4]Q[0]Vm[4]0Vm[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VCEQ (register) A2"                      ,"111100100Vd[4]0sz[0]Vn[3210]Vd[3210]1110Vn[4]Q[0]Vm[4]0Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VCGE (register) A2"                      ,"111100110Vd[4]0sz[0]Vn[3210]Vd[3210]1110Vn[4]Q[0]Vm[4]0Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VCGT (register) A2"                      ,"111100110Vd[4]1sz[0]Vn[3210]Vd[3210]1110Vn[4]Q[0]Vm[4]0Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VCEQ (immediate #0) A1"                  ,"111100111Vd[4]11size[10]01Vd[3210]0F[0]010Q[0]Vm[4]0Vm[3210]"                 ,"")
  PROCvfp_addencoding("S$"  ,"VCGE (immediate #0) A1"                  ,"111100111Vd[4]11size[10]01Vd[3210]0F[0]001Q[0]Vm[4]0Vm[3210]"                 ,"")
  PROCvfp_addencoding("S$"  ,"VCGT (immediate #0) A1"                  ,"111100111Vd[4]11size[10]01Vd[3210]0F[0]000Q[0]Vm[4]0Vm[3210]"                 ,"")
  PROCvfp_addencoding("S$"  ,"VCLE (immediate #0) A1"                  ,"111100111Vd[4]11size[10]01Vd[3210]0F[0]011Q[0]Vm[4]0Vm[3210]"                 ,"")
  PROCvfp_addencoding("S$"  ,"VCLT (immediate #0) A1"                  ,"111100111Vd[4]11size[10]01Vd[3210]0F[0]100Q[0]Vm[4]0Vm[3210]"                 ,"")
  PROCvfp_addencoding("S$"  ,"VCLS A1"                                 ,"111100111Vd[4]11size[10]00Vd[3210]01000Q[0]Vm[4]0Vm[3210]"                    ,"")
  PROCvfp_addencoding("S$"  ,"VCLZ A1"                                 ,"111100111Vd[4]11size[10]00Vd[3210]01001Q[0]Vm[4]0Vm[3210]"                    ,"")
  PROCvfp_addencoding("S$"  ,"VCNT A1"                                 ,"111100111Vd[4]11size[10]00Vd[3210]01010Q[0]Vm[4]0Vm[3210]"                    ,"")
  PROCvfp_addencoding("S$"  ,"VCVT (float and fixed,SIMD) A1"          ,"1111001U[0]1Vd[4]imn[543210]Vd[3210]111op[0]0Q[0]Vm[4]1Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VCVT (float and integer,SIMD) A1"        ,"111100111Vd[4]11size[10]11Vd[3210]011op[10]Q[0]Vm[4]0Vm[3210]"                ,"")
  PROCvfp_addencoding("S$"  ,"VDUP (scalar) A1"                        ,"111100111Vd[4]11imm4[3210]Vd[3210]11000Q[0]Vm[4]0Vm[3210]"                    ,"")
  PROCvfp_addencoding("S$"  ,"VDUP (ARM core) A1"                      ,"cond[3210]11101esize[1]Q[0]0Vd[3210]Rt[3210]1011Vd[4]0esize[0]10000"          ,"")
  PROCvfp_addencoding("S$"  ,"VEOR A1"                                 ,"111100110Vd[4]00Vn[3210]Vd[3210]0001Vn[4]Q[0]Vm[4]1Vm[3210]"                  ,"")
  PROCvfp_addencoding("S$"  ,"VEXT A1"                                 ,"111100101Vd[4]11Vn[3210]Vd[3210]imm[3210]Vn[4]Q[0]Vm[4]0Vm[3210]"             ,"")
  PROCvfp_addencoding("S$"  ,"VHADD,VHSUB A1"                          ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]00op[0]0Vn[4]Q[0]Vm[4]0Vm[3210]"     ,"")
  PROCvfp_addencoding("S$"  ,"VLD (multiple) A1"                       ,"111101000Vd[4]10Vn[3210]Vd[3210]type[3210]size[10]align[10]Vm[3210]"          ,"")
  PROCvfp_addencoding("S$"  ,"VLD (single one) A1"                     ,"111101001Vd[4]10Vn[3210]Vd[3210]size[10]op[10]ia[3210]Vm[3210]"               ,"")
  PROCvfp_addencoding("S$"  ,"VLD (single all) A1"                     ,"111101001Vd[4]10Vn[3210]Vd[3210]11op[10]size[10]T[0]a[0]Vm[3210]"             ,"")
  PROCvfp_addencoding("S$"  ,"VMAX,VMIN (integer) A1"                  ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]0110Vn[4]Q[0]Vm[4]op[0]Vm[3210]"     ,"")
  PROCvfp_addencoding("S$"  ,"VMAX,VMIN (floating-point) A1"           ,"111100100Vd[4]op[0]sz[0]Vn[3210]Vd[3210]1111Vn[4]Q[0]Vm[4]0Vm[3210]"          ,"")
  PROCvfp_addencoding("S$"  ,"VMLA,VMLS (floating-point) A1"           ,"111100100Vd[4]op[0]sz[0]Vn[3210]Vd[3210]1101Vn[4]Q[0]Vm[4]1Vm[3210]"          ,"")
  PROCvfp_addencoding("S$"  ,"VMLA,VMLAL,VMLS,VMLSL (integer) A1"      ,"1111001op[0]0Vd[4]size[10]Vn[3210]Vd[3210]1001Vn[4]Q[0]Vm[4]0Vm[3210]"        ,"")
  PROCvfp_addencoding("S$"  ,"VMLA,VMLAL,VMLS,VMLSL (integer) A2"      ,"1111001U[0]1Vd[4]size[10]Vn[3210]Vd[3210]10op[0]0Vn[4]0Vm[4]0Vm[3210]"        ,"")
  PROCvfp_addencoding("S$"  ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A1"    ,"1111001Q[0]1Vd[4]size[10]Vn[3210]Vd[3210]0op[0]0F[0]Vn[4]1Vmx[4]0Vmx[3210]"   ,"")
  PROCvfp_addencoding("S$"  ,"VMLA,VMLAL,VMLS,VMLSL (by scalar) A2"    ,"1111001U[0]1Vd[4]size[10]Vn[3210]Vd[3210]0op[0]10Vn[4]1Vmx[4]0Vmx[3210]"      ,"")
  PROCvfp_addencoding("S$"  ,"VMOV (immediate) A1"                     ,"1111001imm[7]1Vd[4]000imm[654]Vd[3210]opcmode[3210]0Q[0]opcmode[4]1imm[3210]" ,"00xx0,010x0,011xx,11110")
  PROCvfp_addencoding("S$"  ,"VMOV (register) A1"                      ,"111100100Vd[4]10Vm[3210]Vd[3210]0001Vm[4]Q[0]Vm[4]1Vm[3210]"                  ,"")
  PROCvfp_addencoding("S$"  ,"VMOVL A1"                                ,"1111001U[0]1Vd[4]imm3[210]000Vd[3210]101000Vm[4]1Vm[3210]"                    ,"")
  PROCvfp_addencoding("S$"  ,"VMOVN A1"                                ,"111100111Vd[4]11size1[10]10Vd[3210]001000Vm[4]0Vm[3210]"                      ,"")
  PROCvfp_addencoding("S$"  ,"VMUL (floating-point) A1"                ,"111100110Vd[4]0sz[0]Vn[3210]Vd[3210]1101Vn[4]Q[0]Vm[4]1Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VMUL,VMULL (by integer and poly) A1"     ,"1111001op[0]0Vd[4]size[10]Vn[3210]Vd[3210]1001Vn[4]Q[0]Vm[4]1Vm[3210]"        ,"")
  PROCvfp_addencoding("S$"  ,"VMUL,VMULL (by integer and poly) A2"     ,"1111001U[0]1Vd[4]size[10]Vn[3210]Vd[3210]11op[0]0Vn[4]0Vm[4]0Vm[3210]"        ,"")
  PROCvfp_addencoding("S$"  ,"VMUL,VMULL (by scalar) A1"               ,"1111001Q[0]1Vd[4]size[10]Vn[3210]Vd[3210]100F[0]Vn[4]1Vmx[4]0Vmx[3210]"       ,"")
  PROCvfp_addencoding("S$"  ,"VMUL,VMULL (by scalar) A2"               ,"1111001U[0]1Vd[4]size[10]Vn[3210]Vd[3210]1010Vn[4]1Vmx[4]0Vmx[3210]"          ,"")
  PROCvfp_addencoding("S$"  ,"VMVN (immediate) A1"                     ,"1111001imm[7]1Vd[4]000imm[654]Vd[3210]opcmode[3210]0Q[0]opcmode[4]1imm[3210]" ,"10xx0,110x0,1110x")
  PROCvfp_addencoding("S$"  ,"VMVN (register) A1"                      ,"111100111Vd[4]11size[10]00Vd[3210]01011Q[0]Vm[4]0Vm[3210]"                    ,"")
  PROCvfp_addencoding("S$"  ,"VNEG A1"                                 ,"111100111Vd[4]11size[10]01Vd[3210]0F[0]111Q[0]Vm[4]0Vm[3210]"                 ,"")
  PROCvfp_addencoding("S$"  ,"VORR (immediate) A1"                     ,"1111001imm[7]1Vd[4]000imm[654]Vd[3210]opcmode[3210]0Q[0]01imm[3210]"          ,"00xx1,010x1")
  PROCvfp_addencoding("S$"  ,"VORR (register) A1"                      ,"111100100Vd[4]1op[0]Vn[3210]Vd[3210]0001Vn[4]Q[0]Vm[4]1Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VPADAL A1"                               ,"111100111Vd[4]11size[10]00Vd[3210]0110U[0]Q[0]Vm[4]0Vm[3210]"                 ,"")
  PROCvfp_addencoding("S$"  ,"VPADD A1"                                ,"111100100Vd[4]size[10]Vn[3210]Vd[3210]1011Vn[4]Q[0]Vm[4]1Vm[3210]"            ,"")
  PROCvfp_addencoding("S$"  ,"VPADD A2"                                ,"111100110Vd[4]0sz[0]Vn[3210]Vd[3210]1101Vn[4]Q[0]Vm[4]0Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VPADDL A1"                               ,"111100111Vd[4]11size[10]00Vd[3210]0010U[0]Q[0]Vm[4]0Vm[3210]"                 ,"")
  PROCvfp_addencoding("S$"  ,"VPMAX,VPMIN (integer) A1"                ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]1010Vn[4]Q[0]Vm[4]op[0]Vm[3210]"     ,"")
  PROCvfp_addencoding("S$"  ,"VPMAX,VPMIN (floating-point) A1"         ,"111100110Vd[4]op[0]sz[0]Vn[3210]Vd[3210]1111Vn[4]Q[0]Vm[4]0Vm[3210]"          ,"")
  PROCvfp_addencoding("S$"  ,"VQABS A1"                                ,"111100111Vd[4]11size[10]00Vd[3210]01110Q[0]Vm[4]0Vm[3210]"                    ,"")
  PROCvfp_addencoding("S$"  ,"VQADD A1"                                ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]0000Vn[4]Q[0]Vm[4]1Vm[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VQDMLAL,VQDMLSL A1"                      ,"111100101Vd[4]size[10]Vn[3210]Vd[3210]10op[0]1Vn[4]0Vm[4]0Vm[3210]"           ,"")
  PROCvfp_addencoding("S$"  ,"VQDMLAL,VQDMLSL A2"                      ,"111100101Vd[4]size[10]Vn[3210]Vd[3210]0op[0]11Vn[4]1Vmx[4]0Vmx[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VQDMULH A1"                              ,"111100100Vd[4]size[10]Vn[3210]Vd[3210]1011Vn[4]Q[0]Vm[4]0Vm[3210]"            ,"")
  PROCvfp_addencoding("S$"  ,"VQDMULH A2"                              ,"1111001Q[0]1Vd[4]size[10]Vn[3210]Vd[3210]1100Vn[4]1Vmx[4]0Vmx[3210]"          ,"")
  PROCvfp_addencoding("S$"  ,"VQDMULL A1"                              ,"111100101Vd[4]size[10]Vn[3210]Vd[3210]1101Vn[4]0Vm[4]0Vm[3210]"               ,"")
  PROCvfp_addencoding("S$"  ,"VQDMULL A2"                              ,"111100101Vd[4]size[10]Vn[3210]Vd[3210]1011Vn[4]1Vmx[4]0Vmx[3210]"             ,"")
  PROCvfp_addencoding("S$"  ,"VQMOVN,VQMOVUN A1"                       ,"111100111Vd[4]11size1[10]10Vd[3210]0010op[10]Vm[4]0Vm[3210]"                  ,"")
  PROCvfp_addencoding("S$"  ,"VQNEG A1"                                ,"111100111Vd[4]11size[10]00Vd[3210]01111Q[0]Vm[4]0Vm[3210]"                    ,"")
  PROCvfp_addencoding("S$"  ,"VQRDMULH A1"                             ,"111100110Vd[4]size[10]Vn[3210]Vd[3210]1011Vn[4]Q[0]Vm[4]0Vm[3210]"            ,"")
  PROCvfp_addencoding("S$"  ,"VQRDMULH A2"                             ,"1111001Q[0]1Vd[4]size[10]Vn[3210]Vd[3210]1101Vn[4]1Vmx[4]0Vmx[3210]"          ,"")
  PROCvfp_addencoding("S$"  ,"VQRSHL A1"                               ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]0101Vn[4]Q[0]Vm[4]1Vm[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VQRSHRN,VQRSHRUN A1"                     ,"1111001U[0]1Vd[4]imm6r[543210]Vd[3210]100op[0]01Vm[4]1Vm[3210]"               ,"")
  PROCvfp_addencoding("S$"  ,"VQSHRN,VQSHRUN A1"                       ,"1111001U[0]1Vd[4]imm6r[543210]Vd[3210]100op[0]00Vm[4]1Vm[3210]"               ,"")
  PROCvfp_addencoding("S$"  ,"VQSHL (register) A1"                     ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]0100Vn[4]Q[0]Vm[4]1Vm[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VQSHL,VQSHLU (immediate) A1"             ,"1111001U[0]1Vd[4]imm6l[543210]Vd[3210]011op[0]L[0]Q[0]Vm[4]1Vm[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VQSUB A1"                                ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]0010Vn[4]Q[0]Vm[4]1Vm[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VRADDHN A1"                              ,"111100111Vd[4]size1[10]Vn[3210]Vd[3210]0100Vn[4]0Vm[4]0Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VRSUBHN A1"                              ,"111100111Vd[4]size1[10]Vn[3210]Vd[3210]0110Vn[4]0Vm[4]0Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VSUBHN (integer) A1"                     ,"111100101Vd[4]size1[10]Vn[3210]Vd[3210]0110Vn[4]0Vm[4]0Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VRECPE A1"                               ,"111100111Vd[4]11size[10]11Vd[3210]010F[0]0Q[0]Vm[4]0Vm[3210]"                 ,"")
  PROCvfp_addencoding("S$"  ,"VRECPS A1"                               ,"111100100Vd[4]0sz[0]Vn[3210]Vd[3210]1111Vn[4]Q[0]Vm[4]1Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VREV A1"                                 ,"111100111Vd[4]11size[10]00Vd[3210]000op[10]Q[0]Vm[4]0Vm[3210]"                ,"")
  PROCvfp_addencoding("S$"  ,"VRHADD A1"                               ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]0001Vn[4]Q[0]Vm[4]0Vm[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VRSHL A1"                                ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]0101Vn[4]Q[0]Vm[4]0Vm[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VRSHR A1"                                ,"1111001U[0]1Vd[4]imm6r[543210]Vd[3210]0010L[0]Q[0]Vm[4]1Vm[3210]"             ,"")
  PROCvfp_addencoding("S$"  ,"VRSHRN A1"                               ,"111100101Vd[4]imm6r[543210]Vd[3210]100001Vm[4]1Vm[3210]"                      ,"")
  PROCvfp_addencoding("S$"  ,"VRSQRTE A1"                              ,"111100111Vd[4]11size[10]11Vd[3210]010F[0]1Q[0]Vm[4]0Vm[3210]"                 ,"")
  PROCvfp_addencoding("S$"  ,"VRSQRTS A1"                              ,"111100100Vd[4]1sz[0]Vn[3210]Vd[3210]1111Vn[4]Q[0]Vm[4]1Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VRSRA A1"                                ,"1111001U[0]1Vd[4]imm6r[543210]Vd[3210]0011L[0]Q[0]Vm[4]1Vm[3210]"             ,"")
  PROCvfp_addencoding("S$"  ,"VSHL (immediate) A1"                     ,"111100101Vd[4]imm6l[543210]Vd[3210]0101L[0]Q[0]Vm[4]1Vm[3210]"                ,"")
  PROCvfp_addencoding("S$"  ,"VSHL (register) A1"                      ,"1111001U[0]0Vd[4]size[10]Vn[3210]Vd[3210]0100Vn[4]Q[0]Vm[4]0Vm[3210]"         ,"")
  PROCvfp_addencoding("S$"  ,"VSHLL A1"                                ,"1111001U[0]1Vd[4]imm6l[543210]Vd[3210]101000Vm[4]1Vm[3210]"                   ,"")
  PROCvfp_addencoding("S$"  ,"VSHLL A2"                                ,"111100111Vd[4]11size[10]10Vd[3210]001100Vm[4]0Vm[3210]"                       ,"")
  PROCvfp_addencoding("S$"  ,"VSHR A1"                                 ,"1111001U[0]1Vd[4]imm6r[543210]Vd[3210]0000L[0]Q[0]Vm[4]1Vm[3210]"             ,"")
  PROCvfp_addencoding("S$"  ,"VSHRN A1"                                ,"111100101Vd[4]imm6r[543210]Vd[3210]100000Vm[4]1Vm[3210]"                      ,"")
  PROCvfp_addencoding("S$"  ,"VSLI A1"                                 ,"111100111Vd[4]imm6l[543210]Vd[3210]0101L[0]Q[0]Vm[4]1Vm[3210]"                ,"")
  PROCvfp_addencoding("S$"  ,"VSRA A1"                                 ,"1111001U[0]1Vd[4]imm6r[543210]Vd[3210]0001L[0]Q[0]Vm[4]1Vm[3210]"             ,"")
  PROCvfp_addencoding("S$"  ,"VSRI A1"                                 ,"111100111Vd[4]imm6r[543210]Vd[3210]0100L[0]Q[0]Vm[4]1Vm[3210]"                ,"")
  PROCvfp_addencoding("S$"  ,"VST (multiple) A1"                       ,"111101000Vd[4]00Vn[3210]Vd[3210]type[3210]size[10]align[10]Vm[3210]"          ,"")
  PROCvfp_addencoding("S$"  ,"VST (single one) A1"                     ,"111101001Vd[4]00Vn[3210]Vd[3210]size[10]op[10]ia[3210]Vm[3210]"               ,"")
  PROCvfp_addencoding("S$"  ,"VSUB (floating-point) A1"                ,"111100100Vd[4]1sz[0]Vn[3210]Vd[3210]1101Vn[4]Q[0]Vm[4]0Vm[3210]"              ,"")
  PROCvfp_addencoding("S$"  ,"VSUB (integer) A1"                       ,"111100110Vd[4]size[10]Vn[3210]Vd[3210]1000Vn[4]Q[0]Vm[4]0Vm[3210]"            ,"")
  PROCvfp_addencoding("S$"  ,"VSUBL,VSUBW A1"                          ,"1111001U[0]1Vd[4]size[10]Vn[3210]Vd[3210]001op[0]Vn[4]0Vm[4]0Vm[3210]"        ,"")
  PROCvfp_addencoding("S$"  ,"VSWP A1"                                 ,"111100111Vd[4]11size[10]10Vd[3210]00000Q[0]Vm[4]0Vm[3210]"                    ,"")
  PROCvfp_addencoding("S$"  ,"VTBL,VTBX A1"                            ,"111100111Vd[4]11Vn[3210]Vd[3210]10len[10]Vn[4]op[0]Vm[4]0Vm[3210]"            ,"")
  PROCvfp_addencoding("S$"  ,"VTRN A1"                                 ,"111100111Vd[4]11size[10]10Vd[3210]00001Q[0]Vm[4]0Vm[3210]"                    ,"")
  PROCvfp_addencoding("S$"  ,"VTST A1"                                 ,"111100100Vd[4]size[10]Vn[3210]Vd[3210]1000Vn[4]Q[0]Vm[4]1Vm[3210]"            ,"")
  PROCvfp_addencoding("S$"  ,"VUZP A1"                                 ,"111100111Vd[4]11size[10]10Vd[3210]00010Q[0]Vm[4]0Vm[3210]"                    ,"")
  PROCvfp_addencoding("S$"  ,"VZIP A1"                                 ,"111100111Vd[4]11size[10]10Vd[3210]00011Q[0]Vm[4]0Vm[3210]"                    ,"")
  PROCvfp_addencoding("$"   ,"VFMA,VFMS A1"                            ,"111100100Vd[4]op[0]sz[0]Vn[3210]Vd[3210]1100Vn[4]Q[0]Vm[4]1Vm[3210]"          ,"")

ENDPROC

REM ** Add Entry to Lookup List **

DEF PROCvfp_addlookup(pattern$,encoding$,dtfilter$,align$,param$)

  REM check for ALL data-type specifier
  IF dtfilter$="ALL" THEN dtfilter$="8,I8,S8,U8,P8,16,I16,S16,U16,P16,F16,32,I32,S32,U32,F32,64,I64,S64,U64,F64"

  vfppattern$(vfplookup%) = pattern$
  vfpencoding$(vfplookup%) = encoding$
  vfpdtfilter$(vfplookup%) = dtfilter$
  vfpalign$(vfplookup%) = align$
  vfpparam$(vfplookup%) = param$
  vfplookup% += 1
ENDPROC

REM ** Add Entry to Encoding List **

DEF PROCvfp_addencoding(version$,encoding$,bitpattern$,opcmode$)
  vfpversion$(vfpenc%)    = version$
  vfpencname$(vfpenc%)    = encoding$
  vfpbitpattern$(vfpenc%) = bitpattern$
  vfpopcmode$(vfpenc%)    = opcmode$
  vfpenc% += 1
ENDPROC

REM ********************************
REM **                            **
REM ** Assemble a VFP Instruction **
REM **                            **
REM ********************************

DEF FNvfp(inst$)
LOCAL lookup%, op%, encoding$, encoding%
LOCAL vfpinstdebug$, debug$

  REM setup debug string
  vfpinstdebug$=" ("+inst$+")"

  REM match the instruction to the appropriate lookup entry - also finds the encoding into encoding%,encoding$
  lookup% = FNvfp_matchlookup(inst$)
  IF lookup% = -1 THEN ERROR 0,"VFP unrecognised instruction format : " + inst$

  REM ** process the bitpattern **
  PROCvfp_assemble

  REM show debug
  IF vfpdebug% AND (p% AND 2)<>0 THEN
    PRINT "inst   : " ; inst$
    PRINT "lookup : " ; lookup%
    PRINT "name/sz: " ; vfppattern$(lookup%) + " - " + vfpdtfilter$(lookup%)
    PRINT "enc    : " ; vfpencoding$(lookup%)
    PRINT "param  : " ; vfpparam$(lookup%)
    PRINT "ops    : " ; vfpop%
    op%=0
    FOR op%=0 TO vfpop%-1
      PRINT "op     : " ; vfpop$(op%) ; " = " ; vfpopval$(op%) ; " = " ; vfpopval%(op%)
    NEXT
    PRINT "enc    : " ; vfpencname$(encoding%)
    PRINT "bitpat : " ; vfpbitpattern$(encoding%)
    PRINT "output : " ; ~O%!-4
  ENDIF

=0

REM ***************************************
REM ** Match Instruction to Lookup Entry **
REM ***************************************

DEF FNvfp_matchlookup(inst$)
LOCAL lookup%
  FOR lookup%=0 TO vfplookup%-1
    IF FNvfp_match(lookup%,inst$) THEN =lookup%
  NEXT
=-1

DEF FNvfp_match(lookup%,inst$)
LOCAL pat$,pat%,patlen%,ins%,inslen%,oprepeats,optpat%
LOCAL c$,n$,opt,i$,reglist
LOCAL op$,o%,opval$
LOCAL dt$,dt%,dtfilt$, reg$,reg%,reginc, imm$,imm%,immbits%,immmax%,immmin%, n$, size%, immneg%,immbits$
LOCAL par$,par%,parlen%,val$,val%,bp%,bplen%,bp$,bpop$
LOCAL opcmodelist$,opcmode$,b3%,b2%,b1%,b0%,opc%,opclen%,opc$,opcmatch,dtopt

  REM clear the data-type and get the data-type filter
  dt$=""
  dt%=0
  dtfilt$=vfpdtfilter$(lookup%)
  size%=0

  REM get the pattern and set-up counters for parsing
  pat$=vfppattern$(lookup%)
  pat%=1
  patlen%=LEN(pat$)
  ins%=1
  inslen%=LEN(inst$)

  REM lookup the encoding to get the opcmode list
  encoding% = -1

  REM opt is the optional flag, skip is the skipping flag, reglist marks when in a register list
  opt=FALSE
  skip=FALSE
  skipOR=FALSE
  optOR=FALSE
  reglist=FALSE

  REM clear op count
  vfpop%=0

  REM setup defaults for immediate values (as immediate may be optional but data is needed in encoding)
  IF INSTR(pat$,"<#") > 0 THEN
    PROCvfpop("imm","0",0)
    PROCvfpop("imn","0",0)
    PROCvfpop("U"  ,"1",1)
  ENDIF

  REM loop until we have parsed the entire pattern
  WHILE pat%<=patlen%

    REM get the char
    c$=MID$(pat$,pat%,1)
    pat%+=1

    REM if end of optional section, or we are skipping rest of optional section...
    IF c$="}" OR c$="|" OR skip OR skipOR THEN

      CASE c$ OF
      WHEN "}"
        REM at end of optional section we need to repeat if flag set and it wasn't skipped this time
        oprepeats = (MID$(pat$,pat%,1) = "~")
        IF oprepeats THEN
          IF NOT skip THEN pat%=optpat% ELSE pat%+=1
        ENDIF
        IF optOR AND skip THEN =FALSE
        IF skip THEN ins%=optins%
        skipOR=FALSE
        skip=FALSE
        opt=FALSE
        optOR=FALSE

      WHEN "|"
        IF skip THEN ins%=optins% ELSE skipOR=TRUE
        skip=FALSE
        optOR=TRUE

      ENDCASE

    ELSE

      CASE c$ OF
      WHEN "{"
        REM begin optional section - store current offsets
        opt=TRUE
        skip=FALSE
        skipOR=FALSE
        optOR=FALSE
        optins%=ins%
        optpat%=pat%-1

      WHEN "<"
        REM parse op-code within <>
        IF NOT FNvfp_parseop THEN
          IF opt THEN skip=TRUE ELSE =FALSE
        ENDIF

      WHEN "("
        reglist=TRUE
        IF MID$(inst$,ins%,1)="{" THEN ins%+=1

      WHEN ")"
        IF MID$(inst$,ins%,1)="}" THEN
          IF NOT reglist THEN PROCvfperror(0,"VFP register list bracket mismatch")
          ins%+=1
        ENDIF
        reglist=FALSE

      WHEN " ",","

        REM skip spaces
        WHILE ins%<=inslen% AND MID$(inst$,ins%,1)=" "
          ins%+=1
        ENDWHILE
        IF c$="," THEN
          IF MID$(inst$,ins%,1)<>"," THEN
            IF NOT opt THEN =FALSE ELSE skip=TRUE
          ELSE
            ins%+=1
          ENDIF
          WHILE ins%<=inslen% AND MID$(inst$,ins%,1)=" "
            ins%+=1
          ENDWHILE
        ENDIF

      OTHERWISE

        REM ** Other chars - match each char exactly **

        CASE c$ OF
        WHEN "\":c$=MID$(pat$,pat%,1):pat%+=1
        WHEN "(":c$="{":reglist=TRUE
        WHEN ")":c$="}":reglist=FALSE
        ENDCASE

        i$=MID$(inst$,ins%,1)
        IF c$<>i$ THEN
          IF NOT opt THEN =FALSE ELSE skip=TRUE
        ELSE
          ins%+=1
        ENDIF

      ENDCASE

    ENDIF

  ENDWHILE

  REM ** matched - add in ops from params **

  par$ = vfpparam$(lookup%)
  par% = 1
  parlen% = LEN(par$)
  WHILE par% <= parlen%

    op$ = FNvfp_parse(par$,par%,parlen%,"=")
    par%+=1
    dtopt = (MID$(par$,par%,1)="?")
    IF dtopt THEN par%+=1
    val$ = FNvfp_parse(par$,par%,parlen%,",")
    par%+=1

    IF dtopt THEN
      REM data-type specific value - need to see where our current DT is in the list
      val$ = FNvfp_parsedtparam(dt$,dtfilt$,val$)
    ENDIF

    IF LEFT$(val$,3)="bp_" THEN

      REM bit pattern
      bp$=RIGHT$(val$,LEN(val$)-3)
      bp%=1
      bplen%=LEN(bp$)
      val%=0
      WHILE bp%<=bplen%
        c$=MID$(bp$,bp%,1)
        CASE c$ OF
        WHEN "0","1"
          val%=(val%<<1) OR VAL(c$)
          bp%+=1
        OTHERWISE
          bpop$=FNvfp_parse(bp$,bp%,bplen%,"[")
          bp%+=1
          op%=FNvfp_matchop(bpop$)
          IF op%=-1 THEN PROCvfperror(0,"VFP internal error - bad op in param bitpattern : " + bpop$)
          opval% = vfpopval%(op%)
          WHILE bp%<=bplen% AND MID$(bp$,bp%,1)<>"]"
            valbit% = INSTR("0123456789ABCDEF",MID$(bp$,bp%,1))-1
            IF valbit% = -1 THEN PROCvfperror(0,"VFP internal error - bit bit in param bitpattern : " + bp$)
            valbit% = (opval%>>valbit%) AND 1
            val%=(val%<<1) OR valbit%
            bp%+=1
          ENDWHILE
          bp%+=1
        ENDCASE
      ENDWHILE

    ELSE
      val% = EVAL(val$)
    ENDIF

    PROCvfpop(op$,val$,val%)
  ENDWHILE

  REM lookup the encoding if we haven't found it already
  IF encoding% = -1 THEN PROCvfp_lookupencoding

=TRUE

DEF PROCvfp_lookupencoding
  encoding$=vfpencoding$(lookup%)
  encoding% = FNvfp_matchencoding(encoding$)
  IF encoding% = -1 THEN PROCvfperror(0,"VFP internal mismatch - unrecognised encoding : " + encoding$)
  opcmodelist$ = vfpopcmode$(encoding%)
ENDPROC

REM *******************
REM ** Parse Op Code **
REM *******************
REM NB; most variables are local to the outer routine to allow parameter passing
REM     (these would be class level variables if implemented in an OO language)

REM Exit
REM   returns TRUE if matched, FALSE otherwise

DEF FNvfp_parseop
LOCAL op$
LOCAL esize%,immshift%,immshift$, reglimit$,reglimit%
LOCAL imm6,imm4,imm4%,imm6l%,imm6r%

  REM read the opcode
  op$=FNvfp_parse(pat$,pat%,patlen%,">")
  pat%+=1

  REM process the op - storing the results for subsequent encoding evaluation
  REM ops table has op string and op value stored for each op found

  CASE op$ OF
  WHEN "c"

    cond$=FNvfp_parse(inst$,ins%,inslen%,". ")
    CASE cond$ OF
    WHEN "EQ"     :cond%=%0000
    WHEN "NE"     :cond%=%0001
    WHEN "CS","HS":cond%=%0010
    WHEN "CC","LO":cond%=%0011
    WHEN "MI"     :cond%=%0100
    WHEN "PL"     :cond%=%0101
    WHEN "VS"     :cond%=%0110
    WHEN "VC"     :cond%=%0111
    WHEN "HI"     :cond%=%1000
    WHEN "LS"     :cond%=%1001
    WHEN "GE"     :cond%=%1010
    WHEN "LT"     :cond%=%1011
    WHEN "GT"     :cond%=%1100
    WHEN "LE"     :cond%=%1101
    WHEN "AL",""  :cond%=%1110
    OTHERWISE     :=FALSE
    ENDCASE
    PROCvfpop("cond",cond$,cond%)

  WHEN "dt"

    REM get the data-type string & length
    dt$=FNvfp_parse(inst$,ins%,inslen%,". ")
    c$=LEFT$(dt$,1)
    IF LEN(dt$)>1 AND INSTR("ISUF",c$)>0 THEN dt%=VAL(RIGHT$(dt$,LEN(dt$)-1)) ELSE dt%=0

    REM validate the data-type parsed
    IF dt$="" OR INSTR("ISUF",c$)<1 OR (dtfilt$<>"" AND INSTR(dtfilt$,dt$)<1) THEN = FALSE
    IF INSTR("ISU",c$)>0 AND (dt%<>8 AND dt%<>16 AND dt%<>32 AND dt%<>64) THEN =FALSE
    IF c$="F" AND (dt%<>32 AND dt%<>64) THEN =FALSE

    REM add the op codes to the op list relating to the data-type parsed
    REM dt=datatype size, U=unsigned flag, F=float flag, size=encoded size, size1=size-1, imm3=alternative size encoding
    PROCvfpop("dt",dt$,dt%)

    IF c$="U" THEN val%=1 ELSE val%=0
    PROCvfpop("U",STR$~val%,val%)

    IF c$="F" THEN val%=1 ELSE val%=0
    PROCvfpop("F",STR$~val%,val%)

    IF c$="F" THEN
      IF dt%=32 THEN PROCvfpop("sz","0",0) ELSE PROCvfpop("sz","1",1)
    ENDIF

    size%=0
    CASE dt% OF
    WHEN  8:size%=%00:imm3%=%001:esize%=%10
    WHEN 16:size%=%01:imm3%=%010:esize%=%01
    WHEN 32:size%=%10:imm3%=%100:esize%=%00
    WHEN 64:size%=%11
    ENDCASE
    PROCvfpop("size" ,STR$~size%,size%)
    PROCvfpop("size1",STR$~(size%-1),(size%-1))
    PROCvfpop("esize",STR$~(esize%),esize%)
    PROCvfpop("imm3" ,STR$~imm3%,imm3%)
    IF dt%=64 THEN PROCvfpop("L",STR$ size%,1) ELSE PROCvfpop("L",STR$ size%,0)

  WHEN "size"

    REM get the data-type size
    dt$=FNvfp_parse(inst$,ins%,inslen%,". ")
    IF dt$<>"" THEN dt%=VAL(dt$) ELSE dt%=0

    REM validate the data-type size parsed
    IF dt$="" OR (dt%<>8 AND dt%<>16 AND dt%<>32 AND dt%<>64) OR (dtfilt$<>"" AND INSTR(dtfilt$,dt$)<1) THEN =FALSE

    REM add the opcodes for the data-type parsed - dt=datatype size, size=encoded size
    PROCvfpop("dt",dt$,dt%)
    size%=0:esize%=0
    CASE dt% OF
    WHEN  8:size%=%00:esize%=%10
    WHEN 16:size%=%01:esize%=%01
    WHEN 32:size%=%10:esize%=%00
    WHEN 64:size%=%11
    ENDCASE
    PROCvfpop("size" ,STR$~size%,size%)
    PROCvfpop("esize",STR$~(esize%),esize%)
    IF dt%=64 THEN PROCvfpop("L",STR$ size%,1) ELSE PROCvfpop("L",STR$ size%,0)

  WHEN "spec"

    REM look for special register name and encode reg
    reg$ = FNvfp_parse(inst$,ins%,inslen%,", ")
    reg% = 0
    CASE reg$ OF
    WHEN "FPSID":reg%=%0000
    WHEN "FPSCR":reg%=%0001
    WHEN "MVFR1":reg%=%0110
    WHEN "MVFR0":reg%=%0111
    WHEN "FPEXC":reg%=%1000
    OTHERWISE:=FALSE
    ENDCASE
    PROCvfpop("spec",reg$,reg%)

  WHEN "lbl"

    REM look for an expression - label or otherwise
    REM get the absolute address and sub the PC from it
    REM then check range against #+-10, encoded 8 bits word aligned
    REM U=1 when positive, U=0 when negative
    REM imm contains the immediate (imm8 in ARM)
    REM Rn = R15

    val$ = FNvfp_parse(inst$,ins%,inslen%,":;")
    val% = EVAL(val$)
    val% = val% - P% - 8
    IF (val% AND %11)<>0 OR val%<=-1024 OR val%>=1024 THEN PROCvfperror(0,"VFP label out of range : &" + STR$~val%)
    IF val%>=0 THEN PROCvfpop("U","1",1) ELSE PROCvfpop("U","0",0)
    val% = ABS(val%) >> 2
    PROCvfpop("imm",STR$~val%,val%)
    PROCvfpop("Vn" ,"PC",%1111)

  WHEN "@"  : REM align

  LOCAL align$,a%,alen%,aval%,align%,found

    REM align is optional so we need to ensure default of 0 irrespective if actuall specified
    PROCvfpop("align","",0)
    REM validation the instruction contains an "@"
    IF MID$(inst$,ins%,1)<>"@" THEN = FALSE

    REM skip the @ and get the value specified
    ins%+=1

    val$ = FNvfp_parse(inst$,ins%,inslen%,"],")
    val% = VAL(val$)
    found=FALSE
    align%=0

    REM verify alignment given against align string and encode the result
    align$ = vfpalign$(lookup%)
    IF LEFT$(align$,1)="?" THEN
      REM extract the alignment string for the data-type/size specified
      align$=RIGHT$(align$,LEN(align$)-1)
      align$=FNvfp_parsedtparam(dt$,dtfilt$,align$)
    ENDIF

    REM find the alignment and encoding in the alignment validation string
    a%=1
    alen%=LEN(align$)
    WHILE a%<=alen% AND NOT found
      a$=FNvfp_parse(align$,a%,alen%,",")
      a%+=1
      IF a$<>"" THEN
        ax%=INSTR(a$,"x")
        aval%=VAL(LEFT$(a$,ax%-1))
        IF val%=aval% THEN
          align%=EVAL("%"+RIGHT$(a$,LEN(a$)-ax%))
          found=TRUE
        ENDIF
      ENDIF
    ENDWHILE

    IF NOT found THEN PROCvfperror(0,"VFP invalid @ alignment : " + val$)
    PROCvfpop("align",val$,align%)

  WHEN "!"

    REM ** writeback flag ** - sets Rm to R15 or R13 (used in VLDx/VSTx as flag) and also the W flag (used in VLDM/VSTM)
    w%=0
    c$=MID$(inst$,ins%,1)
    CASE c$ OF
    WHEN "!"
      val%=%1101 : val$="wb"    : w%=1 : ins%+=1
    WHEN ",",""," "
      val%=%1111 : val$="no-wb" : w%=0
    OTHERWISE
       =FALSE
    ENDCASE
    PROCvfpop("Vm",val$,val%)
    PROCvfpop("W",STR$ w%,w%)

  OTHERWISE

    REM we didn't match an entire opcode, so we now look at the first char to find the option required
    c$=LEFT$(op$,1)
    d$=MID$(op$,2,1)

    CASE c$ OF
    WHEN "Q","D","S","R"

      REM check correct char is specified in the instruction
      REM this version insists on R for ARM core, the assembler version does not and allows sp,lr,PC and just integers
      IF MID$(inst$,ins%,1)<>c$ THEN =FALSE
      ins%+=1

      REM get the register name from the pattern (prefix and 1 char 'name')
      n$=LEFT$(op$,2)

      REM data-type F64 can't be used with a SIMD quad register (ensures correct syntax is found)
      IF c$="Q" AND dt$="F64" THEN =FALSE

      REM parse the register number string
      reg$=FNvfp_parse(inst$,ins%,inslen%,", -[]{}@!")
      reg%=EVAL(reg$)
      CASE c$ OF
      WHEN "Q":IF reg%<0 OR reg%>15 THEN PROCvfperror(0,"VFP quadword register out of range : " + STR$ reg%)
      WHEN "D":IF reg%<0 OR reg%>31 THEN PROCvfperror(0,"VFP double register out of range : " + STR$ reg%)
      WHEN "S":IF reg%<0 OR reg%>31 THEN PROCvfperror(0,"VFP single register out of range : " + STR$ reg%)
      WHEN "R":IF reg%<0 OR reg%>15 THEN PROCvfperror(0,"VFP ARM core register out of range : " + STR$ reg%)
      ENDCASE

      REM look for register being part of a list - val% acts as a flag for testing [x] value is consistent later
      val%=-1
      regcount%=1
      reginc=FALSE

      REM look for end of range specifier
      IF MID$(op$,3,1)="-" THEN

        REM lookup existing register op
        op%=FNvfp_matchop(n$)
        IF op%=-1 THEN PROCvfperror(0,"VFP internal error - unexpected register offset : " + op$)

        REM see if not incrementing
        IF reg%<vfpopinc%(op%) THEN PROCvfperror(0,"VFP register list range must be ascending")

        REM set val% as flag
        val%=0

        REM store new end of list
        vfpopinc%(op%) = reg%

        REM calculate register count
        regcount%=vfpopinc%(op%) - vfpopval%(op%) + 1

      ENDIF

      REM look for part of incrementing list specifier
      IF MID$(op$,3,1)="+" THEN

        REM the char after the + is either ? for a incrementing list of n length, or a number for a specific increment
        val$=MID$(op$,4,1)
        reginc = (val$="?")

        REM find the existing register in the op table
        op%=FNvfp_matchop(n$)
        IF op%=-1 THEN PROCvfperror(0,"VFP internal error - unexpected register offset : " + op$)

        REM for an increment list find the next number, otherwise look for the specific offset specified
        IF reginc THEN val%=vfpopinc%(op%)+1 ELSE val%=VAL(val$)+vfpopval%(op%)

        REM verify the register found is the correct one (can't report error as might be different on next variation of instruction)
        IF reg%<>val% THEN =FALSE

        REM for an incremental list, inc the register count
        IF reginc THEN vfpopinc%(op%) += 1

        REM calc the number of entries in the list
        regcount%=vfpopinc%(op%) - vfpopval%(op%) + 1

        REM remove the +n operand from the opcode
        op$=LEFT$(op$,2)+RIGHT$(op$,LEN(op$)-4)

      ENDIF

      var$=""

      REM parse scalar offset
      IF MID$(op$,3,1)<>"[" THEN
         REM if no scalar, but one is in the instruction, it's not this encoding...
         IF MID$(inst$,ins%,1)="[" THEN =FALSE
      ELSE

        REM verify this isn't a double register (currently the only option with scalar offsets)
        IF c$<>"D" THEN PROCvfperror(0,"VFP unexpected scalar offset on non-double register")

        REM look for a placeholder version with no-offset variable
        IF MID$(op$,3,2)="[]" THEN
          IF MID$(inst$,ins%,2)<>"[]" THEN =FALSE
          ins%+=2
        ELSE
          IF (MID$(inst$,ins%,1)<>"[" OR MID$(inst$,ins%+2,1)<>"]") THEN =FALSE

          REM get the scalar name and value, and validate the offset
          var$=MID$(op$,4,1)
          var%=VAL(MID$(inst$,ins%+1,1))

          REM after the [x] can be a register number limit in hex [0-F]
          reglimit$=MID$(op$,6,1)
          IF reglimit$<>"" AND INSTR("0123456789ABCDEF",reglimit$)>0 THEN
            reglimit%=EVAL("&"+reglimit$)
            IF reg%>reglimit% THEN PROCvfperror(0,"VFP double scalar register out of range (0-" + STR$ reglimit% + ")")
          ENDIF

          REM validate the size of the scalar offset specified - for 8 bit 0-7, 16bit 0-3, 32bit 0-1
          CASE dt% OF
          WHEN 32   : IF (var%<0 OR var%>1) THEN PROCvfperror(0,"VFP double scalar 32bit offset out of range (0-1)")
          WHEN 16   : IF (var%<0 OR var%>3) THEN PROCvfperror(0,"VFP double scalar 16bit offset out of range (0-3)")
          WHEN  8   : IF (var%<0 OR var%>7) THEN PROCvfperror(0,"VFP double scalar 8bit offset out of range (0-7)")
          OTHERWISE : PROCvfperror(0,"VFP internal error - scalar used with unknown operation size")
          ENDCASE

          REM if we have a + on our reg we verify the scalar offset is consistent with before, or we add the new op
          IF val%>=0 THEN
            op%=FNvfp_matchop(var$)
            IF op%=-1 THEN PROCvfperror(0,"VFP internal error - inconsistent double scalar offset")
            IF vfpopval%(op%) <> var% THEN PROCvfperror(0,"VFP double scalar offset inconsistent")
          ELSE
            PROCvfpop(var$,STR$ var%,var%)
          ENDIF

          ins%+=3
        ENDIF

      ENDIF

      REM add reg to the list if this is not a + offset
      IF val%=-1 THEN

        PROCvfpop(n$,reg$,reg%)

        REM encode the V variant used in the encoding

        REM encode the register number
        CASE c$ OF
        WHEN "S" : reg% = ((reg% AND %11110)>>1) OR ((reg% AND %00001)<<4)
        WHEN "Q" : reg% = reg% * 2
        ENDCASE
        PROCvfpop("V"+d$,STR$ reg%,reg%)

        REM set the Q (quadword) flag
        IF FNvfp_matchop("Q") = -1 OR c$="Q" THEN
          IF c$="Q" THEN PROCvfpop("Q",c$,1) ELSE PROCvfpop("Q",c$,0)
        ENDIF

      ENDIF

      REM update register count (D or S types only)
      IF reglist THEN
        CASE c$ OF
        WHEN "D"
          IF reginc THEN val%=VAL(dtfilt$) ELSE val%=32
          IF regcount%>val% THEN PROCvfperror(0,"VFP double float register list can not contain more than 16 registers")
          PROCvfpop("regcount",STR$(regcount%*2),regcount%*2)
        WHEN "S"
          IF reginc THEN val%=VAL(dtfilt$) ELSE val%=32
          IF regcount%>val% THEN PROCvfperror(0,"VFP single float register list can not contain more than 32 registers")
          PROCvfpop("regcount",STR$(regcount%)  ,regcount%)
        ENDCASE
      ENDIF

    WHEN "#"

      REM 8 bit   - can be moved around in a destination register, allowing for a wide range of possible numbers (ARM p302)
      REM 8 bit   - can be encoded into floating point formats (ARM p305)
      REM 8 bit   - if DT is set we need to filter available values against the op:cmode bit field
      REM 4-6 bit - fbits (ARM p894)

      REM check we have a "#" in the instruction
      IF MID$(inst$,ins%,1)<>"#" THEN =FALSE
      ins%+=1

      REM parse the number of bits string
      immbits$=RIGHT$(op$,LEN(op$)-1)    : REM extract the values after the # from the op
      immneg=FALSE                       : REM immneg flag - negate immediate given for encoding
      imm6=FALSE                         : REM create imm6 op flag
      imm4=FALSE                         : REM create imm4 op flag
      immshift%=0                        : REM immediate value must be multile of this and will be shifted right by this for encoding

      REM immediate number of bits is either specified directly or is 'd' meaning the same as the size specified in the instruction
      CASE immbits$ OF

      WHEN "c"
        immbits%=6
        immmax%=32
        immmin%=1
        imm6=FALSE

      WHEN "d"
        immbits%=size%+3                 : REM  fbits - use size encoding where 8=0,16=1,32=2,64=3 - add 3 to equal bit count of size
        immmax%=(1<<immbits%)            : REM  we allow 1 higher as size% based values are 0-n
        immmin%=1                        : REM  minimum is 1 for fbits
        imm6=TRUE

      WHEN "e"
        immbits%=size%+2                 : REM  fbits - use size encoding where 8=0,16=1,32=2,64=3 - add 2 to equal size bit count - 1 for narrowing
        immmax%=(1<<immbits%)            : REM  we allow 1 higher as size% based values are 0-n
        immmin%=1                        : REM  minimum is 1 for fbits
        imm6=TRUE

      WHEN "f"
        immbits%=size%+3                 : REM  fbits - use size encoding where 8=0,16=1,32=2,64=3 - add 3 to equal bit count of size
        immmax%=(1<<immbits%)            : REM  we allow 1 higher as size% based values are 0-n
        IF immbits%=4 THEN immmin%=0 ELSE immmin%=1
        imm4=TRUE                        : REM create imm4, note min is 0 when 16 bits (p895 ARM)

      OTHERWISE

        REM check for factor specified as sn on the end of the op
        immshift$ = RIGHT$(immbits$,2)
        imm$=RIGHT$(immshift$,1)
        CASE TRUE OF
        WHEN LEFT$(immshift$,1)="s" AND INSTR("12345678",imm$)>0
          immshift%=VAL(imm$)
        ENDCASE

        REM the +- flag means the value can be positive or negative (used for offsets in VLDR/VSTR) and must be word aligned (4*bits)
        IF LEFT$(immbits$,2)="+-" THEN
          immbits$ = RIGHT$(immbits$,LEN(immbits$)-2)
          immbits%=VAL(immbits$)
          immmax%=(1<<immbits%)-1
          immmin%=-immmax%
        ELSE
          immbits%=ABS(VAL(immbits$))
          IF immbits%<32 THEN immmax%=(1<<immbits%)-1 ELSE immmax%=0
          immmin%=0
          REM see if the immediate bit count was negative
          immneg = (LEFT$(immbits$,1)="-")
        ENDIF

      ENDCASE

      REM check if invalid bit count
      IF immbits%<0 OR immbits%>32 THEN PROCvfperror(0,"VFP internal error - immediate bit count out of range : " + STR$~immbit%)

      REM read the immediate value specified
      imm$=FNvfp_parse(inst$,ins%,inslen%,"]")

      REM less than 32 is for fbits - 32 is used for VMOV type immediate numbers
      IF immbits%<32 THEN

        REM get the value and verify it
        IF imm$="" THEN imm%=0 ELSE imm%=EVAL(imm$)
        IF imm% < immmin% OR imm% > immmax% THEN PROCvfperror(0,"VFP immediate out of range : &" + STR$~imm%)

        REM apply any shift
        IF immshift% > 0 THEN imm% = imm% << immshift%

        IF immmin%<0 THEN
          REM when negative is possible we are encoding a register offset
          REM      the U flag indicates + or - offset
          REM      the immediate must be word aligned as it divided by 4 for encoding
          val%=ABS(imm%)
          IF (val% AND %11)<>0 THEN PROCvfperror("0,"VFP immdiate value must be word aligned")
          val%=val%>>2
          PROCvfpop("imm",imm$,val%)
          IF imm%<0 THEN PROCvfpop("U","0",0) ELSE PROCvfpop("U","1",1)
        ELSE
          IF immneg THEN imm%=NOT(imm%)
          imn%=0-imm%
          REM add imm and inverse ops
          PROCvfpop("imm",imm$,imm%)
          REM imn is 0-imm - used where encoding is x-n WHERE 1<n<=x
          PROCvfpop("imn",imm$,imn%)

          IF imm6 THEN
            REM imm6 is used by many VQ and VR instructions to encode the shift constant
            REM we need to encode a left and right version as the encoding is different
            CASE immbits% OF
            WHEN 3 : imm6l% = %001000 OR (imm% AND %111)   : imm6r% = %001000 OR (imn% AND %111)
            WHEN 4 : imm6l% = %010000 OR (imm% AND %1111)  : imm6r% = %010000 OR (imn% AND %1111)
            WHEN 5 : imm6l% = %100000 OR (imm% AND %11111) : imm6r% = %100000 OR (imn% AND %11111)
            WHEN 6 : imm6l% = (imm% AND %111111)           : imm6r% = (imn% AND %111111)
            OTHERWISE : PROCvfperror(0,"VFP internal error - unexpected imm6 bit count")
            ENDCASE
            PROCvfpop("imm6l",STR$ imm6l%,imm6l%)
            PROCvfpop("imm6r",STR$ imm6r%,imm6r%)
          ENDIF

          IF imm4 THEN
            imm4%=0
            CASE immbits% OF
            WHEN 4:imm4%=16 - imm%
            WHEN 5:imm4%=32 - imm%
            ENDCASE
            PROCvfpop("imm4",STR$ imm4%,imm4%)
          ENDIF

        ENDIF

      ELSE

        REM see if the immediate value has a data-type specifier
        CASE LEFT$(imm$,4) OF
        WHEN "I64."

          imm%=EVAL(RIGHT$(imm$,LEN(imm$)-4))
          IF imm%<0 OR imm%>255 THEN PROCvfperror(0,"VFP immedate I64. out of range (0-255) : " + STR$ imm%)
          opcmode$="11110":opc$="00000"
          opcmode%=%11110

        WHEN "F32."

          imm%=EVAL(RIGHT$(imm$,LEN(imm$)-4))
          IF imm%<0 OR imm%>255 THEN PROCvfperror(0,"VFP immedate F32. out of range (0-255) : " + STR$ imm%)
          opcmode$="01111":opc$="00000"
          opcmode%=%01111

        WHEN "F64."

          REM NB: F64 is same as F32
          imm%=EVAL(RIGHT$(imm$,LEN(imm$)-4))
          IF imm%<0 OR imm%>255 THEN PROCvfperror(0,"VFP immedate F64. out of range (0-255) : " + STR$ imm%)
          opcmode$="01111":opc$="00000"
          opcmode%=%01111

        OTHERWISE

          REM we have a limited set of encoding options for 32 or 64bit numbers
          REM we find a suitable encoding of opcmode and then match it against the list from the encoding

          REM get the immediate value
          IF imm$="" THEN imm%=0 ELSE imm%=EVAL(imm$)

          REM make sure the number is in the correct format for encoding
          REM   this option is used for VAND which is a VBIC with the specified number made negative
          REM   so we have to reverse what was supplied to encode it correctly
          IF immneg THEN imm%=NOT(imm%)

          CASE dt% OF
          WHEN 8
            IF imm%<-&00FF OR imm%>&00FF THEN PROCvfperror(0,"Immediate out of range for 8bit data-type : " + STR$ imm%)
            imm%=imm% AND &00FF:imm%=imm% OR (imm%<<8) OR (imm%<<16) OR (imm%<<24)
          WHEN 16
            IF imm%<-&FFFF OR imm%>&FFFF THEN PROCvfperror(0,"Immediate out of range for 16bit data-type : " + STR$ imm%)
            imm%=imm% AND &FFFF:imm%=imm% OR (imm%<<16)
          ENDCASE

          REM easiest way to handle encoding logic is to split into 4 bytes
          b3%=(imm%>>24) AND 255
          b2%=(imm%>>16) AND 255
          b1%=(imm%>>8 ) AND 255
          b0%= imm%      AND 255

          CASE TRUE OF
          WHEN b3%=0   AND b2%=0   AND b1%=0                : opcmode$="x000x" : imm%=b0%
          WHEN b3%=0   AND b2%=0   AND b1%<>0  AND b0%=0    : opcmode$="x001x" : imm%=b1%
          WHEN b3%=0   AND b2%<>0  AND b1%=0   AND b0%=0    : opcmode$="x010x" : imm%=b2%
          WHEN b3%<>0  AND b2%=0   AND b1%=0   AND b0%=0    : opcmode$="x011x" : imm%=b3%
          WHEN b3%=0   AND b1%=0   AND b2%=b0% AND b0%<>0   : opcmode$="x100x" : imm%=b0%
          WHEN b2%=0   AND b0%=0   AND b3%=b1% AND b1%<>0   : opcmode$="x101x" : imm%=b1%
          WHEN b3%=0   AND b2%=0   AND b1%<>0  AND b0%=255  : opcmode$="x1100" : imm%=b1%
          WHEN b3%=0   AND b2%<>0  AND b1%=255 AND b0%=255  : opcmode$="x1101" : imm%=b2%
          WHEN b3%=b2% AND b2%=b1% AND b1%=b0% AND b0%<>0   : opcmode$="01110" : imm%=b0%
          OTHERWISE:PROCvfperror(0,"VFP immediate out of range : &" + STR$~imm%)
          ENDCASE

          REM get the encoding if we haven't already
          IF encoding% = - 1 THEN PROCvfp_lookupencoding

          REM pattern match opcmode with opcmodelist to see if we can use the immediate encoding we found
          REM    within the bitpatterns x means any bit and is used on both sides of the matching process
          opc%=1
          opclen%=LEN(opcmodelist$)
          opcmatch = FALSE
          opcmode%=0
          WHILE opc%<=opclen% AND NOT opcmatch
            opc$=FNvfp_parse(opcmodelist$,opc%,opclen%,",")
            opc%+=1
            opcmatch = FNvfp_bitmatch(opc$,opcmode$,opcmode%)
          ENDWHILE

          IF NOT opcmatch THEN PRINT "No match : " + opcmode$ + " in " + opcmodelist$

          IF NOT opcmatch THEN =FALSE
          opcmode$ = opcmode$+" OR "+opc$

        ENDCASE

        REM negate the value if required
        REM IF immneg THEN imm%=NOT(imm%)

        REM store the immediate value and the opcmode encoding
        PROCvfpop("opcmode",opcmode$,opcmode%)
        PROCvfpop("imm",STR$~imm%,imm%)

      ENDIF

    OTHERWISE
      PROCvfperror(0,"VFP internal error - unexpected op code in instruction descriptor : " + op$)
    ENDCASE

  ENDCASE

=TRUE

REM ** Report VFP Error **

DEF PROCvfperror(vfperr%,vfperr$)
  ERROR vfperr%,vfperr$ + vfpinstdebug$
ENDPROC

REM ** Add Op to List **

DEF PROCvfpop(opname$,opval$,opval%)
LOCAL op%
  op% = FNvfp_matchop(opname$)
  IF op%=-1 THEN
    op%=vfpop%
    vfpop%+=1
  ENDIF
  vfpop$(op%)=opname$
  vfpopval$(op%)=opval$
  vfpopval%(op%)=opval%
  vfpopinc%(op%)=opval%
ENDPROC

REM ** Find Op in Table **

DEF FNvfp_matchop(opname$)
LOCAL op%
  op%=0
  WHILE op% < vfpop%
    IF vfpop$(op%) = opname$ THEN =op%
    op%+=1
  ENDWHILE
=-1

REM ** Find Encoding in Table **

DEF FNvfp_matchencoding(encoding$)
LOCAL e%
  e%=0
  WHILE e%<vfpenc%
    IF vfpencname$(e%)=encoding$ THEN =e%
    e%+=1
  ENDWHILE
=-1

REM ** Align The Assembler **

DEF FNvfpalign(a%)
LOCAL i%
  i%=a%-(P% AND (a%-1))
  P%+=i%:O%+=i%
=0

REM *************************
REM ** VFP Parsing Support **
REM *************************

DEF FNvfp_parse(inst$,RETURN ins%,inslen%,term$)
LOCAL temp$,c$
  temp$=""
  WHILE ins%<=inslen%
    c$=MID$(inst$,ins%,1)
    IF INSTR(term$,c$)>0 THEN =temp$
    temp$+=c$
    ins%+=1
  ENDWHILE
=temp$

DEF FNvfp_bitmatch(b1$,b2$,RETURN bp%)
LOCAL c%,b1len%,c1$,c2$
  bp%=0
  b1len%=LEN(b1$)
  IF b1len% <> LEN(b2$) THEN =FALSE
  c%=1
  WHILE c%<=b1len%
    c1$=MID$(b1$,c%,1)
    c2$=MID$(b2$,c%,1)
    IF c1$<>"x" AND c2$<>"x" AND c1$<>c2$ THEN =FALSE
    bp%=bp% << 1
    IF c1$="1" OR c2$="1" THEN bp%=bp% OR 1
    c%+=1
  ENDWHILE
=TRUE

DEF FNvfp_parsedtparam(dt$,dtfilt$,val$)
LOCAL dt%,dtlen%,val%,vallen%
  dt%=1
  dtlen%=LEN(dtfilt$)
  val%=1
  vallen%=LEN(val$)
  WHILE dt%<=dtlen%
    out$=FNvfp_parse(val$,val%,vallen%,"|")
    IF FNvfp_parse(dtfilt$,dt%,dtlen%,",")=dt$ THEN =out$
    dt%+=1
    val%+=1
  ENDWHILE
  PROCvfperror(0,"VFP internal error - unable to locate dtparam against data-type list")
=""

REM *******************************
REM ** Assemble from bit-pattern **
REM *******************************

DEF PROCvfp_assemble
LOCAL bp$,bp%,bplen%,bit%,c$,valbit%,not,var$,op%

  REM get the bit-pattern
  bp$ = vfpbitpattern$(encoding%)
  bp% = 1
  bplen% = LEN(bp$)

  REM clear the instruction
  O%!0 = 0

  REM loop from bit31 to bit0
  bit%=31
  WHILE bit%>=0

    REM check if something buggy has happened with our encoding string
    IF bp%>bplen% THEN PROCvfperror(0,"VFP internal error - insufficient bits in bitpattern : " + bp$)

    REM get the next bit
    c$=MID$(bp$,bp%,1)
    bp%+=1

    REM process this bit
    CASE c$ OF
    WHEN "0","1"

      REM 0,1 are immediate values
      valbit% = VAL(c$)
      O%!0 = O%!0 OR (valbit% << bit%)
      bit%-=1
      not=FALSE

    WHEN "!"

      REM set the NOT the variable flag (doesn't apply to immediate values as that would be mad :-) )
      not=TRUE

    OTHERWISE

      REM we have a variable so get the variable name
      var$=c$+FNvfp_parse(bp$,bp%,bplen%,"[")

      REM match the variable against the op table
      op% = FNvfp_matchop(var$)
      IF op% = -1 THEN PROCvfperror(0,"VFP internal error - unknown op in bitpattern : " + var$)

      REM get the value of the variable from the op table
      val% = vfpopval%(op%)

      REM apply the NOT flag to the entire variable (reverse all bits)
      IF not THEN val%=0-val%

      REM process the bit list following the variable name
      bp%+=1
      not=FALSE
      WHILE bp%<=bplen% AND MID$(bp$,bp%,1) <> "]"

        REM check something buggy hasn't happened with our encoding string
        IF bit%<0 THEN PROCvfperror(0,"VFP internal error - too many bits in bitpattern : " + bp$)

        REM get the bit and procses NOT logic
        bit$ =MID$(bp$,bp%,1)
        IF bit$="!" THEN
          not=TRUE
        ELSE

          REM lookup the bit number (0-15) (no need for higher numbers for ARM encoding)
          valbit% = INSTR("0123456789ABCDEF",bit$) - 1
          IF valbit% < 0 THEN PROCvfperror(0,"VFP internal error - unknown op bit in bitpattern : " + bp$)

          REM extract the bit
          valbit% = (val% >> valbit%) AND 1

          REM apply the NOT flag - applies just to this bit
          IF not THEN valbit%=valbit% EOR 1

          REM OR the bit into our instruction
          O%!0 = O%!0 OR (valbit% << bit%)
          bit%-=1
          not=FALSE

        ENDIF
        bp%+=1
      ENDWHILE
      bp%+=1
    ENDCASE
  ENDWHILE

  REM inc to next instruction
  P%+=4:O%+=4
ENDPROC

REM ************************************
REM **                                **
REM ** Generate Assembler Header File **
REM **                                **
REM ************************************
REM creates header file for use in basic assembler version
REM
REM constants...
REM
REM op numbers     - each param (op) replaced with a descriptive define - vfp_op_<name> EQU <value>
REM op datatype    - (as below) vfp_op_datatype_<name> EQU <value>
REM encoding flags - (as below) vfp_enc_flag_<name> EQU <value>
REM
REM structures...
REM
REM table of 4 char unique inst-codes and associated ptr to syntax table containing each variation
REM   0-3  = 4 char inst-code
REM   4-7  = ptr to 1st syntax for op
REM
REM syntax lookup table per unique 4 char op
REM   0-3  = ptr to syntax string   (0=last)
REM   4-7  = ptr to encoding
REM   8-11 = ptr to data-type list  (0=none)
REM  12-15 = ptr to align list      (0=none)
REM  16-19 = ptr to params table    (0=none)
REM
REM data-type list (list of words containing data-types or sizes)
REM    0-3 = 0 if end of list
REM     or
REM      0 = data-type ('S','U','I','F') or space if size only data-type
REM    1-2 = data-type size as string (byte 2 is space char (32) if unused)
REM      3 = data-type size in bytes
REM
REM align list
REM    0-3 = 0 if end of list
REM     or
REM      0 = alignment
REM      1 = alignment bit encoding
REM    2-3 = 0
REM params list
REM      0 = op number (0=end of list)
REM      1 = number of bit fields (1=single, 2+=per data-type)
REM    2-3 = 0
REM      4+= bit-field record
REM
REM bit-field record
REM    0-3 = base immediate constant
REM    4-7 = ptr to args (0=none) (i.e. constant value)
REM
REM bit-field args
REM    0-3 = 0 = end of list
REM     or
REM      0 = param number
REM      1 = bit mask
REM      2 = amount to shift right
REM      3 = 0
REM
REM encoding
REM    0-3 = flags (bit0=VFPv2, bit1=VFPv3, bit2=SIMD)
REM    4-7 = ptr to opcmode list (0=none)
REM      8+= bitfield record (as above) containing encoding
REM
REM opcmode list
REM    0-3 = 0 = end of list
REM     or
REM    0-4 = 5 char string of bit-pattern (each char is 0,1 or x - where x means any)
REM    5-7 = 0

DEF PROCVFPLib_saveasm(file$)
LOCAL vfpdt%,vfpdt$
LOCAL opcmode%,opcmode$
LOCAL tab$,quo$
LOCAL file%

  REM ** First we need to create the optimised lookup tables from the syntax and encoding tables **

  REM declare new arrays
  vfpdt% = 0
  DIM vfpdt$(100)
  vfpbfa%=0
  DIM vfpbfa$(200)
  vfpot% = 0
  DIM vfpot$(100)
  DIM vfpotfirst%(100)
  vfpalist%=0
  DIM vfpalist$(100)
  vfppalist%=0
  DIM vfppalist$(100)

  REM build unique list of all op names referenced
  PROCvfp_oasm_buildoplist

  REM build list of unique data-type combinations
  PROCvfp_oasm_builddtlist

  REM build sorted list of fist 4 chars of syntax variations
  PROCvfp_oasm_buildoptable

  REM build list of unique alignment combinations
  PROCvfp_oasm_buildalist

  REM build list of unique bitfield arg combinations
  REM (used to optimise VFP_Encoding output
  PROCvfp_oasm_buildbfatable

  REM build unique param list
  PROCvfp_oasm_buildparamtable

  REM ** Output the file for ObjAsm **

  tab$=CHR$(9)
  quo$=CHR$(34)
  file%=OPENOUT(file$)

  ON ERROR LOCAL PROCvfp_oasm_error:END

  PROCvfp_oasm_header
  PROCvfp_oasm_macros
  PROCvfp_oasm_data
  PROCvfp_oasm_footer

  CLOSE#file%

  file%=0
  SYS "OS_File",18,file$,&FFF
ENDPROC

DEF PROCvfp_oasm_error
 ON ERROR OFF
 IF file%>0 THEN CLOSE#file%:file%=0
 PRINT REPORT$;" at line ";ERL
ENDPROC

REM ** Build BitfieldArgs Table **

DEF PROCvfp_oasm_buildbfatable
LOCAL enc%,pat$,found%,bfa%

  REM add encoding bitfields to bitfieldargs table
  REM (param bitfields added when parsing op names)
  enc%=0
  WHILE enc% < vfpenc%
    pat$ = vfpbitpattern$(enc%)
    pat$ = FNvfp_oasm_tobfastr(pat$)
    PROCvfp_oasm_bfaadd(pat$)
    enc%+=1
  ENDWHILE
ENDPROC

DEF PROCvfp_oasm_bfaadd(pat$)
LOCAL found%,bfa%
  found%=FALSE
  bfa%=FNvfp_oasm_bfamatch(pat$)
  IF bfa%=-1 THEN
    vfpbfa$(vfpbfa%) = pat$
    vfpbfa%+=1
  ENDIF
ENDPROC

DEF FNvfp_oasm_bfamatch(pat$)
LOCAL bfa%
  bfa%=0
  WHILE bfa%<vfpbfa%
    IF vfpbfa$(bfa%) = pat$ THEN =bfa% ELSE bfa%+=1
  ENDWHILE
=-1

DEF FNvfp_oasm_tobfastr(pat$)
LOCAL o$,p%,plen%
  o$ = ""
  p%=1
  plen%=LEN(pat$)
  WHILE p%<=plen%
    c$=MID$(pat$,p%,1)
    CASE c$ OF
    WHEN "0","1"
      o$+="0"
    OTHERWISE
      o$+=FNvfp_parse(pat$,p%,plen%,"]")
      o$+="]"
    ENDCASE
    p%+=1
  ENDWHILE
=o$

REM ** Build Align List Table **

DEF PROCvfp_oasm_buildalist
LOCAL lookup%,a%,found%
  lookup% = 0
  WHILE lookup% < vfplookup%
    align$ = vfpalign$(lookup%)
    IF align$<>"" THEN PROCvfp_oasm_bal_add(align$)
    lookup%+=1
  ENDWHILE
ENDPROC

DEF PROCvfp_oasm_bal_add(align$)
LOCAL a%
  a%=FNvfp_oasm_bal_match(align$)
  IF a%=-1 THEN
    vfpalist$(vfpalist%) = align$
    vfpalist%+=1
  ENDIF
ENDPROC

DEF FNvfp_oasm_bal_match(align$)
LOCAL a%
  a%=0
  WHILE a%<vfpalist%
    IF vfpalist$(a%) = align$ THEN =a%
    a%+=1
  ENDWHILE
=-1


REM ** Build Op-Table - first 4 chars of each instruction code **

DEF PROCvfp_oasm_buildoptable
LOCAL lookup%,pat$,code$
LOCAL complete%,skip%

  REM create the list of 4 letter codes
  lookup% = 0
  WHILE lookup% < vfplookup%
    pat$ = vfppattern$(lookup%)
    code$ = LEFT$(pat$,4)
    PROCvfp_oasm_bopt_add(code$,lookup%)
    lookup%+=1
  ENDWHILE

  REM sort the list (slow ripple sort - but ok here)
  skip%=1
  complete%=FALSE
  WHILE NOT complete%
    complete%=TRUE
    ot%=0
    WHILE ot% < vfpot%-skip%
      IF vfpot$(ot%) > vfpot$(ot%+1) THEN
        code$ = vfpot$(ot%)
        lookup% = vfpotfirst%(ot%)
        vfpot$(ot%) = vfpot$(ot%+1)
        vfpotfirst%(ot%) = vfpotfirst%(ot%+1)
        vfpot$(ot%+1) = code$
        vfpotfirst%(ot%+1) = lookup%
        complete%=FALSE
      ENDIF
      ot%+=1
    ENDWHILE
    skip%+=1
  ENDWHILE

ENDPROC

DEF PROCvfp_oasm_bopt_add(code$,lookup%)
LOCAL ot%,found%
  ot%=0
  found%=FALSE
  WHILE ot% < vfpot% AND NOT found%
    IF vfpot$(ot%) = code$ THEN found%=TRUE ELSE ot%+=1
  ENDWHILE
  IF NOT found% THEN
    vfpot$(vfpot%) = code$
    vfpotfirst%(vfpot%) = lookup%
    vfpot%+=1
  ENDIF
ENDPROC

REM ** Build Op-code List **
REM find all param "op" names used - potentially referenced in params bitfields, and encoding bitfield

DEF PROCvfp_oasm_buildoplist
LOCAL enc%,enc$
LOCAL lookup%,p$,p%,plen%,op$,val$,v%,vlen%,bp$

  vfpop%=0

  REM first add encodings
  enc%=0
  WHILE enc% < vfpenc%
    enc$ = vfpbitpattern$(enc%)
    PROCvfp_oasm_bol_bitpattern(enc$)
    enc% += 1
  ENDWHILE

  REM second add params
  lookup%=0
  WHILE lookup% < vfplookup%

    p$ = vfpparam$(lookup%)
    p% = 1
    plen% = LEN(p$)
    WHILE p% <= plen%

      op$ = FNvfp_parse(p$,p%,plen%,"=")
      PROCvfpop(op$,"",0)
      p%+=1
      val$ = FNvfp_parse(p$,p%,plen%,",")

      IF LEFT$(val$,1) = "?" THEN

        REM per data-type pattern
        v% = 2
        vlen% = LEN(val$)
        WHILE v%<=vlen%
          bp$ = FNvfp_parse(val$,v%,vlen%,"|")
          IF LEFT$(bp$,3) = "bp_" THEN
            bp$ = RIGHT$(bp$,LEN(bp$)-3)
            PROCvfp_oasm_bol_bitpattern(bp$)
          ENDIF
          v%+=1
        ENDWHILE

      ELSE

        REM single pattern for all data-types
        bp$ = val$
        IF LEFT$(bp$,3) = "bp_" THEN
          bp$ = RIGHT$(bp$,LEN(bp$)-3)
          PROCvfp_oasm_bol_bitpattern(bp$)
        ENDIF

      ENDIF
      p%+=1

    ENDWHILE

    lookup%+=1
  ENDWHILE

  REM ** sort the oplist created **
LOCAL max%,op%,o%,swap%,o$
  max%=vfpop%-1
  swap%=1
  WHILE max%>=0  AND swap%=1
    op%=0
    swap%=0
    WHILE op% < max%
      IF FNvfp_uc(vfpop$(op%)) > FNvfp_uc(vfpop$(op%+1)) THEN
        o$ = vfpop$(op%) : vfpop$(op%) = vfpop$(op%+1) : vfpop$(op%+1) = o$
        swap%=1
      ENDIF
      op%+=1
    ENDWHILE
    max%-=1
  ENDWHILE
ENDPROC

DEF FNvfp_uc(s$)
LOCAL l%,c%,o$,b%
  l%=LEN(s$)
  c%=1
  o$=""
  WHILE c%<=l%
    b%=ASC(MID$(s$,c%,1))
    IF b%>=ASC("a") AND b%<=ASC("z") THEN b%-=32
    o$+=CHR$(b%)
    c%+=1
  ENDWHILE
=o$

DEF PROCvfp_oasm_bol_bitpattern(enc$)
LOCAL e%,elen%,c$,op$,pat$

  REM take this opportunity to add this encoding to the bitpattern list
  pat$=FNvfp_oasm_tobfastr(enc$)
  PROCvfp_oasm_bfaadd(pat$)

  REM extract all op names used
  e% = 1
  elen% = LEN(enc$)
  WHILE e% <= elen%
    c$=MID$(enc$,e%,1)
    CASE c$ OF
    WHEN "0","1" : e%+=1
    OTHERWISE
      op$ = FNvfp_parse(enc$,e%,elen%,"[")
      PROCvfpop(op$,"",0)
      op$ = FNvfp_parse(enc$,e%,elen%,"]")
      e%+=1
    ENDCASE
  ENDWHILE
ENDPROC

REM ** Build unique list of data-type lists **

DEF PROCvfp_oasm_builddtlist
LOCAL lookup%,dtf$
  lookup% = 0
  WHILE lookup% < vfplookup%
    dtf$ = vfpdtfilter$(lookup%)
    IF dtf$<>"" THEN PROCvfp_oasm_bdtl_add(dtf$)
    lookup%+=1
  ENDWHILE
ENDPROC

DEF FNvfp_oasm_bdtl_match(dtf$)
LOCAL dt%
  dt%=0
  WHILE dt% < vfpdt%
    IF vfpdt$(dt%) = dtf$ THEN =dt%
    dt%+=1
  ENDWHILE
=-1

DEF PROCvfp_oasm_bdtl_add(dtf$)
LOCAL dt%
  dt%=FNvfp_oasm_bdtl_match(dtf$)
  IF dt%=-1 THEN
    vfpdt$(vfpdt%) = dtf$
    vfpdt% += 1
  ENDIF
ENDPROC

REM ** Build Unique List of Param Lists **

DEF PROCvfp_oasm_buildparamtable
LOCAL lookup%
  lookup%=0
  WHILE lookup% < vfplookup%
    param$ = vfpparam$(lookup%)
    IF param$<>"" THEN PROCvfp_oasm_bpt_add(param$)
    lookup%+=1
  ENDWHILE
ENDPROC

DEF PROCvfp_oasm_bpt_add(param$)
LOCAL pa%
  pa% = FNvfp_oasm_bpt_match(param$)
  IF pa% = - 1 THEN
    vfppalist$(vfppalist%) = param$
    vfppalist%+=1
  ENDIF
ENDPROC

DEF FNvfp_oasm_bpt_match(param$)
LOCAL pa%
  pa%=0
  WHILE pa%<vfppalist%
    IF vfppalist$(pa%) = param$ THEN =pa%
    pa%+=1
  ENDWHILE
=-1

REM ****************************
REM ** Output Asm File Header **
REM ****************************

DEF PROCvfp_oasm_header
  PROCvfp_oasm_putstr(";ObjAsm header file created by VFPLib - (C)2011 TBA Software")
  PROCvfp_oasm_putstr(";")
  PROCvfp_oasm_putstr(";This file contains data-tables used within s.VFP in the BASIC source")
  PROCvfp_oasm_putstr(";")
  PROCvfp_oasm_putstr(";Generated automatically by VFPLib at " + TIME$)
  PROCvfp_oasm_putstr(";")
  PROCvfp_oasm_putstr("  [ :DEF: BuildingVFPData")
  PROCvfp_oasm_putstr(tab$+"INCLUDE  hdr/VFPMacros")
  PROCvfp_oasm_putstr(tab$+"AREA	|VFPLibObjHdr$Code|, CODE, READONLY, PIC")
  PROCvfp_oasm_putstr(tab$+"ENTRY")
  PROCvfp_oasm_putstr("  ]")


ENDPROC

REM *******************
REM ** Output Macros **
REM *******************

DEF PROCvfp_oasm_macros
  REM macros now included in separate source file
ENDPROC

REM *****************
REM ** Output Data **
REM *****************

DEF PROCvfp_oasm_data
  DIM bfaOp$(100)
  DIM bfaBm%(100)
  DIM bfaSh%(100)
  DIM vfpotlist%(100)

  PROCvfp_oasm_data_ops
  PROCvfp_oasm_putstr("  [ :DEF: BuildingVFPData")
  PROCvfp_oasm_putstr("; start of VFP tables")
  PROCvfp_oasm_putstr("VFPtables       DCB ""VFPTABLE""")
  PROCvfp_oasm_putstr(tab$+"DCD VFPOpTable-VFPtables")
  PROCvfp_oasm_putstr(";")
  PROCvfp_oasm_data_dtlist
  PROCvfp_oasm_data_bfalist
  PROCvfp_oasm_data_encodings
  PROCvfp_oasm_data_syntax
  PROCvfp_oasm_putstr("  ]")
ENDPROC

REM ** Output Params List **

DEF PROCvfp_oasm_data_ops
LOCAL op%,label$,value$
  PROCvfp_oasm_putstr(";Param Op Number Definitions")
  PROCvfp_oasm_put("VFP_OpCount","EQU " + STR$ vfpop%,1)
  op%=0
  WHILE op%<vfpop%
    label$="VFP_Op_" + vfpop$(op%)
    value$="EQU " + STR$ op%
    PROCvfp_oasm_put(label$,value$,1)
    op%+=1
  ENDWHILE
  PROCvfp_oasm_putblank
ENDPROC

REM ** Output Datatype Varaitions List **

DEF PROCvfp_oasm_data_dtlist
LOCAL dt%,dtlist$,d%,dlen%,d$
LOCAL dt$,dtsize%
LOCAL label$,l$,line%

  PROCvfp_oasm_putstr(";List of Unique Datatype Combinations")

  dt%=0
  WHILE dt%<vfpdt%

    label$ = "VFPdt_" + FNvfp_oasm_id(dt%)
    line%=1
    dtlist$=vfpdt$(dt%)
    d%=1
    dlen%=LEN(dtlist$)
    WHILE d% <=dlen%
      d$ = FNvfp_parse(dtlist$,d%,dlen%,",")
      d%+=1
      dt$ = LEFT$(d$,1)
      CASE dt$ OF
      WHEN "I","S","U","F","P"
        dtsize% = VAL(RIGHT$(d$,LEN(d$)-1))
      OTHERWISE
        dt$ = " "
        dtsize% = VAL(d$)
      ENDCASE
      l$ = "VFP_DataTypeListEntry "+FNvfp_oasm_str(dt$)+","+FNvfp_oasm_pad(STR$ dtsize%,2)+","+STR$ dtsize%
      PROCvfp_oasm_put(label$,l$,line%)
      line%+=1
    ENDWHILE
    PROCvfp_oasm_put0

    dt%+=1
  ENDWHILE

  PROCvfp_oasm_putblank

ENDPROC

DEF PROCvfp_oasm_data_bfalist
LOCAL bfa%,l$,label$
  PROCvfp_oasm_putstr(";Bit Field Args Lists")
  bfa%=0
  WHILE bfa% < vfpbfa%
    label$ = "VFPbfa_" + FNvfp_oasm_id(bfa%)
    PROCvfp_oasm_data_bitfield(label$,vfpbfa$(bfa%),TRUE)
    bfa%+=1
  ENDWHILE
  PROCvfp_oasm_putblank
ENDPROC

DEF PROCvfp_oasm_data_encodings
LOCAL enc%
  enc%=0
  WHILE enc%<vfpenc%
    PROCvfp_oasm_data_encoding(enc%)
    enc%+=1
  ENDWHILE
ENDPROC

REM ** Output Data for Encoding **

DEF PROCvfp_oasm_data_encoding(enc%)
LOCAL l$,l%
LOCAL flag$,ver$
LOCAL opcmode$,opc$,o%,olen%,o$
LOCAL encoding$

  REM third output the encoding record
  PROCvfp_oasm_putstr(";"+vfpencname$(enc%))

  REM first build the flags string
  flag$=""
  ver$=vfpversion$(enc%)
  IF INSTR(ver$,"2")>0 THEN flag$+="+VFP_Enc_Flag_VFPv2"
  IF INSTR(ver$,"3")>0 THEN flag$+="+VFP_Enc_Flag_VFPv3"
  IF INSTR(ver$,"4")>0 THEN flag$+="+VFP_Enc_Flag_VFPv4"
  IF INSTR(ver$,"S")>0 THEN flag$+="+VFP_Enc_Flag_SIMDv1"
  IF INSTR(ver$,"$")>0 THEN flag$+="+VFP_Enc_Flag_SIMDv2"
  IF flag$<>"" THEN flag$="(" + RIGHT$(flag$,LEN(flag$)-1) + ")"

  REM second output the opcmode list if specified
  opcmode$=""
  opc$=vfpopcmode$(enc%)
  IF opc$<>"" THEN
    opcmode$ = "VFPopc_" + FNvfp_oasm_id(enc%)
    l%=1
    o%=1
    olen%=LEN(opc$)
    WHILE o%<olen%
      o$=FNvfp_parse(opc$,o%,olen%,",")
      o%+=1
      l$="VFP_OPCModeListEntry "+FNvfp_oasm_str(o$)
      PROCvfp_oasm_put(opcmode$,l$,l%)
      l%+=1
    ENDWHILE
    PROCvfp_oasm_put0
  ENDIF

  encoding$="VFPenc_" + FNvfp_oasm_id(enc%)
  l$="VFP_Encoding "+flag$+","+FNvfp_oasm_ptr(opcmode$)
  PROCvfp_oasm_put(encoding$,l$,1)

  REM fourth output the bitfield for the encoding pattern
  PROCvfp_oasm_data_bitfield("", vfpbitpattern$(enc%), 0)

  PROCvfp_oasm_putblank
ENDPROC

REM ** Output Bitfield **

DEF PROCvfp_oasm_data_bitfield(label$,bf$,argsonly%)
LOCAL bf%,bflen%,c$
LOCAL bit%,const%
LOCAL op$,opbit$,opbit%,opbits%,mask%,shift%
LOCAL l$,bfa%,bfastr%,bfa$

  IF NOT argsonly% THEN
    pat$ = FNvfp_oasm_tobfastr(bf$)
    bfastr% = FNvfp_oasm_bfamatch(pat$)
    IF bfastr%=-1 THEN PROCvfperror(0,"VFP Internal Error - Bitfield not in bfa table : " + bf$)
    bfa$="VFPbfa_"+FNvfp_oasm_id(bfastr%)
  ENDIF

  REM calculate length of bitfield (in bits)
  bit%=0
  bf%=1
  bflen%=LEN(bf$)
  WHILE bf%<=bflen%
    c$=MID$(bf$,bf%,1)
    CASE c$ OF
    WHEN "0","1"
      bit%+=1 : bf%+=1
    OTHERWISE
      op$=FNvfp_parse(bf$,bf%,bflen%,"[")  : bf%+=1
      bit$=FNvfp_parse(bf$,bf%,bflen%,"]") : bf%+=1
      bit%+=LEN(bit$)
    ENDCASE
  ENDWHILE

  bit%-=1
  bfa%=0
  const%=0
  bf%=1
  bflen%=LEN(bf$)
  WHILE bf% <= bflen%
    c$=MID$(bf$,bf%,1)
    CASE c$ OF
    WHEN "0"
      bit%-=1
       bf%+=1
    WHEN "1"
      const%=const% OR (1<<bit%)
      bit%-=1
      bf%+=1
    OTHERWISE

      op$=FNvfp_parse(bf$,bf%,bflen%,"[")
      bf%+=1

      mask%=0
      shift%=0
      opbit%=0
      opbits%=0
      oplastbit%=-1
      WHILE MID$(bf$,bf%,1)<>"]" AND bf%<=bflen%
        opbit$ = MID$(bf$,bf%,1)
        bf%+=1
        opbit% = VAL(opbit$)
        mask% = mask% OR (1<<opbit%)
        opbits% += 1
        IF oplastbit%<>-1 AND opbit%<>oplastbit%-1 THEN PROCvfperror(0,"VFP internal error - bit field out of sequence : " + bf$)
        oplastbit% = opbit%
      ENDWHILE
      bit%-=opbits%
      shift% = (bit%+1) - opbit%

      bfaOp$(bfa%) = op$
      bfaBm%(bfa%) = mask%
      bfaSh%(bfa%) = shift%
      bfa%+=1

      bf%+=1
    ENDCASE
  ENDWHILE

  REM write out the bitfield data

  IF NOT argsonly% THEN
    l$="VFP_BitFieldRecord &"+STR$~const%+","+FNvfp_oasm_ptr(bfa$)
    PROCvfp_oasm_put(label$,l$,1)
  ENDIF
  IF argsonly% THEN
    IF bfastr%=-1 THEN label$=""
    bf%=0
    WHILE bf%<bfa%
      l$="VFP_BitFieldArgs VFP_Op_"+bfaOp$(bf%)+", &"+STR$~bfaBm%(bf%)+", "+STR$ bfaSh%(bf%)
      PROCvfp_oasm_put(label$,l$,bf%+1)
      bf%+=1
    ENDWHILE
    PROCvfp_oasm_put0
  ENDIF

ENDPROC

REM ** Output Syntax Data **

DEF PROCvfp_oasm_data_syntax

  REM 1) loop through each 4 char optable entry
  REM      write VFP_OpTableEntry for each entry
  REM
  REM 2) loop through each 4 char optable entry (again)
  REM      create label from 4 chars
  REM      build list of all lookups with these 4 chars at start
  REM        output syntax entry, align list entry, and paramstable for each lookup
  REM      write VFP_SyntaxLookup for each syntax in list from previous step

LOCAL ot%,ot$,l$,label$,o%
LOCAL otlist%,lookup%,param$,pa%
LOCAL alist$,alist%,alistlen%,a$,a%,alen%,astr$,aval%,line%

  PROCvfp_oasm_putstr(";Pattern Definitions")
  lookup% = 0
  WHILE lookup% < vfplookup%
    label$ = "VFPpat_" + FNvfp_oasm_id(lookup%)
    l$ = "VFP_Pattern " + FNvfp_oasm_str(vfppattern$(lookup%))
    PROCvfp_oasm_put(label$,l$,1)
    lookup% += 1
  ENDWHILE
  PROCvfp_oasm_putblank

  PROCvfp_oasm_putstr(";Align List")
  alist% = 0
  WHILE alist% < vfpalist%
    alist$=vfpalist$(alist%)
    IF alist$<>"" THEN
      label$="VFPali_" + FNvfp_oasm_id(alist%)
      a%=1
      REM write out an alignlist / entries for each comma seperated entry in the list
      alen%=LEN(alist$)
      line%=1
      WHILE a%<=alen%
        astr$ = FNvfp_parse(alist$,a%,alen%,",")
        a%+=1
        PROCvfp_oasm_data_align(label$,astr$,line%)
        line%+=1
      ENDWHILE
      PROCvfp_oasm_put0
    ENDIF
    alist% += 1
  ENDWHILE
  PROCvfp_oasm_putblank

  PROCvfp_oasm_putstr(";Params List")
  pa% = 0
  WHILE pa% < vfppalist%
    param$=vfppalist$(pa%)
    IF param$ <>"" THEN
      label$ = "VFPpar_" + FNvfp_oasm_id(pa%)
      PROCvfp_oasm_data_param(label$,param$)
    ENDIF
    pa%+=1
  ENDWHILE
  PROCvfp_oasm_putblank

  PROCvfp_oasm_putstr(";4 char code table")
  ot%=0
  WHILE ot% < vfpot%
    ot$ = vfpot$(ot%)
    l$ = "VFP_OpTableEntry " + FNvfp_oasm_str(ot$) + "," + FNvfp_oasm_ptr("VFPsyn_" + ot$)
    PROCvfp_oasm_put("VFPOpTable",l$,ot%+1)
    ot%+=1
  ENDWHILE
  PROCvfp_oasm_put0
  PROCvfp_oasm_putblank

  PROCvfp_oasm_putstr(";Syntax Lookup table - grouped per 4 char code")

  ot%=0
  WHILE ot% < vfpot%

    REM build list of all syntax patterns with this 4 char code
    ot$ = vfpot$(ot%)
    label$ = "VFPsyn_" + ot$
    otlist%=0
    lookup%=0
    WHILE lookup% < vfplookup%
      pat$ = vfppattern$(lookup%)
      IF LEFT$(pat$,4) = ot$ THEN
        vfpotlist%(otlist%) = lookup%
        otlist%+=1
      ENDIF
      lookup%+=1
    ENDWHILE

    o%=0
    WHILE o%<otlist%

      lookup% = vfpotlist%(o%)
      pattern$  = "VFPpat_" + FNvfp_oasm_id(lookup%)

      enc% = FNvfp_matchencoding(vfpencoding$(lookup%))
      encoding$ = "VFPenc_" + FNvfp_oasm_id(enc%)

      datatype$=""
      dtf$ = vfpdtfilter$(lookup%)
      IF dtf$<>"" THEN
        dt% = FNvfp_oasm_bdtl_match(dtf$)
        datatype$ = "VFPdt_" + FNvfp_oasm_id(dt%)
      ENDIF

      alignlist$=""
      align$ = vfpalign$(lookup%)
      IF align$<>"" THEN
        alist% = FNvfp_oasm_bal_match(align$)
        alignlist$ = "VFPali_" + FNvfp_oasm_id(alist%)
      ENDIF

      paramlist$=""
      param$ = vfpparam$(lookup%)
      IF param$<>"" THEN
        pa% = FNvfp_oasm_bpt_match(param$)
        paramlist$ = "VFPpar_" + FNvfp_oasm_id(pa%)
      ENDIF

      l$ = "VFP_SyntaxLookup "+FNvfp_oasm_ptr(pattern$)+","+FNvfp_oasm_ptr(encoding$)+","+FNvfp_oasm_ptr(datatype$)+","+FNvfp_oasm_ptr(alignlist$)+","+FNvfp_oasm_ptr(paramlist$)
      PROCvfp_oasm_put(label$,l$,o%+1)

      o%+=1
    ENDWHILE

    PROCvfp_oasm_put0

    ot%+=1
  ENDWHILE

  PROCvfp_oasm_putblank

ENDPROC

DEF PROCvfp_oasm_data_param(label$,param$)
LOCAL p%,plen%,inst$,i%,ilen%,v%,vlen%,vars$,v$,opcount%
  opcount%=1
  p%=1
  plen%=LEN(param$)
  WHILE p%<=plen%
    inst$ = FNvfp_parse(param$,p%,plen%,",")
    p%+=1

    i%=1
    ilen%=LEN(inst$)
    op$ = FNvfp_parse(inst$,i%,ilen%,"=")
    val$ = RIGHT$(inst$,ilen%-i%)

    op$ = "VFP_Op_" + op$

    IF LEFT$(val$,1)="?" THEN

      count%=0
      vars$=val$
      v%=2:vlen%=LEN(vars$)
      WHILE v%<=vlen%
        v$=FNvfp_parse(vars$,v%,vlen%,"|")
        v%+=1:count%+=1
      ENDWHILE

      PROCvfp_oasm_data_paramop(label$,op$,count%,opcount%)

      vars$=val$
      v%=2:vlen%=LEN(vars$)
      WHILE v%<=vlen%
        val$=FNvfp_parse(vars$,v%,vlen%,"|")
        PROCvfp_oasm_data_paramval(val$)
        v%+=1
      ENDWHILE

    ELSE
      PROCvfp_oasm_data_paramop(label$,op$,1,opcount%)
      PROCvfp_oasm_data_paramval(val$)
    ENDIF
    opcount%+=1

  ENDWHILE
  PROCvfp_oasm_put0

ENDPROC

DEF PROCvfp_oasm_data_paramop(label$,op$,count%,opcount%)
LOCAL l$
  l$="VFP_ParamsList "+op$+","+STR$ count%
  PROCvfp_oasm_put(label$,l$,opcount%)
ENDPROC

DEF PROCvfp_oasm_data_paramval(val$)
LOCAL l$,val%
  IF LEFT$(val$,3)="bp_" THEN
    val$=RIGHT$(val$,LEN(val$)-3)
    PROCvfp_oasm_data_bitfield("",val$,0)
  ELSE
    val%=EVAL(val$)
    l$="VFP_BitFieldRecord &"+STR$~val%+",0"
    PROCvfp_oasm_put("",l$,2)
  ENDIF
ENDPROC

REM ** Write out an Alignment List Header/Entries **

DEF PROCvfp_oasm_data_align(label$,align$,line%)
LOCAL var%,p%
LOCAL a%,alen%,a$,astr$,astr%,aval$,aval%
LOCAL l$

  REM count number of variations
  var%=0
  p%=1
  WHILE p%>0
    var%+=1
    p%=INSTR(align$,"|",p%) : IF p%>0 THEN p%+=1
  ENDWHILE

  REM write header
  PROCvfp_oasm_put(label$,"VFP_AlignList "+STR$ var%,line%)

  REM remove ? if present
  IF LEFT$(align$,1) = "?" THEN align$=RIGHT$(align$,LEN(align$)-1)

  a%=1
  alen%=LEN(align$)
  WHILE var%>0
    a$ = FNvfp_parse(align$,a%,alen%,"|")
    a%+=1
    IF a$="" THEN
      PROCvfp_oasm_put("","VFP_AlignListEntry 0,0",2)
    ELSE
      aval% = INSTR(a$,"x")
      astr$ = LEFT$(a$,aval%-1)
      astr% = VAL(astr$)
      aval$ = RIGHT$(a$,LEN(a$)-aval%)
      aval% = EVAL("%"+aval$)
      l$ = "VFP_AlignListEntry "+STR$ astr%+","+STR$ aval%
      PROCvfp_oasm_put("",l$,2)
    ENDIF
    var%-=1
  ENDWHILE
  PROCvfp_oasm_put0

ENDPROC

REM **********************************
REM ** Output Data in objAsm format **
REM **********************************

DEF FNvfp_oasm_id(num%)
  IF num%<16 THEN ="0"+STR$~num%
=STR$~num%

DEF FNvfp_oasm_pad(s$,len%)
  IF LEN(s$)<len% THEN s$ += STRING$(len%-LEN(s$)," ")
=CHR$(34)+s$+CHR$(34)

DEF FNvfp_oasm_str(str$)
=CHR$(34)+str$+CHR$(34)

DEF FNvfp_oasm_ptr(label$)
  IF label$="" THEN ="0"
="("+label$ + "-VFPtables)"

DEF PROCvfp_oasm_put(label$,line$,line%)
  IF line%>1 OR label$="" THEN
    BPUT#file%,tab$+tab$+line$
  ELSE
    IF LEN(label$)<8 THEN label$+=tab$
    BPUT#file%,label$+tab$+line$
  ENDIF
ENDPROC

DEF PROCvfp_oasm_putstr(str$)
  BPUT#file%,str$
ENDPROC

DEF PROCvfp_oasm_putblank
  BPUT#file%,""
ENDPROC

DEF PROCvfp_oasm_put0
  BPUT#file%,tab$+tab$+"DCD 0"
ENDPROC

REM *****************
REM ** Output Test **
REM *****************

DEF PROCvfp_oasm_footer
  PROCvfp_oasm_putstr(tab$+tab$+"END")
ENDPROC
