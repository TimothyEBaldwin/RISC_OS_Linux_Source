; This source code in this file is licensed to You by Castle Technology
; Limited ("Castle") and its licensors on contractual terms and conditions
; ("Licence") which entitle you freely to modify and/or to distribute this
; source code subject to Your compliance with the terms of the Licence.
; 
; This source code has been made available to You without any warranties
; whatsoever. Consequently, Your use, modification and distribution of this
; source code is entirely at Your own risk and neither Castle, its licensors
; nor any other person who has contributed to this source code shall be
; liable to You for any loss or damage which You may suffer as a result of
; Your use, modification or distribution of this source code.
; 
; Full details of Your rights and obligations are set out in the Licence.
; You should have received a copy of the Licence with this source code file.
; If You have not received a copy, the text of the Licence is available
; online at www.castle-technology.co.uk/riscosbaselicence.htm
; 
; This header file is autogenerated from the files maintained by the
; RISC OS allocations manager and should not be edited by anyone else.

; hdr:GraphicsV

; ********************
; *** Changes List ***
; ********************

; 28-Aug-02 KJB Created.
;

; reason codes passed in r4 to GraphicsV

GraphicsV_Complete              * 0
GraphicsV_VSync                 * 1
GraphicsV_SetMode               * 2
GraphicsV_SetInterlace          * 3 ; Deprecated
GraphicsV_SetBlank              * 4
GraphicsV_UpdatePointer         * 5
GraphicsV_SetDMAAddress         * 6
GraphicsV_VetMode               * 7
GraphicsV_DisplayFeatures       * 8
GraphicsV_FramestoreAddress     * 9
GraphicsV_WritePaletteEntry     * 10
GraphicsV_WritePaletteEntries   * 11
GraphicsV_ReadPaletteEntry      * 12
GraphicsV_Render                * 13
GraphicsV_IICOp                 * 14
GraphicsV_SelectHead            * 15
GraphicsV_StartupMode           * 16
GraphicsV_PixelFormats          * 17
GraphicsV_ReadInfo              * 18
GraphicsV_VetMode2              * 19

; GraphicsV_SetDMAAddress
GVDAG_VInit                     * 0
GVDAG_VStart                    * 1
GVDAG_VEnd                      * 2
GVDAG_VRender                   * 3

; GraphicsV_DisplayFeatures flags (r0)
GVDisplayFeature_HardwareScroll                     * 1:SHL:0
GVDisplayFeature_HardwarePointer                    * 1:SHL:1
GVDisplayFeature_InterlaceWithProgressiveFramestore * 1:SHL:2
GVDisplayFeature_SeparateFramestore                 * 1:SHL:3 ; GraphicsV_FramestoreAddress implemented
GVDisplayFeature_NoVsyncIRQ                         * 1:SHL:4
GVDisplayFeature_VariableFramestore                 * 1:SHL:5 ; driver-managed framestore address/size changes with mode
GVDisplayFeature_CopyRectangleIsFast                * 1:SHL:6 ; OS_SpriteOp 65 hint: copying rectangles (VRAM->VRAM via GPU) is faster than plotting sprites (RAM->VRAM via CPU)

; GraphicsV_Render flags (r0)
GVRender_SyncIfComplete         * 1:SHL:0
GVRender_SyncIfNotComplete      * 1:SHL:1
GVRender_Sync                   * 2_11:SHL:0

; GraphicsV_Render operation (r1)
GVRender_NOP                    * 0
GVRender_CopyRectangle          * 1
GVRender_FillRectangle          * 2

; GraphicsV_PixelFormats list format (r0)
                        ^ 0
GVPixelFormat_NColour   # 4 ; NColour mode variable value
GVPixelFormat_ModeFlags # 4 ; Relevant mode flags
GVPixelFormat_Log2BPP   # 4 ; Log2BPP mode variable value
GVPixelFormat_Size      # 0 ; Struct size

; GraphicsV_ReadInfo items (r0)
GVReadInfo_Version          * 0 ; Driver version number (BCD * &10000)
GVReadInfo_ModuleName       * 1 ; Module (instance) name if module
GVReadInfo_DriverName       * 2 ; Driver name for display to user
GVReadInfo_HardwareName     * 3 ; Hardware name for display to user (e.g. PCI card name)
GVReadInfo_ControlListItems * 4 ; List of known VIDC control list items

; GraphicsV_VetMode2 result flags (r0)
GVVetMode2_ResultMask           * 3
GVVetMode2_Result_Unsupported   * 0 ; Provided mode is unsupported
GVVetMode2_Result_SysFramestore * 1 ; Mode is supported, and will use the system framestore (i.e. kernel-managed DA 2)
GVVetMode2_Result_ExtFramestore * 2 ; Mode is supported, and will use the external framestore (as defined by R3 & R5)
GVVetMode2_Result_UnkFramestore * 3 ; Mode is supported, but driver doesn't know where the framestore will be (e.g. framestore is managed by another component, like the GPU firmware in the Pi)
GVVetMode2_ExtraBytes_Invalid   * 4 ; The input value of the ExtraBytes control list item was invalid, driver has suggested a new value in R2


                END
