;
; Copyright (c) 2013-2017, Timothy Baldwin
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;

 IF :LNOT: :DEF: Included_Hdr_PVOps
        GBLL    Included_Hdr_PVOps
Included_Hdr_PVOps SETL {TRUE}

 IF :LNOT: :DEF: Included_Hdr_Machine_Machine
        GET     Hdr:Machine.<Machine>
 ENDIF

        GBLA    PVOpsRelocation
PVOpsRelocation SETA 0

        MACRO
        PVOpsImports
        EXTERN  __PVirt_FastSWI
        EXTERN  __PVirt_FindMode
        EXTERN  __PVirt_GetCPSR
        EXTERN  __PVirt_GetSPSR
        EXTERN  __PVirt_GetVCPU
        EXTERN  __PVirt_LoadUsrRegisters
        EXTERN  __PVirt_MOVS_PC_LR
        EXTERN  __PVirt_SWI
        EXTERN  __PVirt_SetCPSR_c_unstack
        EXTERN  __PVirt_SetCPSR_cf_unstack
        EXTERN  __PVirt_SetCPSR_cs_unstack
        EXTERN  __PVirt_SetCPSR_csf_unstack
        EXTERN  __PVirt_SetCPSR_cx_unstack
        EXTERN  __PVirt_SetCPSR_cxf_unstack
        EXTERN  __PVirt_SetCPSR_cxs_unstack
        EXTERN  __PVirt_SetCPSR_cxsf_unstack
        EXTERN  __PVirt_SetSPSR
        EXTERN  __PVirt_TableEnd
        EXTERN  __PVirt_TableStart
        EXTERN  __PVirt_LinuxSyscall
        MEND

        MACRO
        PVJumpTable
      IF PVSys = 2
        PVOpsImports
      ELIF PVSys = 1
        EXPORT  __PVirt_TableStart
__PVirt_TableStart
        EXPORT  __PVirt_SetCPSR_cs_unstack
        EXPORT  __PVirt_SetCPSR_cxs_unstack
__PVirt_SetCPSR_cs_unstack
__PVirt_SetCPSR_cxs_unstack
        MSR     cpsr_s, r1
        B       __PVirt_SetCPSR_c_unstack

        EXPORT  __PVirt_SetCPSR_csf_unstack
        EXPORT  __PVirt_SetCPSR_cxsf_unstack
__PVirt_SetCPSR_csf_unstack
__PVirt_SetCPSR_cxsf_unstack
        MSR     cpsr_sf, r1

        EXPORT  __PVirt_SetCPSR_cf_unstack
        EXPORT  __PVirt_SetCPSR_cxf_unstack
__PVirt_SetCPSR_cf_unstack
__PVirt_SetCPSR_cxf_unstack
        MSR     cpsr_f, r1

        EXPORT  __PVirt_SetCPSR_c_unstack
        EXPORT  __PVirt_SetCPSR_cx_unstack
__PVirt_SetCPSR_c_unstack
__PVirt_SetCPSR_cx_unstack
        LDR     r0, [sp, #16]
        STR     lr, [sp, #16]
        MOV     lr, r0
        LDMFD   sp!, {r0-r3, ip, pc}

        EXPORT  __PVirt_GetCPSR
__PVirt_GetCPSR
        MRS     r0, CPSR
        MOV     pc, lr

        EXPORT  __PVirt_SetSPSR
__PVirt_SetSPSR
        MSR     SPSR_cxsf, r1
        MOV     pc, lr

        EXPORT  __PVirt_GetSPSR
__PVirt_GetSPSR
        MRS     r0, SPSR
        MOV     pc, lr

        EXPORT  __PVirt_GetVCPU
__PVirt_GetVCPU
        DCD     1
        UND

        EXPORT  __PVirt_FindMode
__PVirt_FindMode
        DCD     2
        UND

        EXPORT  __PVirt_MOVS_PC_LR
__PVirt_MOVS_PC_LR
        MOVS    pc, lr
        UND

        EXPORT  __PVirt_LoadUsrRegisters
__PVirt_LoadUsrRegisters
        DCD     3
        UND

        EXPORT  __PVirt_SWI
__PVirt_SWI
        LDR     r0, [sp, #12]
        STR     lr, [sp, #12]
        MOV     lr, r0
        LDMFD   sp!, {r0-r3, pc}

        EXPORT  __PVirt_LinuxSyscall
__PVirt_LinuxSyscall
        DCD     4
        UND

        EXPORT  __PVirt_FastSWI
__PVirt_FastSWI
        MOV     pc, lr
        UND
        
        EXPORT  __PVirt_TableEnd
__PVirt_TableEnd

      ENDIF
        MEND

        MACRO
        InitPVOps
      [ PVSys = 1
        STMFD   sp!, {r0, r1, lr} ; FIXME Remove?
        ADRL    r0, __PVirt_TableStart
        ADRL    r1, __PVirt_TableEnd
        SWI     0xE0202 ; XIXSupport_PatchTable
        LDMFD   sp!, {r0, r1, lr}
      ]
        MEND


; Push a register set
        MACRO
        PushSet$c $set
        IF $set = 0
        ELIF $set = 1 << 0
          STR$c r0, [sp, #-4]!
        ELIF $set = 1 << 1
          STR$c r1, [sp, #-4]!
        ELIF $set = 1 << 2
          STR$c r2, [sp, #-4]!
        ELIF $set = 1 << 3
          STR$c r3, [sp, #-4]!
        ELIF $set = 1 << 4
          STR$c r4, [sp, #-4]!
        ELIF $set = 1 << 5
          STR$c r5, [sp, #-4]!
        ELIF $set = 1 << 6
          STR$c r6, [sp, #-4]!
        ELIF $set = 1 << 7
          STR$c r7, [sp, #-4]!
        ELIF $set = 1 << 8
          STR$c r8, [sp, #-4]!
        ELIF $set = 1 << 9
          STR$c r9, [sp, #-4]!
        ELIF $set = 1 << 10
          STR$c r10, [sp, #-4]!
        ELIF $set = 1 << 11
          STR$c r11, [sp, #-4]!
        ELIF $set = 1 << 12
          STR$c r12, [sp, #-4]!
        ELIF $set = 1 << 14
          STR$c r14, [sp, #-4]!
        ELSE
          DCD   Cond_$c :OR: &092D0000 :OR: ($set)
        ENDIF
        MEND

        MACRO
        PullSet$c $set
        IF $set = 0
        ELIF $set = 1 << 0
          LDR$c r0, [sp], #4
        ELIF $set = 1 << 1
          LDR$c r1, [sp], #4
        ELIF $set = 1 << 2
          LDR$c r2, [sp], #4
        ELIF $set = 1 << 3
          LDR$c r3, [sp], #4
        ELIF $set = 1 << 4
          LDR$c r4, [sp], #4
        ELIF $set = 1 << 5
          LDR$c r5, [sp], #4
        ELIF $set = 1 << 6
          LDR$c r6, [sp], #4
        ELIF $set = 1 << 7
          LDR$c r7, [sp], #4
        ELIF $set = 1 << 8
          LDR$c r8, [sp], #4
        ELIF $set = 1 << 9
          LDR$c r9, [sp], #4
        ELIF $set = 1 << 10
          LDR$c r10, [sp], #4
        ELIF $set = 1 << 11
          LDR$c r11, [sp], #4
        ELIF $set = 1 << 12
          LDR$c r12, [sp], #4
        ELIF $set = 1 << 14
          LDR$c r14, [sp], #4
        ELSE
          DCD   Cond_$c :OR: &08BD0000 :OR: ($set)
        ENDIF
        MEND


        ; Simulates a SWI call
        MACRO
$label  pvSWI$cond $swi
$label
 [ PVSys > 1
        STM$cond.DB sp!, {r0-r3, lr}
        BL$cond __PVirt_SWI
 ]
        SWI$cond $swi
        MEND

        ; Simulates a SWI call, corrupts LR
        MACRO
$label  fvSWI$cond $swi
$label
 [ PVSys > 1
        BL$cond __PVirt_FastSWI
 ]
        SWI$cond $swi
        MEND


        MACRO
$label  pvMRS$c $reg, $psr
        ASSERT  ("$psr" = "CPSR") :LOR: ("$psr" = "SPSR")
 [ PVirt > 0
        LCLA    set
set     SETA    2_0100000000000001 :AND: :NOT: (1 << $reg)
$label
        PushSet$c 0x$set
        BL$c    __PVirt_Get$psr + PVOpsRelocation
   [ $reg != 0
        MOV$c   $reg, r0
   ]
        PullSet$c 0x$set
 |
$label  MRS$c   $reg, $psr
 ]
        MEND

        MACRO
$label  pvMSR$c $psr, $op2a, $op2b
$label
 IF PVirt < 1
        [ "$op2b" = ""
        MSR$c   $psr, $op2a
        |
        MSR$c   $psr, $op2a, $op2b
        ]
 ELIF "$psr" = "SPSR_cxsf"
        STM$c.FD sp!, {r0, r1, lr}
        [ "$op2b" = ""
        MOV$c   r1, $op2a
        |
        MOV$c   r1, $op2a, $op2b
        ]
        BL$c    __PVirt_SetSPSR + PVOpsRelocation
        LDM$c.FD sp!, {r0, r1, lr}
 ELSE

        ASSERT "$psr":LEFT:5 = "CPSR_"
        ASSERT "$psr":LEFT:6 <> "CPSR_x"

  [ "$psr":LEFT:6 = "CPSR_c"
        STM$c.FD sp!, {r0-r3, ip, lr}
        [ "$op2b" = ""
        MOV$c   r1, $op2a
        |
        MOV$c   r1, $op2a, $op2b
        ]
        BL$c    __PVirt_Set$psr._unstack + PVOpsRelocation
  ]

        [ "$op2b" = ""
        MSR$c   $psr, $op2a
        |
        MSR$c   $psr, $op2a, $op2b
        ]
 ENDIF ; PVirt
        MEND

        MACRO
$label  MOVS_PC_LR $c
 [ PVirt > 0
$label  B$c     __PVirt_MOVS_PC_LR + PVOpsRelocation
 |
$label  MOV$c.S pc, lr
 ]
        MEND


                        ^       0
                        #       8 ; Reserved for ELF thread local variables.
vcpu_vectors            #       4
vcpu_irq_pending        #       1
vcpu_cpsr               #       1
                        #       2
vcpu_r13_svc            #       4
vcpu_r14_svc            #       4
vcpu_spsr_svc           #       4
vcpu_r13_usr            #       4
vcpu_r14_usr            #       4
vcpu_spsr_usr           #       4
vcpu_r13_irq            #       4
vcpu_r14_irq            #       4
vcpu_spsr_irq           #       4
vcpu_r13_fiq            #       4
vcpu_r14_fiq            #       4
vcpu_spsr_fiq           #       4
vcpu_r13_und            #       4
vcpu_r14_und            #       4
vcpu_spsr_und           #       4
vcpu_r13_abt            #       4
vcpu_r14_abt            #       4
vcpu_spsr_abt           #       4
vcpu_DFAR               #       4

 ENDIF
        END
