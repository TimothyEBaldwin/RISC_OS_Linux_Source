;
; Copyright (c) 2013-2017, Timothy Baldwin
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;

 IF :LNOT: :DEF: Included_Hdr_PVOps
        GBLL    Included_Hdr_PVOps
Included_Hdr_PVOps SETL {TRUE}

 IF :LNOT: :DEF: Included_Hdr_Machine_Machine
        GET     Hdr:Machine.<Machine>
 ENDIF

        GBLA    PVOpsRelocation
PVOpsRelocation SETA 0

        GBLS    _PVirt
_PVirt  SETS    "__PVirt"

        MACRO
        PVOpsImports

        ; Linux port SWIs
        EXTERN  $_PVirt._FastSWI
        EXTERN  $_PVirt._SWI

        ; Linux system calls
        EXTERN  $_PVirt._LinuxSyscall

        ; Banked registers and PSR manipulation
        ; Implementions for 26-bit (TODO), 32-bit native and 32-bit user mode.
        EXTERN  $_PVirt._GetCPSR
        EXTERN  $_PVirt._GetSPSR
        EXTERN  $_PVirt._LoadSaveBlock
        EXTERN  $_PVirt._LoadUsr
        EXTERN  $_PVirt._LoadUsrRegisters
        EXTERN  $_PVirt._MOVS_PC_LR
        EXTERN  $_PVirt._SetCPSR_c
        EXTERN  $_PVirt._SetCPSR_cxsf
        EXTERN  $_PVirt._SetCPSR_c_unstack
        EXTERN  $_PVirt._SetCPSR_cf_unstack
        EXTERN  $_PVirt._SetCPSR_cs_unstack
        EXTERN  $_PVirt._SetCPSR_csf_unstack
        EXTERN  $_PVirt._SetCPSR_cx_unstack
        EXTERN  $_PVirt._SetCPSR_cxf_unstack
        EXTERN  $_PVirt._SetCPSR_cxs_unstack
        EXTERN  $_PVirt._SetCPSR_cxsf_unstack
        EXTERN  $_PVirt._SetSPSR
        EXTERN  $_PVirt._StoreUsr

        ; Virtual banked registers
        EXTERN  $_PVirt._GetVCPU
        EXTERN  $_PVirt._VModeOffsets

        ; For InitPVOps
        EXTERN  $_PVirt._TableEnd
        EXTERN  $_PVirt._TableStart

        MEND

        MACRO
        PVJumpTable
      IF PVSys = 3
        PVOpsImports
      ELIF PVSys > 0
        EXPORT  $_PVirt._TableStart
$_PVirt._TableStart
        EXPORT  $_PVirt._SetCPSR_cs_unstack
        EXPORT  $_PVirt._SetCPSR_cxs_unstack
$_PVirt._SetCPSR_cs_unstack
$_PVirt._SetCPSR_cxs_unstack
        MSR     cpsr_s, r1
        B       $_PVirt._SetCPSR_c_unstack

        EXPORT  $_PVirt._SetCPSR_csf_unstack
        EXPORT  $_PVirt._SetCPSR_cxsf_unstack
$_PVirt._SetCPSR_csf_unstack
$_PVirt._SetCPSR_cxsf_unstack
        MSR     cpsr_sf, r1

        EXPORT  $_PVirt._SetCPSR_cf_unstack
        EXPORT  $_PVirt._SetCPSR_cxf_unstack
$_PVirt._SetCPSR_cf_unstack
$_PVirt._SetCPSR_cxf_unstack
        MSR     cpsr_f, r1

        EXPORT  $_PVirt._SetCPSR_c_unstack
        EXPORT  $_PVirt._SetCPSR_cx_unstack
$_PVirt._SetCPSR_c_unstack
$_PVirt._SetCPSR_cx_unstack
        LDR     r0, [sp, #16]
        STR     lr, [sp, #16]
        MOV     lr, r0
        LDMFD   sp!, {r0-r3, ip, pc}

        EXPORT  $_PVirt._GetCPSR
$_PVirt._GetCPSR
        MRS     r0, CPSR
        MOV     pc, lr

        EXPORT  $_PVirt._SetSPSR
$_PVirt._SetSPSR
        MSR     SPSR_cxsf, r1
        MOV     pc, lr

        EXPORT  $_PVirt._GetSPSR
$_PVirt._GetSPSR
        MRS     r0, SPSR
        MOV     pc, lr

        EXPORT  $_PVirt._GetVCPU
$_PVirt._GetVCPU
        DCD     1
        UND

        EXPORT  $_PVirt._FindMode
$_PVirt._FindMode
        DCD     2
        UND

        EXPORT  $_PVirt._MOVS_PC_LR
$_PVirt._MOVS_PC_LR
        MOVS    pc, lr
        UND

        EXPORT  $_PVirt._LoadUsrRegisters
$_PVirt._LoadUsrRegisters
        DCD     3
        UND

        EXPORT  $_PVirt._SWI
$_PVirt._SWI
        LDR     r0, [sp, #12]
        STR     lr, [sp, #12]
        MOV     lr, r0
        LDMFD   sp!, {r0-r3, pc}

        EXPORT  $_PVirt._LinuxSyscall
$_PVirt._LinuxSyscall
        DCD     4
        UND

        EXPORT  $_PVirt._FastSWI
$_PVirt._FastSWI
        MOV     pc, lr
        UND
        
        EXPORT  $_PVirt._TableEnd
$_PVirt._TableEnd

      ENDIF
        MEND

        MACRO
        InitPVOps
      [ PVSys = 1 :LOR: PVSys = 2
        STMFD   sp!, {r0, r1, lr} ; FIXME Remove?
        ADRL    r0, $_PVirt._TableStart
        ADRL    r1, $_PVirt._TableEnd
        SWI     0xE0202 ; XIXSupport_PatchTable
        LDMFD   sp!, {r0, r1, lr}
      ]
        MEND

        MACRO
        PVLdR1 $c, $op2a, $op2b
  [ "$op2b" = ""
    [  "$op2a" != "r1"
        MOV$c   r1, $op2a
    ]
  |
        MOV$c   r1, $op2a, $op2b
  ]
        MEND

        ; Simulates a SWI call
        MACRO
$label  pvSWI$cond $swi
$label
 [ PVSys > 0
        STM$cond.DB sp!, {r0-r3, lr}
        BL$cond $_PVirt._SWI
 ]
        SWI$cond $swi
        MEND

        ; Simulates a SWI call, corrupts LR
        MACRO
$label  fvSWI$cond $swi
$label
 [ PVSys > 0
        BL$cond $_PVirt._FastSWI
 ]
        SWI$cond $swi
        MEND


        MACRO
$label  pvMRS$c $reg, $psr
        ASSERT  ("$psr" = "CPSR") :LOR: ("$psr" = "SPSR")
 [ PVirt > 0
        IF      $reg = 0
$label  STR$c   lr, [sp, #-4]!
        BL$c    $_PVirt._Get$psr + PVOpsRelocation
        LDR$c   lr, [sp], #4

        ELIF    $reg = 14
$label  STR$c   r0, [sp, #-4]!
        BL$c    $_PVirt._Get$psr + PVOpsRelocation
        MOV$c   lr, r0
        LDR$c   r0, [sp], #4

        ELSE
$label  STM$c.FD sp!, {r0, lr}
        BL$c    $_PVirt._Get$psr + PVOpsRelocation
        MOV$c   $reg, r0
        LDM$c.FD sp!, {r0, lr}

        ENDIF
 |
$label  MRS$c   $reg, $psr
 ]
        MEND

        MACRO
$label  pvMSR$c $psr, $op2a, $op2b
$label
 IF PVirt < 1
        [ "$op2b" = ""
        MSR$c   $psr, $op2a
        |
        MSR$c   $psr, $op2a, $op2b
        ]
 ELIF "$psr" = "SPSR_cxsf"
        STM$c.FD sp!, {r1, lr}
        PVLdR1  $c, $op2a, $op2b
        BL$c    $_PVirt._SetSPSR + PVOpsRelocation
        LDM$c.FD sp!, {r1, lr}
 ELSE

        ASSERT "$psr":LEFT:5 = "CPSR_"
        ASSERT "$psr":LEFT:6 <> "CPSR_x"

  [ "$psr":LEFT:6 = "CPSR_c"
        STM$c.FD sp!, {r0-r3, ip, lr}
        PVLdR1  $c, $op2a, $op2b
        BL$c    $_PVirt._Set$psr._unstack + PVOpsRelocation
  ]

        [ "$op2b" = ""
        MSR$c   $psr, $op2a
        |
        MSR$c   $psr, $op2a, $op2b
        ]
 ENDIF ; PVirt
        MEND

        MACRO
$label  MOVS_PC_LR $c
 [ PVirt > 0
$label  B$c     $_PVirt._MOVS_PC_LR + PVOpsRelocation
 |
$label  MOV$c.S pc, lr
 ]
        MEND


                        ^       0
                        #       8 ; Reserved for ELF thread local variables.
vcpu_vectors            #       4
vcpu_irq_pending        #       1
vcpu_cpsr               #       1
                        #       2
vcpu_r13_svc            #       4
vcpu_r14_svc            #       4
vcpu_spsr_svc           #       4
vcpu_r13_usr            #       4
vcpu_r14_usr            #       4
vcpu_spsr_usr           #       4
vcpu_r13_irq            #       4
vcpu_r14_irq            #       4
vcpu_spsr_irq           #       4
vcpu_r13_fiq            #       4
vcpu_r14_fiq            #       4
vcpu_spsr_fiq           #       4
vcpu_r13_und            #       4
vcpu_r14_und            #       4
vcpu_spsr_und           #       4
vcpu_r13_abt            #       4
vcpu_r14_abt            #       4
vcpu_spsr_abt           #       4
vcpu_DFAR               #       4

 ENDIF
        END
