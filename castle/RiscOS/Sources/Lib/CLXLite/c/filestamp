/* This source code in this file is licensed to You by Castle Technology
 * Limited ("Castle") and its licensors on contractual terms and conditions
 * ("Licence") which entitle you freely to modify and/or to distribute this
 * source code subject to Your compliance with the terms of the Licence.
 * 
 * This source code has been made available to You without any warranties
 * whatsoever. Consequently, Your use, modification and distribution of this
 * source code is entirely at Your own risk and neither Castle, its licensors
 * nor any other person who has contributed to this source code shall be
 * liable to You for any loss or damage which You may suffer as a result of
 * Your use, modification or distribution of this source code.
 * 
 * Full details of Your rights and obligations are set out in the Licence.
 * You should have received a copy of the Licence with this source code file.
 * If You have not received a copy, the text of the Licence is available
 * online at www.castle-technology.co.uk/riscosbaselicence.htm
 */
/*
  Title:        filestamp.h - easily portable file stamp functions
  Copyright:    (C) 1987, Acorn Computers Ltd., Cambridge, England.
  $Revision: 1.8 $  LH 31-Oct-88
  $Revision: 1.8 $  LDS 18-Apr-89
*/

#ifndef  NULL
# define NULL             0
#endif

#ifdef __riscos
#include "kernel.h"
#include <time.h>
#include "filestamp.h"
#include "host.h"

/* osfile function code */
#define  READ_INFO        5
#define  SET_LOAD         2
#define  SET_EXEC         3
#define  FILEFOUND        1
/* osword function code */
#define  READ_TIME        1
#define  READ_CMOS_TIME  14
#define  FMT_5BYTE        3
/* scale factor for reducing 5 byte times to 4 bytes */
#define  TIMESF           7
#define  TIMEMASK       127

static int round = 0;

unsigned filestamp_get(char *file)
{
  _kernel_osfile_block f;
  int rc;
  char *new_path = file;

  rc = _kernel_osfile(READ_INFO, new_path, &f);

  if (round) {
    unsigned t = ((f.load & 255) * 96 + f.exec % 100) % 100;
    if (t > f.exec) --f.load;
    f.exec -= t;
  }

  if (rc >= 0) {
    if (rc == FILEFOUND) {
      return ((unsigned)f.exec >> TIMESF) |
             (f.load << (32-TIMESF));
    } else {
      return FILESTAMP_NEVER;
    }
  }
  return 0;
}

int filestamp_set(char *file, TimeStamp ts)
{
  _kernel_osfile_block f;
  int host, rc;
  char *new_path;

  new_path = file;

  if ((rc = _kernel_osfile(READ_INFO, new_path, &f)) < 0)
  {
    return 1;
  }
  if (rc != FILEFOUND)
  {
    return -1;
  }
  if ((host = host_system()) == _kernel_HOST_UNDEFINED)
  {
    return 1;
  }
  f.exec = ts << TIMESF;
  ts = ts >> (32 - TIMESF);
  if (host != _kernel_ARTHUR) ts |= 0xffffff;  /* Brazil */
  f.load = (f.load & ~TIMEMASK) | ts;
  if (_kernel_osfile(SET_LOAD, new_path, &f) < 0)
  {
    return 1;
  }
  if (_kernel_osfile(SET_EXEC, new_path, &f) < 0)
  {
    return 1;
  }
  return 1;
}

int filestamp_mk_execable(char *file)
{
  _kernel_osfile_block f;
  int host, rc;
  char *new_path;

  new_path = file;

  if ((rc = _kernel_osfile(READ_INFO, new_path, &f)) < 0)
  {
    return 1;
  }
  if (rc != FILEFOUND)
  {
    return -1;
  }
  if ((host = host_system()) == _kernel_HOST_UNDEFINED)
  {
    return 1;
  }
  if (host != _kernel_ARTHUR) {
    f.exec = (int)0xffffffff;
    if (_kernel_osfile(SET_EXEC, new_path, &f) < 0)
    {
      return 1;
    }
  }
  f.load = (host == _kernel_ARTHUR ? (f.load & 0xff) | 0xfffffe00 : 0);
  if (_kernel_osfile(SET_LOAD, new_path, &f) < 0)
  {
    return 1;
  }
  return 0;
}

unsigned filestamp_now(void)
{
  unsigned w[4];
  int host;

  if ((host = host_system()) == _kernel_HOST_UNDEFINED) return FILESTAMP_NEVER;
  if (host == _kernel_ARTHUR) {
    w[0] = FMT_5BYTE;
    if (_kernel_osword(READ_CMOS_TIME, (int *)w) < 0) return FILESTAMP_NEVER;
  } else {
    /* use 5-byte timer... */
    if (_kernel_osword(READ_TIME, (int *)w) < 0) return FILESTAMP_NEVER;
  }

  return (w[0] >> TIMESF) | (w[1] << (32-TIMESF));
}

extern void filestamp_ignore_centiseconds(int yes)
{
  round = yes;
}
#else

#include <sys/time.h>
#include <sys/stat.h>
#include "filestamp.h"
#include "host.h"

unsigned filestamp_get(char *file)
{
        struct stat st;
        if (stat(file, &st) < 0) {
                return -1;
        }
        return (unsigned) st.st_mtime;
}

int filestamp_set(char *file, TimeStamp ts)
{
        file=file;
        ts=ts;
        return 0;
}

int filestamp_mk_execable(char *file)
{
        file=file;
}

unsigned filestamp_now(void)
{
        time_t t;
        return (unsigned) (time(&t));
}

extern void filestamp_ignore_centiseconds(int yes)
{
        yes=yes;
}
#endif
