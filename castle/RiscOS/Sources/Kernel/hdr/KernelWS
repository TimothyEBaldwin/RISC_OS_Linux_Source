; This source code in this file is licensed to You by Castle Technology
; Limited ("Castle") and its licensors on contractual terms and conditions
; ("Licence") which entitle you freely to modify and/or to distribute this
; source code subject to Your compliance with the terms of the Licence.
; 
; This source code has been made available to You without any warranties
; whatsoever. Consequently, Your use, modification and distribution of this
; source code is entirely at Your own risk and neither Castle, its licensors
; nor any other person who has contributed to this source code shall be
; liable to You for any loss or damage which You may suffer as a result of
; Your use, modification or distribution of this source code.
; 
; Full details of Your rights and obligations are set out in the Licence.
; You should have received a copy of the Licence with this source code file.
; If You have not received a copy, the text of the Licence is available
; online at www.castle-technology.co.uk/riscosbaselicence.htm
; 
        SUBT    > Kernel WorkSpace

OldOpt  SETA    {OPT}
        OPT     OptNoList+OptNoP1List

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Name  Description
; ----       ----  -----------
; 02-Nov-87  APT   Added module SWI hash table
; 03-Nov-87  APT   Modo-fied module SWI hash table info, removed BRKLST
; 09-Nov-87  APT   Removed ESCCNT and ESFLG
; 12-Nov-87  APT   Added IRQsema
; 13-Nov-87  APT   Added DefaultIRQ1V codespace
; 16-Nov-87  APT   PIRQ chain heads
; 18-Nov-87  APT   Reordered EvtHan, EvtHan_ws
; 19-Nov-87  APT   Moved IRQsema
; 01-Dec-87  APT   Added interruptible heap manager workspace
; 08-Dec-87  TMD   Added ECFShift, ECFYOffset
; 14-Dec-87  TMD   Added DisplayNColour, DisplayModeFlags
; 15-Dec-87  TMD   Added KeyAlphabet
; 22-Dec-87  NDR   Using ScratchSpace
; 13-Jan-88  APT   General scratchspace bash, low workspace reordering.
;                  Removed spurious 32 bytes of osbyte wspace
; 14-Jan-88  APT   *type buffer in scratchspace.
;                  MOShasFIQ byte added
; 20-Jan-88  APT   Workspace juggling for speed & space; also discarded
;                  Level0 stuff.
; 28-Jan-88  APT   MetroGnome moved to "public" location for ADFS
; 02-Feb-88  APT   FIQclaim_interlock added
; 05-Feb-88  APT   CallBack_Vector
; 09-Feb-88  APT   RAM for SWI despatch
; 17-Feb-88  TMD   Added VduSaveArea, VduSaveAreaPtr, DisplayModeNo
; 26-Feb-88  APT   NoOfCamEntries manifest
; 03-Mar-88  APT   Shrank SVC despatch
; 03-Mar-88  APT   NoOfCamEntries manifest doubled
; 07-Mar-88  TMD   Added DisplayScreenStart, VduOutputCurrentState,
;                  SpriteMaskSelect, reordered mode variables
; 07-Mar-88  APT   Made CamEntries always at &164
; 07-Mar-88  TMD   Added GCharSizes, GCharSizeX, GCharSizeY
; 08-Mar-88  TMD   Added GCharSpacing, GCharSpaceX, GCharSpaceY
; 08-Mar-88  TMD   Moved GCharSizes..GCharSpaceY into first 1K of workspace
; 15-Mar-88  TMD   Added HLineAddr
; 18-Mar-88  TMD   Added DisplayXWindLimit, DisplayYWindLimit,
;                   DisplayXEigFactor, DisplayYEigFactor, PointerXEigFactor
; 18-Mar-88  APT   Setting variables scratchspace use revised.
; 21-Mar-88  TMD   Removed CursorIndex
; 22-Mar-88  TMD   Added TCharSizeX,TCharSizeY,TCharSpaceX,TCharSpaceY
; 29-Mar-88  TMD   Added GcolOraEorAddr
; 31-Mar-88  TMD   Removed WsFontPtr
; 07-Apr-88  SKS   Added HeapSort use of ScratchSpace
; 14-Apr-88  TMD   Added SerialFlags
; 28-Apr-88  TMD   Added XONXOFFChar
;  5-May-88  APT   Added MemorySpeed
; 18-May-88  APT   Added CannotReset sema at &107, removed pre-1.20 changes.
; 24-May-88  TMD   Added ClipBoxEnable, ClipBoxLCol..ClipBoxTRow, moved in
;                   ScrLoaSpriteCB, ScrLoaBuffer, SrcSavCommon
; 24-May-88  TMD   Flood fill uses ScratchSpace
; 01-Jun-88  TMD   Added AlignSpace for ClipBoxCoords
; 03-Jun-88  BCSKS Make Keyboard buffer into a useful part of the system
;                  Also PrinterBufferSize
; 09-Jun-88  DJS   Draw uses ScratchSpace
; 09-Jun-88  BC    Gave Econet some private debungling space
; 11-Jun-88  SKS   Align IRQ stack to make STMFD not cross two MEMC bdy's
;                  Made info condit'l on AsmArf; someone had commented it out!
; 15-Jun-88  SKS   Added two more instructions in SWIDespatch area
;                  Moved SLVK definition into kernel; it's not public
; 16-Jun-88  SKS   Added 3 more instructions in SWIDespatch area + nailed
;                  SvcTable address for compatibility
; 22-Jun-88  SKS   Moved MEMC_CR_SoftCopy into pubic ws
; 19-Jul-88  APT   Added UpCall handler stuff
; 20-Jul-88  SKS   Added above entry
;                  Amended comment about overlaid workspace in vdu
; 15-Aug-88  SKS   Inserted DomainId at FF8 (set by Wimp on task swap, used by
;                  FileSwitch to tag resources)
; 27-Sep-89  JSR   Added ColourTrans to users of scratch space
; 24-Oct-89  TMD   Added CamEntriesForBigMachines, CamEntriesPointer
; 26-Oct-89  TMD   Added MaxCamEntry, removed NoOfCamEntries symbol
; 27-Oct-89  TMD   Added VIDCClockSpeed
; 09-Nov-89  TMD   Added ResetIndirection
; 15-Jan-91  TMD   Added ROMModuleChain
; 04-Feb-91  DDV   Added DeviceFS as user of ScratchSpace.
; 04-Feb-91  DDV   Added ColourTrans use of ScratchSpace to build diff tables.
; 06-Mar-91  TMD   Added IOSystemType
; 07-Mar-91  LVR   ADFS uses scratch space for floppy formatting
; 07-Mar-91  TMD   Added MonitorLeadType
; 08-Mar-91  TMD   Added PrinterBufferAddr, PrinterBufferSize
; 11-Apr-91  TMD   Added SerialInHandle, SerialOutHandle
; 24-Apr-91  TMD   Added UniqueMachineID
; 09-Jun-91  RM    Added KernelMessagesBlock,ErrorSemaphore and MOSConvertBuffer
; 26-Jul-91  JSR   Extend GeneralMOSBuffer by 4 bytes to make it a valid
;                       length for the default error handler's error buffer
; 19-Aug-91  JSR   Added *If to list of GeneralMOSBuffer users
; 22-Aug-91  TMD   Reduced ErrorSemaphore to a byte, added PortableFlag
; 25-Aug-91  DDV   Updated to indicate correct usage of scratch space by ColourTrans
; 09-Jan-92  DDV   Added FgPattern, BgPattern and indicate use of ScratchSpace by OS_SetColour
; 20-Jan-92  TMD   OS_SetColour no longer uses ScratchSpace
; 17-Feb-92  ECN   Added CLibWord and RISCOSLibWord
; 02-Apr-92  TMD   Added ScreenBlankFlag
; 27-Jul-92  TMD   Create Victoria specific version
; 28-Jul-92  TMD   Moved RAMDiscAddress
; 29-Jul-92  TMD   Moved SpriteSpaceAddress
; 30-Jul-92  TMD   Moved FontCacheAddress
; 31-Jul-92  TMD   Moved ScreenEndAdr from source.vdudecl, and moved actual address!
; 03-Aug-92  TMD   Added PhysRam (moved from hdr:System)
; 24-Aug-92  TMD   Added AbortIndirection
; 26-Aug-92  TMD   Added PreVeneerRegDump
; 02-Sep-92  TMD   Added FirPalAddr, SecPalAddr
; 10-Sep-92  DDV   Added new Vdu Variables for new text expansion buffer
; 17-Sep-92  DDV   Moved NColour into the word initialised VDU workspace
; 17-Sep-92  DDV   Two new colour words added for text foreground and background.
; 27-Jan-93  TMD   Moved RMA to new position
; 29-Jan-93  TMD   Put RMA back to old position (you can't branch to above 32M!)
; 01-Feb-93  TMD   Added PhysRamTable
; 02-Feb-93  TMD   Added VInitSoftCopy and VEndSoftCopy
; 03-Feb-93  TMD   Added PhysRamTableEnd
; 04-Feb-93  TMD   Added extra slot in PhysRamTable (in case soft-loaded OS splits a bank)
; 08-Feb-93  TMD   Added VRAMWidth variable, and extra symbols for skipped bits
; 24-Feb-93  TMD   Changed VRAMPhysAddr to VideoPhysAddr, and split off VideoSize from VRAMSize, to allow for
;                   DRAM-only systems
; 05-Mar-93  TMD   Added CMOSRAMCache
; 19-Apr-93  TMD   Added DAList, AppSpaceDANode and DANode offset symbols
; 26-Apr-93  TMD   Added FreePoolAddress, FreePoolMaxSize, FreePoolSize
; 29-Apr-93  TMD   Changed FontCacheAddress, SpriteSpaceAddress, RAMDiscAddress and FreePoolAddress
;                   in order to make way for L2PT, which is moving above 64M
; 10-May-93  TMD   Added SoftCamMapSize
; 11-May-93  TMD   Moved SoftCamMapSize into area that's not zapped in clearing all memory routine
; 12-May-93  TMD   Added FreePoolDANode, removed FreePoolSize
; 20-May-93  TMD   Moved AplWorkSize into AppSpaceDANode
; 27-May-93  TMD   Added VideoBandwidth
; 04-Jun-93  TMD   Added CurrentMonitorType
; 09-Jun-93  TMD   Added CamMapCorruptDebugBlock
; 07-Jul-93  TMD   Increased FreePoolMaxSize to 64M (had to reduce RAMDiscMaxSize to 48M and
;                   move FreePoolAddress down to do this)
; 15-Jul-93  TMD   Added KernelModeSelector
; 26-Jul-93  SMC   Moved DefaultIRQ1V (had to accommodate IRQs for IOMD DMA)
; 04-Aug-93  TMD   Added L2PTSize, removed FreePoolMaxSize
; 14-Aug-93  TMD   Removed SpriteSpaceAddress, shuffled things down
; 16-Aug-93  TMD   Removed RAMDiscAddress, shuffled things down
; 17-Aug-93  TMD   Removed FontCacheAddress, shuffled things down
;                  Corrected maximum size of system heap to 2M-8K.
;                  Added node (in bottom 32K) for system heap.
; 25-Aug-93  SMC   Added processor vector table at ProcVec_Start
;                  Added ProcVecPreVeneers
; 02-Sep-93  SMC   Moved RMA to &02100000 and changed application space size to 28M.
; 03-Sep-93  TMD   Moved InitKbdWs into SkippedTables (was at start of screen originally)
; 07-Oct-93  TMD   Put in OldMemoryMap option so I can still use it
; 07-Oct-93  TMD   Added ScreenBlankDPMSState, HSWRSoftCopy, VSWRSoftCopy
; 10-Dec-93  BC    Added RawMachineID
; 13-Dec-93  BC    Removed UniqueMachineID
; 14-Jan-94  TMD   Added CDASemaphore
; 18-Jan-94  TMD   Added MMUControlSoftCopy
; 15-Jun-94  AMcC  Renamed file (was VickySpace)
;                  The following values are 'exported' to PublicWS:
;                        Name:                     Used by:
;                        ----------------------------------
;                        BgEcfOraEor               SprExtend
;                        FgEcfOraEor               SprExtend
;                        BranchToSWIExit           TaskWindow
;                        CannotReset               FileCore
;                        DomainId                  FileSwitch
;                        ESC_Status                ADFS, DeviceFS
;                        IRQsema                   Draw, MsgTrans
;                        LatchBSoftCopy            ADFS, Parallel
;                        MEMC_CR_SoftCopy          ADFS
;                        RedirectInHandle          TaskWindow
;                        RedirectOutHandle         TaskWindow
;                        ScratchSpace              ADFS, Colours, Draw, FileCore
;                                                  FileSwitch, FontManager, NetFiler
;                        SoundDMABufferSize        Sound0
;                        SoundDMABuffers           Sound0
;                        SoundWorkSpace            Portable, Sound1, Sound2, Voices
;                        SVCSTK                    FileSwitch
;                        SvcTable                  TaskWindow, Wimp
;                        SysHeapStart              FileSwitch
;                        VduDriverWorkSpace        SprExtend
;
; 31-Oct-94  AMcC/RM/WT  Added CLine_Softcopy for Morris monitor id
; 03-Nov-94  AMcC        Export ScreenBlankFlag and ScreenBlankDPMSState
;                        (for DPMSUtils: part of RISC OS releases 3.50 and 3.60)
; 28-Mar-95  JRH         Added NVRamSize and RTCFitted, conditioned on E2ROMSupport
; 06-Feb-95  SMC         Increased SVC stack size to 12K.
; 18-Jan-96  JRH         Removed CLine_Softcopy cos not needed
; 06-Feb-96  SMC         Increased DefIRQ1Vspace for IRQC registers
; amg 6/12/96 Renaissance. Merge in changes below from 3.70 version. Make changes conditional.
; 07-Feb-95  WT          Added LCD_Active for LCD/CRT dynamic switching support
; 07-Feb-95  WT          Added VStartSoftCopy for dual-panel LCD support
; 18-May-95  WT          Added LCD_Inverted for LCD inversion (well, surprise surprise!)
; 05-Dec-95  WT          Added ProcessorType and ProcessorFlags (1 byte each)
; amg 07/12/96 Renaissance. Shifted ResetType (which is a public export) so it'll
;              stay in the same place.
; 21-Jul-98  NDT         Added PixelRate.  Moved KernelModeSelector to make space.
; 19-Oct-99  KJB         Moved IOSystemType into SkippedTables.
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Memory map:

; Dynamic area node format

                  ^     0
DANode_Link       #     4               ; points to next node (in address order)
DANode_Number     #     4               ; number of this area
DANode_Base       #     4               ; base address of area (points in middle of doubly-mapped areas)
DANode_Flags      #     4               ; various flags
DANode_Size       #     4               ; current logical size of area (not counting holes, if Sparse/PMP area)
DANode_MaxSize    #     4               ; maximum logical size of area
DANode_Workspace  #     4               ; workspace pointer when calling handlers
DANode_Handler    #     4               ; pointer to handler routine for area
DANode_Title      #     4               ; pointer to area title
DANode_SubLink    #     4               ; next node in any disjoint sublist (currently used for Shrinkables only)
DANode_SparseHWM  #     4               ; high water mark, if Sparse area (highest base+size claimed for area)
DANode_SortLink   #     4               ; next node in alphabetically sorted list
DANode_PMP        #     4               ; pointer to physical memory pool - zero if not PMP or has been resized to zero
DANode_PMPSize    #     4               ; number of pages currently in phys pool
DANode_PMPMaxSize #     4               ; size of phys memory pool, in pages
DANode_NodeSize   #     0

; CAM entry format
                  ^     0
CAM_LogAddr       #     4               ; Logical address page is assigned to (lower address if doubly mapped, Nowhere/DuffEntry if not mapped)
CAM_PageFlags     #     4               ; DynAreaFlags_* and PageFlags_*
CAM_PMP           #     4               ; Pointer to PMP (DANode ptr) if DynAreaFlags_PMP. 0 if not.
CAM_PMPIndex      #     4               ; Index of page in PMP page list. Invalid if not in PMP.
CAM_EntrySize     #     0
CAM_EntrySizeLog2 *     4


; The addresses below are only temporary; eventually most of them will be allocated at run time (we hope!)

 [ HiProcVecs
ProcVecs            * &FFFF0000
 |
ProcVecs            * &00000000
 ]
; Currently, zero page must be located at the processor vectors
ZeroPage            * ProcVecs

; Sort out 26/32 bit versions
SVCStackSize        *  32*1024
IRQStackSize        *   8*1024
ABTStackSize        *   8*1024
UNDStackSize        *   8*1024
KbuffsMaxSize       *  64*1024
ScreenMaxSize       * 480*1024
DCacheCleanSize     * 256*1024  ;should be multiple of 64k

AplWorkMaxSize      * &20000000 ; 512M - temporary (need to decide this at boot time)
RMAAddress          * AplWorkMaxSize ; temporary - run time allocate?
RMAMaxSize          * &10000000 ; 256M
SysHeapChunkAddress * RMAAddress + RMAMaxSize
SysHeapAddress      * SysHeapChunkAddress
SysHeapMaxSize      * 32:SHL:20
FreePoolAddress     * 0

IOLimit             * &BA000000 ; initial lower limit on room for IO space (DA creation may move limit up)
IO                  * &FA000000 ; works downwards

                    ^ &FA000000
HALWorkspaceSize    * &00100000
HALWorkspace        # HALWorkspaceSize
IRQStackAddress     # &00100000
SVCStackAddress     # &00100000
ABTStackAddress     # &00100000
UNDStackAddress     # &00100000
PhysicalAccess      # &00100000
DCacheCleanAddress  # &00040000 ; eg. for StrongARM, 256k of space
KbuffsBaseAddress   # &000A8000 ; kernel buffers for long command lines, size KbuffsMaxSize
HALWorkspaceNCNB    # &00118000 ; 32K of uncacheable HAL workspace (if requested)
L2PT                # &00400000
L1PT                # &003F0000
CursorChunkAddress  # &00008000
DuffEntry           # &00008000 ; No page ever mapped in here (L2PT entry always 0), also, all non mapped pages
Nowhere             * DuffEntry                ; use this as their CAM entry. There is only one 'Nowhere' (synonym).
CAMspace            * CAM_EntrySize*1024*1024 ; 1M entries = enough for 4GB of RAM
CAM                 # CAMspace

IRQSTK              * IRQStackAddress + IRQStackSize
ABTSTK              * ABTStackAddress + ABTStackSize
UNDSTK              * UNDStackAddress + UNDStackSize

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; system variables

        ^  0,R12

OSBYTEFirstVar  #  0

ByteVars  #  0                 ; The main osbyte variables, accessed
                               ; via calls &A6 to &FF

VarStart  #  2                 ; &A6,&A7
ROMPtr    #  2                 ; &A8,&A9
ROMInfo   #  2                 ; &AA,&AB
KBTran    #  2                 ; &AC,&AD
VDUvars   #  2                 ; &AE,&AF

CFStime   #  1                 ; &B0
InputStream #  1               ; &B1
KeyBdSema #  1                 ; &B2

ROMPollSema #  1               ; &B3
OSHWM     #  1                 ; &B4

RS423mode #  1                 ; &B5
NoIgnore  #  1                 ; &B6
CFSRFS    #  1                 ; &B7
VULAcopy  #  2                 ; &B8,&B9

ROMatBRK  #  1                 ; &BA
BASICROM  #  1                 ; &BB

ADCchanel #  1                 ; &BC
ADCmaxchn #  1                 ; &BD
ADCconv   #  1                 ; &BE

RS423use     #  1              ; &BF
RS423conflag #  1              ; &C0

FlashCount # 1                 ; &C1
SpacPeriod # 1                 ; &C2
MarkPeriod # 1                 ; &C3

KeyRepDelay # 1                ; &C4
KeyRepRate  # 1                ; &C5

ExecFileH   # 1                ; &C6
SpoolFileH  # 1                ; &C7

ESCBREAK    # 1                ; &C8 (200)

KeyBdDisable # 1               ; &C9
KeyBdStatus  # 1               ; &CA

RS423HandShake # 1             ; &CB
RS423InputSupr # 1             ; &CC
RS423CFSFlag   # 1             ; &CD

EconetOScall # 1               ; &CE
EconetOSrdch # 1               ; &CF
EconetOSwrch # 1               ; &D0

SpeechSupr # 1                 ; &D1
SoundSupr # 1                  ; &D2

BELLchannel # 1                ; &D3
BELLinfo    # 1                ; &D4
BELLfreq    # 1                ; &D5
BELLdur     # 1                ; &D6

StartMessSupr # 1              ; &D7

SoftKeyLen # 1                 ; &D8

PageModeLineCount # 1          ; &D9

VDUqueueItems # 1              ; &DA

TABch # 1                      ; &DB
ESCch # 1                      ; &DC

IPbufferCh # 4                 ; &DD,&DE,&DF,&E0
RedKeyCh   # 4                 ; &E1,&E2,&E3,&E4

ESCaction  # 1                 ; &E5
ESCeffect  # 1                 ; &E6

u6522IRQ # 1                   ; &E7
s6850IRQ # 1                   ; &E8
s6522IRQ # 1                   ; &E9

TubeFlag # 1                   ; &EA

SpeechFlag # 1                 ; &EB

WrchDest # 1                   ; &EC
CurEdit  # 1                   ; &ED

SoftResetVars # 0              ; Reset to here on soft reset

KeyBase # 1                    ; &EE
Shadow # 1                     ; &EF
Country # 1                    ; &F0

UserFlag # 1                   ; &F1

SerULAreg # 1                  ; &F2

TimerState # 1                 ; &F3

SoftKeyConsist # 1             ; &F4

PrinterDrivType   # 1          ; &F5
PrinterIgnore     # 1          ; &F6

BREAKvector # 3                ; &F7,&F8,&F9

MemDriver  # 1                 ; &FA - where the VDU drivers write to
MemDisplay # 1                 ; &FB - where we display from

LangROM # 1                    ; &FC

LastBREAK # 1                  ; &FD

KeyOpt # 1                     ; &FE

StartOptions # 1               ; &FF

HardResetVars # 0              ; Reset to here on hard reset
PowerOnResetVars # 0           ; Reset to here on power-on reset

; These two can dovetail in here to use up 2 bytes before the AlignSpace!

SerialInHandle # 1              ; Handle for serial input stream  (0 if not open currently)
SerialOutHandle # 1             ; Handle for serial output stream (-----------""----------)

        AlignSpace

EventSemaphores # 32            ; One byte for each of 32 events

TimerAlpha # 8                  ; As used by time (bottom 5 bytes)
TimerBeta  # 8                  ; ................................
; both aligned to word boundaries

RealTime # 8                    ; 5-byte fast real-time

PrinterActive # 4               ; Handle/active flag for printer (word aligned)

IntervalTimer # 5               ; Up Counter synchronous with TIME.
; Event generated when Zero is reached
; bottom byte aligned to word boundary

SecondsTime # 1 ; the soft copy (centi-)seconds of the RTC
CentiTime   # 1 ; """"""""""""""""""""""""""""""""""""""""

FlashState # 1 ; which flash colours are we using

SecondsDirty # 1                ; the dirty flag for start up!

MinTick # 1                     ; the minutes odd/even state

DCDDSRCopy # 1                  ; copy of ACIA bits to check for change

TVVertical # 1                  ; *TV first parameter

TVInterlace # 1                 ; *TV second parameter

CentiCounter # 1                ; Counter for VDU CTRL timing

Alphabet # 1                    ; Current alphabet number

Keyboard # 1                    ; Current keyboard number

KeyAlphabet # 1                 ; Alphabet associated with current keyboard

                GBLS    PrinterPrefix
PrinterPrefix   SETS    "PrinterType$"

PrinterTypeName #       6 + :LEN: (PrinterPrefix)

        AlignSpace

SerialFlags # 4                 ; New serial flags

XONXOFFChar # 1                 ; Character to send before rest (0 if none)

        AlignSpace

OSBYTEVarSize * @-OSBYTEFirstVar

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; End of variables' space

; *** layout of a descriptor block for a display pointer shape ***

                  ^  0
PointerBlkHAL     #  0  ; fields up to private part passed to HAL
PointerWidth      #  1  ; actual (unpadded) shape width in bytes (from OS_Word 21)
PointerHeight     #  1  ; shape height in pixels
                  #  2  ; alignment padding
PointerBuffLA     #  4  ; logical address of shape buffer (up to 8 * 32 bytes)
PointerBuffPA     #  4  ; physical address of shape buffer
PointerBlkPrivate #  0  ; fields below here not used by HAL
PointerActiveX    #  1  ; active x in pixels from left
PointerActiveY    #  1  ; active y in pixels from top
                  #  2  ; alignment padding
PointerBlkSize    #  0


; ***********************************
; ***  Main Vdu Driver Workspace  ***
; ***********************************

        ^ 0

FgEcf  # 4 * 8  ; Foreground Ecf, set by GCOL(a,0-127)
BgEcf  # 4 * 8  ; Background Ecf, set by GCOL(a,128-255)
GPLFMD # 4      ; Foreground action, set by GCOL(a,0-127)
GPLBMD # 4      ; Background action, set by GCOL(a,128-255)
GFCOL  # 4      ; Foreground colour, set by GCOL(a,0-127)
GBCOL  # 4      ; Background colour, set by GCOL(a,128-255)

GWLCol # 4      ; Graphics window left column  --
GWBRow # 4      ; Graphics window bottom row     |
GWRCol # 4      ; Graphics window right column   |
GWTRow # 4      ; Graphics window top row      --

qqqPad   # 3
QQ       # 17   ;Queue - QQ+1 is on a word boundary
QOffset  # 4    ;Value to add to VDUqueueItems to point to next queue posn.
JVec     # 4    ;Jump vector to internal routines

; Start of MODE table workspace

ScreenSize # 4  ; number of bytes needed for this mode (assumed 1st in list)

XWindLimit # 4  ; Maximum value of GWRCol (internal representation)

; LineLength must be immediately after YWindLimit

YWindLimit # 4  ; Maximum value of GWTRow (internal representation)

LineLength # 4  ; Length of one pixel row in bytes

NColour # 4     ; Number of colours minus 1

; End of word mode variables

YShftFactor # 4 ; Number of places to shift YCoord in address generation after
                ; multiplying by 5, holds
                ; 7,6,5 or 4 for 8,4,2 or 1 bits per pixel (640x256 mode) or
                ; 6,5,4 or 3 for 8,4,2 or 1 bits per pixel (320x256 mode).

ModeFlags # 4   ; Bit 0 => non-graphic, Bit 1 => teletext, Bit 2 => gap mode

XEigFactor # 4  ; Number of places to shift XCoord in external to internal
                ; coordinate conversion, holds
                ; 1 for 640x256 mode
                ; 2 for 320x256 mode
                ; 3 for 160x256 (BBC micro mode 2)

YEigFactor # 4  ; number of shifts to convert between internal/external Y

Log2BPC # 4     ; Log to base 2 of BytesPerChar ie (0,1,2,3,4)

Log2BPP # 4     ; Log to base 2 of BitsPerPix ie (0,1,2,3)

ECFIndex # 4    ; Index into default ECF tables

ScrRCol # 4     ; Maximum column number in this screen mode
ScrBRow # 4     ; Maximum row number in this screen mode

PalIndex # 4    ; Index into palette tables (0,1,2,3)

; End of table-initialised workspace

; Next 3 must be together in this order !

XShftFactor # 4 ; Number of places to shift XCoord in address generation,
                ; holds 2,3,4 or 5 for 8,4,2,1 bits per pixel respectivly
GColAdr # 4     ; Address of Ecf to plot - either FgEcf or BgEcf

ScreenStart # 4         ; Start address of screen (for VDU drivers)

NPix # 4        ; Number of pixels per word minus 1, holds
                ; holds 3,7,15 or 31 for 8,4,2,1 bits per pixel modes

AspectRatio # 4 ; Pixel shape : 0 square, 1 horz rect, 2 vert rect

BitsPerPix # 4  ; Bits per pixel (1,2,4,8)

BytesPerChar # 4        ; Bytes per 8 pixels of character
                        ; (same as BitsPerPix except in double pixel modes)

             # 4        ; SPARE (avoiding changes of exported addresses for now)

RowMult # 4     ; Row multiplier for text manipulation

RowLength # 4   ; Bytes per text row in this mode (eg 640,1280,5120)

; The following (up to and including NewPtY) must be together in this order
; (relied upon by DefaultWindows)

TWLCol # 4      ; Text window left column  --
TWBRow # 4      ; Text window bottom row     |
TWRCol # 4      ; Text window right column   |
TWTRow # 4      ; Text window top row      --

OrgX # 4        ; Screen origin (external representation)
OrgY # 4

GCsX # 4        ; Graphics cursor (external representation)
GCsY # 4

OlderCsX # 4    ; Very old X coordinate (internal)
OlderCsY # 4    ; Very old Y coordinate (internal)

OldCsX # 4      ; Old graphics cursor (internal representation) --
OldCsY # 4      ;                                                 |
                ;                                                 |
GCsIX  # 4      ; Graphics cursor (internal representation)       |
GCsIY  # 4      ;                                                 |
                ;                                                 |
NewPtX # 4      ; Newest point (internal representation)          |
NewPtY # 4      ;                                               --

; End of together block

TForeCol # 4    ; Text foreground colour
TBackCol # 4    ; Text background colour

CursorX # 4     ; Text cursor X position ; these 3 must be in same order as ...
CursorY # 4     ; Text cursor Y position
CursorAddr # 4  ; Screen address of (output) cursor

InputCursorX # 4        ; Input cursor X position ; ... these 3
InputCursorY # 4        ; Input cursor Y position
InputCursorAddr # 4     ; Screen address of input cursor

EORtoggle # 4   ; Toggle between gap and non-gap
RowsToDo  # 4   ; in the CLS

VduStatus # 4   ; Vdu2, Window, Shadow bits (others in CursorFlags)

CBWS # 8        ; Clear block (VDU 23,8..) workspace
CBStart # 2
CBEnd # 2

CursorDesiredState # 4
CursorStartOffset # 4
CursorEndOffset # 4
CursorCounter # 4
CursorSpeed # 4
Reg10Copy # 4

CursorFill # 4  ; Word to EOR cursor ; MUST be immediately before CursorNbit

CursorNbit # 4  ; Pointer to cursor code for current mode

DisplayStart # 4        ; Start address of screen (for display)
DriverBankAddr # 4      ; Default start address for VDU drivers
DisplayBankAddr # 4     ; Default start address for display
DisplayNColour # 4      ; No. of colours -1 for displayed mode
DisplayModeFlags # 4    ; ModeFlags for displayed mode
DisplayModeNo # 4       ; ModeNo for displayed mode
DisplayScreenStart # 4  ; Where VDU outputs to when outputting to screen

DisplayXWindLimit # 4   ; Used for pointer programming
DisplayYWindLimit # 4
DisplayXEigFactor # 4
DisplayYEigFactor # 4
DisplayLog2BPP # 1
PointerXEigFactor # 1
                  # 2

Ecf1 # 8        ; The Ecf patterns
Ecf2 # 8
Ecf3 # 8
Ecf4 # 8

DotLineStyle # 8        ; Dot dash line pattern

ModeNo # 4      ; Current mode number

TFTint # 4      ; Text foreground tint          (in bits 6,7)
TBTint # 4      ; Text background tint
GFTint # 4      ; Graphics foreground tint
GBTint # 4      ; Graphics background tint

TotalScreenSize # 4     ; Amount configured for screen (in bytes)

MaxMode # 4             ; Maximum mode number allowed (20 for now)

ScreenEndAddr # 4       ; Logical address of screen (start of 2nd copy)

CursorFlags # 4 ; Silly Master cursor movement flags

CursorStack # 4 ; Bit stack of nested cursor states (0 => on, 1 => off)
                ; (bit 31 = TOS)

ECFShift # 4    ; number of bits to rotate right ECF OR and EOR masks by
ECFYOffset # 4  ; vertical offset to ECF index

        ASSERT  ECFShift =  Legacy_ECFShift
        ASSERT ?ECFShift = ?Legacy_ECFShift
        ASSERT  ECFYOffset =  Legacy_ECFYOffset
        ASSERT ?ECFYOffset = ?Legacy_ECFYOffset

WsVdu5 # 0      ; Vdu 5 workspace
WsScr # 4
WsEcfPtr # 4
; WsFontPtr # 4 ; not needed any more, kept in register
EndVerti # 4
StartMask # 4
EndMask # 4
FontOffset # 4
TempPlain # 16  ; only used for MODE 10

VIDCClockSpeed # 4      ; current VIDC clock speed in kHz (now always zero)

CurrentMonitorType # 4  ; initialised from configured one

PixelRate # 4   ; Pixel Rate in kHz

BorderL # 4             ; Size of border
BorderB # 4
BorderR # 4
BorderT # 4

GraphicWs # 300 ; All graphics workspace is overlaid here
EndGraphicWs # 0

 [ :DEF: ShowWS
 ! 0,"16 ":CC::STR:@
 ]
        AlignSpace 16

GCharSizes  # 0
GCharSizeX  # 4         ; width of VDU 5 chars in pixels
GCharSizeY  # 4         ; height of VDU 5 chars in pixels

GCharSpacing # 0
GCharSpaceX  # 4        ; horizontal spacing between VDU 5 chars in pixels
GCharSpaceY  # 4        ; vertical   ------------------""-----------------

TCharSizes  # 0
TCharSizeX  # 4         ; width of VDU 4 chars in pixels
TCharSizeY  # 4         ; height of VDU 4 chars in pixels

TCharSpacing # 0
TCharSpaceX  # 4        ; horizontal spacing between VDU 4 chars in pixels
TCharSpaceY  # 4        ; vertical   ------------------""-----------------

HLineAddr      # 4      ; address of exported HLine
GcolOraEorAddr # 4      ; address of FgEcfOraEor etc

BlankPalAddr  # 4       ; address of block for blank palette
FirPalAddr    # 4       ; address of block for first flash state palette
SecPalAddr    # 4       ; address of block for second flash state palette

CurrentGraphicsVDriver # 4 ; Current driver number

PointerShapes      # 0
PointerShape1      # 4  ; pointers to defined shapes 1 to 4
PointerShape2      # 4
PointerShape3      # 4
PointerShape4      # 4
PointerShapesH     # 0
PointerShapeH1     # 4  ; pointers to holding shapes 1 and 2 (so updates never hit shape given to HAL)
PointerShapeH2     # 4

PointerShapeBlocks # 6*PointerBlkSize ; room for the 6 shape descriptors themselves

PointerShapeLA     # 4               ; logical address of current shape buffer (owned by HAL)
PointerShapeNumber # 1               ; includes bit 7 linkage flag
                   # 3               ; alignment padding
PointerX           # 4               ; co-ordinates of pointer (not always = mouse)
PointerY           # 4

 [ :DEF: ShowWS
  ! 0, "PointerShapes @ ":CC::STR:(PointerShapes)
 ]

GraphicsVFeatures  # 4               ; features word from current driver, refreshed each mode change
TrueVideoPhysAddr  # 4               ; VideoPhysAddr is a lie, use this instead
MaxGraphicsVDrivers * 8
GraphicsVDrivers # MaxGraphicsVDrivers*4 ; List of drivers
                # 4*4                ; SPARE (avoiding changes of exported addresses for now)

TextFgColour    # 4             ; Fg/Bg colour stored as a colour number, computed on VDU 18 and re-poked!
TextBgColour    # 4             ;

; In this brave new world there is a pointer to the text expansion
; buffer used for VDU 4 / 5 text plotting.

; This now lives in the system heap.

TextExpandArea # 4      ; Pointer to Text expand area (in system heap)
TextExpandArea_Size * (8*1024)

                 # 2*4   ; SPARE (avoiding changes of exported addresses for now)

ScreenBlankFlag # 1     ; 0 => unblanked, 1 => blanked

        ASSERT  ScreenBlankFlag =  Legacy_ScreenBlankFlag
        ASSERT ?ScreenBlankFlag = ?Legacy_ScreenBlankFlag

ScreenBlankDPMSState # 1       ; 0 => just blank video
                               ; 1 => blank to stand-by (hsync off)
                               ; 2 => blank to suspend (vsync off)
                               ; 3 => blank to off (H+V off)

        ASSERT  ScreenBlankDPMSState =  Legacy_ScreenBlankDPMSState
        ASSERT ?ScreenBlankDPMSState = ?Legacy_ScreenBlankDPMSState


 [ :DEF: ShowWS
 ! 0,"64 ":CC::STR:@
 ]
        AlignSpace 64

FgEcfOraEor # 4*16      ; Interleaved zgora & zgeor
        ASSERT  FgEcfOraEor =  Legacy_FgEcfOraEor
        ASSERT ?FgEcfOraEor = ?Legacy_FgEcfOraEor

BgEcfOraEor # 4*16      ; Interleaved zgora & zgeor
        ASSERT  BgEcfOraEor =  Legacy_BgEcfOraEor
        ASSERT ?BgEcfOraEor = ?Legacy_BgEcfOraEor

BgEcfStore  # 4*16      ; Interleaved zgora & zgeor to store background

;Current state of pattern
LineDotCnt # 4          ; Count down to restarting pattern
LineDotPatLSW # 4       ; Current state of pattern LSWord
LineDotPatMSW # 4       ;    "      "   "     "    MSWord

DotLineLength # 4       ; Dot Pattern repeat length as given in *FX163,242,n

BBCcompatibleECFs # 4   ; 0 => BBC compatible, 1 => native

SpAreaStart # 4         ; Start of sprite area
SpChooseName # 16       ; No comment says Richard
SpChoosePtr # 4

SWP_W # 1               ; Width & height of image to restore
SWP_H # 1
SWP_Callback # 1        ; Nonzero if palette update callback registered
SWP_Mutex # 1           ; Mutex to prevent re-entrancy
SWP_Restore # 1         ; Nonzero if restore needed in RestorePointer
SWP_Dirty # 1           ; Nonzero if need replot due to palette change
          # 2
SWP_Coords # 4          ; Coordinates of last plot
SWP_Pos # 4             ; Address to restore pixels to, 0 if not displayed
SWP_Under # 4           ; Pointer to copy of screen pixels from under the pointer
SWP_Palette # 3*4       ; Pointer colours converted to pixel values for current mode

TeletextOffset # 4      ; Offset to current teletext flash bank

TeletextCount # 4       ; Number of vsyncs till next teletext flash

WrchNbit # 4            ; Pointer to char code for current mode

CharWidth # 4           ; Width of a character in bytes (same as BytesPerChar except
                        ; in HiResTTX MODE 7, where characters are 16 pixels wide)
                        ; This could also be defined as (TCharSizeX<<Log2BPC)/8

TextOffset # 4          ; Byte offset into screen bank at which text window starts.
                        ; Keeps the text window centered when e.g. when mode 7 picks
                        ; a higher resolution mode than strictly necessary.

TTXFlags # 4            ; VDU 23,18 flags
TTXFlag_Suspend         * 1:SHL:0
TTXFlag_Conceal         * 1:SHL:1
TTXFlag_BlackEnable     * 1:SHL:2
TTXFlag_TransModeShift  * 3
TTXFlag_TransModeMask   * 3:SHL:TTXFlag_TransModeShift
                        ; bits 9-11 must be zero
TTXFlag_FgTransEOR      * 1:SHL:12
                        ; bits 13-15 must be zero
TTXFlag_BgTransEOR      * 1:SHL:16
                        ; bits 17-19 must be zero
TTXFlag_FgTransBIC      * 1:SHL:20
                        ; bits 21-23 must be zero
TTXFlag_BgTransBIC      * 1:SHL:24

BeepBlock # 8           ; OSWORD block for VDU 7

ScreenMemoryClaimed # 1 ; NZ => memory has been claimed or is unusable
ExternalFramestore # 1  ; NZ => using external framestore rather than screen memory DA

     AlignSpace

TTXDoubleCountsPtr # 4 ; Number of double height chars on each line
TTXMapPtr          # 4
TTXLineStartsPtr   # 4
TTXNewWorkspace    # 4 ; Temp variable to allow mode changes to fail gracefully if TTX workspace can't be allocated

 [ :DEF: ShowWS
 ! 0,"16 ":CC::STR:@
 ]
     AlignSpace 16      ; Align workspace to 16 bytes

RAMMaskTb # 32*4        ; Copy of MaskTb for this mode (up to 32 words)

 [ :DEF: ShowWS
 ! 0,"16 ":CC::STR:@
 ]
     AlignSpace 16      ; Align workspace to 16 bytes

VduOutputCurrentState # 0 ; values of R0-R3 to return from SwitchOutputToSprite
                        ; or Mask; next 4 must be in this order
SpriteMaskSelect # 4    ; value of R0 to be given to SWI OS_SpriteOp to set up
                        ; current state
VduSpriteArea # 4       ; Pointer to sprite area containing VDU output sprite
                        ; (0 if output is to screen)
VduSprite # 4           ; Pointer to VDU output sprite (0 if output to screen)

VduSaveAreaPtr # 4      ; Pointer to save area for VDU variables


 [ :DEF: ShowWS
 ! 0,"16,12 ":CC::STR:@
 ]
    AlignSpace 16, 12   ; Make ClipBoxCoords a valid immediate,
                        ; with ClipBoxEnable immediately before it
ClipBoxInfo # 0
ClipBoxEnable # 4       ; 0 => clip box disabled, 1 => enabled

ClipBoxCoords # 0       ; Internal coords of modified area of screen
ClipBoxLCol # 4
ClipBoxBRow # 4
ClipBoxRCol # 4
ClipBoxTRow # 4

FgPattern       # 4*8   ; foreground pattern as defined by OS_SetColour
BgPattern       # 4*8   ; background pattern as defined by OS_SetColour

                # 3*4   ; SPARE (avoiding changes of exported addresses for now)

KernelModeSelector # 4  ; pointer to block in system heap where
                        ; current mode selector is copied

 [ :DEF: ShowWS
 ! 0,"16 ":CC::STR:@
 ]
     AlignSpace 16      ; Align workspace to 16 bytes

TextExpand # 4*1024     ; Tim's massive text expansion table for whizzy WRCH
; TextPlain is now always hard against the end of TextExpand for this mode

TTXSoftFonts * TextExpand + 2*1024      ; Soft fonts in teletext mode

 [ :DEF: ShowWS
 ! 0,"64 ":CC::STR:@
 ]
     AlignSpace 64      ; Align workspace to 64 bytes

; Some infrequently used buffers which can be overlaid

LargeCommon     # SpriteAreaCBsize + SpriteCBsize + MaxSpritePaletteSize ; the largest area

ScrLoaSpriteCB  * LargeCommon   ; (size = SpriteCBsize + MaxSpritePaletteSize)
        ASSERT ?LargeCommon >= SpriteCBsize + MaxSpritePaletteSize
ScrSavCommon    * LargeCommon   ; (size = SpriteAreaCBsize + SpriteCBsize
                                ;  + MaxSpritePaletteSize)
        ASSERT ?LargeCommon >= SpriteAreaCBsize + SpriteCBsize + MaxSpritePaletteSize
TempModeSelector * LargeCommon  ; (size = ModeSelector_MaxSize)
        ASSERT ?LargeCommon >= ModeSelector_MaxSize

FldQueueSize    * ScratchSpaceSize
FldQueueStart   * ScratchSpace

 [ :DEF: ShowWS
 ! 0,"64 ":CC::STR:@
 ]
     AlignSpace 64      ; Align workspace to 64 bytes

Font # &700             ; 7 pages of (soft) font

SaveAreaSize * 12*1024-@

VduSaveArea # SaveAreaSize      ; save area for switching output to sprites

VDWSSize # 0

                ASSERT  VDWSSize <= 12 * 1024

; IIC bus info block

               ^ 0
IICBus_Type    # 4 ; Bus type (HAL_IICType)
IICBus_Status  # 4 ; Bus status (HAL_IICMonitorTransfer)
IICBus_Device  # 4 ; Bus device (HAL_IICDevice)
IICBus_Size    # 0

; *****************************************************************************
;                 Space in the first 32K is allocated below
; *****************************************************************************
; Real workspace definition

; locations used during reset only. Not cleared by ClearPhysRAM, but
; cleared later (just before DEFHAN).

; Note that these are all relative to ZeroPage!

                ^       &80             ; steer clear of FIQ code
InitIRQHandler  #       4               ; pointer to IRQ handler (LDR PC'ed from IRQ HW vector)
InitIRQWs       #       16              ; workspace for IRQ handler
InitUsedStart   #       4               ; start of used pages (L2PT etc) not to be cleared
InitUsedEnd     #       4               ; end of used pages
InitUsedBlock   #       4               ; current block in PhysRamTable
InitClearRamWs  #       10*4
InitDMABlock    #       8               ; block of DMAable memory extracted from PhysRamTable
InitDMAOffset   #       4               ; offset+8 into PhysRamTable where memory was taken
InitDMAEnd      #       4               ; current DMA alloc pos
                AlignSpace 32           ; because we clear 32 at a time
InitWsEnd       #       0

; Basic kernel space - defined locations for external modules

                       ^       &100
IRQ1V                  #       4       ; &100

ESC_Status             #       1       ; &104
        ASSERT  ESC_Status =  Legacy_ESC_Status
        ASSERT ?ESC_Status = ?Legacy_ESC_Status

LatchBSoftCopy         #       1       ; &105
        ASSERT  LatchBSoftCopy =  Legacy_LatchBSoftCopy
        ASSERT ?LatchBSoftCopy = ?Legacy_LatchBSoftCopy

IOCControlSoftCopy     #       1       ; &106

CannotReset            #       1       ; &107
        ASSERT  CannotReset =  Legacy_CannotReset
        ASSERT ?CannotReset = ?Legacy_CannotReset

IRQsema                #       4       ; &108
        ASSERT  IRQsema =  Legacy_IRQsema
        ASSERT ?IRQsema = ?Legacy_IRQsema

MetroGnome             #       4       ; &10C
        ASSERT  MetroGnome =  Legacy_MetroGnome
        ASSERT ?MetroGnome = ?Legacy_MetroGnome

MemorySpeed            #       4       ; &110

MEMC_CR_SoftCopy       #      4       ; &114
        ASSERT  MEMC_CR_SoftCopy =  Legacy_MEMC_CR_SoftCopy
        ASSERT ?MEMC_CR_SoftCopy = ?Legacy_MEMC_CR_SoftCopy

ResetIndirection        #      4       ; &118

; Now all internal definitions

; Up to here is initialized on reset

; Next come handler variables

MemLimit        #       4
UndHan          #       4
PAbHan          #       4
DAbHan          #       4
AdXHan          #       4

ErrHan          #       4
ErrBuf          #       4
ErrHan_ws       #       4

CallAd_ws       #       4     ; smart Rs ordering:
CallAd          #       4     ; can do LDMIA of r12, pc
CallBf          #       4

BrkAd_ws        #       4
BrkAd           #       4
BrkBf           #       4

EscHan_ws       #       4
EscHan          #       4

EvtHan_ws       #       4
EvtHan          #       4

; The next lot of workspace is in the space vacated by the small soft CAM map area
; (256 words) which is no longer adequate, so we can reuse it

JordanWS        #       0

Serv_SysChains          # 4          ;anchor for block handling 'system' service numbers, in range 1 to 255
Serv_UsrChains          # 4          ;anchor for block handling 'user' service numbers, > 255
Serv_AwkwardChain       # 4          ;anchor for chain handling non-compliant modules (no service table)
 [ :DEF: ShowWS
      ! 0, "Serv_SysChains        at ":CC::STR:(Serv_SysChains)
      ! 0, "Serv_UsrChains        at ":CC::STR:(Serv_UsrChains)
      ! 0, "Serv_AwkwardChain     at ":CC::STR:(Serv_AwkwardChain)
 ]

DAList          #       4       ; Pointer to first node on dynamic area list


                AlignSpace 16
AMBControl_ws   #       4       ; workspace anchor word for AMBControl
DynArea_ws      #       4       ; workspace anchor word for data structures to accelerate OS SWIs for dynamic areas
 [ :DEF: ShowWS
 ! 0, "AMBControl_ws         at ":CC::STR:(AMBControl_ws)
 ! 0, "DynArea_ws            at ":CC::STR:(DynArea_ws)
 ]

Oscli_CmdHashSum        # 4          ;for hashed command lookup
Oscli_CmdHashLists      # 4          ;anchor for hashed command lists structure
 [ :DEF: ShowWS
      ! 0, "Oscli_CmdHashSum      at ":CC::STR:(Oscli_CmdHashSum)
      ! 0, "Oscli_CmdHashLists    at ":CC::STR:(Oscli_CmdHashLists)
 ]


                AlignSpace 16   ; skipped bit must start on 16-byte boundary (ClearPhysRAM does 4 words at a time for skipped areas)
SkippedTables   #       0

PhysRamTable    #       0       ; Pairs of words (physaddr, size+flags)
                                ; indicating RAM present in machine
                                ; Unused entries have size of zero
VideoPhysAddr   #       4       ; Address of video RAM (in the case of DRAM-only machines,
VideoSizeFlags  #       4       ; this is actually a chunk out of DRAM)
DRAMPhysAddrA   #       4       ; Next the DRAM
DRAMSizeFlagsA  #       4
                #       8 * 16  ; Space for 17 DRAM banks + 1 VRAM bank total
PhysRamTableEnd #       0
DRAMPhysTableSize *     (PhysRamTableEnd-DRAMPhysAddrA) / 8

 [ :DEF: ShowWS
 ! 0, "VideoPhysAddr held at  ":CC::STR:(VideoPhysAddr)
 ]

L2PTUsed        #       4       ; Amount of memory used for L2PT
SoftCamMapSize  #       4       ; Amount of memory (in bytes) used for soft CAM map
                                ; (whole number of pages)

                AlignSpace
HAL_StartFlags  #       4
HAL_Descriptor  #       4
HAL_Workspace   #       4
HAL_WsSize      #       4

ICache_Info              #  0
ICache_NSets             #  4
ICache_Size              #  4
ICache_LineLen           #  1
ICache_Associativity     #  1

Cache_Type               #  1
Cache_Flags              #  1

DCache_Info              #  0
DCache_NSets             #  4
DCache_Size              #  4
DCache_LineLen           #  1
DCache_Associativity     #  1

ProcessorArch            #  1
ProcessorType            #  1   ; Processor type (handles 600 series onwards)

DCache_CleanBaseAddress  #  0   ; word used either for IndexBit or CleanBaseAddress
DCache_IndexBit          #  4
DCache_CleanNextAddress  #  0   ; word used either for IndexSegStart or CleanNextAddress
DCache_IndexSegStart     #  4
DCache_RangeThreshold    #  4
                AlignSpace
ProcessorFlags           #  4    ; Processor flags (IMB, Arch4 etc)
 [ :DEF: ShowWS
 ! 0, "ProcessorType  at  ":CC::STR:(ProcessorType)
 ! 0, "ProcessorFlags at  ":CC::STR:(ProcessorFlags)
 ]

                AlignSpace

MMU_PPLTrans             #  4
MMU_PCBTrans             #  4
MMU_PPLAccess            #  4

Proc_Cache_CleanInvalidateAll     #       4
Proc_Cache_CleanInvalidateRange   #       4
Proc_Cache_CleanAll               #       4
Proc_Cache_CleanRange             #       4
Proc_Cache_InvalidateAll          #       4
Proc_Cache_InvalidateRange        #       4
Proc_Cache_RangeThreshold         #       4
Proc_Cache_Examine                #       4
Proc_ICache_InvalidateAll         #       4
Proc_ICache_InvalidateRange       #       4
Proc_TLB_InvalidateAll            #       4
Proc_TLB_InvalidateEntry          #       4
Proc_DSB_ReadWrite                #       4
Proc_DSB_Write                    #       4
Proc_DSB_Read                     #       4
Proc_DMB_ReadWrite                #       4
Proc_DMB_Write                    #       4
Proc_DMB_Read                     #       4
Proc_IMB_Full                     #       4
Proc_IMB_Range                    #       4
Proc_IMB_List                     #       4
Proc_MMU_Changing                 #       4
Proc_MMU_ChangingEntry            #       4
Proc_MMU_ChangingUncached         #       4
Proc_MMU_ChangingUncachedEntry    #       4
Proc_MMU_ChangingEntries          #       4
Proc_MMU_ChangingUncachedEntries  #       4

Cache_Lx_Info                     #       4       ; Cache level ID register
Cache_Lx_MaxLevel                 *       2       ; Current machines have max of 2 cache levels
Cache_Lx_DTable                   #       4*Cache_Lx_MaxLevel ; Data/unified cache layout for all supported levels
Cache_Lx_ITable                   #       4*Cache_Lx_MaxLevel ; Instruction cache layout for all supported levels
Cache_HALDevice                   #       4       ; Pointer to any HAL cache device we're using


IOAllocPtr      #       4               ; current lowpoint of mapped I/O space (also upper limit on DAs)
IOAllocLimit    #       4               ; current lowest allowed I/O space (DA creation may move this up)


  [ :DEF: ShowWS
        ! 0, "Free space before DebuggerSpace = ":CC::STR:(&300-@)
 ]

        ASSERT  @ <= &300
                        #       (&300-@)
 [ :LNOT: HiProcVecs
; Note that this is currently located within the skipped region, even though it
; doesn't need to be. It was just an easy way of adding the IIC bus info to the
; region. The debugger will initialise DebuggerSpace on startup, so it doesn't
; matter that it doesn't get cleared during the main RAM clear.
DebuggerSpace           #       16*8    ; Debugger module needs some zero page
DebuggerSpace_Size      *       ?DebuggerSpace

        ASSERT  DebuggerSpace =  Legacy_DebuggerSpace
        ASSERT ?DebuggerSpace = ?Legacy_DebuggerSpace
 |
DebuggerSpace           *       &2000   ; Debugger gets a page all to itself!
DebuggerSpace_Size      *       &1000
 ]

IICBus_Count       *    5 ; 5 buses is enough for all current machines
IICBus_Base        #    IICBus_Size*IICBus_Count

PageTable_PageFlags #   4               ; Page flags used for page tables. L2PT uses this directly, L1PT adds in PageFlags_Unavailable.

                AlignSpace 16   ; skipped bit must end on 16-byte boundary (ClearPhysRAM does 4 words at a time for skipped areas)
SkippedTablesEnd #      0

; NVRAM support

NVRamSize          #    1               ; Size of NVRam (E2ROM & CMOS) fitted in 256byte units
NVRamBase          #    1               ; Base of NVRam
NVRamSpeed         #    1               ; Clock hold time in 0.5us units
NVRamPageSize      #    1               ; Page size for writing (log2)
NVRamWriteSize     #    1               ; Size of writable region (256byte units)

                   AlignSpace


AppSpaceDANode     #    DANode_NodeSize ; Dummy area node for application space (not on list)
FreePoolDANode     #    DANode_NodeSize ; Area node for free pool
SysHeapDANode      #    DANode_NodeSize ; Area node for system heap
CDASemaphore       #    4               ; Semaphore for OS_ChangeDynamicArea - non-zero => routine threaded
MMUControlSoftCopy #    4               ; Soft copy of ARM control register
IRQMax             #    4               ; from HAL_IRQMax
DeviceCount     #       4       ; size of our table of devices in the system heap
DeviceTable     #       4       ; pointer to table

ProcVec_Start           #       0       ; Start of processor vector table
ProcVec_Branch0         #       4       ; Branch through zero
ProcVec_UndInst         #       4       ; Undefined instruction vector
ProcVec_SWI             #       4       ; SWI vector
ProcVec_PrefAb          #       4       ; Prefetch abort vector
ProcVec_DataAb          #       4       ; Data abort vector
ProcVec_AddrEx          #       4       ; not used (was Address exception vector on 26-bit-only ARMs)
ProcVec_IRQ             #       4       ; IRQ vector
ProcVec_End             #       0

ProcVecPreVeneersSize   *       4*4     ; Space for preveneers for loading handler addresses from 0 page.
ProcVecPreVeneers       #       ProcVecPreVeneersSize

AplWorkSize * AppSpaceDANode + DANode_Size

ExtendedROMFooter # 4 ; Pointer to the extended ROM footer structure. 0 if not initialised, -1 if not found.

CPUFeatures # 2*4

 [ :DEF: ShowWS
        ! 0, "Free space after EnvString = ":CC::STR:(&500-@)
 ]

        ASSERT  @ <= &500               ; a convenient address to remember
                #       (&500-@)

CamMapCorruptDebugBlock #       &40     ; somewhere to dump registers in case of emergency

 [ :DEF: ShowWS
        ! 0, "Free space after CamMap debug block = ":CC::STR:((JordanWS+256*4)-@)
 ]

        ASSERT  @ <= JordanWS+256*4
                #       (JordanWS+256*4-@)  ; pad out to original size

CamEntriesPointer #     4       ; points to where CAM soft copy is
                                ; (CamEntries for machines up to 8MBytes,
                                ; CamEntriesForBigMachines for larger machines)

MaxCamEntry     #       4       ; maximum index into the cam map, ie
                                ; 511 for 16MByte machines, 383 for 12MBytes
                                ; 255 for 8MBytes, otherwise 127

RAMLIMIT        #       4

ROMPhysAddr     #       4

HiServ_ws       #       4
HiServ          #       4
SExitA          #       4
SExitA_ws       #       4
UpCallHan_ws    #       4
UpCallHan       #       4

ROMModuleChain  #       4               ; pointer to head of ROM module chain

; now a section that it's handy to have in simply loadable places

 [ :DEF: ShowWS
 ! 0,"16 ":CC::STR:@
 ]
             AlignSpace 16

KeyWorkSpaceSize   *  &200
KeyWorkSpace       #  KeyWorkSpaceSize
 [ :DEF: ShowWS
      ! 0, "KeyWorkSpace          at ":CC::STR:(KeyWorkSpace)
 ]

; The following were reordered on 26-Jul-91. Old ordering was:
; GeneralMOSBuffer
; ModuleSWI_HashTab
; Module_List
; Curr_Active_Object
; VecPtrTab
; ExceptionDump

; SWI hash table moved to OldIRQ1Vspace on 12-Nov-97, for Ursula (wider hashing)
;
; !!!! Free Space
;
  [ ChocolateSysHeap
ChocolateBlockArrays  #  0
ChocolateCBBlocks     #  4            ; -> array of quick access blocks for Callback
ChocolateSVBlocks     #  4            ; -> array of quick access blocks for software vectors
ChocolateTKBlocks     #  4            ; -> array of quick access blocks for tickers
ChocolateMRBlocks     #  4            ; -> array of blocks for ROM module nodes (reduces no. of individual blocks in heap)
ChocolateMABlocks     #  4            ; -> array of blocks for active module nodes (reduces no. of individual blocks in heap)
ChocolateMSBlocks     #  4            ; -> array of blocks for module SWI hash nodes (reduces no. of individual blocks in heap)
 [ :DEF: ShowWS
      ! 0, "ChocolateCBBlocks     at ":CC::STR:(ChocolateCBBlocks)
      ! 0, "ChocolateSVBlocks     at ":CC::STR:(ChocolateSVBlocks)
      ! 0, "ChocolateTKBlocks     at ":CC::STR:(ChocolateTKBlocks)
      ! 0, "ChocolateMRBlocks     at ":CC::STR:(ChocolateMRBlocks)
      ! 0, "ChocolateMABlocks     at ":CC::STR:(ChocolateMABlocks)
      ! 0, "ChocolateMSBlocks     at ":CC::STR:(ChocolateMSBlocks)
 ]

; !!!! Free Space (40 bytes)
OldSWIHashspace    #  10*4
  |
; !!!! Free Space (64 bytes)
OldSWIHashspace    #  16*4
  ]

;
;was:
;ModuleSHT_Entries  *  16
;ModuleSWI_HashTab  #  4*ModuleSHT_Entries

Module_List        #  4
 [ :DEF: ShowWS
      ! 0, "Module_List           at ":CC::STR:(Module_List)
 ]

Curr_Active_Object #  4

; Vector Claim & Release tables etc

VecPtrTab          #  NVECTORS * 4

ExceptionDump      #  4

OldGeneralMOSBuffer # 256+4      ;spare

 [ :DEF: ShowWS
 ! 0,"16 ":CC::STR:@
 ]
            AlignSpace  16 ; Ensures we can MOV rn, #OsbyteVars if <=&1000

OsbyteVars      #       OSBYTEVarSize
 ASSERT OsbyteVars < &10000 ; Must keep in first 64K so address can be read by
                            ; (and stored in) OS_Bytes &A6,&A7. SKS

; These must be in first 4K
NBuffers        *       10
BuffInPtrs      #       4 * NBuffers
BuffOutPtrs     #       4 * NBuffers

VariableList    #       4

; Oscli stuff
OscliCBtopUID   #       4
OscliCBbotUID   #       4
OscliCBcurrend  #       4

ReturnCode      #       4
RCLimit         #       4

SpriteSize      #       4       ; saved on startup for Sprite code

TickNodeChain   #       4

PIRQ_Chain      #       4
PFIQasIRQ_Chain #       4

; Workspace

EnvTime            #    5

RedirectInHandle   #    1
        ASSERT  RedirectInHandle =  Legacy_RedirectInHandle
        ASSERT ?RedirectInHandle = ?Legacy_RedirectInHandle

RedirectOutHandle  #    1
        ASSERT  RedirectOutHandle =  Legacy_RedirectOutHandle
        ASSERT ?RedirectOutHandle = ?Legacy_RedirectOutHandle

MOShasFIQ          #    1
FIQclaim_interlock #    1
CallBack_Flag      #    1
IRQ_CallBack_Flag * CallBack_Flag
MonitorLeadType    #    1       ; some function of the monitor lead inputs, as yet undetermined
MentionCMOSReset   #    1       ; non zero reports CMOS resets prior to the start banner

                AlignSpace

DUMPER          #       17 * 4  ; now 17 words for 32-bit

                #       4       ; PxxxIRQ_Chain used to be here
Page_Size       #       4
CMOSRAMCache    #       256

; Was Free space (752 bytes) left by old IRQ despatch (new IRQ despatch moved as it required more space).
; Re-used for various purposes on 12-Nov-97, for Ursula
;
      ASSERT @ = &C34                            ;if fails, may need to rearrange padding to sort hash table alignment
;
ModuleSHT_Entries  *  128
ModuleSHT_Padding0 #  12                         ;spare, so that SWI hashtable is aligned for easy immediate address load
ModuleSWI_HashTab  #  4*ModuleSHT_Entries
 [ :DEF: ShowWS
      ! 0, "ModuleSWI_HashTab     at ":CC::STR:(ModuleSWI_HashTab)
 ]
;
SysVars_StickyPointers # (10+1)*4                ;used if ChocolateSysVars is TRUE (1 dummy pointer for 0 size)
 [ :DEF: ShowWS
      ! 0, "SysVars_StickyPtrs    at ":CC::STR:(SysVars_StickyPointers)
 ]
;
Abort32_dumparea   # 6*4          ;info for OS_ReadSysInfo 7 - 32-bit PSR, fault address, 32-bit PC (room for two copies)
 [ :DEF: ShowWS
      ! 0, "Abort32_dumparea      at ":CC::STR:(Abort32_dumparea)
 ]
;
Help_guard         # 4            ;for *help, guard against foreground re-entrancy (multiple taskwindows)
Help_msgdescr      # 4*4          ;for *help, 4 words MessageTrans descriptor
 [ :DEF: ShowWS
      ! 0, "Help_guard            at ":CC::STR:(Help_guard)
 ]
;
PCI_status         # 4            ;bit 0 = 1 if PCI exists or 0 if PCI does not exist, bits 1..31 reserved (0)
 [ :DEF: ShowWS
      ! 0, "PCI_status            at ":CC::STR:(PCI_status)
 ]
IOMD_NoInterrupt          # 4     ;no. of irq devices for extant IOMD
IOMD_DefaultIRQ1Vcode     # 4     ;default irq code start address (ROM) for extant IOMD
IOMD_DefaultIRQ1Vcode_end # 4     ;default irq code end address (ROM)
IOMD_Devices              # 4     ;default irq devices table address (ROM)
 [ :DEF: ShowWS
      ! 0, "IOMD_NoInterrupt      at ":CC::STR:(IOMD_NoInterrupt)
 ]
;
  [ mjsSysHeapNodesTrace
mjsSHNodesTrace_ws # 0
mjsSHNT_hcl_total  # 4    ;total calls to ClaimSysHeapNode
mjsSHNT_hfr_total  # 4    ;total calls to FreeSysHeapNode
mjsSHNT_hop_total  # 4    ;total calls to DoSysHeapOpWithExpansion
mjsSHNT_ohc_total  # 4    ;total calls to OS_Heap for SysHeap claim
mjsSHNT_ohf_total  # 4    ;total calls to OS_Heap for SysHeap free
mjsSHNT_ohx_total  # 4    ;total calls to OS_Heap for SysHeap expand or shrink
mjsSHNT_vcs_total  # 4    ;total SysVar ClaimVNode calls that picked up a sticky node
mjsSHNT_vch_total  # 4    ;total SysVar ClaimVNode calls that went to the heap for a node
mjsSHNT_vxs_total  # 4    ;total SysVar ExpandOrShrinkVNode calls that tried to do sticky change
mjsSHNT_vxh_total  # 4    ;total SysVar ExpandOrShrinkVNode calls that went to the heap
mjsSHNT_vfs_total  # 4    ;total SysVar FreeVNode calls that stuck
mjsSHNT_vfh_total  # 4    ;total SysVar FreeVNode calls that dropped a node to the heap
 [ :DEF: ShowWS
      ! 0, ""
      ! 0, "**WARNING** compiling in code to trace some SysHeap node statistics (mjsSysHeapNodesTrace TRUE)"
      ! 0, ""
      ! 0, "mjsSHNodesTrace_ws    at ":CC::STR:(mjsSHNodesTrace_ws)
 ]
ModuleSHT_Padding1 #  752-12-4*ModuleSHT_Entries-11*4-6*4-5*4-4-4*4-12*4 ;spare
  |
ModuleSHT_Padding1 #  752-12-4*ModuleSHT_Entries-11*4-6*4-5*4-4-4*4      ;spare
  ]
;
      ASSERT @ = &C34 + 752
;
;was:
;OldIRQ1Vspace       # 752


CallBack_Vector   #  4

; interruptible heap manager workspace

HeapSavedReg_R0     # 4
HeapSavedReg_R1     # 4
HeapSavedReg_R2     # 4
HeapSavedReg_R3     # 4
HeapSavedReg_R4     # 4
HeapSavedReg_R13    # 4
HeapReturnedReg_R0  # 4
HeapReturnedReg_R1  # 4
HeapReturnedReg_R2  # 4
HeapReturnedReg_R3  # 4
HeapReturnedReg_R4  # 4
HeapReturnedReg_R13 # 4
HeapReturnedReg_PSR # 4                 ; also acts as interlock

PrinterBufferAddr   #  4                ; holds address of printer buffer
PrinterBufferSize   #  4                ; size of printer buffer - not to be confused with PrintBuffSize
                                        ; which is the (constant) default size for the MOS's smallish buffer
RawMachineID        #  8                ; 64 bits for unique machine ID
KernelMessagesBlock #  20               ; 5 Words for messagetrans message block.
ErrorSemaphore      #  1                ; Error semaphore to avoid looping on error translation.
PortableFlags       #  1                ;
PowerSave * &80                         ; Gets set in PortableFlags when we've switched to slow speed

        AlignSpace

MOSConvertBuffer    #  12               ; Enough romm for 8 hex digits.
AbortIndirection    #  4                ; Pointer to list of addresses and trap routines
PreVeneerRegDump    #  17*4             ; room for r0-r15, spsr

 [ CacheCommonErrors
CachedErrorBlocks   #  4                ; pointer to sysheap node holding the error block cache
 ]

 [ :DEF: ShowWS
 ! 0, "low space free ":CC::STR:(&FE8-@)
 ]
 ASSERT @ < &FE8

; Words for old tools of assorted varieties
; Don't move the following as their positions are assumed by other modules

                        ^       &FE8
CLibCounter             #       1               ; Counter for Shared C Library tmpnam function
        ASSERT  CLibCounter =  Legacy_CLibCounter
        ASSERT ?CLibCounter = ?Legacy_CLibCounter

        AlignSpace

; ECN 17-Feb-92
; Added RISCOSLibWord and CLibWord. The ROM RISCOSLib and CLib must continue
; to work even when they are killed since ROM apps are hard linked to the
; ROM libraries. They cannot use the private word since the block pointed
; to by this will be freed.
RISCOSLibWord           #       4
        ASSERT  RISCOSLibWord =  Legacy_RISCOSLibWord
        ASSERT ?RISCOSLibWord = ?Legacy_RISCOSLibWord

CLibWord                #       4
        ASSERT  CLibWord =  Legacy_CLibWord
        ASSERT ?CLibWord = ?Legacy_CLibWord

FPEAnchor               #       4
        ASSERT  FPEAnchor =  Legacy_FPEAnchor
        ASSERT ?FPEAnchor = ?Legacy_FPEAnchor

DomainId                #       4       ; SKS added for domain identification
        ASSERT  DomainId =  Legacy_DomainId
        ASSERT ?DomainId = ?Legacy_DomainId

Modula2_Private         #       4       ; MICK has FFC and uses it it in USR mode

VduDriverWorkSpace      #       VDWSSize
        ASSERT  VduDriverWorkSpace =  Legacy_VduDriverWorkSpace
        ASSERT ?VduDriverWorkSpace = ?Legacy_VduDriverWorkSpace

 ASSERT (VduDriverWorkSpace :AND: 63) = 0 ; For Tim (VDU5)


 [ :DEF: ShowWS
 ! 0, "high space free ":CC::STR:(&4000-@)
 ]

                        ^       &4000
ScratchSpaceSize        *       &4000

Export_ScratchSpace            #       ScratchSpaceSize
        ASSERT  Export_ScratchSpace =  ScratchSpace
        ASSERT ?Export_ScratchSpace = ?ScratchSpace

 ASSERT @ <= &8000 ; Start of apl

; *****************************************************************************
; Users of ScratchSpace declare yourself here:

; NRaine: Filling a polygon uses ScratchSpace to flatten the path

; DSeal: Draw module uses ScratchSpace on fill operations (this supercedes
;   NRaine's declaration above).

; SKS: HeapSort with (r1 & 0x80000000) & ~(r1 & 0x20000000) & (r5 <= 16K)
;      uses ScratchSpace as a temp slot for data shuffling after sorting

; TMD: Flood fill uses ScratchSpace for the flood queue.

; Tidying the RMA uses ScratchSpace while all modules are dead

; LVR: ADFS uses scratch space to format floppies on 1772 based machines

; DDV: ColourTrans uses scratch space to build palette tables when in
;      ColourTrans_SelecTable/RetrunColourNumber and also whilst generating
;      stipple pattterns.

                        ^       0
GSNameBuff              #       &100
GS_Stack                #       &200
GS_StackPtr_Lim         *       &200 / 4        ; Number of words in stack.
GS_StackPtr             #       4
GSVarWSpace_Size        #       0

                        ^      @ + ScratchSpace

; Pointers for SubstituteArgs: no external calls.
; Ensure these don't overlap FileSwitch's buffers below!

MacExStartPtrs          #       44
MacExEndPtrs            #       44

; OS_CLI has a buffer for alias expansion: ReadVarVal and SubstituteArgs
;    are called while the buffer is held. Also used for module prefixes:
;    Module called twice in this case.

OldAliasExpansionBuffer #       100     ;spare, mjs: shouldn't this have been &100 ??!??


; EvaluateExpression space. Calls ReadUnsigned, BinaryToDecimal and ReadVarVal.

ExprWSpace              *       @

                        ^       0, R12
exprBracDif             #       2       ; keep exprSTRACC aligned
tos_op                  #       2       ; 1 byte for use as STRACC-1
ExprSVCstack            #       4

ExprStackLimit          *       @ - exprBracDif + ExprWSpace + &100   ;keep 256 buffer zone for stack overflow
ExprStackStart          *       ScratchSpace + ScratchSpaceSize


; *****************************************************************************
; ***            Cursor, Sound DMA, SWI, and OSCLI workspace.               ***
; *****************************************************************************

TopOfDMAWorkSpace       *       CursorChunkAddress + 32*1024

                        ^       TopOfDMAWorkSpace ; Note we will be going down

; Sound

SoundWorkSpaceSize      *       &1000

Export_SoundDMABufferSize  *    &1000
        ASSERT  Export_SoundDMABufferSize =  SoundDMABufferSize

SoundEvtSize            *       &1000

Export_SoundDMABuffers         |#|     SoundDMABufferSize * 2
        ASSERT  Export_SoundDMABuffers =  SoundDMABuffers
        ASSERT ?Export_SoundDMABuffers = ?SoundDMABuffers

Export_SoundWorkSpace          |#|     SoundWorkSpaceSize + SoundEvtSize
        ASSERT  Export_SoundWorkSpace =  SoundWorkSpace
        ASSERT ?Export_SoundWorkSpace = ?SoundWorkSpace

; Cursor
; mjs Sep 2000, Kernel/HAL split
; Note that cursor data memory is expected to be uncacheable, since HAL may use it
; directly for h/w DMA. This may not be true since RO 3.7, but should be sorted
; eventually for next generation RO
;
; Currently (Jan 2013) only the sound DMA buffers are mapped in uncacheable.
; This means CursorData is mapped in cacheable, despite the OS treating it as
; uncacheable.

CursorDataSize          *       &600            ; four defined shapes, plus 2 holding shapes
CursorData              |#|     CursorDataSize
CursorSoundRAM          *       CursorData

SPARE_oldCursorSpace    |#|     &200            ; padding to avoid changing exported addresses for now

; SWI despatcher

BranchToSWIExit         |#|     4

SvcTable                |#|     &400

 [ SupportARMT
SWIDespatch_Size        *       15*4
 |
SWIDespatch_Size        *       13*4    ; can save 2 instructions if no Thumb
 ]
SWIDespatch             |#|     SWIDespatch_Size


; Buffers

KeyBuffSize             *       &100
RS423InBuffSize         *       &100
RS423OutBuffSize        *       &C0
PrintBuffSize           *       &400
Sound0BuffSize          *       4
Sound1BuffSize          *       4
Sound2BuffSize          *       4
Sound3BuffSize          *       4
SpeechBuffSize          *       4
MouseBuffSize           *       &40
KeyBuff                 |#|     KeyBuffSize
RS423InBuff             |#|     RS423InBuffSize
RS423OutBuff            |#|     RS423OutBuffSize
PrintBuff               |#|     PrintBuffSize
Sound0Buff              |#|     Sound0BuffSize
Sound1Buff              |#|     Sound1BuffSize
Sound2Buff              |#|     Sound2BuffSize
Sound3Buff              |#|     Sound3BuffSize
SpeechBuff              |#|     SpeechBuffSize
MouseBuff               |#|     MouseBuffSize

; IRQ despatch

MaxInterrupts           *       192     ; 192 needed by OMAP5. Increase in future if necessary.
DefIRQ1Vspace           *       12*MaxInterrupts+128

DefaultIRQ1V            |#|     DefIRQ1Vspace

 [ :DEF: ShowWS
 ! 0, "CursorChunkAddress free ":CC::STR:(@-CursorChunkAddress)
 ]

 ASSERT @ >= CursorChunkAddress

; *****************************************************************************
;                        High system workspace
; *****************************************************************************

                ^       SVCStackAddress

                       #       SVCStackSize    ; svcstk size. Overflow will give abort
SVCSTK                 #       0

SysHeapStart           *       SysHeapAddress


; *****************************************************************************

    ASSERT            LongCLISize >= 256+4     ;minimum size of GeneralMOSBuffer

;Kernel buffers area

                      ^  KbuffsBaseAddress

; GeneralMOSBuffer: re-use with caution!
; Here's just some of the users:
; user                  use(s)
; default error handler error buffer (must be 246+4 bytes big)
; *If                   expression to be evaluated to control the *If
;                       Command line to be submited on the expression
;                         evaluating to non-zero (the THEN clause).
GeneralMOSBuffer      #  LongCLISize

EnvString             #  LongCLISize

AliasExpansionBuffer  #  LongCLISize
ArgumentBuffer        *  AliasExpansionBuffer

ExprBuff              #  LongCLISize
exprSTRACC            #  LongCLISize

OscliBuffSize         *  LongCLISize
OscliNoBuffs          *  16
RedirectBuff          #  OscliBuffSize
OscliCircBuffStart    #  OscliBuffSize * OscliNoBuffs
OscliCircBuffLimit    #  0

GSVarWSpace           #  GSVarWSpace_Size

SysVarWorkSpace	      #  40             ; used by the sys$* variables for reading the current time into

ROMBuildDate          #  128
 [ UseNewFX0Error
NewFX0Error           #  64
 ]

HeapBackgroundError   #  256 ; For storing errors generated in the background by the forced completion of a foreground heap op

KbuffsEnd             #  0
KbuffsSize            *  KbuffsEnd - KbuffsBaseAddress  ;size of Kernel buffers area

    ASSERT            ((KbuffsSize + &FFF) :AND: &FFFFF000) <= KbuffsMaxSize

      ! 0, "Kbuffs                at ":CC::STR:(KbuffsBaseAddress)
      ! 0, "Kbuffs Size           is ":CC::STR:(KbuffsSize)

    [ {FALSE}
      ! 0, "GeneralMOSBuffer      at ":CC::STR:(GeneralMOSBuffer)
      ! 0, "EnvString             at ":CC::STR:(EnvString)
      ! 0, "AliasExpansionBuffer  at ":CC::STR:(AliasExpansionBuffer)
      ! 0, "ArgumentBuffer        at ":CC::STR:(ArgumentBuffer)
      ! 0, "ExprBuff              at ":CC::STR:(ExprBuff)
      ! 0, "exprSTRACC            at ":CC::STR:(exprSTRACC)
      ! 0, "RedirectBuff          at ":CC::STR:(RedirectBuff)
      ! 0, "OscliCircBuffStart    at ":CC::STR:(OscliCircBuffStart)
    ]


        OPT     OldOpt
        END
