/* This source code in this file is licensed to You by Castle Technology
 * Limited ("Castle") and its licensors on contractual terms and conditions
 * ("Licence") which entitle you freely to modify and/or to distribute this
 * source code subject to Your compliance with the terms of the Licence.
 *
 * This source code has been made available to You without any warranties
 * whatsoever. Consequently, Your use, modification and distribution of this
 * source code is entirely at Your own risk and neither Castle, its licensors
 * nor any other person who has contributed to this source code shall be
 * liable to You for any loss or damage which You may suffer as a result of
 * Your use, modification or distribution of this source code.
 *
 * Full details of Your rights and obligations are set out in the Licence.
 * You should have received a copy of the Licence with this source code file.
 * If You have not received a copy, the text of the Licence is available
 * online at www.castle-technology.co.uk/riscosbaselicence.htm
 */

#define ix_SYSCALL_branch 1
#include "ix/syscalls.h"
#include "Kernel.h"

#include <stdint.h>
#include <stdbool.h>
#include "Global/OSMem.h"


struct DANode {
  struct DANode *Link;    // points to next node
  uint32_t Number;        // number of this area
  char    *Base;          // base address of area (points in middle of doubly-mapped areas)
  uint32_t Flags;         // various flags
  uint32_t Size;          // current size of area (not counting holes, if Sparse area)
  uint32_t MaxSize;       // maximum size of area
  uint32_t Workspace;     // workspace pointer when calling handlers
  void (*Handler)();      // pointer to handler routine for area
  char    *Title;         // pointer to area title
  uint32_t SubLink;       // next node in any disjoint sublist (currently used for Shrinkables only)
  uint32_t SparseHWM;     // high water mark, if Sparse area (highest base+size claimed for area)
  struct DANode *SortLink;// next node in alphabetically sorted list
  uint32_t PMP;           // pointer to physical memory pool - zero if not PMP or has been resized to zero
  uint32_t PMPSize;       // number of pages currently in phys pool
  uint32_t PMPMaxSize;    // size of phys memory pool, in pages

  int File;
};

struct result {
  int r0, r1, r2, r3;
};

struct MMresult {
  uint32_t error;
  int amount;
};

#define Page_Size 0x1000

// Non APCS routines called by inline assembler.
extern void CheckAppSpace(void);
extern void VariformInternal(void);

#define MY_PROT (ix_PROT_READ | ix_PROT_WRITE | ix_PROT_EXEC)
#define MY_MAP (ix_MAP_PRIVATE | ix_MAP_ANONYMOUS | ix_MAP_FIXED)
#define PID_LENGTH 12

static inline uint32_t get_file_size(int fd) {
  struct ix_stat s;
  ix_fstat(fd, &s);
  return s.st_size;
}

int MakeTempFile(const char *mem_name) {

  // First try the new in Linux 3.17 system call memfd_create()
  int fd = ix_memfd_create(mem_name ? mem_name : "RISC OS", ix_MFD_CLOEXEC);
  if (fd != -ix_ENOSYS) return fd;

  // If that doesn't exist use the traditional way...
  static const char prefix[] = "/dev/shm/RISC OS #";
  char name[sizeof(prefix) + PID_LENGTH];
  char *n = name;

  // Copy prefix
  const char *p = prefix;
  while (*p) *n++ = *p++;

  // Use PID as suffix.
  unsigned pid = ix_getpid();

  __asm {
        MOV     r0, &pid          // Input
        MOV     r1, n             // Output buffer
        MOV     r2, #PID_LENGTH   // Buffer size
        MOV     r3, #4            // Input size in bytes
        MOV     r4, #1            // Convert as cardinal
        BL      VariformInternal, {r0-r4}, {}, {r0-r2, r10-r12, lr, psr}
  }

  fd = ix_open(name, ix_O_RDWR | ix_O_CLOEXEC | ix_O_CREAT | ix_O_EXCL | ix_O_NOFOLLOW, 0700);
  if (fd >= 0) ix_unlink(name);

  return fd;
}

#define CALL_HANDLER(...)           \
        MOV     r2, pages;          \
        MOV     r3, amount;         \
        MOV     r4, da->Size;       \
        MOV     r5, Page_Size;      \
        MOV     r12, da->Workspace; \
        BLX     da->Handler, {r0, r2, r3, r4, r5, r12}, {__VA_ARGS__}

__value_in_regs struct MMresult doMoveMemory(uint32_t number, int amount, struct DANode* restrict da1) {
  struct MMresult result;
  struct DANode *da = da1;

  result.error = 0;
  int fudge = 0;

  if (da1 == &FreePoolDANode) {
    // Requests to adjust the free pool actually mean the application space
    da = &AppSpaceDANode;
    amount = -amount;
  }

  if (da == &AppSpaceDANode) {

    fudge = 0x8000;

    // Check if the app approves
    __asm {
        MOV     r0, number
        MOV     r10, amount
        BL      CheckAppSpace, {r0, r10}, {r0, psr}
        MOVVS   result.error, r0
        BVS     error
    }
  }

  uint32_t Size = da->Size - fudge;

  if (amount > 0) {

    // Clamp amount to maxinum area size.
    if (amount > da->MaxSize - da->Size) amount = da->MaxSize - da->Size;

    // Call the handler
    int pages = amount / Page_Size;
    if (da->Handler) {
      __asm {
        MOV     r0, #DAHandler_PreGrow
        CALL_HANDLER(r0, psr)
        MOVVS   result.error, r0
        BVS     error
      }
    }

    // Work out new area size.
    uint32_t newSize = da->Size + amount;

    // Is it backed by a Linux file?
    if (da->File >= 0) {

      // Grow the file.
      if (ix_ftruncate(da->File, newSize - fudge)) goto error;

      // Is it doublely mapped?
      if (da->Flags & DynAreaFlags_DoublyMapped) {

        // If so move and extend bottom mapping.
        if (ix_mmap(da->Base - newSize, newSize, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, da->File, 0) != da->Base - newSize) goto error;
      }

    } else {

      // Extend the mapping.
      if (ix_mmap(da->Base + da->Size, amount, MY_PROT, MY_MAP, -1, 0) != da->Base + da->Size) goto error;
    }

    // Store new size
    da->Size = newSize;

    // Reentry permitted.
    CDASemaphore = 0;

    // Call the handler
    if (da->Handler) __asm {
        MOV     r0, #DAHandler_PostGrow
        CALL_HANDLER(psr)
    }

  } else {

    // Make amount positive.
    amount = -amount;

    // Clamp amount to area size.
    if (amount > da->Size - fudge) amount = da->Size - fudge;

    // Out if nothing to move.
    if (amount == 0) goto error;

    // Call the handler
    if (da->Handler) {
      int pages = amount / Page_Size;
      __asm {
        MOV     r0, #DAHandler_PreShrink
        CALL_HANDLER(r0, r3, psr)
        MOV     amount, r3
        MOVVS   result.error, r0
        BVS     error
      }
    }

    // Page align amount again.
    amount = (amount + (Page_Size - 1)) & ~(Page_Size - 1);

    // Out if nothing to move.
    if (amount <= 0) goto error;

    uint32_t newSize = da->Size - amount;

    // Is it doublely mapped?
    if (da->Flags & DynAreaFlags_DoublyMapped) {

      // Move the bottom mapping up
      if (ix_mmap(da->Base - newSize, newSize, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, da->File, 0) != da->Base - newSize) goto error;

      // Remove the start of the bottom mapping.
      ix_mmap(da->Base - da->Size, amount, ix_PROT_NONE, MY_MAP | ix_MAP_NORESERVE, -1, 0);
    }

    // Is it backed by a Linux file?
    if (da->File >= 0) {

      // Truncate file
      ix_ftruncate(da->File, newSize - fudge);

    } else {

      // remove the end of the area
      ix_mmap(da->Base + newSize, amount, ix_PROT_NONE, MY_MAP | ix_MAP_NORESERVE, -1, 0);

    }

    // Store new size
    da->Size = newSize;

    // Reentry permitted.
    CDASemaphore = 0;


    // Call the handler
    int pages = amount / Page_Size;
    if (da->Handler) __asm {
        MOV     r0, #DAHandler_PostShrink
        CALL_HANDLER(psr)
    }

    // Renegate the amount for Service_MemoryMoved
    amount = -amount;

  }

  // If application space changed record it.
  if (da == &AppSpaceDANode) MemLimit = da->Size;

  // If free pool requested reinvert amount.
  if (da1 == &FreePoolDANode) amount = -amount;

  result.amount = amount;
  return result;

error:
  CDASemaphore = 0;
  result.amount = 0;
  return result;
}

__value_in_regs struct result do_DynArea_AlterFile(int r0, int r1, int fd, struct DANode* restrict da) {
  struct result r = {r0, r1, fd, da->File};

  if (fd >= 0) {
    struct ix_stat s;
    ix_fstat(fd, &s);// FIXME Error
    da->Size =  s.st_size;// FIXME Check with handler?

    if (ix_mmap(da->Base, da->MaxSize, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, fd, 0) == da->Base) {
      da->File = fd;
      if (da->Flags & DynAreaFlags_DoublyMapped) {
        ix_mmap(da->Base - da->Size, da->Size, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, fd, 0);
        ix_mmap(da->Base - da->MaxSize, da->MaxSize -da->Size, ix_PROT_NONE, MY_MAP | ix_MAP_NORESERVE, -1, 0);
      }
    } else {
      // FIXME Error
    }
  }
  return r;
}

void Init_MapInRAM2(void* addr, int permissions, unsigned length) {
  if (ix_mmap(addr, length, MY_PROT, ix_MAP_FIXED | ix_MAP_PRIVATE | ix_MAP_ANONYMOUS, -1, 0) != addr) {
    ix_MESSAGE(2, "Memory mapping failed, try running \"sudo sysctl vm.mmap_min_addr=8192\"\n");
    ix_exit(101);
  }
}

static void do_IMB_part(void *start, void *end, char *start2, uint32_t size2) {
  if (start2 > start) start = start2;
  if ((start2 + size2) < end) end = start2 + size2;
  if (start < end) ix_cacheflush(start, end, 0);
}

void do_IMB(unsigned unused, void *start, void *end) {
  (void)unused;
  do_IMB_part(start, end, (void *)ZeroPage, 0x4000);
  do_IMB_part(start, end, (void *)ScratchSpace, ScratchSpaceSize);
  do_IMB_part(start, end, (void *)0x8000, AplWorkSize - 0x8000);
  do_IMB_part(start, end, (void *)CursorChunkAddress, TopOfDMAWorkSpace - CursorChunkAddress);

  struct DANode* i = DAList;
  while(i) {
    do_IMB_part(start, end, i->Base, i->Size);
    i = i->Link;
  }
}

__value_in_regs struct result do_AMBControlSWI(int reason, int r1, int handle, int r3, int r4) {

  switch (reason) {
    case 0: {
      handle = MakeTempFile("Wimp Slot");
      uintptr_t size = r1 * Page_Size;
      if (size > AplWorkMaxSize - 0x8000) {
        size = AplWorkMaxSize - 0x8000;
        r1 = size / Page_Size;
      }
      ix_ftruncate(handle, size);
      ix_mmap((void *)0x8000, AplWorkMaxSize - 0x8000, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, handle, 0);
      AppSpaceDANode.File = handle;
      MemLimit = AplWorkSize = size + 0x8000;
      break;
    }
    case 1:
      ix_ftruncate(handle, 0);
      ix_close(handle);
      if (AppSpaceDANode.File == handle) {
        ix_mmap((void *)0x8000, AplWorkMaxSize - 0x8000, ix_PROT_NONE, MY_MAP | ix_MAP_NORESERVE, -1, 0);
        MemLimit = AplWorkSize = 0x8000;
        AppSpaceDANode.File = -1;
      }
      break;
    case 2: {
      r3 = get_file_size(handle) / Page_Size;
      uintptr_t size = r1 * Page_Size;
      if (size > AplWorkMaxSize - 0x8000) {
        size = AplWorkMaxSize - 0x8000;
        r1 = size / Page_Size;
      }
      ix_ftruncate(handle, size);
      if (AppSpaceDANode.File == handle) {
        MemLimit = AplWorkSize = size + 0x8000;
      }
      break;
    }
    case 3:
      if (r1 == -1) {
        ix_mmap((void *)0x8000, AplWorkMaxSize - 0x8000, ix_PROT_NONE, MY_MAP | ix_MAP_NORESERVE, -1, 0);
        MemLimit = AplWorkSize = 0x8000;
        AppSpaceDANode.File = -1;
      } else {
        uintptr_t size = get_file_size(handle);
        ix_mmap((void *)0x8000, AplWorkMaxSize - 0x8000, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, handle, 0);
        AppSpaceDANode.File = handle;
        MemLimit = AplWorkSize = 0x8000 + size;
      }
      break;
    case 0x103:
      if (r1 != -1) ix_mmap((void *)(r1 ? r1 : 0x8000), r4 * Page_Size, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, handle, r3 * Page_Size);
      break;
    case 4:
      ix_MESSAGE(2, "AMBControl_SWI 4\n");
      r1 = AppSpaceDANode.File == handle ? 0x8000 : -1;
      r3 = get_file_size(handle) / Page_Size;
      break;
    default:
      ix_MESSAGE(2, "Bad AMBControl_SWI\n");
      ix_exit(2);
      break;
  }
  struct result r = {reason, r1, handle, r3};
  return r;
}
