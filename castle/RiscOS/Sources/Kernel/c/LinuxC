/* This source code in this file is licensed to You by Castle Technology
 * Limited ("Castle") and its licensors on contractual terms and conditions
 * ("Licence") which entitle you freely to modify and/or to distribute this
 * source code subject to Your compliance with the terms of the Licence.
 *
 * This source code has been made available to You without any warranties
 * whatsoever. Consequently, Your use, modification and distribution of this
 * source code is entirely at Your own risk and neither Castle, its licensors
 * nor any other person who has contributed to this source code shall be
 * liable to You for any loss or damage which You may suffer as a result of
 * Your use, modification or distribution of this source code.
 *
 * Full details of Your rights and obligations are set out in the Licence.
 * You should have received a copy of the Licence with this source code file.
 * If You have not received a copy, the text of the Licence is available
 * online at www.castle-technology.co.uk/riscosbaselicence.htm
 */

#define ix_SYSCALL_branch 1
#include <syscalls.h>
#include "Kernel.h"

#include <stdint.h>
#include <stdbool.h>
#include "Global/OSMem.h"


struct DANode {
  struct DANode *Link;    // points to next node
  uint32_t Number;        // number of this area
  char    *Base;          // base address of area (points in middle of doubly-mapped areas)
  uint32_t Flags;         // various flags
  uint32_t Size;          // current size of area (not counting holes, if Sparse area)
  uint32_t MaxSize;       // maximum size of area
  uint32_t Workspace;     // workspace pointer when calling handlers
  void (*Handler)();      // pointer to handler routine for area
  char    *Title;         // pointer to area title
  uint32_t SubLink;       // next node in any disjoint sublist (currently used for Shrinkables only)
  uint32_t SparseHWM;     // high water mark, if Sparse area (highest base+size claimed for area)
  struct DANode *SortLink;// next node in alphabetically sorted list
  uint32_t PMP;           // pointer to physical memory pool - zero if not PMP or has been resized to zero
  uint32_t PMPSize;       // number of pages currently in phys pool
  uint32_t PMPMaxSize;    // size of phys memory pool, in pages

  int File;
};

struct result {
  int r0, r1, r2, r3;
};

struct MMresult {
  uint32_t error;
  int amount;
};

#define Page_Size 0x1000

// Non APCS routines called by inline assembler.
extern void CheckAppSpace(void);
extern void VariformInternal(void);

#define MY_PROT (ix_PROT_READ | ix_PROT_WRITE | ix_PROT_EXEC)
#define MY_MAP (ix_MAP_PRIVATE | ix_MAP_ANONYMOUS | ix_MAP_FIXED)
#define PID_LENGTH 12

static inline uint32_t get_file_size(int fd) {
  struct ix_stat s;
  ix_fstat(fd, &s);
  return s.st_size;
}

int MakeTempFile(const char *mem_name) {

  // First try the new in Linux 3.17 system call memfd_create()
  int fd = ix_memfd_create(mem_name, ix_MFD_CLOEXEC);
  if (fd != -ix_ENOSYS) return fd;

  // If that doesn't exist use the traditional way...
  static const char prefix[] = "/tmp/RISC OS #";
  char name[sizeof(prefix) + PID_LENGTH];
  char *n = name;

  // Copy prefix
  const char *p = prefix;
  while (*p) *n++ = *p++;

  // Use PID as suffix.
  unsigned pid = ix_getpid();

  __asm {
        MOV     r0, &pid          // Input
        MOV     r1, n             // Output buffer
        MOV     r2, #PID_LENGTH   // Buffer size
        MOV     r3, #4            // Input size in bytes
        MOV     r4, #1            // Convert as cardinal
        BL      VariformInternal, {r0-r4}, {}, {r0-r2, r10-r12, lr, psr}
  }

  fd = ix_open(name, ix_O_RDWR | ix_O_CLOEXEC | ix_O_CREAT | ix_O_EXCL | ix_O_NOFOLLOW, 0700);
  if (fd >= 0) ix_unlink(name);

  return fd;
}

#define CALL_HANDLER(...)           \
        MOV     r2, pages;          \
        MOV     r3, amount;         \
        MOV     r4, da->Size;       \
        MOV     r5, Page_Size;      \
        MOV     r12, da->Workspace; \
        BLX     da->Handler, {r0, r2, r3, r4, r5, r12}, {__VA_ARGS__}

__value_in_regs struct MMresult doMoveMemory(uint32_t number, int amount, struct DANode* restrict da1) {
  struct MMresult result;
  struct DANode *da = da1;

  result.error = 0;
  int fudge = 0;

  if (da1 == &FreePoolDANode) {
    // Requests to adjust the free pool actually mean the application space
    da = &AppSpaceDANode;
    amount = -amount;
  }

  if (da == &AppSpaceDANode) {

    fudge = 0x8000;

    // Check if the app approves
    __asm {
        MOV     r0, number
        MOV     r10, amount
        BL      CheckAppSpace, {r0, r10}, {r0, psr}
        MOVVS   result.error, r0
        BVS     error
    }
  }

  uint32_t Size = da->Size - fudge;

  // Doubly mapped areas must be file backed, so make it so.
  if (da->File == -2) {

    //Open tempoary file.
    int fd = MakeTempFile(da->Title);
    if (fd < 0) goto error;

    // Replace mapping.
    if ((!da->Size || ix_pwrite(fd, da->Base + fudge, da->Size - fudge, 0) != da->Size)
      && ix_mmap(da->Base + fudge, da->MaxSize - fudge, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, fd, 0) != da->Base + fudge) {
      ix_close(fd);
      goto error;
    }

    // And store it.
    da->File = fd;
  }

  if (amount > 0) {

    // Clamp amount to maxinum area size.
    if (amount > da->MaxSize - da->Size) amount = da->MaxSize - da->Size;

    // Call the handler
    int pages = amount / Page_Size;
    if (da->Handler) {
      __asm {
        MOV     r0, #0
        CALL_HANDLER(r0, psr)
        MOVVS   result.error, r0
        BVS     error
      }
    }

    // Work out new area size.
    uint32_t newSize = da->Size + amount;

    // Is it backed by a Linux file?
    if (da->File >= 0) {

      // Grow the file.
      if (ix_ftruncate(da->File, newSize - fudge)) goto error;

      // Extend the mapping.
      if (ix_mmap(da->Base + da->Size, amount, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, da->File, da->Size - fudge) != da->Base + da->Size) goto error;

      // Is it doublely mapped?
      if (da->Flags & DynAreaFlags_DoublyMapped) {

        // If so move and extend bottom mapping.
        if (ix_mmap(da->Base - newSize, newSize, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, da->File, 0) != da->Base - newSize) goto error;
      }

    } else {

      // Extend the mapping.
      if (ix_mmap(da->Base + da->Size, amount, MY_PROT, MY_MAP, -1, 0) != da->Base + da->Size) goto error;
    }

    // Store new size
    da->Size = newSize;

    // Reentry permitted.
    CDASemaphore = 0;

    // Call the handler
    if (da->Handler) __asm {
        MOV     r0, #1
        CALL_HANDLER(psr)
    }

  } else {

    // Make amount positive.
    amount = -amount;

    // Clamp amount to area size.
    if (amount > da->Size - fudge) amount = da->Size - fudge;

    // Out if nothing to move.
    if (amount == 0) goto error;

    // Call the handler
    if (da->Handler) {
      int pages = amount / Page_Size;
      __asm {
        MOV     r0, #2
        CALL_HANDLER(r0, r3, psr)
        MOV     amount, r3
        MOVVS   result.error, r0
        BVS     error
      }
    }

    // Page align amount again.
    amount = (amount + (Page_Size - 1)) & ~(Page_Size - 1);

    // Out if nothing to move.
    if (amount <= 0) goto error;

    uint32_t newSize = da->Size - amount;

    // Is it doublely mapped?
    if (da->Flags & DynAreaFlags_DoublyMapped) {

      // Move the bottom mapping up
      if (ix_mmap(da->Base - newSize, newSize, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, da->File, 0) != da->Base - newSize) goto error;

      // Remove the start of the bottom mapping.
      ix_mmap(da->Base - da->Size, amount, ix_PROT_NONE, MY_MAP | ix_MAP_NORESERVE, -1, 0);
    }

    // remove the end of the area
    ix_mmap(da->Base + newSize, amount, ix_PROT_NONE, MY_MAP | ix_MAP_NORESERVE, -1, 0);

    // Is it backed by a Linux file?
    if (da->File >= 0) {

      // Truncate file
      ix_ftruncate(da->File, newSize - fudge);
    }

    // Store new size
    da->Size = newSize;

    // Reentry permitted.
    CDASemaphore = 0;


    // Call the handler
    int pages = amount / Page_Size;
    if (da->Handler) __asm {
        MOV     r0, #4
        CALL_HANDLER(psr)
    }

    // Renegate the amount for Service_MemoryMoved
    amount = -amount;

  }

  // If application space changed record it.
  if (da == &AppSpaceDANode) MemLimit = da->Size;

  // If free pool requested reinvert amount.
  if (da1 == &FreePoolDANode) amount = -amount;

  result.amount = amount;
  return result;

error:
  CDASemaphore = 0;
  result.amount = 0;
  return result;
}

__value_in_regs struct result do_DynArea_AlterFile(int r0, int r1, int fd, struct DANode* restrict da) {
  struct result r = {r0, r1, fd, da->File};

  if (fd >= 0) {
    struct ix_stat s;
    ix_fstat(fd, &s);// FIXME Error
    da->Size =  s.st_size;// FIXME Check with handler?

    if (ix_mmap(da->Base, da->MaxSize, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, fd, 0) == da->Base) {
      da->File = fd;
      if (da->Flags & DynAreaFlags_DoublyMapped) {
        ix_mmap(da->Base - da->Size, da->Size, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, fd, 0);
        ix_mmap(da->Base - da->MaxSize, da->MaxSize -da->Size, ix_PROT_NONE, MY_MAP | ix_MAP_NORESERVE, -1, 0);
      }
    } else {
      // FIXME Error
    }
  }
  return r;
}

void Init_MapInRAM2(void* addr, int permissions, unsigned length) {

  int map = ix_MAP_PRIVATE | ix_MAP_ANONYMOUS;
  int prot = MY_PROT;

  // Specify ix_MAP_FIXED when mapping in low addresses, otherwise it is interpreted as anywhere.
  if (addr < (void *)0x8000) map |= ix_MAP_FIXED;

  // Or are we just reserving address space.
  if (permissions == -1) {
    map |= ix_MAP_NORESERVE;
    prot = ix_PROT_NONE;
  }

  if (ix_mmap(addr, length, prot, map, -1, 0) != addr) {
    ix_MESSAGE(2, "Memory mapping failed, try running \"sudo sysctl vm.mmap_min_addr=8192\"\n");
    ix_exit(3);
  }
}

static void do_IMB_part(void *start, void *end, char *start2, uint32_t size2) {
  if (start2 > start) start = start2;
  if ((start2 + size2) < end) end = start2 + size2;
  if (start < end) ix_cacheflush(start, end, 0);
}

void do_IMB(unsigned unused, void *start, void *end) {
  (void)unused;
  do_IMB_part(start, end, (void *)ZeroPage, 0x4000);
  do_IMB_part(start, end, (void *)ScratchSpace, ScratchSpaceSize);
  do_IMB_part(start, end, (void *)0x8000, AplWorkSize - 0x8000);
  do_IMB_part(start, end, (void *)CursorChunkAddress, TopOfDMAWorkSpace - CursorChunkAddress);

  struct DANode* i = DAList;
  while(i) {
    do_IMB_part(start, end, i->Base, i->Size);
    i = i->Link;
  }
}

__value_in_regs struct result do_AMBControlSWI(int reason, int r1, int handle, int r3, int r4) {

  switch (reason) {
    case 0: {
      handle = MakeTempFile("Wimp Slot");
      uintptr_t size = r1 * Page_Size;
      if (size > AplWorkMaxSize - 0x8000) {
        size = AplWorkMaxSize - 0x8000;
        r1 = size / Page_Size;
      }
      ix_ftruncate(handle, size);
      ix_mmap((void *)0x8000, size, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, handle, 0);
      ix_mmap((void *)(0x8000 + size), AplWorkMaxSize - 0x8000 - size, ix_PROT_NONE, MY_MAP | ix_MAP_NORESERVE, -1, 0);
      AppSpaceDANode.File = handle;
      MemLimit = AplWorkSize = size + 0x8000;
      break;
    }
    case 1:
      ix_ftruncate(handle, 0);
      ix_close(handle);
      break;
    case 2: {
      r3 = get_file_size(handle) / Page_Size;
      uintptr_t size = r1 * Page_Size;
      if (size > AplWorkMaxSize - 0x8000) {
        size = AplWorkMaxSize - 0x8000;
        r1 = size / Page_Size;
      }
      ix_ftruncate(handle, size);
      if (AppSpaceDANode.File == handle) {
        // FIXME - performance
        ix_mmap((void *)0x8000, size, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, handle, 0);
        ix_mmap((void *)(0x8000 + size), AplWorkMaxSize - 0x8000 - size, ix_PROT_NONE, MY_MAP | ix_MAP_NORESERVE, -1, 0);
        MemLimit = AplWorkSize = size + 0x8000;
      }
      break;
    }
    case 3:
      if (r1 == -1) {
        ix_mmap((void *)0x8000, AplWorkMaxSize - 0x8000, ix_PROT_NONE, MY_MAP | ix_MAP_NORESERVE, -1, 0);
        MemLimit = AplWorkSize = 0x8000;
        AppSpaceDANode.File = -1;
      } else {
        uintptr_t size = get_file_size(handle);
        ix_mmap((void *)0x8000, size, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, handle, 0);
        ix_mmap((void *)(0x8000 + size), AplWorkMaxSize - 0x8000 - size, ix_PROT_NONE, MY_MAP | ix_MAP_NORESERVE, -1, 0);
        AppSpaceDANode.File = handle;
        MemLimit = AplWorkSize = 0x8000 + size;
      }
      break;
    case 0x103:
      if (r1 != -1) ix_mmap((void *)(r1 ? r1 : 0x8000), r4 * Page_Size, MY_PROT, ix_MAP_SHARED | ix_MAP_FIXED, handle, r3 * Page_Size);
      break;
    case 4:
      ix_MESSAGE(2, "AMBControl_SWI 4\n");
      r1 = AppSpaceDANode.File == handle ? 0x8000 : -1;
      r3 = get_file_size(handle) / Page_Size;
      break;
    default:
      ix_MESSAGE(2, "Bad AMBControl_SWI\n");
      ix_exit(2);
      break;
  }
  struct result r = {reason, r1, handle, r3};
  return r;
}

// OS Memory 24
// Reads /proc/self/maps

struct line {
  uintptr_t start, end;
  unsigned permission;
};

struct stream {
  int index;
  int size;
  int fd;
  unsigned char buffer[256];
};

static int get_char(struct stream *s) {
  if (s->index == s->size) {
    int i = ix_read(s->fd, s->buffer, sizeof(s->buffer));
    if (i <= 0) return -1;
    s->index = 0;
    s->size = i;
  }
  return s->buffer[s->index++];
}

static uintptr_t get_hex(struct stream *s) {
  uintptr_t v = 0;
  while (true) {
    int i = get_char(s);
    if (i >= 'a') i -= 'a' - 'A';
    if (i > '9') i -= 'A' - '9' - 1;
    if (i < 0) return ~(uintptr_t)0;
    i -= '0';
    if (i < 0) return v;
    v <<= 4;
    v |= i;
  }
}

static const unsigned CMA_invert =
  CMA_Partially_UserR |
  CMA_Partially_UserW |
  CMA_Partially_PrivR |
  CMA_Partially_PrivW |
  CMA_Partially_UserXN |
  CMA_Partially_PrivXN;


static __value_in_regs struct line get_line(struct stream *s) {
  struct line l;
  l.permission = 0;
  l.end = ~(uintptr_t)0;

  l.start = get_hex(s);
  if (l.start == ~(uintptr_t)0) return l;
  l.end = get_hex(s);

  if (get_char(s) == 'r') l.permission |= CMA_Completely_UserR  | CMA_Completely_PrivR  | CMA_Partially_UserR  | CMA_Partially_PrivR;
  if (get_char(s) == 'w') l.permission |= CMA_Completely_UserW  | CMA_Completely_PrivW  | CMA_Partially_UserW  | CMA_Partially_PrivW;
  if (get_char(s) != 'x') l.permission |= CMA_Completely_UserXN | CMA_Completely_PrivXN | CMA_Partially_UserXN | CMA_Partially_PrivXN;

  while(get_char(s) >= 32);
  return l;
}

unsigned do_CheckMemoryAccess(unsigned reason, uintptr_t low, uintptr_t high) {

  // This implemention does not support "physically mapped" or "abortable".
  // There is no distenction between privileged and user.

  (void)reason;
  struct stream s;
  s.index = 0;
  s.size = 0;
  s.fd = ix_open("/proc/self/maps", ix_O_RDONLY, 0);

  struct line l;
  do {
    l = get_line(&s);
  } while(l.end <= low);

  uintptr_t prev_end = low;
  unsigned permission = ~0U;

  while(true) {
    if (prev_end < l.start) permission &= (CMA_Completely_UserXN | CMA_Completely_PrivXN | CMA_Partially_UserXN | CMA_Partially_PrivXN) ^ CMA_invert;
    if (l.start >= high) break;
    permission &= l.permission ^ CMA_invert;

    if (l.end >= high) break;
    prev_end = l.end;
    l = get_line(&s);
  }

  ix_close(s.fd);
  return permission ^ CMA_invert;
}
