; Copyright 2008 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; This header file is autogenerated from the files maintained by the
; RISC OS allocations manager and should not be edited by anyone else.

; hdr:GraphicsV

; ********************
; *** Changes List ***
; ********************

; 28-Aug-02 KJB Created.
;

; reason codes passed in r4 to GraphicsV

                          ; R4 bits: | 31-24  | 23-16
GraphicsV_Complete              * 0  ; -      | -
GraphicsV_VSync                 * 1  ; Driver | Head
GraphicsV_SetMode               * 2  ; Driver | Head
GraphicsV_SetInterlace          * 3  ; Driver | Head ; Deprecated
GraphicsV_SetBlank              * 4  ; Driver | Head
GraphicsV_UpdatePointer         * 5  ; Driver | Head
GraphicsV_SetDMAAddress         * 6  ; Driver | Head
GraphicsV_VetMode               * 7  ; Driver | Head
GraphicsV_DisplayFeatures       * 8  ; Driver | Head
GraphicsV_FramestoreAddress     * 9  ; Driver | Head
GraphicsV_WritePaletteEntry     * 10 ; Driver | Head/Overlay
GraphicsV_WritePaletteEntries   * 11 ; Driver | Head/Overlay
GraphicsV_ReadPaletteEntry      * 12 ; Driver | Head/Overlay
GraphicsV_Render                * 13 ; Driver | Head
GraphicsV_IICOp                 * 14 ; Driver | Head
GraphicsV_SelectHead            * 15 ; Driver | -
GraphicsV_StartupMode           * 16 ; Driver | Head
GraphicsV_PixelFormats          * 17 ; Driver | Head
GraphicsV_ReadInfo              * 18 ; Driver | -
GraphicsV_VetMode2              * 19 ; Driver | Head
GraphicsV_CreateOverlay         * 20 ; Driver | -
GraphicsV_DestroyOverlay        * 21 ; Driver | Overlay
GraphicsV_SetOverlayPosition    * 22 ; Driver | Overlay
GraphicsV_MapOverlayBuffer      * 23 ; Driver | Overlay
GraphicsV_UnmapOverlayBuffer    * 24 ; Driver | Overlay
GraphicsV_DiscardOverlayBuffer  * 25 ; Driver | Overlay
GraphicsV_VetOverlay            * 26 ; Driver | -
GraphicsV_SetOverlayTransform   * 27 ; Driver | Overlay
GraphicsV_SetOverlayZOrder      * 28 ; Driver | -

; GraphicsV_SetDMAAddress (r0)
GVDAG_VInit                     * 0
GVDAG_VStart                    * 1
GVDAG_VEnd                      * 2
GVDAG_VRender                   * 3

; GraphicsV_WritePaletteEntry / WritePaletteEntries / ReadPaletteEntry (r0)
GVPaletteType_Normal    * 0 ; &BBGGRRSS palette/gamma entry
GVPaletteType_Border    * 1 ; &BBGGRRSS border colour
GVPaletteType_Pointer   * 2 ; &BBGGRRSS pointer palette entry
GVPaletteType_ColourKey * 3 ; Raw pixel value to write to framebuffer, may be read-only

; GraphicsV_DisplayFeatures flags (r0)
GVDisplayFeature_HardwareScroll                     * 1:SHL:0
GVDisplayFeature_HardwarePointer                    * 1:SHL:1
GVDisplayFeature_InterlaceWithProgressiveFramestore * 1:SHL:2
GVDisplayFeature_SeparateFramestore                 * 1:SHL:3 ; GraphicsV_FramestoreAddress implemented
GVDisplayFeature_NoVsyncIRQ                         * 1:SHL:4
GVDisplayFeature_VariableFramestore                 * 1:SHL:5 ; driver-managed framestore address/size changes with mode
GVDisplayFeature_CopyRectangleIsFast                * 1:SHL:6 ; OS_SpriteOp 65 hint: copying rectangles (VRAM->VRAM via GPU) is faster than plotting sprites (RAM->VRAM via CPU)

; GraphicsV_Render flags (r0)
GVRender_SyncIfComplete         * 1:SHL:0
GVRender_SyncIfNotComplete      * 1:SHL:1
GVRender_Sync                   * 2_11:SHL:0

; GraphicsV_Render operation (r1)
GVRender_NOP                    * 0
GVRender_CopyRectangle          * 1
GVRender_FillRectangle          * 2

; GraphicsV_PixelFormats list format (r0)
                        ^ 0
GVPixelFormat_NColour   # 4 ; NColour mode variable value
GVPixelFormat_ModeFlags # 4 ; Relevant mode flags
GVPixelFormat_Log2BPP   # 4 ; Log2BPP mode variable value
GVPixelFormat_Size      # 0 ; Struct size

; GraphicsV_ReadInfo items (r0)
GVReadInfo_Version          * 0 ; Driver version number (BCD * &10000)
GVReadInfo_ModuleName       * 1 ; Module (instance) name if module
GVReadInfo_DriverName       * 2 ; Driver name for display to user
GVReadInfo_HardwareName     * 3 ; Hardware name for display to user (e.g. PCI card name)
GVReadInfo_ControlListItems * 4 ; List of known VIDC control list items
GVReadInfo_MaxOverlays      * 5 ; Max number of overlays that can be created, indicates overlay API implemented

; GraphicsV_VetMode2 result flags (r0)
GVVetMode2_ResultMask           * 3
GVVetMode2_Result_Unsupported   * 0 ; Provided mode is unsupported
GVVetMode2_Result_SysFramestore * 1 ; Mode is supported, and will use the system framestore (i.e. kernel-managed DA 2)
GVVetMode2_Result_ExtFramestore * 2 ; Mode is supported, and will use the external framestore (as defined by R3 & R5)
GVVetMode2_Result_UnkFramestore * 3 ; Mode is supported, but driver doesn't know where the framestore will be (e.g. framestore is managed by another component, like the GPU firmware in the Pi)
GVVetMode2_ExtraBytes_Invalid   * 4 ; The input value of the ExtraBytes control list item was invalid, driver has suggested a new value in R2

; GraphicsV_CreateOverlay / VetOverlay flags (r2)
GVOverlayFlag_Scalable            * 1:SHL:0

GVOverlayType_Mask   * 255
GVOverlayType_ZOrder * 0
GVOverlayType_Basic  * 1

                END

