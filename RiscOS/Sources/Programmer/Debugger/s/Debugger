; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     > Debugger.s.Debugger - ARM/RISC OS debugger (principally for machine code)

; Authors:      Roger Wilson (Brazil version)
;               Andrew F. Powis (Arthur version)
;               Stuart K. Swales (Arthur fixes/enhancements)
;               Tim Dobson (Adjusting headers, ARM600 variant)
;               Alan Glover (fixes/enhancements, ARM6/ARM7 instructions)
;               William Turner (StrongARM compatibility)
;               Kevin Bracey (ARMv4+5, Thumb, fixes/enhancements, 32-bit)
;               Steve Revill (Slight changes to ADR and SWI disassembly)
;               Ben Avison (halfword, doubleword and unaligned word support)

; 1.18  SKS     Fixed disassembly of #xx,yy operands
; 1.19  SKS     Fixed disassembly of LSR #32, ASR #32
;               Comment where LDR pc relative comes from
; 1.20  SKS     Fixed fp/coproc disassembly, memoryi/memorya parameters
; 1.21  SKS     Fixed *debug response wrt ESCape
; 1.22  SKS     Fixed memory wrt wrapping at 64M

; ---- Released for Arthur 2.00 ----

; 1.22  TMD 22-Nov-89    Fixed source to assemble again with new headers,
;                        and with new AAsm which objects to DCD rel.sym.
;                        (shouldn't affect object file)
;
; 1.23  AMG 30-Oct-90    Various fixes/enhancements
;                        1. ADR made from ADD/SUB Rn,R15,#nn
;                        2. SWP/SWPB now recognised, with >ARM2 warning
;                        3. LDR/STR and LDF/STF now decode PC relative addressing
;                           in the instruction, not the comment field
;                        4. MRC/MCR to CP15 (ie ARM3 control) are commented
;                        5. Comment position moved in for longer comments
;                        6. Silly code detection and indication added...
;                           a) NV condition code
;                           b) SWI following a CDP
;                           c) MUL Rx,Rx or MUL R15,Rx
;                           d) LDM/STM with ^ and !
;                           e) LDM with ^ - bank switches
;                           f) Use of R8-R14 after a xxxP instruction
; 1.24  ENevill ??-Mar-91
;                        Text extraction, untested I think - AMG
;
; 1.25  AMG 11-Mar-91    Fixed disassembly of ADD rd,R15,rm as an ADR
;                        Change OS_Confirm usage to use EQ flag, not ASCII Y
;
; **** Version 1.24 and 1.25 have not been tested, though the bug fix
;      in 1.25 has been checked using 1.23's source.
;
; 1.26  AMG 12-Mar-91    Altered wacky shift coding to give
;                        ADD R0,R0,#0,ROR #24 instead of
;                        ADD R0,R0,#0,24 which confuses people
;
; **** This version is also untested, but changes made have been checked
;      with 1.23's source again
;
; 1.27  ECN 15-Mar-91    Internationalised
; 1.27  ECN 08-Apr-91    Fixed logic of MCR/MRC disassembly.
;                        Bit 20 = 0 => MCR, = 1 => MRC
;                        Internal ARM datasheet is wrong wrt MCR/MRC
;                        VLSI datasheet and assemblers are correct
; 1.27  ECN 19-Apr-91    Fixed "Enter new value" message in MemoryA

; 1.28  AMG 25-Apr-91    Corrected 'use ! and ^' message in messages file.
;                        Added BadSWI error for unused SWIs and associated
;                          message
;
; 1.29  AMG 10-May-91    Used mask &FC000000 instead of &FC000003 to force
;                        LDR/STR into addressing range since it was
;                          messing up LDRB R0,[PC,#1] disassembly
;
; 1.30  AMG 23-May-91    Use global Bad SWI message.
;                        Sort out Message Token not found for bad syntax
;                          to MEMORYI & MEMORY
;
; 1.31  amg 31-May-91    Change invalid instruction used by InitStore to
;                          &E6000010 - which is still invalid - the old
;                          one, &E1000090, is now a SWP instruction!
;                        Added new FPA  URD and NRM instructions
;
; 1.32  amg 05-Jun-91    Added new FPA  LFM/SFM instructions. While in that
;                          area also fixed a bug where coproc offsets were
;                          treated as a 12 bit number, not an 8 bit one.
;
; 1.33  amg 21-Jun-91    Bugfix: Use Global copy of 'Escape' error message
;
; 1.34  amg 18-Jul-91    Tidy up internationalisation to save some space.
;
; 1.36  ECN 07-Aug-91    Inserted NOP after LDM forcing user bank followed
;                        by access to banked register.
;
; 1.37  amg 26-Nov-91    RP-0512 (hang accessing &3000000 - empty IO slot)
;                        Add address validation as below
;                        &0000000-&1ffffff - Use OS_ValidateAddress
;                        &2000000-&2ffffff - No checks (always present)
;                        &3000000-&33fffff - No access (I/O areas)
;                        &3400000-&3ffffff - Read access only (ROMs)
;                                              (writes=VIDC or MEMC)
;                        MEMORYA will trap interactive mode going into
;                        a read-only/no access area too.
;
; 1.38  amg 24-Jan-92    Repaired non-interactive MEMORYA (RP-0970)
;
; 1.39  amg 13-Apr-92    Revert fix of Rp-0512 to a switchable flag,
;                        off by default

; ---- Released for RISC OS 3.10 ----

; 1.40  TMD 27-Jul-92    Added variant for ARM600 which doesn't wrap
;                        addresses at 64M
;
; 1.41  ECN 10-Aug-93    Internationalised help/syntax messages
;
; 1.42  TMD 27-Oct-93    Fixed bug MED-00167 - coprocessor data transfers to
;                        PC-relative address were disassembled wrong.
; 1.43  TMD 01-Dec-93    Fixed bug MED-01490 - couldn't set breakpoints
;                         above 32MB (eg in RMA!).
; 1.44  amg 23-Jan-94    Catch up on new ARM6/7 opcodes: MRS, MSR, MULL, MLAL and
;                         check conformance with FPA10 spec. Tighten up tests
;                         for MUL/MULL/SWP - now insist b7:b4=2_1001
;                        Add national switch to override internationalised help/syntax

; ---- Released for RISC OS 3.60 ----

; 1.46  WT  07-Feb-96    Made StrongARM compatible (breakpoint code breaks IDcache)
; 1.48  KJB 04-Jun-96    Added ARMv4 instructions (BX, LDR[H|SH|SB], STRH)
;                        SWP wasn't being disassembled
;                        CP15 comments amended to ARMv4
;                        ARM3 warning removed from SWP (after all, MRS,
;                          MULL etc don't have warnings!)

; ---- Released for RISC OS 3.70 ----

; 1.49  KJB 07-Oct-96    Operation code of MRC, MCR was shown times 2.
;                        FLT was showing wrong dest reg, with registers
;                          shown in wrong order.
;                        WFC etc were showing precision.
;                        Unknown FP opcodes now shown as normal coprocessor
;                          operations.
;                        LDC/STC (and FP derivatives) didn't detect
;                          post-indexing with no writeback. Now reported as
;                          undefined instructions.
;                        UMULLEQS no longer pushes registers into the
;                          comment field.
;                        MSR/MRS now specified as described in ARM
;                          Architecture Reference 4.
; 1.50  KJB 10-Oct-96    Lots of warnings added.
;                        More FP opcodes tightened up.
;                        PC-relative load/store with writeback no longer
;                         shown as simple ADR.
;                        Thumb disassembly added.
; 1.51  KJB 29-Oct-96    Bugs introduced by 1.49 and 1.50 fixed.
;                        Warnings added to the LDRH family to match LDC and LDR.
;                        Warning about StrongARM STM^ bug added.
;                        Source code tidied up and simplified with macros.
; 1.52  KJB 06-Nov-96    More bug fixes.
;                        StrongARM warning revised following Digital guidelines.
; 1.53  KJB 11-Nov-96    SWI called checkreg for no apparent reason.
;                        Stopped Addr26 screwing up Thumb disassembly.
;                        Set Addr26 to True.
; 1.54  KJB 27-Mar-98    Test for post-indexed LDRH etc with W set didn't work.
;                        Service call table added.
; 1.55  KJB 08-May-98    Made Addr26 flag only affect disassembly of BL
;                        and use of lr and pc. Addresses are not wrapped
;                        to 64M. This makes sense for our 32-bit ARM in 26-bit
;                        mode.
; 1.57-1.59              Build changes only.
; 1.60  KJB 20-Apr-00    32-bit compatibility added.
;                        New *ShowFPRegs command.
;                        Added ARMv5 instructions (BLX, CLZ, BKPT, CDP2 et al)
;                        Handling of instruction extension space adjusted as
;                        per ARMv4.
;                        Fixed some Thumb instructions.
;                        Added "info" form of LDC and STC
;                        NV condition code is now undefined, except for the
;                        new instructions using it.
; 1.61  KJB 11-Jul-00    ARMv5 warning now shown reliably.
; 1.62  KJB 08-Sep-00    Changed invalid instruction to &E7FFFFFF (as per ARM
;                        recommendation that &E7FxxxFx should be used)
;                        Branch disassembly changed - when running on a
;                        26-bit systems, branch instructions in the lower
;                        64M will be wrapped within 64M, but branches
;                        above 64M will not.
;                        Disassembly of VFP instruction set added.
;                        PC-relative LDRH family instructions calculated
;                        target address incorrectly.
; 1.63  SAR 30-Jan-01    ADDS Rd,PC,#imm (and SUBS) no longer map to ADR.
;                        Unknown SWIs, such as 'User' and 'OS_Undefind' are now
;                        disassembled as 'SWI &num'.
; 1.64  KJB 31-Jan-01    Added ARMv5TE instructions.
;                        Corrected Thumb high ADD/CMP/MOV.
; 1.65  KJB 08-Feb-01    Breakpoints now work on 32-bit systems - it got
;                        confused over which breakpoint was hit.
;                        *MemoryI T now disassembles 24 instructions by default
;                        rather than 48.
; 1.67  KJB 15-Feb-01    QADD etc "corrected" to have operands in Rm,Rn order.
; 1.68  SAR 21-Mar-01    Unknown SWIs displayed as hex.
; 1.70  SAR 21-Mar-01    Wacky shift coding changed back to #0,24 to match
;                        ARM documentation.
; 1.71  KJB 18-Apr-01    Fixed and tidied *ShowFPRegs - in particular will work
;                        correctly with 26-bit FPEmulators.
; 1.72  SAR 28-Apr-01    Introduced the Disassemble$Options code variable to
;                        control various alternatives for disassembly. In
;                        particular, the register name output can now be in
;                        APCS mode(s).
;       MJS 05-May-01    Added P flag to *MemoryX commands to access physical
;                        addresses.
; 1.73  KJB 10-May-01    Fixed warnings on SWP.
;                        Changes to message files to correct syntax errors.
;                        *MemoryX P works on IOMD-based systems if OS_Memory 13
;                        fails.
;                        Changed to use ObjAsm.
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:PublicWS
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:EnvNumbers
        GET     Hdr:Proc
        GET     Hdr:VduExt
        GET     Hdr:Tokens
        GET     Hdr:MsgTrans
        GET     Hdr:FPEmulator
        GET     Hdr:ResourceFS
        GET     Hdr:CPU.FPA

        GET     Hdr:Debugger

        GET     VersionASM

        GET     Hdr:Debug

                GBLL    debug
debug           SETL    False

                GBLL    national
national        SETL    False

                GBLL    StrongARM
StrongARM       SETL    True

                GBLL    WarnSArev2
WarnSArev2      SETL    False           ; Warn about hitting the SA revision 2 STM^ bug

                GBLL    WarnARMv5
WarnARMv5       SETL    True            ; Indicate ARMv5 or later instructions

                GBLL    WarnARMv5E
WarnARMv5E      SETL    True

                GBLL    WarnARMv6
WarnARMv6       SETL    True            ; Indicate ARMv6 or later instructions

                GBLL    ARMv6
ARMv6           SETL    False           ; Don't do ARMv6 yet until complete

                GBLL    CirrusDSP
CirrusDSP       SETL    False

 [ :LNOT: :DEF: standalone
                GBLL    standalone
standalone      SETL    False
 ]


; Continue not up to much

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Debug global workspace

                ^       0, wp

; Breakpoint code section - keep layout same as RelocatedCode section

nbreakpoints    *       16

BreakCodeStart  #       nbreakpoints*8  ; Breakpoint entry code segments
                #       4*5             ; Save other registers before JMP
BreakCodeEnd    #       0               ; End of copied area

; Areas accessed pc relative by relocated breakpoint code

TrapStore       #       4               ; Store for breakpoint id
Registers       #       4*17            ; Register dump area
pc_register     *       Registers + 4*15 ; dumped pc
psr_register    *       Registers + 4*16 ; dumped psr
r12Store        #       4               ; r12 for breakpoint code
JumpStore       #       4               ; address of breakpoint code in ROM

Breaklist       #       nbreakpoints*8  ; List of addresses, old data

OldExceptionDumpArea #  4               ; Old exception register dump area

WindowWidth     #       4
BytesPerLine    #       4

Mistake         #       4               ;potential error number

OldAddress      #       4               ;address of last instruction
OldThumbAddress #       4               ;address of last Thumb instruction
OldThumbInst    #       4               ; last Thumb instruction disassembled
PhysAddrWrd     #       4

MessageFile_Block #     16              ; File handle for MessageTrans
MessageFile_Open  #     4               ; Opened message file flag

SysIs32bit      #       1               ; non-zero if on a 32-bit system
                #       3

; SAR
DisOpts         #       4               ; Disassembler options
DisOpt_APCS     *       2_1             ; Use APCS register names (when set)
DisOpt_v6       *       2_10            ; Use 'v6' rather than 'sb'
DisOpt_v7       *       2_100           ; Use 'v7' rather than 'sl'
DisOpt_v8       *       2_1000          ; Use 'v8' rather than 'fp'
DisOpt_sp       *       2_10000         ; Use 'SP' rather than 'R13'
DisOpt_lr       *       2_100000        ; Use 'LR' rather than 'R14'
DisRegLabels    *       @               ; Pointers to register name strings
DisReg_R0       #       4
DisReg_R1       #       4
DisReg_R2       #       4
DisReg_R3       #       4
DisReg_R4       #       4
DisReg_R5       #       4
DisReg_R6       #       4
DisReg_R7       #       4
DisReg_R8       #       4
DisReg_R9       #       4
DisReg_R10      #       4
DisReg_R11      #       4
DisReg_R12      #       4
DisReg_R13      #       4
DisReg_R14      #       4
DisReg_R15      #       4
DisReg_F        #       1               ; Prefix char for FP registers
DisReg_C        #       1               ; Prefix char for Co-pro registers
                #       1
                #       1

StringBuffer    #       160             ; Temp string buffer. Big enough to
                                        ; hold a disassembled instruction
                                        ; and a full register set + three instrs
 ASSERT (?StringBuffer :AND: 2_11)=0
TotalSpace      *       :INDEX: @

; List of mistakes

                ^       1
Mistake_PlingHat #      1
Mistake_Banked  #       1
Mistake_SWICDP  #       1
Mistake_MUL     #       1
Mistake_R15shift #      1
Mistake_R15     #       1
Mistake_PCwriteback #   1
Mistake_BytePC  #       1
Mistake_StorePC #       1
Mistake_Unpred  #       1
Mistake_RdRn    #       1
Mistake_RmRn    #       1
Mistake_RdLoRdHi #      1
Mistake_RdLoRm  #       1
Mistake_RdHiRm  #       1
Mistake_Rninlist #      1
Mistake_RdRm    #       1
Mistake_STMHat  #       1
Mistake_ARMv5   #       1
Mistake_ARMv5E  #       1
Mistake_ARMv6   #       1

                ^       -1
Potential_SWICDP #      -1
Potential_Banked #      -1
Potential_Banked_Next # -1
Potential_SWICDP_Next # -1

; Overlaid workspace

ExeBufLen       *       4+4+4+?Registers

                ^       :INDEX: StringBuffer, wp
CoreBuffer      #       16              ; Enough for a line of bytes
 ASSERT ?StringBuffer >= ?CoreBuffer

                ^       :INDEX: StringBuffer, wp
ExecuteBuffer   #       ExeBufLen
 ASSERT ?StringBuffer >= ?ExecuteBuffer

; Internal flags
Command_64bitData *     1 :SHL: 0

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Useful constants

TAB             *       9
LF              *       10
CR              *       13
space           *       " "
quote           *       """"
colon           *       ":"
delete          *       &7F
ampersand       *       "&"

; Useful macros

; AddChar - Add a character (possibly conditionally) to the disassembly
;           eg  AddChar "B",NE
        MACRO
        AddChar   $c,$cond
        MOV$cond  R10,#"$c"
        STR$cond.B R10,[R0],#1
        MEND

; AddStr - Add a string (possibly conditionally) to the disassembly,
;          optionally adding the ARM condition field - eg
;              AddStr BX_string,,conds
        MACRO
        AddStr  $c,$cond,$conds,$two
        ADR$cond R10,$c
        [ "$conds" <> ""
          BL$cond  SaveStringConditions$two
        |
          BL$cond  SaveString
        ]
        MEND

; TestBit - check to see if a bit is set, and add one of two characters
;           depending on that bit. Needn't add a character in both
;           or indeed either case; exits with Z bit set appropriately.
;              eg    TestBit 24,"L"
        MACRO
        TestBit $bit,$set,$unset
        TSTS    R4,#1:SHL:$bit
        [ "$set" <> "" :LAND: "$unset" <> ""
        MOVEQ   R10,#"$unset"
        MOVNE   R10,#"$set"
        STRB    R10,[R0],#1
        |
          [ "$set" <> ""
          AddChar "$set",NE
          ]
          [ "$unset" <> ""
          AddChar "$unset",EQ
          ]
        ]
        MEND

; TestStr - check to see if a bit is set, and add one of two strings
;           depending on that bit. Needn't add a string in both
;           cases. Optionally add the ARM condition field. eg
;                  TestStr 20,Ldr,Str,conds
        MACRO
        TestStr $bit,$set,$unset,$conds,$two
        TSTS    R4,#1:SHL:$bit
        [ "$set" <> "" :LAND: "$unset" <> ""
        ADREQ   R10,$unset
        ADRNE   R10,$set
          [ "$conds" <> ""
          BL    SaveStringConditions$two
          |
          BL    SaveString
          ]
        |
          [ "$set" <> ""
          AddStr   $set,NE,$conds
          ]
          [ "$unset" <> ""
          AddStr   $unset,EQ,$conds
          ]
        ]
        MEND

ARM_Addr_Mask * &FC000000 ; local mask to avoid knocking off byte offsets

        AREA    |Debugger$$Code|, CODE, READONLY, PIC

Module_BaseAddr

        DCD     0
        DCD     Debug_Init - Module_BaseAddr
        DCD     Debug_Die - Module_BaseAddr
        DCD     Debug_Service - Module_BaseAddr
        DCD     Debug_Title - Module_BaseAddr
        DCD     Debug_HelpStr - Module_BaseAddr
        DCD     Debug_HC_Table - Module_BaseAddr
        DCD     Module_SWISystemBase + DebuggerSWI * Module_SWIChunkSize
        DCD     Debug_SWI_Code - Module_BaseAddr
        DCD     Debug_SWI_Name - Module_BaseAddr
        DCD     0
 [ International_Help <> 0
        DCD     message_filename - Module_BaseAddr
 |
        DCD     0
 ]
 [ :LNOT: No32bitCode
        DCD     Debug_Flags - Module_BaseAddr
 ]

Debug_Title ; share with
Debug_SWI_Name
        DCB     "Debugger", 0           ; SWI class
        DCB     "Disassemble", 0        ; +0
        DCB     "DisassembleThumb", 0   ; +1
        DCB     0

Debug_HelpStr
        DCB     "Debugger", TAB, "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
        DCB     " $Module_MinorVersion"
 ]
        DCB     0
        ALIGN

 [ :LNOT: No32bitCode
Debug_Flags
        DCD     ModuleFlag_32bit
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Debug_Init Entry

        LDR     r2, [r12]               ; Hard or soft init ?
        TEQ     r2, #0
        BNE     %FT00

; Hard init

        LDR     r3, =TotalSpace         ; Claim module workspace
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        EXIT    VS                      ; 'No room' good enough error

        STR     r2, [r12]

00      MOV     wp, r2


        ADRL    r0, RelocatedCodeStart  ; fwd ref
        MOV     r3, #BreakCodeEnd - BreakCodeStart
01      SUBS    r3, r3, #4              ; Move breakpoint code to RAM
        LDRPL   r1, [r0, r3]
        STRPL   r1, [r2, r3]
        BPL     %BT01

 [ StrongARM
        MOV     r0, #1
        MOV     r1, r2
        ADD     r2, r1, #(nbreakpoints*8)
        SWI     XOS_SynchroniseCodeAreas
 ]

        ADRL    r14, BreakTrap          ; Address of breakpoint code in ROM
        STR     r14, JumpStore          ; fwd ref
        STR     wp, r12Store            ; A good idea to initialise it

        ADR     r1, Breaklist           ; Clear breakpoint list
        MOV     r3, #nbreakpoints
        MOV     r14, #-1
10      STR     r14, [r1], #8           ; Only need to zap address field
        SUBS    r3, r3, #1
        BNE     %BT10

        ADR     r1, Registers           ; Clear register dump area
        MOV     r3, #17
        MOV     r14, #0
        STR     r14, MessageFile_Open
20      STR     r14, [r1], #4
        SUBS    r3, r3, #1
        BNE     %BT20

        MOV     r0, #ExceptionDumpArea  ; Change exception register dump area
        ADR     r1, Registers
        SWI     XOS_ChangeEnvironment
        STRVC   r1, OldExceptionDumpArea

        EXIT    VS

        MOV     r3, #0
        STR     R3, Mistake
        STR     R3, OldAddress          ;Init vars for dodgy code detection
        STR     R3, OldThumbAddress
        STR     R3, OldThumbInst
        STR     R3, PhysAddrWrd
        MRS     R3, CPSR
        ANDS    R3, R3, #2_11100        ; non-zero if in a 32-bit mode
        STRB    R3, SysIs32bit
        BEQ     %FT40

; Fill in the zero page branch table

        ASSERT  nbreakpoints*8 <= ?DebuggerSpace
        MOV     R0, #DebuggerSpace + nbreakpoints*8
        LDR     R1, =&E51FF004          ; LDR PC,[PC,#-4]
        ADR     R2, BreakCodeStart + (nbreakpoints-1)*8
30      STMDB   R0!, {R1, R2}
        SUB     R2, R2, #8
        CMP     R0, #DebuggerSpace
        BHI     %BT30

 [ StrongARM
        MOV     r0, #1
        MOV     r1, #DebuggerSpace
        ADD     r2, r1, #(nbreakpoints)*8-4
        SWI     XOS_SynchroniseCodeAreas
        CLRV
 ]

40
        ; SAR
        MOV     R3, #0
        STR     R3, DisOpts
        BL      create_codevar
        BL      init_codevar

	[ standalone
	BLVC    declareresourcefsfiles
	]

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    no registers trashable

        ALIGN
Debug_ServiceTable
        DCD     0
        DCD     Debug_ServiceBody - Module_BaseAddr
        DCD     Service_Reset                   ; &27
      [ standalone
        DCD     Service_ResourceFSStarting      ; &60
      ]
        DCD     0

        DCD     Debug_ServiceTable - Module_BaseAddr
Debug_Service ROUT
        MOV     r0, r0
        TEQ     r1, #Service_Reset
      [ standalone
	TEQNE   R1,#Service_ResourceFSStarting
      ]
        MOVNE   pc, lr

Debug_ServiceBody
      [ standalone
        TEQ     R1,#Service_ResourceFSStarting
        BEQ     serviceresourcefsstarting
      ]
        Entry   "r0, r1"
        LDR     wp, [r12]
        MOV     r0, #ExceptionDumpArea          ; Set exception dump area
        ADR     r1, Registers
        SWI     XOS_ChangeEnvironment
        STRVC   r1, OldExceptionDumpArea
        EXIT

      [ standalone
; ResourceFS has been reloaded - redeclare resource files
; In    R2 -> address to call
;       R3 -> workspace for ResourceFS module

serviceresourcefsstarting
        Push    "R0,LR"
        ADRL    R0,resourcefsfiles
        MOV     LR,PC                   ; LR -> return address
        MOV     PC,R2                   ; R2 -> address to call
        Pull    "R0,PC"
      ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Debug_Die Entry

        LDR     wp, [r12]

        BL      SwapAllBreakpoints      ; Be nice

        MOV     r0, #ExceptionDumpArea  ; Restore old exception dump area
        MOV     r1, #0                  ; if current one is us
        SWI     XOS_ChangeEnvironment
        ADR     r14, Registers
        TEQS    r14, r1
        MOVEQ   r0, #ExceptionDumpArea
        LDREQ   r1, OldExceptionDumpArea
        SWIEQ   XOS_ChangeEnvironment
        LDR     r0, MessageFile_Open
        TEQS    r0, #0
        ADRNE   r0, MessageFile_Block
        SWINE   XMessageTrans_CloseFile
        MOV     r0, #0
        STR     r0, MessageFile_Open

        ; SAR
        BL      destroy_codevar

      [ standalone
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_DeregisterFiles ; ignore errors
      ]

        CLRV
        EXIT                            ; Don't refuse to die

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;                        (No. of Parameters)

Debug_HC_Table ; Name       Max  Min

        [ national
        Command BreakClr,    1,   0,
        Command BreakList,   0,   0,
        Command BreakSet,    1,   1,
        Command Continue,    0,   0,
        Command Debug,       0,   0,
        Command InitStore,   1,   0,
        Command Memory,      5,   1,; P B R + R
        Command MemoryA,     4,   1,; P B R V
        Command MemoryI,     7,   1,; P T A +/- B + C
        Command ShowRegs,    0,   0,
        Command ShowFPRegs,  0,   0,
        |
        Command BreakClr,    1,   0, International_Help
        Command BreakList,   0,   0, International_Help
        Command BreakSet,    1,   1, International_Help
        Command Continue,    0,   0, International_Help
        Command Debug,       0,   0, International_Help
        Command InitStore,   1,   0, International_Help
        Command Memory,      5,   1, International_Help     ; P B R + R
        Command MemoryA,     4,   1, International_Help     ; P B R V
        Command MemoryI,     7,   1, International_Help     ; P T A +/- B + C
        Command ShowRegs,    0,   0, International_Help
        Command ShowFPRegs,  0,   0, International_Help
        ]

        DCB     0                       ; end of table

        GET     TokHelpSrc
        ALIGN

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = instruction to disassemble
;       r1 = address to disassemble relative to (bug in 1.00 debug did relative
;                                                to module base only !)

; Out   r1 -> core containing string
;       r2 = length of string excluding 0 terminator

Debug_SWI_Code Entry "r9"

        LDR     wp, [r12]
        TEQ     R11,#0 ;only one SWI
        BEQ     swi00
        TEQ     R11,#1
        BEQ     swi01

        ADR     R0,ErrorBlock_ModuleBadSWI
        BL      CopyErrorP1

        EXIT

        MakeInternatErrorBlock ModuleBadSWI,,BadSWI

swi00
        LDR     R14,Mistake

        CMPS    R14,#Potential_Banked_Next  ;potential error if a banked access occurs (after LDM)
        MOVEQ   R14,#Potential_Banked
        CMPS    R14,#Potential_SWICDP_Next  ;potential error if a SWI occurs (after coproc)
        MOVEQ   R14,#Potential_SWICDP

        STR     R14,Mistake

        MOV     R9, R1
        BL      Instruction

        LDR     R14,Mistake

        CMPS    R14,#Potential_Banked
        CMPNES  R14,#Potential_SWICDP
        MOVEQ   R14,#0

        STREQ   R14,Mistake

        EXIT                           ; Preserve flags

swi01
        MOV     R9,R1
        BL      ThumbInstruction

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkreg
        STMFD   R13!,{R14}
        LDR     R14,Mistake
        CMPS    R14,#Potential_Banked
        MOVEQ   R14,#Mistake_Banked
        STR     R14,Mistake
        LDMFD   R13!,{R15}


; In    r0 = instruction to disassemble
;       r9 = where it is

; Out   r1 -> core containing string
;       r2 = length of string including 0
;       r10,r11 corrupt

Instruction Entry "r0, r3-r9"

        SUB     R4, R9, #4
        LDR     R5, OldAddress
        TEQS    R4, R5
        MOV     R4, #0
        STRNE   R4, Mistake         ;not going in sequence, so forget context
        STR     R9, OldAddress      ;save for next time

        MOV     r4, r0

        ADR     r0, StringBuffer        ; Always build into temp buffer

 [ debug :LAND: True
        MOV     r14, #0                 ; zap buffer
        MOV     r3, #?StringBuffer-4
00      STR     r14, [r0, r3]
        SUBS    r3, r3, #4
        BPL     %BT00
 ]

        MOV     r3, r4, LSR #24         ; r3 := primary instruction nibble
        AND     r3, r3, #2_00001111     ; remove condition codes
        TEQS    r3, #&0F
        BEQ     Swi                     ; [software interrupt = 0F]

        CMP     r3, #&0C
        BHS     Coprocessor             ; [coproc 0C..0E]

        CMP     r3, #&0A
        BHS     Branch                  ; [branch = 0A..0B]

        CMP     r3, #&08
        BHS     LdmStm                  ; [load/store multiple = 08,09]

        CMP     r3, #&04
        BHS     LdrStr                  ; [load/store register = 04..07]

        B       DataProcessing          ; [data processing = 00.03]

; .............................................................................

Undefined
        MOV     r14, #0                 ; Undefined can't have a mistake :)
        STR     r14, Mistake

        ADR     r0, StringBuffer        ; Reset pointer
        ADR     r10, Unknown
        BL      lookup_r10

; .............................................................................
; In    r0 -> buffer to be terminated. registers stacked as for entry
;       r10 -> string to be appended first

SaveStringEnd

        BL      SaveString

; .............................................................................
; In    r0 -> buffer to be terminated. registers stacked as for entry

; Out   r1 -> completed buffer
;       r2 = length of buffer

InstructionEnd

        BL      TestMistakes

        MOV     r14, #0
        STRB    r14, [r0]

        ADR     r1, StringBuffer
        SUBS    r2, r0, r1              ; Clears V flag

        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Software interrupt

        ; arrive here with cccc 1111 xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        cccc 1111 nnnn nnnn nnnn nnnn nnnn nnnn
        ;
        ; SWI{cond} <number|name>
        ;
        ; where cccc = condition
        ;       nnnn = number

Swi     LDR     R10, Mistake
        CMP     R10, #Potential_SWICDP
        MOVEQ   R10, #Mistake_SWICDP
        STREQ   R10, Mistake

        AddStr  Swi_Instruction,,conds

        BL      Tab

        MOV     r1, r0
        ADR     r2, StringBuffer+?StringBuffer
        SUB     r2, r2, r1
        BIC     r0, r4, #&FF000000      ; Mask out SWI<cc>
        SWI     XOS_SWINumberToString   ; This may give error (eg. Buffer over)
        BVS     InstructionEnd
        MOV     R3, #24
        BL      unknown_swis
        ADD     r0, r1, r2
        B       InstructionEnd

; Compare the string against 'User' and 'OS_Unknown' with or without the leading 'X'. If
; it matches, dump the SWI number as a string with a preceding '&' into the buffer instead.
;
; Entry...
;   R0 - SWI number
;   R1 - pointer to string
;   R2 - offset to last char of string
;   R3 - number of bits to print in SWI number
; Exit...
;   R0 - corrupted
;   R1 - preserved
;   R2 - offset to last char of string (may be different)
;   R3 - preserved
;   R8 - corrupted
;
unknown_swis
        Entry
        ; Ensure all bytes after the SWI name string up to the next word boundary are zero
        MOV     R14, #0
        ADD     R8, R1, R2
unk_swi_align
        TST     R8, #2_11
        STRNEB  R14, [R8], #1
        BNE     unk_swi_align
        ; Compare this SWI name string against some pre-defined unknown SWI name strings
        ADR     R8, str_user
        BL      strcmp
        ADRNE   R8, str_xuser
        BLNE    strcmp
        ADRNE   R8, str_os_undefined
        BLNE    strcmp
        ADRNE   R8, str_xos_undefined
        BLNE    strcmp
        BEQ     unk_swi_replace
        SUB     R2,R2,#1                ; Adjust to avoid taking the zero byte
        EXIT
        ; Replace the SWI name string with the SWI number decoded as hexadecimal
unk_swi_replace
        MOV     R8, R0
        MOV     R0, R1
        SUB     R2, R3, #4
        BL      StoreHex
        SUB     R2, R0, R1              ; Convert end pointer back to offset
        EXIT

; Compare two word-aligned strings. They *must* be padded with zero or more null bytes after
; the terminator (which must also be null) up to the word boundary.
;
; Entry...
;   R1    - pointer to first string
;   R8    - pointer to second string
; Exit...
;   R1    - preserved
;   R8    - corrupted
;   flags - EQ=match, NE=don't match
strcmp
        Entry   "R0, R1"
strcmp_loop
        LDR     R0, [R1], #4
        LDR     R14, [R8], #4
        TEQ     R0, R14
        BNE     strcmp_exit             ; Conditional Pull is bad on newer ARMs, branch instead
        TST     R0, #&FF000000
        BNE     strcmp_loop
strcmp_exit
        EXIT

        ; Some SWI names indicating that a SWI number was not recognised (in length order)
str_user
        DCB     "User", 0
        ALIGN
str_xuser
        DCB     "XUser", 0
        ALIGN
str_os_undefined
        DCB     "OS_Undefined", 0
        ALIGN
str_xos_undefined
        DCB     "XOS_Undefined", 0
        ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Branch, Branch and Link

        ; arrive here with cccc 101x xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        cccc 101l oooo oooo oooo oooo oooo oooo
        ;
        ; B{L}{cond} address
        ;
        ; where cccc = condition
        ;          l = Link
        ;          o = 24-bit signed offset (in words)

Branch ROUT

        MOV     r14, r4, LSR #28        ; if "NV" condition code
        TEQ     r14, #15
        BEQ     BLX_offset              ; then it's BLX

        AddChar "B"
        TestBit 24,"L"

        BL      Conditions

        BL      Tab

        MOV     r4, r4, ASL #8          ; shift offset up to top
BranchCommon
        LDRB    r2, SysIs32bit

        ADD     r8, r9, r4, ASR #6
        ADD     r8, r8, #8              ; pc + 8

        TST     r9, #ARM_Addr_Mask      ; if in bottom 64M, and system is 26 bit
        TEQEQ   r2, #0                  ; then...
        BICEQ   r8, r8, #ARM_Addr_Mask  ; Wrap in 64MByte space for 26-bit
        BEQ     BranchLdrStrCommon

; Check no wrap for 32-bit. Wrap detected by one address being < &10000000
; and one being >= &80000000.

        TST     r8, #&F0000000
        TSTNE   r9, #&F0000000
        BNE     BranchLdrStrCommon      ; EQ if one of the addresses is < &10000000

        ORRS    r2, r8, r9              ; MI if one of the addresses is >= &80000000

        MOVMI   r2, #Mistake_Unpred     ; must have wrapped
        STRMI   r2, Mistake

BranchLdrStrCommon
        MOV     r2, #32-4                 ; (keeping byte offsets)
        BL      StoreHex

        B       InstructionEnd

Unknown DCB     "M00", 0                ; "Undefined instruction"
Swi_Instruction
        DCB     "SWI", 0
Ldm     DCB     "LDM", 0
Stm     DCB     "STM", 0
W_Back  DCB     "!,{", 0
        ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Load and store multiple

        ; arrive here with cccc 100x xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        cccc 100p uswl nnnn rrrr rrrr rrrr rrrr
        ;
        ; <LDM|STM>{cond}<I|D><A|B> Rn{!},register list{^}
        ;
        ; where cccc = condition
        ;          p = Pre-indexing/~Post-indexing
        ;          u = Up/~Down
        ;          s = the ^ bit (transfer user registers, or restore PSR)
        ;          w = Writeback
        ;          l = Load/~Store
        ;       nnnn = Rn
        ;       rrrr = register list
LdmStm ROUT

        ANDS    R5, R4, #&7F00
        BLNE    checkreg        ;error if R8-R14 in list

        ;test for silly conditions - ldm/stm ! and ^ with R15 not in list is bad,
        ;and LDM ^ with R15 not in the list is a deferred bank error

        TestBit 15
        BNE     notbad ;R15 in list

        TestBit 22
        BEQ     notbad ;not forcing user

        ;case 1 - ! too
        TestBit 21
        MOVNE   r10, #Mistake_PlingHat
        STRNE   r10, Mistake
        BNE     notbad2 ;don't bother with next test

        ;case 2 - LDM
        TestBit 20
        MOVNE   r10,#Potential_Banked_Next
        STRNE   r10,Mistake
        BNE     notbad2 ; don't bother with next test

notbad
        ;case 3 - Rn in list with writeback
        TestBit 21
        BEQ     notbad3
        MOV     r10, r4, LSR #16
        AND     r10, r10, #2_1111
        MOV     r14, #1
        MOV     r14, r14, LSL r10
        TSTS    r4, r14
        BEQ     notbad3
        TestBit 20                              ; If it's an STM
        SUBEQ   r14, r14, #1
        TSTEQS  r4, r14                         ; and Rn is lowest in list, then it's okay
        MOVNE   r10,#Mistake_Rninlist
        STRNE   r10,Mistake
        BNE     notbad2

notbad3
        ;case 4 - storing PC
        AND     r14, r4, #1 :SHL: 20 :OR: 1 :SHL: 15
        TEQ     r14, #1 :SHL: 15
        BNE     notbad2
        ; okay, we're storing PC, but complaining about APCS would be boring.
        ; Therefore don't bother whinging about STMFD R13!,{[any R0-R9],R11,R12,R14,PC}
        AND     r14, r4, #2_1111 :SHL: 21
        TEQ     r14, #2_1001 :SHL: 21           ; Check FD, !, and no ^
        ANDEQ   r14, r4, #2_1111 :SHL: 16
        TEQEQ   r14, #13 :SHL: 16               ; Check R13
        ANDEQ   r14, r4, #2_1111110000000000
        TEQEQ   r14,     #2_1101100000000000
        MOVNE   r10,#Mistake_StorePC
        STRNE   r10,Mistake

notbad2
        TestStr 20,Ldm,Stm,conds        ; Load/~Store bit

        TestBit 23,"I","D"              ; Up/~Down bit

        TestBit 24,"B","A"              ; Pre/~Post bit

        MOV     r5, r4, LSR #16         ; Rn
        AND     r5, r5, #2_1111
        TEQS    r5, #15
        MOVEQ   r14, #Mistake_R15
        STREQ   r14, Mistake
        BL      Tab_Dis_Register

        TST     r4, #1 :SHL: 21         ; Writeback bit
        ADR     r10, W_Back
        ADDEQ   r10, r10, #1            ; just do ',{'
        BL      SaveString

; Register list

        MOV     r5, #0          ; Current register
 [ WarnSArev2
        MOV     r7, #0          ; Total registers
 ]
        MOV     r8, #0          ; Registers in current group

RegList ADD     r2, r5, #1
        TST     r2, r4, LSR r2
        BCC     Next

        TEQ     r8, #0
        BLNE    AddComma

        BL      Dis_Register
        ADD     r5, r5, #1
 [ WarnSArev2
        ADD     r7, r7, #1
 ]
        TEQS    r5, #16
        BEQ     Xxm_End

        ADD     r2, r5, #1
        TSTS    r2, r4, LSR r2
        MOV     r8, #1
        BCC     Next                    ; If next reg not done, loop

Count   ADD     r8, r8, #1
        ADD     r5, r5, #1              ; Count registers
        TEQS    r5, #16
        BEQ     Group

        ADD     r2, r5, #1
        TSTS    r2, r4, LSR r2
        BCS     Count

; Group or single register

Group   MOV     r6, #","
        CMPS    r8, #3
        MOVHS   r6, #"-"
        STRB    r6, [r0], #1

        SUB     r5, r5, #1
        BL      Dis_Register
 [ WarnSArev2
        ADD     r7, r7, r8
        SUB     r7, r7, #1
 ]

Next    ADD     r5, r5, #1
        TEQS    r5, #16
        BNE     RegList

Xxm_End
        AddChar "}"                     ; end register list

        TestBit 22,"^"                  ; '^' bit

        [ WarnSArev2
        BEQ     InstructionEnd          ; It's not ^
        TestBit 20
        BNE     InstructionEnd          ; It's not a store

        ; If we have more than 1 register in a STM user bank,
        ; then it may fail on early StrongARMs
        CMPS    r7, #1
        MOVHI   r10, #Mistake_STMHat
        STRHI   r10, Mistake
        ]

        B       InstructionEnd

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Load or store register

LdrStr  ROUT
        ; Load and Store Word or Byte
        ; arrive here with cccc 01xx xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        cccc 010p ubwl nnnn dddd iiii iiii iiii
        ;        or        cccc 011p ubwl nnnn dddd rrrr rtt0 mmmm
        ;
        ; <LDR|STR>{cond}{B}    Rd,[Rn,#offset]{!}
        ;                       Rd,[Rn,{+|-}Rm{,shift}]{!}
        ; <LDR|STR>{cond}{B}{T} Rd,[Rn],#offset
        ;                       Rd,[Rn],{+|-}Rm{,shift}
        ; where cccc = condition
        ;          p = Pre-indexed/~Post-indexed
        ;          u = Up/~Down
        ;          b = Byte/~Word
        ;          w = Writeback (or T bit if post-indexed)
        ;          l = Load/~Store
        ;       nnnn = Rn
        ;       dddd = Rd
        ;      rrrrr = shift amount
        ;         tt = shift type (LSL, LSR, ASR or ROR)
        ;       mmmm = Rm
        ;       iiii = 12-bit unsigned immediate offset

        ; Not totally clear which order these tests should be in, but it
        ; doesn't matter for the time being - this restriction applies to
        ; both LDR and PLD.
        TST     r4, #1 :SHL: 25         ; If Rm and shift and trying Rs
        TSTNE   r4, #1 :SHL: 4          ; then that was xxR Rd,[Rn,Rm,SHF Rs]
        [ ARMv6
        BNE     UndefinedExtension      ; but ARM2 doesn't do that anymore
        |
        BNE     Undefined               ; but ARM2 doesn't do that anymore
        ]

        MOV     r14, r4, LSR #28
        TEQ     r14, #15
        BEQ     Preload

        TestStr 20,Ldr,Str,conds        ; Load/~Store bit

        MOV     r5, r4, LSR #12         ; Rd
        AND     r5, r5, #2_1111

        TST     r4, #1 :SHL: 22         ; Byte/~Word bit
        BEQ     %FT01

        AddChar "B"
        TEQS    r5, #15
        MOVEQ   r10, #Mistake_BytePC
        STREQ   r10, Mistake
        BEQ     %FT03

1       TEQS    r5, #15
        TSTEQS  r4, #1 :SHL: 20
        MOVEQ   r10, #Mistake_StorePC
        STREQ   r10, Mistake

3       AND     r10, r4, #2_1001 :SHL: 21
        TEQS    r10,     #2_0001 :SHL: 21 ; postincrement with writeback ?
        AddChar "T",EQ                    ; -> T(ranslate)

        BL      Tab_Dis_Register        ; uses r5 from above

        ; Check for writeback LDR/STR with Rd=Rn
        AND     r10, r4, #2_1001 :SHL: 21
        TEQS    r10, #2_1000 :SHL: 21
        BEQ     %FT10                   ; if not writeback, okay

      [ {FALSE}                         ; ARM ARM says nothing about zero
        TestBit 25                      ; offset OK, and it isn't entirely
        BNE     %FT05                   ; logical - KJB
        MOVS    r14, r4, LSL #32-12
        BEQ     %FT10                   ; zero offset, so okay
      ]

5       AND     r14, r4, #2_1111 :SHL: 12
        AND     r10, r4, #2_1111 :SHL: 16
        TEQS    r10, r14, LSL #4
        MOVEQ   r10, #Mistake_RdRn
        STREQ   r10, Mistake

        ; Check for post-indexed LDR/STR with Rm=Rn
10      AND     r14, r4, #2_11000 :SHL: 21
        TEQS    r14, #2_10000 :SHL: 21
        BNE     %FT20
        AND     r14, r4, #2_1111 :SHL: 16
        AND     r10, r4, #2_1111
        TEQS    r10, r14, LSR #16
        MOVEQ   r10, #Mistake_RmRn
        STREQ   r10, Mistake

20
DataTransfer_Common ; for CPDT - address part similar to LDR/STR (no reg index)
        AddChar ","

DataTransfer_Common_NoComma

        ;from 1.23, show resultant LDR/STR Rx,[R15,#nnn] address directly

        MOV     R5,R4,LSR #16
        AND     R5,R5,#15
        TEQ     R5,#15
        BNE     not_rel

        TestBit 21                      ; Writeback bit set?
        MOVNE   r10, #Mistake_PCwriteback
        STRNE   r10, Mistake
        TST     r4, #2_1001 :SHL: 24    ; or post-indexed LDR/STR? (can have post-indexed CPDT without writeback)
        MOVEQ   r10, #Mistake_PCwriteback
        STREQ   r10, Mistake

        ; if immediate offset, pre-indexed, no writeback then it's PC-relative
        AND     r14,R4,#2_11001 :SHL: 21
        TEQS    r14,#2_01000 :SHL: 21
        BNE     not_rel

        MOV     R8,R4,LSL #32-12
        MOV     R8,R8,LSR #32-12

; offset in LDC/STC instructions is a word offset

        TestBit 27                      ; if a coproc data transfer
        MOVNE   r8, r8, LSL #2          ; then multiply offset by 4

        TestBit 23                      ; Up/~Down bit
        SUBEQ   r8, r9, r8              ; Form offset from required address
        ADDNE   r8, r9, r8

        ADD     r8, r8, #8
        B       BranchLdrStrCommon

not_rel
        AddChar "["

        MOV     r5, r4, LSR #16         ; Rn
        BL      Dis_Register

        TestStr 24,Close_B+1,Close_B    ; Pre/~Post bit - just ',' else '],'

        TestBit 25                      ; Shift/~Immediate bit
        BNE     %FT90

; Immediate offset

        AND     r14, r4, #2_1111001 :SHL: 21 ; post-indexed CPDT, no writeback?
        TEQ     r14, #2_1100000 :SHL: 21
        BEQ     CPDT_info

        AddChar "#"

        TestBit 23,,"-"                 ; Up/~Down bit

        MOV     r8, r4, LSL #32-12
        MOV     r8, r8, LSR #32-12      ; r4 & 0x0FFF
        TestBit 27
        MOVNE   r8, r8, LSL #2          ; Word offset if coprocessor
        BL      StoreDecimal

80
        TestBit 24,"]"                 ; Pre/~Post bit
                                       ; [preincrement, so close]

        AND     r10, r4, #2_1001 :SHL: 21
        TEQS    r10,     #2_1001 :SHL: 21 ; preincrement with writeback ?
        AddChar "!",EQ

        B       InstructionEnd

; CPDT info form
CPDT_info
        AddChar "{"
        AND     r8, r4, #&FF
        BL      StoreDecimal
        AddChar "}"
        B       InstructionEnd


; Register offset
90
        TestBit 23,,"-"                 ; Up/~Down bit

        MOV     r5, r4                  ; Rm
        BL      Dis_Register

        BL      ShiftField

        B       %BT80

Preload ROUT
        ; Preload
        ; arrive here with 1111 01xx xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        1111 0101 u101 nnnn 1111 iiii iiii iiii
        ;        or        1111 0111 u101 nnnn 1111 rrrr rtt0 mmmm
        ;
        ; PLD [Rn,#offset]
        ;     [Rn,{+|-}Rm{,shift}]
        ;
        ; where    u = Up/~Down
        ;       nnnn = Rn
        ;      rrrrr = shift amount
        ;         tt = shift type (LSL, LSR, ASR or ROR)
        ;       mmmm = Rm
        ;       iiii = 12-bit unsigned immediate offset

        [ WarnARMv5E
        MOV     r14, #Mistake_ARMv5E
        STR     r14, Mistake
        ]

        AddStr  Pld
        BL      Tab
        AND     r5, r4, #2_10111:SHL:20
        TEQ     r5, #2_10101:SHL:20
        ANDEQ   r5, r4, #2_1111:SHL:12
        TEQEQ   r5, #2_1111:SHL:12
        BEQ     DataTransfer_Common_NoComma
        B       Undefined


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Mull    DCB     "MULL",0
        ALIGN
Mlal    DCB     "MLAL",0
        ALIGN
Mul     DCB     "MUL", 0
Mla     DCB     "MLA", 0
aswp    DCB     "SWP", 0
Ldr     DCB     "LDR", 0
Str     DCB     "STR", 0
Open_B  DCB     ",[", 0
Close_B DCB     "],", 0
Pld     DCB     "PLD", 0

UndefinedDataProcessing ROUT
        ; Arrive here with cccc 000x xxxx xxxx xxxx xxxx 1xx1 xxxx

        TSTS    R4,#2_11:SHL:5
        TSTEQS  R4,#2_1:SHL:24
        BNE     LoadStoreExtension

ArithmeticExtension
        ; Arrive here with cccc 0000 oooo xxxx xxxx xxxx 1001 xxxx
        AND     R5,R4,#2_1111:SHL:20
        CMP     R5,#2_1000:SHL:20
        BHS     mul_long                ; opcode 8-15 = long multiply

        CMP     R5,#2_0100:SHL:20
        [ ARMv6
        BEQ     maal                    ; opcode 4 = long multiply accumulatee accumulate
        BHI     Undefined               ; opcode 5-7 undefined
        |
        BHS     Undefined               ; opcode 4-7 undefined
        ]

        ; Multiply + Multiply-with-Accumulate
        ; Arrive here with cccc 0000 00xx xxxx xxxx xxxx 1001 xxxx
        ; Format is        cccc 0000 00as dddd nnnn ssss 1001 mmmm
        ;
        ; MUL{cond}{S} Rd,Rm,Rs
        ; MLA{cond}{S} Rd,Rm,Rs,Rn
        ;
        ; where cccc = condition
        ;          a = Accumulate
        ;          s = Set flags
        ;       dddd = Rd
        ;       nnnn = Rn
        ;       ssss = Rs
        ;       mmmm = Rm

        TestStr 21,Mla,Mul,conds        ; Accumulate bit

        TestBit 20,"S"                  ; Update flags bit

        MOV     r5, r4, LSR #16         ; Rd
        BL      Tab_Dis_Register

        AND     R5,R4,#15               ; Rm
        MOV     R10, R4, LSR #16
        AND     R10,R10,#15
        MOV     R8, R4, LSR #12
        AND     R8, R8, #15
        MOV     R9, R4, LSR #8
        AND     R9, R9, #15

        TEQS    R5, R10
        MOVEQ   R14, #Mistake_RdRm
        STREQ   R14, Mistake

        TEQS    R10, #15
        TEQNES  R8, #15
        TEQNES  R9, #15
        TEQNES  R5, #15
        MOVEQ   R14, #Mistake_R15
        STREQ   R14, Mistake

        BL      Comma_Dis_Register

        MOV     r5, r4, LSR #8          ; Rs
        BL      Comma_Dis_Register

        TestBit 21                      ; MLA has extra operand
        MOVNE   r5, r4, LSR #12         ; Rn
        BLNE    Comma_Dis_Register
        BNE     InstructionEnd

        TST     r4, #2_1111:SHL:12      ; Check Rn=R0 for MUL
        BNE     Undefined

        B       InstructionEnd

mul_long
        ; Multiply long + Multiply-with-Accumulate long
        ; Arrive here with cccc 0000 1xxx xxxx xxxx xxxx 1001 xxxx
        ; Format is        cccc 0000 1uas hhhh llll ssss 1001 mmmm
        ;
        ; <U|S><MULL|MLAL>{cond}{S} RdLo,RdHi,Rm,Rs
        ;
        ; where cccc = condition
        ;          u = Signed/~Unsigned
        ;          a = Accumulate
        ;          s = Set flags
        ;       hhhh = RdHi
        ;       llll = RdLo
        ;       ssss = Rs
        ;       mmmm = Rm

        ;deal with signed/unsigned
        TestBit 22,"S","U"

        ;note: the accumulate works differently here to MUL/MLA
        ;on an accumulating multiply you get Rd+=Rm * Rs, otherwise
        ;you get Rd==Rm * Rs, so wheras MLA uses one more register
        ;than MUL both MULL/MLAL use four registers.

        TestStr 21,Mlal,Mull,conds      ; Accumulate bit

        TestBit 20,"S"                  ; Update flags bit

        ; This stupid opcode can be too long. Will hardly ever happen
        ; so don't increase the tab width (might break some programs).
        ; Instead, just push the registers over one space.
        BL      TabOrPushOver

        MOV     r5, r4, LSR #12         ; RdLo
        AND     r6, r5, #2_1111
        BL      Dis_Register

        MOV     r5, r4, LSR #16         ; RdHi
        AND     r7, r5, #2_1111
        BL      Comma_Dis_Register

        MOV     r5, r4                  ; Rm
        AND     r8, r5, #2_1111
        BL      Comma_Dis_Register

        MOV     r5, r4, LSR #8          ; Rs
        AND     r9, r5, #2_1111
        BL      Comma_Dis_Register

        ; Can't use R15 as any register, unpredictable
        ; if RdLo=RdHi or RdLo=Rm or RdHi=Rm
        LDR     r14, Mistake
        TEQS    r7, r8
        MOVEQ   r14, #Mistake_RdHiRm
        TEQS    r6, r8
        MOVEQ   r14, #Mistake_RdLoRm
        TEQS    r6, r7
        MOVEQ   r14, #Mistake_RdLoRdHi
        TEQS    r6, #15
        TEQNES  r7, #15
        TEQNES  r8, #15
        TEQNES  r9, #15
        MOVEQ   r14, #Mistake_R15
        STR     r14, Mistake

        B       InstructionEnd

swp_type
        ; arrive here with cccc 0001 xxxx xxxx xxxx xxxx 1001 xxxx
        TestBit 23
 [ ARMv6
        BNE     LdrexStrex
 |
        BNE     Undefined
 ]

swp
        ; Swap register/memory
        ; arrive here with cccc 0001 0xxx xxxx xxxx xxxx 1001 xxxx
        ; format is        cccc 0001 0b00 nnnn dddd 0000 1001 mmmm
        ;
        ; SWP{cond}{B} Rd,Rm,[Rn]
        ;
        ; where cccc = condition
        ;          b = Byte/~Word
        ;       nnnn = Rn
        ;       dddd = Rd
        ;       mmmm = Rm

        TSTS    R4,#2_1111 :SHL: 8
        BNE     Undefined

        TST     R4,#2_11 :SHL: 20
        BNE     Undefined

        AddStr  aswp,,conds
        TestBit 22,"B"

        MOV     r9,r4,LSR #16
        AND     r9,r9,#2_1111           ; Rn

        MOV     R5,R4,LSR #12
        AND     r5,r5,#2_1111           ; Rd
        ; Rd=Rn -> unpredictable
        TEQS    r5,r9
        MOVEQ   r14,#Mistake_RdRn
        STREQ   r14,Mistake
        ; Rd/Rn=R15 -> unpredictable
        TEQS    r5,#15
        TEQNES  r9,#15
        MOVEQ   r14,#Mistake_R15
        STREQ   r14,Mistake
        BL      Tab_Dis_Register

        AND     R5,R4,#2_1111           ; Rm
        ; Rm=Rn -> unpredictable
        TEQS    r5,r9
        MOVEQ   r14,#Mistake_RmRn
        STREQ   r14,Mistake
SwpCommon1
        ; Rm=R15 -> unpredictable
        TEQS    r5,#15
        MOVEQ   r14,#Mistake_R15
        STREQ   r14,Mistake
        BL      Comma_Dis_Register
SwpCommon2
        AddStr  Open_B
        MOV     r5,r9                   ; Rn
        BL      Dis_Register
        AddChar "]"
        B       InstructionEnd

LoadStoreExtension
        ; Arrive here with cccc 000p xxxx xxxx xxxx xxxx 1oo1 xxxx
        ; (poo != 000)
        TSTS    r4, #2_11:SHL:5
        BEQ     swp_type

LdrStrH ; Load and Store Halfword/Doubleword or Load Signed Byte
        ; arrive here with cccc 000x xxxx xxxx xxxx xxxx 1nn1 xxxx
        ; (nn != 00)
        ; format is        cccc 000p uiwl nnnn dddd aaaa 1sh1 bbbb
        ;
        ; LDR{cond}<H|SH|SB|D> Rd,[Rn,<#offset|Rm>]{!}
        ;                      Rd,[Rn],<#offset|Rm>
        ; STR{cond}<H|D>       Rd,[Rn,<#offset|Rm>]{!}
        ;                      Rd,[Rn],<#offset|Rm>
        ; where cccc = condition
        ;          p = Pre-indexed/~Post-indexed
        ;          u = Up/~Down
        ;          i = Immediate/~Register offset
        ;          w = Writeback (must be zero if post-indexed)
        ;          l = Load/~Store
        ;       nnnn = Rn
        ;       dddd = Rd
        ;       aaaa = immediate offset high nibble (if i==1), else 0
        ;          s = Signed/~Unsigned halfword
        ;          h = Halfword/~Signed byte
        ;       bbbb = immediate offset low nibble (if i==1), else Rm

        ; cccc 000x x0xx xxxx xxxx nnnn 1xx1 xxx is undefined if any of
        ; nnnn are 1.
        TSTS    r4, #1:SHL:22           ; Immediate/~Register offset
        BNE     %F5
        TSTS    r4, #&00000F00
        BNE     Undefined

5       AND     r5, r4, #1:SHL:24 :OR: 1:SHL:21
        TEQS    r5, #1:SHL:21           ; Check for post-indexed with W set (illegal)
        BEQ     Undefined

        TSTS    r4, #1:SHL:20           ; Load/~Store
        BNE     %F20
        AND     r5, r4, #&000000F0
        TEQS    r5, #&000000B0
        BEQ     %F20

        ; STRSB or STRSH - actually LDRD+STRD
        TestStr 5,Str,Ldr,conds
        AddChar "D"
        TestBit 12                      ; Must be even-numbered register
        BNE     Undefined

        [ WarnARMv5E
        MOV     r14, #Mistake_ARMv5E
        STR     r14, Mistake
        ]

        AND     r10, r4, #15:SHL:12     ; r10 = Rd << 12

        ; Check for Rd/Rd+1=Rn with writeback
        AND     r14, r4, #2_10010:SHL:20
        TEQS    r14, #2_10000:SHL:20
        BEQ     %F15

        AND     r14, r4, #14:SHL:16
        TEQ     r14, r10, LSL #4
        MOVEQ   r14, #Mistake_RdRn
        STREQ   r14, Mistake

15      ; Check for LDRD with Rd/Rd+1=Rm
        TSTS    r4, #1:SHL:5            ; H clear => LDRD
        TSTEQS  r4, #1:SHL:22           ; I clear => [Rd,Rm]
        ANDEQ   r14, r4, #14
        TEQEQS  r14, r10, LSR #12
        MOVEQ   r14, #Mistake_RdRm
        STREQ   r14, Mistake

        ; Check for LDRD/STRD of R14+PC
        TEQ     r10, #14:SHL:12
        MOVEQ   r14, #Mistake_R15
        STREQ   r14, Mistake

        B       %F22

20
        TestStr 20,Ldr,Str,conds
        TestBit 6,"S"
        TestBit 5,"H","B"

22      MOV     r5, r4, LSR #12
        BL      Tab_Dis_Register

        ; Check we're not storing/loading PC
        TEQS    r5, #15
        MOVEQ   r10, #Mistake_R15
        STREQ   r10, Mistake
        BEQ     %FT30

        ;
        ; Check for Rd=Rn with writeback
        ;
        AND     r10, r4, #2_10010:SHL:20        ; If pre-indexed and no writeback, then OK
        TEQS    r10, #2_10000:SHL:20
        BEQ     %FT30
        AND     r10, r4, #&F:SHL:16             ; If Rd <> Rn then OK
        TEQS    r5, r10, LSR #16
        BNE     %FT30
      [ {FALSE}
        TSTS    r4, #1:SHL:22                   ; If a register offset, then fail
        BEQ     %FT25
        TSTS    r4, #&F
        TSTEQS  r4, #&F00
        BEQ     %FT30                           ; If an immediate offset of 0, then OK
      ]

25      MOV     r10, #Mistake_RdRn
        STR     r10, Mistake

30      MOV     r5, r4, LSR #16
        AND     r5, r5, #&F
        TEQS    r5, #15
        BNE     not_ldrh_rel

        ;
        ; Check for PC-writeback
        ;
        AND     r10, r4, #2_10010:SHL:20
        TEQS    r10, #2_10000:SHL:20
        MOVNE   r10, #Mistake_PCwriteback
        STRNE   r10, Mistake

        ANDEQ   r10, r4, #2_10110:SHL:20        ; Check P,I and W bits
        TEQEQS  r10, #2_10100:SHL:20            ; Must be pre-indexed,immediate,no writeback
        BNE     not_ldrh_rel

        ; show resultant [LD|ST]R[H|SH|SB] Rd,[PC,#nn] address directly

        AddChar ","
        AND     r8,  r4, #&0000000F
        AND     r10, r4, #&00000F00
        ORR     r8, r8, r10, LSR #4
        TSTS    r4, #1:SHL:23           ; Up/~Down bit
        SUBEQ   r8, r9, r8
        ADDNE   r8, r9, r8
        ADD     r8, r8, #8
        B       BranchLdrStrCommon


not_ldrh_rel

        AddStr  Open_B                  ; ",["

        BL      Dis_Register

        TSTS    r4, #1:SHL:24           ; Pre/~Post bit
        ADRL    r10, Close_B
        ADDNE   r10, r10, #1            ; just ',' else '],'
        BL      SaveString
        TSTS    r4, #1:SHL:22           ; Immediate/~Register bit
        BEQ     ldrstrh_reg

        AddChar "#"
        TestBit 23,,"-"                 ; Up/~Down bit

        AND     r8,  r4, #&0000000F
        AND     r10, r4, #&00000F00
        ORR     r8, r8, r10, LSR #4
        BL      StoreDecimal
        B       %F50

ldrstrh_reg
        TestBit 23,,"-"                 ; Up/~Down bit
        AND     r5, r4, #&F
        BL      Dis_Register

        ; Check for Rm=Rn in register post-indexed case
        AND     r6, r4, #&F :SHL: 16
        TEQS    r5, r6, LSR #16
        TSTEQS  r4, #1:SHL:24
        MOVEQ   r6, #Mistake_RmRn
        STREQ   r6, Mistake

50      TSTS    r4, #1:SHL:24           ; Pre/~Post bit
        BEQ     InstructionEnd

        AddChar "]"

        TestBit 21,"!"                  ; Writeback bit
        B       InstructionEnd


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data processing opcodes

        ; Arrive here with cccc 00xx xxxx xxxx xxxx xxxx xxxx xxxx
        ; Format is        cccc 000o ooos nnnn dddd rrrr rtt0 mmmm
        ;                  cccc 000o ooos nnnn dddd ssss 0tt1 mmmm
        ;                  cccc 001o ooos nnnn dddd rrrr iiii iiii
        ;
        ; <data op>{cond}{S} Rd,Rn,op2    (0-7,12,14: AND,EOR,SUB,RSB,ADD,ADC,SBC,RSC,ORR,BIC)
        ; <data op>{cond}{S} Rd,op2       (13,15: MOV,MVN)
        ; <compare>{cond}{P} Rn,op2       (8-11: TST,TEQ,CMP,CMN)
        ;
        ;        op2 = #imm
        ;              Rm{,<LSL|LSR|ASR|ROR> <#imm|Rs>}
        ;              Rm,RRX
        ;
        ; where cccc = condition
        ;       oooo = operation
        ;          s = Set flags (required for comparisons)
        ;       nnnn = Rn (0 if not used, 15 signals P flag on compares)
        ;       dddd = Rd (0 if not used)
        ;      rrrrr = rotate/shift amount
        ;         tt = shift type (LSL,LSR,ASR,ROR) (RRX encoded by ROR #0)
        ;   iiiiiiii = immediate
        ;       mmmm = Rm
DataProcessing ROUT

        LDR     r3, =&02000090          ; Data processing op with bit 4 set
        AND     r3, r4, r3              ; -> shift by Rs, but bit 7 set, so
        TEQS    r3, #&90                ; is not defined
        BEQ     UndefinedDataProcessing ; MUL/MLA in here too (and SWP from 1.23)
                                        ; (and MULL/MLAL from 1.44)
                                        ; (and LDRH etc from 1.48)

        MOV     r6, r4, LSR #21         ; r6 := dp opcode
        AND     r6, r6, #2_1111
;Version 1.25 bug fix - only apply ADR to immediate operands
        ;If ADD or SUB, and Rn=15 then call it ADR instead
        TEQS    R6,#2
        TEQNES  R6,#4
        BNE     notADR ;not ADD/SUB

        MOV     R5,R4,LSR #16
        AND     R5,R5,#15
        TEQS    R5,#15
        BNE     notADR ;Rn not R15

        TST     r4, #1 :SHL: 20
        BNE     notADR ;S bit set - not ADR

        TestBit 25                      ; I bit
        BNE     isADR
notADR
        AND     r5, r4, #2_11001 :SHL: 20
        TEQS    r5, #2_10000 :SHL: 20           ; Check for opcodes 8-11 with S clear
        BEQ     ControlExtension

        ADR     r10, OpcTAB
        ADD     r10, r10, r6, LSL #2

        BL      SaveStringConditions

        MOV     r5, r4, LSR #12         ; Rd
        CMP     r6, #&08                ; TEQ,TST,CMP,CMN
        RSBHSS  r14, r6, #&0B
        BLO     %FT10

        ANDS    r5, r5, #2_1111         ; If Rd = pc then xxxP
        BEQ     %FT05
        TEQ     r5, #15
        BNE     Undefined               ; Otherwise check Rd=R0
        AddChar "P"
        MOV     R10, #Potential_Banked_Next
        STR     R10, Mistake            ; potential bank access error

5       BL      Tab
        B       %FT20

10
        TestBit 20,"S"                  ; Update flags bit

        BL      Tab_Dis_Register

        BL      AddComma

        TEQ     r6, #13                 ; MOV
        TEQNE   r6, #15                 ; MVN
        BNE     %FT20
        TSTS    r4, #2_1111 :SHL: 16    ; Check that Rn=R0
        BNE     Undefined
        B       Operand_2

20      MOV     r5, r4, LSR #16         ; Rn
        BL      Dis_Register
        BL      AddComma

Operand_2
        TestBit 25                      ; Immediate bit
        BNE     Immediate

        MOV     r5, r4                  ; Rm
        BL      Dis_Register

        BL      ShiftField
        B       InstructionEnd


Immediate
        AddChar "#"

        MOV     r2, r4, LSR #7
        AND     r2, r2, #2_11110        ; Yes, I really do mean 30, see the book
        AND     r8, r4, #2_11111111
        MOV     r8, r8, ROR r2

        MOVS    r14, r8, LSR #8         ; Does value fit in LSB
        BNE     %FT10
        TEQ     r2, #0                  ; but have a non-zero shift ?
        BNE     WackyShift
10

;Testing for weird shifts, ie representable numbers as <data><no shift> but are in fact <data><shift>
;removed

        CMPS    r8, #10
        BLO     Rem_Number              ; If really simple, just display number
                                        ; ie. 0..9 unambiguous

        MOV     r2, #8-4                ; default is byte
        CMPS    r8, #&100
        MOVHS   r2, #16-4               ; then halfword
        CMPS    r8, #&10000
        MOVHS   r2, #32-4               ; then fullword
        BL      StoreHex

        CMPS    r8, #8192               ; If really big, don't comment on it
        BHS     InstructionEnd          ; May have VSet from CMP!

        BL      Tab                     ; Will also insert '; '

        AddChar "="


Rem_Character
        CMPS    r8, #delete
        CMPNES  r8, #space-1
        BLS     Rem_Number

        CMPS    r8, #&100
        BHS     Rem_Number

        MOV     r10, #quote
        STRB    r10, [r0], #1
        STRB    r8,  [r0], #1
        STRB    r10, [r0], #1
        B       InstructionEnd


Rem_Number
        BL      StoreDecimal
        B       InstructionEnd

;ADR pseudo-op - display address being created instead of the ADD/SUB

isADR
        AddStr  AdrTAB,,conds
        MOV     R5, R4, LSR #12
        BL      Tab_Dis_Register
        BL      AddComma
        MOV     R2, R4, LSR #7
        AND     R2, R2, #2_11110
        AND     R8, R4, #2_11111111
        MOV     r8, r8, ROR r2
        TEQS    R6, #2
        SUBEQ   R8, R9, R8
        ADDNE   R8, R8, R9
        ADD     R8, R8, #8
        MOV     R2, #32-4
        BL      StoreHex
        B       InstructionEnd

CPSR_or_SPSR
        TestBit 22
        ADREQ   R10,cpsr_tab
        ADRNE   R10,spsr_tab
        B       SaveString

ControlExtension
        ; arrive here with cccc 00i1 0xx0 xxxx xxxx xxxx rxxs xxxx
        ; (irs != 011)
        ;
        ; This was simple when it was just MRS and MSR, but
        ; ARMv5 and 5E have made it much harder. The approach we
        ; take is to first split between register and immediate,
        ; then split the register form up by bits 4:7.

        [ ARMv6
        MOV     r5, r4, LSR #28
        TEQ     r5, #15
        BEQ     ControlExtension_uncond
        ]

        TestBit 25
        BNE     ControlExtension_immediate

        ANDS    r5, r4, #2_1111 :SHL: 4         ; 0 = MRS/MSR
        BEQ     MRS_MSR_reg

        CMP     r5, #2_0011 :SHL: 4             ; 1,2,3 = CLZ/BX
        BLS     CLZ_BX_type

        TEQ     r5, #2_0101 :SHL: 4             ; 5 = QADD etc
        BEQ     SaturatingArithmetic

        TEQ     r5, #2_0111 :SHL: 4             ; 7 = BKPT
        BEQ     is_BKPT

        CMP     r5, #2_1000 :SHL: 4             ; 2,4,6 undefined
        BLO     Undefined

        TST     r5, #2_0001 :SHL: 4             ; 8,10,12,14 = SMUL etc
        BEQ     Mul16

        B       Undefined                       ; 9,11,13,15 undefined

ControlExtension_immediate
        ; arrive here with cccc 0011 0xx0 xxxx xxxx xxxx xxxx xxxx
        LDR     r3, =1:SHL:21 + 2_1111:SHL:12
        AND     r5, r4, r3
        TEQ     r5, r3
        BEQ     is_MSR
        B       Undefined

MRS_MSR_reg
        ; arrive here with cccc 0001 0xx0 xxxx xxxx xxxx 0000 xxxx
        TestBit 21
        BNE     is_MSR

is_MRS  ; arrive here with cccc 0001 0x00 xxxx xxxx xxxx 0000 xxxx
        ;
        ; format is        cccc 0001 0r00 1111 dddd 0000 0000 0000
        ;
        ; MRS{cond} Rd, <CPSR|SPSR>
        ; where cccc = condition
        ;          r = 1 for SPSR, 0 for CPSR
        MOVS    r5, r4, LSL #20            ; bottom 12 bits should be 0
        BNE     Undefined
        AND     r14, r4, #2_1111 :SHL: 16  ; bits 16-19 should be 1
        TEQS    r14, #2_1111 :SHL: 16
        BNE     Undefined

        AddStr  MrsTAB,,conds
        MOV     r5, r4, LSR #12
        BL      Tab_Dis_Register           ; Rd
        BL      AddComma
        BL      CPSR_or_SPSR
        B       InstructionEnd

OpcTAB  DCB     "AND",0
        DCB     "EOR",0
SubTAB  DCB     "SUB",0
        DCB     "RSB",0
AddTAB  DCB     "ADD",0
        DCB     "ADC",0
        DCB     "SBC",0
        DCB     "RSC",0
        DCB     "TST",0
        DCB     "TEQ",0
        DCB     "CMP",0
        DCB     "CMN",0
        DCB     "ORR",0
        DCB     "MOV",0
        DCB     "BIC",0
        DCB     "MVN",0

cpsr_tab DCB    "CPSR",0
spsr_tab DCB    "SPSR",0
BxTAB   DCB     "BX", 0
BxjTAB  DCB     "BXJ",0
        ALIGN

BkptTAB DCB     "BKPT",0

        ALIGN

is_MSR  ; arrive here with cccc 0001 0x10 xxxx xxxx xxxx 0000 xxxx
        ;               or cccc 0011 0x10 xxxx 1111 xxxx xxxx xxxx
        ;
        ; format is        cccc 0001 0r10 fsxc 1111 0000 0000 mmmm
        ;        or        cccc 0011 0r10 fsxc 1111 rrrr iiii iiii
        ; MSR{cond} <CPSR|SPSR>_<fields>, Rm
        ; MSR{cond} <CPSR|SPSR>_<fields>, #imm
        ;
        ; where cccc = condition
        ;          r = 1 for SPSR, 0 for CPSR
        ;       fsxc = field mask bits
        ;       rrrr = rotate amount (/2)
        ;       iiii = immediate
        ;       mmmm = Rm
        TestBit 25                    ; if register, bits 4-11 must be 0
        BNE     %FT01

        TST     r4, #2_11111111 :SHL: 4
        BNE     Undefined

01      AND     r10, r4, #2_1111 :SHL: 12
        TEQ     r10, #2_1111 :SHL: 12
        BNE     Undefined

05      ADR     r10, MsrTAB
        BL      SaveStringConditions
        BL      Tab
        BL      CPSR_or_SPSR
        AddChar "_"
        TestBit 16,"c"
        TestBit 17,"x"
        TestBit 18,"s"
        TestBit 19,"f"
        BL      AddComma
        B       Operand_2

CLZ_BX_type
        ; arrive here with cccc 0001 0xx0 xxxx xxxx xxxx 00xx xxxx
        TestBit 22
        BNE     is_CLZ

is_BX   ; arrive here with cccc 0001 00x0 xxxx xxxx xxxx 00la xxxx  (la != 00)
        ;
        ; format is        cccc 0001 0010 1111 1111 1111 00l1 mmmm
        ;
        ; B{L}X{cond} Rm
        ;
        ; where cccc = condition
        ;          l = Link
        ;       mmmm = Rm
        LDR     r3, =&002FFF00
        AND     r5, r4, r3
        TEQ     r5, r3
        BNE     Undefined

        TestBit 4
        BEQ     is_BXJ

        TestStr 5,BlxTAB,BxTAB,conds
        AND     R5,R4,#2_1111
        BL      Tab_Dis_Register

        [ WarnARMv5
        TestBit 5
        MOVNE   r10, #Mistake_ARMv5
        STRNE   r10, Mistake
        ]

        B       InstructionEnd

is_BXJ  ; arrive here with cccc 0001 0010 1111 1111 1111 0010 xxxx
        ; format is        cccc 0001 0010 1111 1111 1111 0010 mmmm
        ;
        ; BXJ{cond}   Rm
        ;
        ; where cccc = condition
        ;       mmmm = Rm
        AddStr  BxjTAB,,conds
        AND     R5,R4,#2_1111
        BL      Tab_Dis_Register
        B       InstructionEnd

BLX_offset
        ; arrive here with 1111 101x xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        1111 101h oooo oooo oooo oooo oooo oooo
        ;
        ; BLX address
        ;
        ; where    h = bit 1 of offset
        ;          o = signed offset (bits 25-2)
        [ WarnARMv5
        MOV     r10, #Mistake_ARMv5
        STR     r10, Mistake
        ]

        ADR     r10, BlxTAB
        BL      SaveString
        BL      Tab

        MOVS    r4, r4, ASL #8          ; shift offset up to top (bit 1 into C)
        ADDCS   r4, r4, #1 :SHL: 7      ; put bit 1 underneath
        B       BranchCommon


is_CLZ  ; arrive here with cccc 0001 01x0 xxxx xxxx xxxx 00xx xxxx
        ;
        ; format is        cccc 0001 0110 1111 dddd 1111 0001 mmmm
        ;
        ; CLZ{cond} Rd, Rm
        ;
        ; where cccc = condition
        ;       dddd = Rd
        ;       mmmm = Rm
        LDR     r3, =&002F0F10
        TestBit 5
        BNE     Undefined
        AND     r5, r4, r3
        TEQ     r5, r3
        BNE     Undefined

        [ WarnARMv5
        MOV     r10, #Mistake_ARMv5
        STR     r10, Mistake
        ]

        ADR     r10, ClzTAB
        BL      SaveStringConditions
        MOV     r5, r4, LSR #12
        BL      Tab_Dis_Register
        MOV     r5, r4
        BL      Comma_Dis_Register
        B       InstructionEnd

is_BKPT ; arrive here with cccc 0001 0xx0 xxxx xxxx xxxx 0111 xxxx
        ;
        ; format is        1110 0001 0010 nnnn nnnn nnnn 0111 nnnn
        ;
        ; BKPT <number>     (note conditional not permitted)
        ;
        ; where nnnn = number
        AND     r5, r4, #2_11:SHL:21
        TEQ     r5, #2_01:SHL:21
        BNE     Undefined
        AND     r5, r4, #2_1111:SHL:28
        TEQ     r5, #2_1110:SHL:28
        BNE     Undefined

        [ WarnARMv5
        MOV     r10, #Mistake_ARMv5
        STR     r10, Mistake
        ]

        ADR     r10, BkptTAB
        BL      SaveString
        BL      Tab

        MOV     r8, r4, LSR #8
        MOV     r8, r8, LSL #20
        AND     r5, r4, #2_1111
        ORR     r8, r5, r8, LSR #16
        MOV     r2, #16-4
        BL      StoreHex
        B       InstructionEnd

SaturatingArithmetic
        ; arrive here with cccc 0001 0xx0 xxxx xxxx xxxx 0101 xxxx
        ; format is        cccc 0001 0ds0 nnnn dddd 0000 0101 mmmm
        ;
        ; Q{D}<ADD|SUB>{cond} Rd, Rm, Rn
        ;
        ; where cccc = condition
        ;          d = Double
        ;          s = Subtract/~Add
        ;       nnnn = Rn
        ;       dddd = Rd
        ;       mmmm = Rm

        TST     r4, #2_1111:SHL:8
        BNE     Undefined

        [ WarnARMv5E
        MOV     r14, #Mistake_ARMv5E
        STR     r14, Mistake
        ]

        AND     r14, r4, #15:SHL:16
        TEQ     r14, #15:SHL:16
        ANDNE   r14, r4, #15:SHL:12
        TEQNE   r14, #15:SHL:12
        ANDNE   r14, r4, #15
        TEQNE   r14, #15
        MOVEQ   r14, #Mistake_R15
        STREQ   r14, Mistake

        AddChar "Q"
        TestBit 22,"D"
        TestStr 21,SubTAB,AddTAB,conds
        MOV     r5, r4, LSR #12
        BL      Tab_Dis_Register
        MOV     r5, r4
        BL      Comma_Dis_Register
        MOV     r5, r4, LSR #16
        BL      Comma_Dis_Register
        B       InstructionEnd

Mul16   ROUT
        ; arrive here with cccc 0001 0xx0 xxxx xxxx xxxx 1xx0 xxxx
        ; format is        cccc 0001 0oo0 dddd nnnn ssss 1yx0 mmmm
        ;
        ; SMLA<B|T><B|T>{cond}  Rd, Rm, Rs, Rn       op = 0
        ; SMLAW<B|T>{cond}      Rd, Rm, Rs, Rn       op = 1, x = 0
        ; SMULW<B|T>{cond}      Rd, Rm, Rs           op = 1, x = 1
        ; SMLAL<B|T><B|T>{cond} RdLo, RdHi, Rm, Rs   op = 2
        ; SMUL<B|T><B|T>{cond}  Rd, Rm, Rs           op = 3
        ;
        ; where cccc = condition
        ;         oo = operation
        ;       dddd = Rd or RdHi
        ;       nnnn = Rn or RdLo
        ;       ssss = Rs
        ;          y = Top/~Bottom of Rs
        ;          x = Top/~Bottom of Rm
        ;       mmmm = Rm

        AND     r7, r4, #2_11:SHL:21    ; r7 = oo (<< 21)
        TestBit 5
        ORRNE   r6, r7, #1:SHL:20       ; r6 = oox (<< 20)
        MOVEQ   r6, r7
        ADR     r10, Mul16TAB
        ADD     r10, r10, r6, LSR #17
        SUB     r10, r10, r6, LSR #20   ; r10 = Mul16TAB + 7 * oox
        BL      SaveString
        TestBit 6,"T","B"
        BL      Conditions

        TEQ     r6, #2_011:SHL:20
        TEQNE   r7, #2_11 :SHL:21
        BNE     %FT10
        TST     r4, #2_1111:SHL:12      ; Check Rn field is 0 for SMUL
        BNE     Undefined
10
        [ WarnARMv5E
        MOV     r14, #Mistake_ARMv5E
        STR     r14, Mistake
        ]

        BL      TabOrPushOver

        TEQ     r7, #2_10 :SHL:21       ; EQ if SMLAL
        BNE     %FT15

        MOV     r5, r4, LSR #12
        AND     r8, r5, #15
        BL      Dis_Register            ; RdLo
        MOV     r5, r4, LSR #16
        AND     r9, r5, #15
        BL      Comma_Dis_Register      ; RdHi

        TEQ     r8, r9
        MOVEQ   r14, #Mistake_RdLoRdHi
        STREQ   r14, Mistake
        B       %FT17

15      MOV     r5, r4, LSR #16
        BL      Dis_Register            ; Rd

17      MOV     r5, r4
        BL      Comma_Dis_Register      ; Rm
        MOV     r5, r4, LSR #8
        BL      Comma_Dis_Register      ; Rs

        CMP     r6, #2_010:SHL:20
        MOVLS   r5, r4, LSR #12
        BLLS    Comma_Dis_Register      ; Rn

        AND     r14, r4, #15:SHL:16
        TEQ     r14, #15:SHL:16
        ANDNE   r14, r4, #15:SHL:12
        TEQNE   r14, #15:SHL:12
        ANDNE   r14, r4, #15:SHL:8
        TEQNE   r14, #15:SHL:8
        ANDNE   r14, r4, #15
        TEQNE   r14, #15
        MOVEQ   r14, #Mistake_R15
        STREQ   r14, Mistake

        B       InstructionEnd


AdrTAB  DCB     "ADR",0
MrsTAB  DCB     "MRS",0
MsrTAB  DCB     "MSR",0
BlxTAB  DCB     "BLX",0
ClzTAB  DCB     "CLZ",0
Mul16TAB
        DCB     "SMLAB",0,0
        DCB     "SMLAT",0,0
        DCB     "SMLAW",0,0
        DCB     "SMULW",0,0
        DCB     "SMLALB",0
        DCB     "SMLALT",0
        DCB     "SMULB",0,0
        DCB     "SMULT",0
        ALIGN

Ldc     DCB     "LDC", 0
Stc     DCB     "STC", 0
Cdp     DCB     "CDP", 0
Mcr     DCB     "MCR", 0
Mrc     DCB     "MRC", 0
Cp      DCB     "CP", 0
Mcrr    DCB     "MCRR", 0
Mrrc    DCB     "MRRC", 0

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Coprocessor
        ; Coprocessor operations
        ; arrive here with cccc 11nn xxxx xxxx xxxx xxxx xxxx xxxx
        ; with nn <> 11

        MOV     r2, r4, LSR #28         ; No currently known coprocessors use "2" opcodes
        TEQ     r2, #15
        BEQ     Coprocessor_NotFP

        AND     r2, r4, #2_1111 :SHL: 8 ; r2 := CP# << 8

        TEQS    r2, #1 :SHL: 8
        BEQ     Floating_Point          ; [Floating Point coprocessor]

        TEQS    r2, #2 :SHL: 8
        BEQ     New_FPA                 ;new FPA

        TEQS    r2, #10 :SHL: 8
        TEQNES  r2, #11 :SHL: 8
        BEQ     VFP

 [ CirrusDSP
        CMPS    r2, #4 :SHL: 8
        BLO     Coprocessor_NotFP
        CMPS    r2, #6 :SHL: 8
        BLS     CirrusDSPInstruction
 ]

Coprocessor_NotFP

; Currently unknown coprocessor

        TEQS    r3, #&0E
        BEQ     Co_Operations

Co_Transfer

        ; arrive here with cccc 110x xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        cccc 110p unwl nnnn dddd #### iiii iiii
        ;
        ; <LDC|STC>{cond}{L} CP#,Cd,[Rn,#imm]{!}
        ;                    CP#,Cd,[Rn],#imm
        ;                    CP#,Cd,[Rn],{info}
        ; <LDC|STC>2{L}      ...
        ;
        ; where cccc = condition
        ;          p = Pre-indexed/~Post-indexed
        ;          u = Up/~Down
        ;          n = Transfer length
        ;          w = Writeback
        ;          l = Load/~Store
        ;       nnnn = Rn
        ;       dddd = Cd
        ;       #### = CP#
        ;       iiii = immediate offset (in words), or info (puw = 010)

; Coprocessor Data Transfer (CPDT)

        TST     r4, #2_1101 :SHL: 21
        BEQ     CoprocessorExtension     ; Post-indexed, down, no writeback

        TestStr 20,Ldc,Stc,conds,2      ; Load/~Store bit

        TestBit 22,"L"                  ; Length bit

        BL      Tab_CPN                 ; CP#

        MOV     r5, r4, LSR #12         ; CRd
        BL      Dis_C_Register

CPDT_Common                             ; FP entry point from below

        BIC     r3, r3, #2_1000         ; Make like a normal data transfer
                                        ; 0C,0D -> 04,05 (STC,LDC -> STR,LDR)
        BIC     r4, r4, #&00000F00      ; Clear CP# field
        B       DataTransfer_Common

CoprocessorExtension
        ; arrive here with cccc 1100 0x0x xxxx xxxx xxxx xxxx xxxx
        TestBit 22
        BEQ     Undefined

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Coprocessor Double Register Transfer (CPRRT)

CPRRT
        ; arrive here with cccc 1100 010x xxxx xxxx xxxx xxxx xxxx
        ; format is        cccc 1100 010l nnnn dddd #### oooo mmmm
        ;
        ; <MCRR|MRRC>{cond} CP#,op,Rd,Rn,Cm
        ;
        ; where cccc = cond
        ;          l = Load/~Store (ie load from coprocessor)
        ;       nnnn = Rn
        ;       dddd = Rd
        ;       #### = CP#
        ;       oooo = operation
        ;       mmmm = Cm

        [ WarnARMv5E
        MOV     r14, #Mistake_ARMv5E
        STR     r14, Mistake
        ]

        TestStr 20,Mrrc,Mcrr,conds
        BL      Tab_CPN
        MOV     r8, r4, LSR #4
        AND     r8, r8, #2_1111
        BL      StoreDecimal
        BL      AddComma
        BL      Dis_RdRn
        BL      AddComma
        MOV     r5, r4
        BL      Dis_C_Register
        B       InstructionEnd

; Disassemble Rd and Rn for CPRRT instructions
Dis_RdRn Entry
50      MOV     r5, r4, LSR #12
        AND     r6, r5, #2_1111
        BL      Dis_Register
        MOV     r5, r4, LSR #16
        AND     r7, r5, #2_1111
        BL      Comma_Dis_Register
        TestBit 20
        BEQ     %FT10
        TEQ     r6, r7
        MOVEQ   r14, #Mistake_RdRn
        STREQ   r14, Mistake
10      TEQ     r6, #15
        TEQNE   r7, #15
        MOVEQ   r14, #Mistake_R15
        STREQ   r14, Mistake
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Co_Operations

        ; arrive here with cccc 1110 xxxx xxxx xxxx xxxx xxxx xxxx

        TestBit 4               ; Transfer/~Operation bit
        BNE     Co_Transfers

; Coprocessor Data Operation (CPDO)
        ; arrive here with cccc 1110 xxxx xxxx xxxx xxxx xxx0 xxxx
        ; format is        cccc 1110 oooo nnnn dddd #### iii0 mmmm
        ;
        ; CDP{cond} CP#,op,Cd,Cn,Cm{,info}
        ; CDP2      CP#,op,Cd,Cn,Cm{,info}
        ;
        ; where cccc = cond
        ;       oooo = operation
        ;       nnnn = Cn
        ;       dddd = Cd
        ;       #### = CP#
        ;        iii = info
        ;       mmmm = Cm

        MOV     R10, #Potential_SWICDP_Next ;deferred warning in case SWI next
        STR     R10, Mistake

        AddStr  Cdp,,conds,2

        BL      Tab_CPN                 ; CP#

        MOV     r8, r4, LSR #20         ; CPOpc
        AND     r8, r8, #2_1111         ; All of nibble for CPDO
        BL      StoreDecimal_Comma

        MOV     r5, r4, LSR #12         ; CRd
        BL      Dis_C_Register_Comma

CPRT_CPDO_Common

        MOV     r5, r4, LSR #16         ; CRn
        BL      Dis_C_Register_Comma

        MOV     r5, r4                  ; CRm
        BL      Dis_C_Register

        MOV     r8, r4, LSR #5          ; CP
        ANDS    r8, r8, #2_111          ; non-zero ?
        BLNE    AddComma
        BLNE    StoreDecimal

        ;if MRC/MCR check for system control coprocessor and comment accordingly

        TestBit 4                       ; Transfer/~Operation bit
        BEQ     InstructionEnd

        AND     R5,R4,#&F00
        TEQS    R5,#&F00
        BNE     InstructionEnd          ; Not CP15

        AND     R5,R4,#&F0000
        TEQS    R5,#&40000
        BEQ     InstructionEnd
        CMPS    R5,#&80000
        BHI     InstructionEnd

        BL      Tab

        ADR     R10,msgtable
        ADD     R10,R10,R5,LSR #14
        BL      lookup_r10
        B       SaveStringEnd


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Coprocessor Register Transfer (CPRT)

Co_Transfers
        ; arrive here with cccc 1110 xxxx xxxx xxxx xxxx xxx1 xxxx
        ; format is        cccc 1110 oool nnnn dddd #### iii1 mmmm
        ;
        ; <MCR|MRC>{cond} CP#,op,Rd,Cn,Cm{,info}
        ; <MCR|MRC>2      CP#,op,Rd,Cn,Cm{,info}
        ;
        ; where cccc = cond
        ;        ooo = operation
        ;          l = Load/~Store (ie load from coprocessor)
        ;       nnnn = Cn
        ;       dddd = Rd
        ;       #### = CP#
        ;        iii = info
        ;       mmmm = Cm

        TestStr 20,Mrc,Mcr,conds,2      ; Load/~Store bit

        BL      Tab_CPN                 ; CP#

        MOV     r8, r4, LSR #21         ; CPOpc
        AND     r8, r8, #2_111          ; Only three bits for CPRT
        BL      StoreDecimal_Comma

        MOV     r5, r4, LSR #12         ; Rd (ARM register)
        BL      Dis_Register
        BL      AddComma

        B       CPRT_CPDO_Common

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Tab_CPN Entry

        BL      Tab

        AddStr  Cp

        MOV     r8, r4, LSR #8
        AND     r8, r8, #2_1111
        BL      StoreDecimal_Comma      ; CP#
        EXIT

        LTORG

msgtable
msg0    = "M02",0       ; CP15,C0 : ARMv4 ID
msg1    = "M03",0       ; CP15,C1 : ARMv4 Control
msg2    = "M04",0       ; CP15,C2 : ARMv4 Translation Table
msg3    = "M05",0       ; CP15,C3 : ARMv4 Domain Access Control
msg4    = "M08",0       ; CP15,C4 : ARMv4 - Bad register
msg5    = "M06",0       ; CP15,C5 : ARMv4 Fault Status
msg6    = "M07",0       ; CP15,C6 : ARMv4 Fault Address
msg7    = "M51",0       ; CP15,C7 : ARMv4 Cache Operations
msg8    = "M52",0       ; CP15,C8 : ARMv4 TLB Operations


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

WackyShift
        AND     r8, r4, #&FF            ; Get unrotated byte back
        MOV     r2, #8-4                ; Display unrotated byte,decimal rotate
        BL      StoreHex

        AddChar ","

        MOV     r8, r4, LSR #7          ; Extract shift part again
        AND     r8, r8, #30
        B       Rem_Number

ShiftField ROUT

        MOV     r2, r4, LSR #4
        ANDS    r2, r2, #&FF            ; LSL #0 -> no shift at all
        MOVEQ   pc, lr

        Entry

        TEQ     r2, #2_00000110         ; ROR #0 -> RRX
        BEQ     %FT80

        AND     r1, r2, #2_00000110     ; Each is 6 chars long
        ADR     r10, ShiftTypes
        ADD     r10, r10, r1, LSL #1
        ADD     r10, r10, r1
        BL      SaveString

        TST     r2, #2_00000001
        BNE     %FT50                   ; [, SHF Rs]

; Shift number

        AddChar "#"

        MOVS    r8, r2, LSR #3          ; LSR #0 -> LSR #32
        MOVEQ   r8, #32                 ; ASR #0 -> ASR #32
        BL      StoreDecimal
        EXIT

50 ; Shift register

        MOV     r5, r2, LSR #4          ; Rs

        AND     r5, r5, #2_1111
        TEQS    r5, #15
        MOVEQ   r14, #Mistake_R15shift
        STREQ   r14, Mistake

        BL      Dis_Register
        EXIT


80      ADR     r10, %FT90              ; RRX
        BL      SaveString
        EXIT

90
        DCB     ",RRX", 0

ShiftTypes
        DCB     ",LSL ", 0              ; 00x
        DCB     ",LSR ", 0              ; 01x
        DCB     ",ASR ", 0              ; 02x
        DCB     ",ROR ", 0              ; 03x

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r5 = fp register

Dis_F_Register EntryS "r2"

        LDRB    r10, DisReg_F
        AND     r5, r5, #2_111          ; Only 8 FP registers
;       MOV     r10, #"F"
        B       %FT20

; .............................................................................

Dis_C_Register ALTENTRY

        LDRB    r10, DisReg_C
;        MOV     r10, #"C"
;        B       %FT20

; .............................................................................
; In    r5 = register number
;       r10 = first character

20      STRB    r10, [r0], #1
        AND     r5, r5, #2_1111
        ADD     r2, r5, #"0"
        CMPS    r5, #10
        AddChar "1",HS
        SUBHS   r2, r2, #10
        STRB    r2, [r0], #1
        EXITS

; .............................................................................

Comma_Dis_Register ALTENTRY

        BL      AddComma
        B       %FT50

; .............................................................................

Tab_Dis_Register ALTENTRY

        BL      Tab
        B       %FT50

; .............................................................................

; In    r5 = register number (in bottom 4 bits, rest can be garbage)
; Out   r5 = register number (correctly masked)
;       r2, r10 corrupted

Dis_Register ALTENTRY

50      AND     R5, R5, #2_1111
;        TEQ     r5, #15
;        BEQ     Dis_pc

        CMP      R5,#8
        BLHS     checkreg

        ADD     R14, R12, #:INDEX: DisRegLabels
        LDR     R14, [R14, R5, LSL #2]
        LDR     R14, [R14]

;       MOV     R14, #"R"
;       ORR     R14, R14, #"1" :SHL: 8
;       ORR     R14, R14, #"4" :SHL: 16

        STRB    R14, [R0], #1
        MOV     R14, R14, LSR #8
        STRB    R14, [R0], #1
        MOVS    R14, R14, LSR #8
        STRNEB  R14, [R0], #1
        EXITS

; .............................................................................

;Dis_pc
;       AddStr  pc_Reg
;        EXITS
;
;
;pc_Reg  DCB     "PC", 0
;        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r10 -> string, 0 to copy into buffer
;       r0 -> current buffer position

; Out   r0 ++, r10++

SaveString EntryS

10      LDRB    r14, [r10], #1
        CMPS    r14, #32
        STRHSB  r14, [r0], #1
        BHS     %BT10
        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r4 = instruction

; Out   r0++ with condition codes appended

Conditions Entry "r1, r10"

10      MOV     r1, r4, LSR #28
        CMPS    r1, #14
        EXIT    EQ                      ; 14 = AL (no code printed)
        ADRLO   r10, CondSym            ; 15 was NV, now undefined
        ADDLO   r1, r10, r1, LSL #1
        LDRLOB  r10, [r1], #1
        STRLOB  r10, [r0], #1
        LDRLOB  r10, [r1], #1
        STRLOB  r10, [r0], #1
        EXIT    LO
        PullEnv
        B       Undefined


CondSym DCB     "EQ"                    ; 0
        DCB     "NE"                    ; 1
        DCB     "CS"                    ; 2
        DCB     "CC"                    ; 3
        DCB     "MI"                    ; 4
        DCB     "PL"                    ; 5
        DCB     "VS"                    ; 6
        DCB     "VC"                    ; 7

        DCB     "HI"                    ; 8
        DCB     "LS"                    ; 9
        DCB     "GE"                    ; 10
        DCB     "LT"                    ; 11
        DCB     "GT"                    ; 12
        DCB     "LE"                    ; 13

        ALIGN

; .............................................................................

SaveStringConditions ALTENTRY

        BL      SaveString
        B       %BT10

; .............................................................................

SaveStringConditions2 ALTENTRY

        BL      SaveString
        MOV     r14, r4, LSR #28
        TEQ     r14, #15
        BNE     %BT10
        [ WarnARMv5
        LDR     r10, Mistake
        CMP     r10, #0
        MOVLE   r10, #Mistake_ARMv5
        STRLE   r10, Mistake
        ]
        AddChar "2"
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Pad with spaces to operand field or comment field

Tab Entry

10      ADR     r1, StringBuffer
        SUB     r1, r0, r1
15      MOV     r14, #space
        STRB    r14, [r0], #1
        TEQS    r1, #7
        EXIT    EQ
        CMPS    r1, #25 ;new exit position for longer comments
        BLO     %BT10

        ADR     r10, Rem
        BL      SaveString
        EXIT

TabOrPushOver
        ALTENTRY
        ADR     r1, StringBuffer
        SUB     r1, r0, r1
        CMPS    r1, #8
        BLO     %BT15
        AddChar " "
        EXIT




Rem     DCB     " ; ", 0
        ALIGN

TestMistakes
        Entry   "r5"
        LDR     R5,Mistake
        CMPS    R5,#1
        BLT     exitM

        BL      Tab
        MOV     R10,#0
        STR     R10,Mistake
        ADR     R10,Silly
        SUB     R5,R5,#1
        ADD     R10,R10,R5,LSL #2
;        LDR     R5,[R5]
;        ADD     R10,R10,R5
        BL      lookup_r10
        BL      SaveString
exitM
        EXIT

Silly
        =       "M10",0         ; ! and ^
        =       "M11",0         ; Not R8-R14
        =       "M12",0         ; SWI after CDP
        =       "M13",0         ; Rd=Rm or Rd=R15
        =       "M53",0         ; Shift by R15
        =       "M54",0         ; Not R15
        =       "M55",0         ; PC writeback
        =       "M56",0         ; Byte load/store of PC
        =       "M57",0         ; May store PC+8 or PC+12
        =       "M58",0         ; Unpredictable
        =       "M59",0         ; Rd=Rn
        =       "M60",0         ; Rm=Rn
        =       "M61",0         ; RdLo=RdHi
        =       "M62",0         ; RdLo=Rm
        =       "M63",0         ; RdHi=Rm
        =       "M64",0         ; Rn in list
        =       "M66",0         ; Rd=Rm
        =       "M67",0         ; Only 1 reg on SA-110 rev 2
        =       "M68",0         ; ARMv5 or later
        =       "M69",0         ; ARMv5E or later
        =       "M70",0         ; ARMv6 or later

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> buffer
;       r2 = bit position to start at
;       r8 = value to store in hex

; Out   r0 ++

StoreHex Entry "r2"

        AddChar "&"

10      MOV     r14, r8, LSR r2
        AND     r14, r14, #15
        CMPS    r14, #9
        ORRLS   r14, r14, #"0"
        ADDHI   r14, r14, #"A"-10
        STRB    r14, [r0], #1
        SUBS    r2, r2, #4
        BPL     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> current buffer position
;       r8 = value to store in decimal

; Out   r0++

StoreDecimal EntryS "r1-r2, r4"

        SUB     sp, sp, #16
        MOV     r4, r0

        MOV     r0, r8
        MOV     r1, sp
        MOV     r2, #16                 ; Can't get an error with this much
        SWI     XOS_BinaryToDecimal     ; r2 := length of number

        MOV     r0, r4
10      SUBS    r2, r2, #1
        LDRPLB  r14, [r1], #1
        STRPLB  r14, [r0], #1
        BNE     %BT10

        ADD     sp, sp, #16
        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

StoreDecimal_Comma Entry

        BL      StoreDecimal
        B       %FT50

;..............................................................................
; In    r0 -> output buffer

; Out   comma appended, r0++, flags preserved

AddComma ALTENTRY

50
        AddChar ","
        EXIT

; .............................................................................

Dis_C_Register_Comma ALTENTRY

        BL      Dis_C_Register
        B       %BT50

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MemoryI_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGMMI", 0
        ALIGN


MemoryI_Code Entry "r6-r11"

        MOV     R6,#"T"
        BL      MemoryCommon
        TEQS    R6,#1
        MOVEQ   R6,#2

        ADR     r2, MemoryI_Error
        MOV     r10, #0 ; arguments can only be 32-bit
        BL      GetCommandParms
        BLVS    CopyErrorR2
        EXIT    VS

        TST     r8, #secondparm
        ADDEQ   r7, r9, r6, LSL #4      ; r7 = r9 + r6 * 24
        ADDEQ   r7, r7, r6, LSL #3

        TEQ     r6, #4

        BICEQ   r9, r9, #3              ; ensure word aligned
        BICEQ   r7, r7, #3
        BICNE   r9, r9, #1              ; ensure halfword aligned
        BICNE   r7, r7, #1

        TEQS    r9, r7                  ; If same, ensure we do one word
        BNE     %FT05

        ADD     r7, r7, r6

05
        BL      SwapAllBreakpoints

10 ; Loop doing disassembly until ESCape or ended

        SWI     XOS_ReadEscapeState
        BCS     %FT95

        BL      DisplayHexWord_R9       ; Display address

        BLVC    MarkPC

        MOVVC   r2, r6                  ; Display characters at address
        BLVC    DisplayCharacters
        EXIT    VS

        SWI     XOS_WriteS
        DCB     " : ", 0
        ALIGN

        EXIT    VS

        Push    "r0, r1"
        MOV     r0, r9
        BL      do_readW
        MOV     r10, r1
        Pull    "r0, r1"

        TEQS    r6, #4
        BNE     %F40
        BL      DisplayHexWord
        B       %F45
40      BL      DisplayHexHalfword

45      BLVC    MarkBreakpoints

        EXIT    VS

        Push    "r1"
        MOV     r0, r9
        BL      do_readW
        MOV     r0, r1
        Pull    "r1"
        MOV     r1, r9
        TEQS    r6, #4
        BNE     %F50
        SWI     XDebugger_Disassemble
        B       %F55
50      SWI     XDebugger_DisassembleThumb
55      MOVVC   r0, r1

        SWIVC   XOS_Write0
        SWIVC   XOS_NewLine
        EXIT    VS

        ADD     r9, r9, r6

        TEQS    r9, r7
        BNE     %BT10


90      BL      SwapAllBreakpoints
        EXIT

95      BL      AckEscape
        B       %BT90

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

InitStore_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGINS", 0
        ALIGN


UserMemStart  * &8000

InitStore_Code Entry "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        ADR     r0, InitStore_Error
        BL      ReadOneParm             ; r7 := parm, r8 state
        BLVS    CopyError
        EXIT    VS

        TST     r8, #hasparm
        LDREQ   r7, =&E7FFFFFF          ; A nice invalid instruction
        SWI     XOS_GetEnv              ; r1 -> end of user memory

        MOV     r14, #UserMemStart
10      TEQ     r14, r1                 ; Might have zero apl space
        STRNE   r7, [r14], #4
        BNE     %BT10

        BL      message_writes
        DCB     "M16", 0                ; "Store inititalised to &"
        ALIGN

        MOVVC   r10, r7
        BLVC    DisplayHexWord
        SWIVC   XOS_NewLine
        EXIT

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ShowRegs_Code

        LDR     wp, [r12]

; .............................................................................

ShowRegs_Code_Common Entry "r6-r11"

        BL      message_writes        ; Display address of register dump
        DCB     "M17", 0              ; "Register dump (stored at &)
        ALIGN

        ADRVC   r10, Registers
        BLVC    DisplayHexWord
        EXIT    VS

        BL      message_writes
        DCB     "M18", 0              ; ") is:"
        ALIGN
        EXIT    VS

        MOV     r4, #0
        ADR     r11, Registers

10 ; Display dumped registers

        TST     r4, #3
        SWIEQ   XOS_NewLine
        EXIT    VS

        SWINE   XOS_WriteI+space

        SWIVC   XOS_WriteI+"R"

        MOVVC   r8, r4
        BLVC    DisplayDecimalNumber
        EXIT    VS

        CMPS    r4, #10
        SWILO   XOS_WriteI+space
        EXIT    VS

        SWI     XOS_WriteS
        DCB     " = ", 0
        ALIGN

        LDRVC   r10, [r11, r4, LSL #2]
        BLVC    DisplayHexWord
        EXIT    VS

        ADD     r4, r4, #1
        TEQS    r4, #16
        BNE     %BT10

        SWI     XOS_NewLine
        EXIT    VS

; Display processor mode (r10 = dumped pc at end of loop)

; Check whether we're 26 or 32 bit
        LDRB    r0, SysIs32bit
        TEQ     r0, #0
        BEQ     ShowRegs_Mode_26

        BL      message_writes
        DCB     "M19", 0                ; "Mode "
        ALIGN

        LDRVC   r10, [r11, #4*16]       ; get saved PSR

        ANDVC   r2, r10, #2_11111       ; Mask with M[4:0] bits
        ADRVC   r0, ARM32_Modes
        ADDVC   r0, r0, r2, LSL #2
        ADDVC   r0, r0, r2, LSL #1
        SWIVC   XOS_Write0
        EXIT    VS

        BL      message_writes
        DCB     "M20", 0                ; " flags set: "
        ALIGN

        MOVVC   r0, #"N"
        MOVVC   r1, #N_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"Z"
        MOVVC   r1, #Z_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"C"
        MOVVC   r1, #C_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"V"
        MOVVC   r1, #V_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"Q"
        MOVVC   r1, #Q32_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"J"
        MOVVC   r1, #J32_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"G"
        MOVVC   r1, #GE3_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"G"
        MOVVC   r1, #GE2_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"G"
        MOVVC   r1, #GE1_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"G"
        MOVVC   r1, #GE0_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"E"
        MOVVC   r1, #E32_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"A"
        MOVVC   r1, #A32_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"I"
        MOVVC   r1, #I32_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"F"
        MOVVC   r1, #F32_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"T"
        MOVVC   r1, #T32_bit
        BLVC    DoFlagBit
        EXIT    VS

        BL      message_writes
        DCB     "M14", 0                ; "   PSR = "
        BLVC    DisplayHexWord

        SWIVC   XOS_NewLine
        EXIT

ShowRegs_Mode_26

        BL      message_writes
        DCB     "M19", 0                ; "Mode "
        ALIGN

        ANDVC   r2, r10, #2_11          ; Mask with M[1:0] bits
        ADRVC   r0, ARM_Modes
        ADDVC   r0, r0, r2, LSL #2
        SWIVC   XOS_Write0
        EXIT    VS

        BL      message_writes
        DCB     "M20", 0                ; " flags set: "
        ALIGN

        MOVVC   r0, #"N"
        MOVVC   r1, #N_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"Z"
        MOVVC   r1, #Z_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"C"
        MOVVC   r1, #C_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"V"
        MOVVC   r1, #V_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"I"
        MOVVC   r1, #I_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"F"
        MOVVC   r1, #F_bit
        BLVC    DoFlagBit

        SWIVC   XOS_NewLine
        EXIT


ARM_Modes
        DCB     "USR", 0
        DCB     "FIQ", 0
        DCB     "IRQ", 0
        DCB     "SVC", 0

ARM32_Modes
        DCB     "USR26", 0
        DCB     "FIQ26", 0
        DCB     "IRQ26", 0
        DCB     "SVC26", 0
        DCB     "00100", 0
        DCB     "00101", 0
        DCB     "00110", 0
        DCB     "00111", 0
        DCB     "01000", 0
        DCB     "01001", 0
        DCB     "01010", 0
        DCB     "01011", 0
        DCB     "01100", 0
        DCB     "01101", 0
        DCB     "01110", 0
        DCB     "01111", 0
        DCB     "USR32", 0
        DCB     "FIQ32", 0
        DCB     "IRQ32", 0
        DCB     "SVC32", 0
        DCB     "10100", 0
        DCB     "10101", 0
        DCB     "MON32", 0
        DCB     "ABT32", 0
        DCB     "11000", 0
        DCB     "11001", 0
        DCB     "11010", 0
        DCB     "UND32", 0
        DCB     "11100", 0
        DCB     "11101", 0
        DCB     "11110", 0
        DCB     "SYS32", 0
        ALIGN

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 = flag bit to test
;       r10 = psr
;       r0 = uppercase char to print if set

; Out   char printed uppercase or lowercase, r0 corrupt

DoFlagBit Entry

        TST     r1, r10
        ORREQ   r0, r0, #&20            ; Cheap lowercase, known values input
        SWI     XOS_WriteC
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Memory_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGMEM", 0
        ALIGN


Memory_Code Entry "r6-r11",8

        MOV     R6,#"B"
        BL      MemoryCommon

        ADR     r2, Memory_Error
        MOV     r10, #0 ; arguments can only be 32-bit
        BL      GetCommandParms
        BLVS    CopyErrorR2
        EXIT    VS

        TST     r8, #secondparm
        ADDEQ   r7, r9, #256            ; [no second parameter]

        TEQS    r7, r9                  ; If same, ensure we do one byte/word
        ADDEQ   r7, r7, r6

        BL      SwapAllBreakpoints

        MOV     r0, #VduExt_WindowWidth
        MOV     r1, #-1
        Push    "r0, r1"
        MOV     r0, sp
        MOV     r1, sp
        SWI     XOS_ReadVduVariables
        Pull    "r0, r1"
        STR     r0, WindowWidth

        CMPS    r0, #8+2+3*32+3+1*32
        MOVHS   r14, #32
        MOVLO   r14, #16
        STR     r14, BytesPerLine

        MOV     r11, #0                 ; Force header on first row

05 ; Loop displaying memory

        SWI     XOS_ReadEscapeState
        BCS     %FT95

        TST     r11, #15
        BLEQ    MemoryHeader

        BLVC    DisplayHexWord_R9       ; address

        SWIVC   XOS_WriteI+space
        SWIVC   XOS_WriteI+colon
        BVS     %FT90

        LDR     r8, BytesPerLine
        TST     r6, #&C
        MOVNE   r8, r8, LSR #2          ; words or double-words per line
        TST     r6, #&A
        MOVNE   r8, r8, LSR #1          ; half-words or double-words per line

        MOV     r0, r9

10
        CMP     r6, #8
        BEQ     %FT25
        CMP     r6, #2
        BHI     %FT20
        BEQ     %FT15

        MOV     r2, #8-4                ; byte

        SWI     XOS_WriteI+space        ; Display byte
        BVS     %FT90

        CMP     r0, r7
        BCS     %FT50                   ; [ended, so blank. DO NOT READ BYTE]

        Push    "r1"
        BL      do_readB
        MOV     r10, r1
        ADD     r0, r0, #1
        Pull    "r1"
        B       %FA30

15      MOV     r2, #16-4

        SWI     XOS_WriteI+space
        SWIVC   XOS_WriteI+space
        BVS     %FT90

        CMP     r0, r7
        BCS     %FT50                   ; [ended, so blank. DO NOT READ HWORD]

        Push    "r1"
        BL      do_readH
        MOV     r10, r1
        ADD     r0, r0, #2
        Pull    "r1"
        B       %FA30

20
        MOV     r2, #32-4
        SWI     XOS_WriteS              ; Display word
        DCB     "    ", 0
        ALIGN
        BVS     %FT90

        CMP     r0, r7
        BCS     %FT50                   ; [ended, so blank. DO NOT READ WORD]

        Push    "r1"
        BL      do_readW
        MOV     r10, r1
        ADD     r0, r0, #4
        Pull    "r1"
        B       %FA30

25      MOV     r2, #64-4

        SWI     XOS_WriteS              ; Display word
        DCB     "        ", 0
        ALIGN
        BVS     %FT90

        CMP     r0, r7
        BCS     %FT50                   ; [ended, so blank. DO NOT READ DWORD]

        Push    "r1"
        ADD     r1, sp, #4
        BL      do_readD
        MOV     r10, r1
        ADD     r0, r0, #8
        Pull    "r1"

30      BLVC    DisplayHex
        B       %FA60


50      BLVC    Blank                   ; Output r2 spaces

60      BVS     %FT90

        SUBS    r8, r8, #1              ; Loop if not done whole line
        BNE     %BT10                   ; Even if ended in middle, were padding

        BL      SpaceColonSpace
        BVS     %FT90

        SUB     r2, r7, r9              ; nchars to print this row

        LDR     r14, BytesPerLine
        CMP     r2, r14
        MOVHS   r2, r14

        CMPS    r2, #0                  ; VClear
        BLNE    DisplayCharacters
        SWIVC   XOS_NewLine
        BVS     %FT90

        ADD     r11, r11, #1            ; Another line gone by

        LDR     r14, BytesPerLine
        ADD     r9, r9, r14             ; More bytes per line done

        CMPS    r9, r7
        BLO     %BT05


90      BL      SwapAllBreakpoints
        EXIT

95      BL      AckEscape
        B       %BT90

; in all these cases, if the OS_Memory call fails, we assume
; the system is an IOMD-based non-HAL system, where the 512MB
; of physical address space is mapped in at &80000000.

; in: r0 = address, r1 -> buffer to hold (double-word) data
do_readD ROUT
        Push    "r0-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        BNE     %FT50
        LDRD    r2, [r0]         ;read to r2,r3
        STMIA   r1, {r2,r3}
        Pull    "r0-r3, pc"
50
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDR     lr, [sp, #4]
        LDRD    r0, [r2]         ;read from logical mapping into r0,r1
        STMIA   lr, {r0,r1}
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r1, r2, #0       ;clear V
        Pull    "r0-r3, pc"

; in: r0 = address, out: r1 = (word) data
do_readW ROUT
        Push    "r0,r2-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        LDREQ   r1, [r0]
        Pull    "r0,r2-r3, pc",EQ
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDR     r2, [r2]         ;read from logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r1, r2, #0       ;clear V
        Pull    "r0,r2-r3, pc"

; in: r0 = address, out: r1 = (half-word) data
do_readH ROUT
        Push    "r0,r2-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        BNE     %FT50
        LDRH    r1, [r0]
        Pull    "r0,r2-r3, pc"
50
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDRH    r2, [r2]         ;read from logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r1, r2, #0       ;clear V
        Pull    "r0,r2-r3, pc"

; in: r0 = address, out: r1 = (byte) data
do_readB ROUT
        Push    "r0,r2-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        LDREQB  r1, [r0]
        Pull    "r0,r2-r3, pc",EQ
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDRB    r2, [r2]         ;read from logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r1, r2, #0       ;clear V
        Pull    "r0,r2-r3, pc"

; in: r0 = address, r1 -> buffer holding (double-word) data
do_writeD ROUT
        Push    "r0-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        BNE     %FT50
        LDMIA   r1, {r2,r3}
        STRD    r2, [r0]         ;write from r2,r3
        Pull    "r0-r3, pc"
50
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDR     lr, [sp, #4]
        LDMIA   lr, {r0,r1}
        STRD    r0, [r2]         ;store from r0,r1 into logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r0, r0, #0       ;clear V
        Pull    "r0-r3, pc"

; in: r0 = address, r1 = (word) data
do_writeW ROUT
        Push    "r0-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        STREQ   r1, [r0]
        Pull    "r0-r3, pc",EQ
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDR     r1, [sp, #4]
        STR     r1, [r2]         ;write to logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r0, r0, #0       ;clear V
        Pull    "r0-r3, pc"

; in: r0 = address, r1 = (half-word) data
do_writeH ROUT
        Push    "r0-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        BNE     %FT50
        STRH    r1, [r0]
        Pull    "r0-r3, pc"
50
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDR     r1, [sp, #4]
        STRH    r1, [r2]         ;write to logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r0, r0, #0       ;clear V
        Pull    "r0-r3, pc"

; in: r0 = address, r1 = (byte) data
do_writeB ROUT
        Push    "r0-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        STREQB  r1, [r0]
        Pull    "r0-r3, pc",EQ
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDR     r1, [sp, #4]
        STRB    r1, [r2]         ;write to logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r0, r0, #0       ;clear V
        Pull    "r0-r3, pc"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SpaceColonSpace Entry

        SWI     XOS_WriteI+space
        SWIVC   XOS_WriteI+colon
        SWIVC   XOS_WriteI+space
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MemoryHeader Entry

        SWI     XOS_NewLine
        EXIT    VS
        BL      message_writes
        DCB     "M22", 0                ; "Address  :"
        ALIGN
        EXIT    VS

        LDR     r0, %FT50+1             ; try an unaligned load
        TEQ     r0, #0
        BEQ     %FT40                   ; pre-ARMv6 style rotated load
                                        ; else ARMv7-style unaligned load
        CMP     r6, #4
        ADRHI   r0, DoubleWords_Unaligned
        ADREQ   r0, Words_Unaligned
        CMP     r6, #2
        ADREQ   r0, HalfWords_Unaligned
        ADRLO   r0, Bytes
        ADR     lr, %FT70
        MOV     pc, r0
40
        CMP     r6, #4
        ADRHI   r0, DoubleWords
        ADREQ   r0, Words
        CMP     r6, #2
        ADREQ   r0, HalfWords
        ADRLO   r0, Bytes
        ADR     lr, %FT70
        MOV     pc, r0
50
        DCD     0, -1
70
        BL      SpaceColonSpace
        EXIT    VS

        LDR     r14, BytesPerLine       ; Doing in 32 ?
        CMPS    r14, #32
        ADREQ   r0, %FT85
        SWIEQ   XOS_Write0

        ADRVC   r0, %FT80
        BLVC    message_write0
        MOVVC   r11, #0
        SWIVC   XOS_NewLine
        EXIT

80
        DCB     "M23"                   ; "   ASCII Data"

85
        DCB     "        ", 0           ; Otherwise centre in field of 32
;                01234567

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9
; As of ARMv7, non-word-aligned loads will abort, but maybe that will change in future?

DoubleWords_Unaligned Entry "r1, r9, r10, r11"

        LDR     r11, BytesPerLine
        MOV     r1, #16
        ADR     r10, Unaligned_Header+46-16

10      SWI     XOS_WriteS
        DCB     "        ", 0
        ALIGN
        ANDVC   r9, r9, #&F
        SUBVC   r0, r10, r9, LSL #1
        SWIVC   XOS_WriteN
        EXIT    VS

        ADD     r9, r9, #8

        SUBS    r11, r11, #8
        BNE     %BT10
        EXIT

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9

Words_Unaligned Entry "r1, r9, r10, r11"

        LDR     r11, BytesPerLine
        MOV     r1, #8
        ADR     r10, Unaligned_Header+46-8

10      SWI     XOS_WriteS
        DCB     "    ", 0
        ALIGN
        ANDVC   r9, r9, #&F
        SUBVC   r0, r10, r9, LSL #1
        SWIVC   XOS_WriteN
        EXIT    VS

        ADD     r9, r9, #4

        SUBS    r11, r11, #4
        BNE     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9

HalfWords_Unaligned Entry "r1, r9, r10, r11"

        LDR     r11, BytesPerLine
        MOV     r1, #4
        ADR     r10, Unaligned_Header+46-4

10      SWI     XOS_WriteS
        DCB     "  ", 0
        ALIGN
        ANDVC   r9, r9, #&F
        SUBVC   r0, r10, r9, LSL #1
        SWIVC   XOS_WriteN
        EXIT    VS

        ADD     r9, r9, #2

        SUBS    r11, r11, #2
        BNE     %BT10
        EXIT


Unaligned_Header
        DCB     " 6 5 4 3 2 1 0 F E D C B A 9 8 7 6 5 4 3 2 1 0"
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9
; Behaviour if non-half-word aligned is unpredictable
; XScale seems to ignore bit 0 of the address, so let's reflect that

HalfWords Entry "r9, r10, r11"

        LDR     r11, BytesPerLine
        MOV     r1, #4
        ADR     r10, Unaligned_Header+46-4

10      SWI     XOS_WriteS
        DCB     "  ", 0
        ALIGN
        ANDVC   r9, r9, #&F
        BICVC   r0, r9, #1
        SUBVC   r0, r10, r0, LSL #1
        SWIVC   XOS_WriteN
        EXIT    VS

        ADD     r9, r9, #2

        SUBS    r11, r11, #2
        BNE     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9
; Behaviour if non-word- or non-double-word- (on an implementation-defined basis) aligned is unpredictable
; XScale seems to ignore the bottom two address bits and fails to carry from bit 2 to 3, so let's reflect that

DoubleWords Entry "r1, r9, r10, r11"

        LDR     r11, BytesPerLine
        MOV     r1, #16
        TST     r9, #4
        ADREQ   r10, Unaligned_Header+46-16
        ADRNE   r10, BrokenXScale_Header+32-16

10      SWI     XOS_WriteS
        DCB     "        ", 0
        ALIGN
        ANDVC   r0, r9, #8
        SUBVC   r0, r10, r0, LSL #1
        SWIVC   XOS_WriteN
        EXIT    VS

        ADD     r9, r9, #8

        SUBS    r11, r11, #8
        BNE     %BT10
        EXIT

BrokenXScale_Header
        DCB     " F E D C F E D C 7 6 5 4 7 6 5 4"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9

Words Entry "r1, r9, r10, r11"

        LDR     r11, BytesPerLine
        MOV     r1, #8
        ADR     r10, Words_Header+14-8

10      SWI     XOS_WriteS
        DCB     "    ", 0
        ALIGN
        ANDVC   r0, r9, #3
        SUBVC   r0, r10, r0, LSL #1
        ANDVC   lr, r9, #&C
        ADDVC   r0, r0, lr, LSL #2
        SWIVC   XOS_WriteN
        EXIT    VS

        ADD     r9, r9, #4

        SUBS    r11, r11, #4
        BNE     %BT10
        EXIT

Words_Header
        DCB     " 2 1 0 3 2 1 0", 0, 0
        DCB     " 6 5 4 7 6 5 4", 0, 0
        DCB     " A 9 8 B A 9 8", 0, 0
        DCB     " E D C F E D C", 0, 0

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Count from r9 to r9+15 modulo 16 along the top

Bytes Entry "r9, r10, r11"

        LDR     r11, BytesPerLine

10      SWI     XOS_WriteI+space
        SWI     XOS_WriteI+space
        MOVVC   r2, #4-4
        ANDVC   r10, r9, #&F
        BLVC    DisplayHex
        EXIT    VS

        ADD     r9, r9, #1

        SUBS    r11, r11, #1
        BNE     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Fill remaining space with 1 + r2/4 blanks

; In    r2 = number of blanks to go (multiple of 4)

Blank Entry

10      SWI     XOS_WriteI+space
        EXIT    VS

        SUBS    r2, r2, #4
        BPL     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; in    r12 to be indirected
;       r0 -> string
;       r6 = character to check for

; Out   r1 -> string
;       r6 = 1, 2, 4 or 8 if r6 = 'B' on entry, else r6 = 1 or 4 depending on whether 'r6' present
;       any matching flag is skipped
;       r0 corrupt

MemoryCommon Entry

        LDR     wp, [r12]

        MOV     r1, r0

        MOV     r0, #0
        STR     r0, PhysAddrWrd
        BL      MemoryPhys

        BL      SkipSpaces              ; check for 'r6',space
        TEQ     r6, #'B'
        BNE     %FT20
        TEQ     r0, #'B'
        TEQNE   r0, #'b'
        MOVEQ   r6, #1
        TEQ     r0, #'H'
        TEQNE   r0, #'h'
        MOVEQ   r6, #2
        TEQ     r0, #'D'
        TEQNE   r0, #'d'
        MOVEQ   r6, #8
        TEQNE   r6, #2
        TEQNE   r6, #1
        B       %FT25
20      TEQ     r0, r6                  ; Check upper case
        ADDNE   r6, r6, #"a"-"A"
        TEQNE   r0, r6                  ; Check lower case
        MOVEQ   r6, #1
25      ; Valid character must also be followed by space
        LDREQB  r0, [r1, #1]
        TEQEQ   r0, #space
        ADDEQ   r1, r1, #2              ; skip flag character and space if match
        MOVNE   r6, #4                  ; default to 4 in case of no match

        LDR     r0, PhysAddrWrd
        TEQ     r0, #0
        BLEQ    MemoryPhys

        EXIT

;if we see we are doing a physical access, do cache flush to minimise
;possible confusion for user (eg. looking at memory via physical address
;that could otherwise be seen as different to view via logical address,
;if writeback data cache)
;
MemoryPhys ROUT
        ; check for 'P',space,
        Push    "r0, r14"
        BL      SkipSpaces
        TEQ     r0, #"p"
        TEQNE   r0, #"P"
        LDREQB  r0, [r1, #1]
        TEQEQ   r0, #space
        Pull    "r0, pc",NE
        MOV     r0, #1
        STR     r0, PhysAddrWrd
        ADD     r1, r1, #2
        MOV     r0, #&80000001   ; flush cache(s)
        SWI     XOS_MMUControl
        Pull    "r0, pc"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MemoryA_Code Entry "r6-r11", 8+8

        MOV     R6,#"B"
        BL      MemoryCommon

        ADR     r2, MemoryA_Error
        TEQ     r6, #8
        MOVNE   r10, #0
        MOVEQ   r10, #Command_64bitData
        ADD     r11, sp, #8
        BL      GetCommandParms
        EXIT    VS

        TST     r8, #&FF00              ; had operator ?
        BNE     %FT99                   ; [not permitted here]

        BL      SwapAllBreakpoints

        TST     r8, #secondparm
        BEQ     Interactive             ; [no second parameter]

; Simple command, not interactive

        CMP     r6, #8
        BEQ     mai_doubleword
        CMP     r6, #2
        BLO     mai_byte
        BEQ     mai_halfword

mai_word
        MOV     r2, #32-4
        Push    "r1"
        MOV     r0, r9
        BL      do_readW
        MOV     r4, r1
        MOV     r1, r7
        BL      do_writeW
        BL      do_readW
        MOV     r5, r1
        ADR     r0, %FT40
        Pull    "r1"
        B       mai_cont

mai_doubleword
        MOV     r2, #64-4
        MOV     r4, sp     ; buffer for old value
        ADD     r5, sp, #8 ; buffer for new value
        Push    "r1"
        MOV     r1, r4
        MOV     r0, r9
        BL      do_readD
        MOV     r1, r5
        BL      do_writeD
        BL      do_readD
        ADR     r0, %FT43
        Pull    "r1"
        B       mai_cont

mai_halfword
        MOV     r2, #16-4
        Push    "r1"
        MOV     r0, r9
        BL      do_readH
        MOV     r4, r1
        MOV     r1, r7
        BL      do_writeH
        BL      do_readH
        MOV     r5, r1
        ADR     r0, %FT42
        Pull    "r1"
        B       mai_cont

mai_byte
        MOV     r2, #8-4
        Push    "r1"
        MOV     r0, r9
        BL      do_readB
        MOV     r4, r1
        MOV     r1, r7
        BL      do_writeB
        BL      do_readB
        MOV     r5, r1
        ADR     r0, %FT41
        Pull    "r1"
mai_cont
        BL      message_write0

        BLVC    DisplayHexWord_R9

        ADRVC   r0, %FT44
        BLVC    message_write0

        MOVVC   r10, r4
        BLVC    DisplayHex

        ADRVC   r0, %FT45
        BLVC    message_write0

        MOVVC   r10, r5
        BLVC    DisplayHex

        SWIVC   XOS_NewLine

        BL      SwapAllBreakpoints
        EXIT

40
        DCB     "M24", 0                ; "Word at &"
41
        DCB     "M25", 0                ; "Byte at &"
42
        DCB     "M75", 0                ; "Half-word at &"
43
        DCB     "M76", 0                ; "Double-word at &"
44
        DCB     "M26", 0                ; " was &"
45
        DCB     "M27", 0                ; " altered to &"
        ALIGN

99      ADR     r0, MemoryA_Error
        BL      CopyError
        EXIT


MemoryA_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGMMA", 0
        ALIGN

; .............................................................................

Interactive ROUT

        SUB     sp, sp, #256            ; Use buffer on stack
        MOV     r8, r6                  ; 1 or 4, initial step +ve

10
        CMPS    r8, #0
        MOVGE   r0, #"+"
        MOVLT   r0, #"-"
        SWI     XOS_WriteC
        SWIVC   XOS_WriteI+space

        BLVC    DisplayHexWord_R9

        BLVC    MarkPC

        BVS     %FT90
        Push    "r0, r1"
        MOV     r0, r9
        ADR     lr, %FT20             ; they don't return using MOVS
        ADD     r1, sp, #8+256        ; buffer for old value if dword
        CMP     r6, #4
        BHI     do_readD
        BEQ     do_readW
        CMP     r6, #2
        BEQ     do_readH
        BLO     do_readB
20
        MOV     r10, r1
        Pull    "r0, r1"
        MOVVC   r2, r6
        BLVC    DisplayCharacters

        BLVC    MarkBreakpoints

        BVS     %FT90
        CMP     r6, #4
        MOVHI   r2, #64-4
        MOVEQ   r2, #32-4
        CMP     r6, #2
        MOVEQ   r2, #16-4
        MOVLO   r2, #8-4
        BLVC    DisplayHex

        SWIVC   XOS_WriteI+space
        SWIVC   XOS_WriteI+colon
        SWIVC   XOS_WriteI+space

        BVS     %FT90
        CMP     r6, #4
        BEQ     %FT40                   ; Disassemble ARM
        CMP     r6, #2
        BNE     %FT50                   ; Don't disassemble for bytes or double-words
                                        ; Else disassemble Thumb
        Push    "r1"
        MOV     r0, r9
        BL      do_readH
        MOV     r0, r1
        Pull    "r1"
        MOVVC   r1, r9
        SWIVC   XDebugger_DisassembleThumb
        MOVVC   r0, r1
        SWIVC   XOS_Write0
        B       %FT50
40

        BVS     %FT48
        Push    "r1"
        MOV     r0, r9
        BL      do_readW
        MOV     r0, r1
        Pull    "r1"
48
        MOVVC   r1, r9
        SWIVC   XDebugger_Disassemble
        MOVVC   r0, r1
        SWIVC   XOS_Write0

50      SWIVC   XOS_NewLine
        ADRVC   r0, %FT96
        BLVC    message_write0

        MOVVC   r0, sp
        MOVVC   r1, #255
        MOVVC   r2, #space
        MOVVC   r3, #&FF
        SWIVC   XOS_ReadLine
        BVS     %FT90
        BCS     %FT95

        MOV     r1, sp
        BL      SkipSpaces
        ADDCC   r9, r9, r8              ; No parm, just advance in current dirn
        MOVCC   r7,r9

        BCC     %BT10

        TEQ     r0, #"+"
        MOVEQ   r8, r6                  ; Change to +ve step
        BEQ     %BT10

        TEQ     r0, #"-"
        RSBEQ   r8, r6, #0              ; Change to -ve step
        BEQ     %BT10

        CMP     r0, #"."                ; End interactive
        BEQ     %FT90                   ; VClear

        ADR     r0, ErrorBlock_Debug_InvalidValue
        BL      CopyError
        Push    "r8"
        CMP     r6, #8
        MOVEQ   r10, #Command_64bitData ; r11 should still be set up from entry to MemoryA_Code
        MOVNE   r10, #0
        BL      ReadOneParm             ; r7 := parm, r8 state
        Pull    "r8"
        BVS     %FT90

        CMP     r6, #8
        BEQ     int_doubleword
        CMP     r6, #2
        BLO     int_byte
        BEQ     int_halfword

int_word
        Push    "r0, r1"
        MOV     r0, r9
        MOV     r1, r7
        BL      do_writeW
        BL      do_readW
        MOV     r10, r1
        Pull    "r0, r1"
        MOV     r2, #32-4
        B       %FT70

int_doubleword
        Push    "r0, r1"
        MOV     r0, r9
        ADD     r1, sp, #8+256+8      ; buffer for new value
        BL      do_writeD
        BL      do_readD
        MOV     r10, r1
        Pull    "r0, r1"
        MOV     r2, #64-4
        B       %FT70

int_halfword
        Push    "r0, r1"
        MOV     r0, r9
        MOV     r1, r7
        BL      do_writeH
        BL      do_readH
        MOV     r10, r1
        Pull    "r0, r1"
        MOV     r2, #16-4
        B       %FT70

int_byte
        Push    "r0, r1"
        MOV     r0, r9
        MOV     r1, r7
        BL      do_writeB
        BL      do_readB
        MOV     r10, r1
        Pull    "r0, r1"
        MOV     r2, #8-4
70

        SWI     XOS_WriteS
        DCB     "                  . ", 0
        ALIGN

        BLVC    DisplayHex
        SWIVC   XOS_NewLine
        BVC     %BT10


90      ADD     sp, sp, #256
        BL      SwapAllBreakpoints
        EXIT

95      BL      AckEscape
        B       %BT90


        MakeInternatErrorBlock Debug_InvalidValue, NOALIGN, M46

96
        DCB     "M29", 0                ; "  Enter new value : "
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BreakSet_Code Entry "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        BL      ReadFirstParm           ; r7 := parm
        EXIT    VS

        TST     r8, #parmfollowed
        BNE     BreakSetError0

        LDRB    r4, SysIs32bit
        BIC     r7, r7, #3              ; Can only set at word address
        TEQ     r4, #0
        BNE     %FT05

        CMP     r7, #&04000000          ; Can only set in bottom 64M (has to
                                        ; construct a branch)
        BHS     BreakSetError1

05      ADR     r4, Breaklist           ; Check for breakpoint already in list
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        TEQ     r1, r7
        BEQ     %FT40                   ; [already allocated, but ensure there]
        SUBS    r3, r3, #8              ; each breakpoint entry is 8 bytes
        BPL     %BT10

        MOV     r3, #(nbreakpoints-1)*8 ; Allocate breakpoint
20      LDR     r1, [r4, r3]
        CMP     r1, #-1
        BEQ     %FT30                   ; [free slot found]
        SUBS    r3, r3, #8
        BPL     %BT20

        ADR     r0, ErrorBlock_Debug_NoRoom
        BL      CopyError
        B       %FA90


30 ; Store breakpoint address and old contents, r3 = breakpoint number*8

        MOV     r1, r7
        STR     r1, [r4, r3]            ; breakpoint address
        LDR     r0, [r1]
        ADD     r14, r4, #4
        STR     r0, [r14, r3]           ; old data

40 ; Place branch at breakpoint address, r3 = breakpoint number*8, r1 valid

        LDRB    r0, SysIs32bit
        TEQ     r0, #0
        ADREQ   r0, BreakCodeStart
        ADDEQ   r0, r0, r3              ; each code entry is 8 bytes too
        BLEQ    MakeBranch
        BLNE    MakeMOVPC
        STR     r2, [r1]
 [ StrongARM
        ;Do the IMB thingy here, for the replaced instruction
        MOV     r0, #1          ;Ranged IMB
        MOV     r2, r1
        SWI     XOS_SynchroniseCodeAreas
 ]
        EXIT


BreakSetError0
        ADR     r0, BreakSet_Error
        BL      CopyError

90      EXIT


BreakSetError1
        ADR     r0, ErrorBlock_Debug_BadBreakpoint
        BL      CopyError
        B       %BA90


BreakSet_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGBST", 0
        ALIGN

        MakeInternatErrorBlock Debug_NoRoom,,M48
        MakeInternatErrorBlock Debug_BadBreakpoint,,M50

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BreakList_Code Entry "r6-r11"

        LDR     wp, [r12]

        ADR     r4, Breaklist           ; Any breakpoints to display ?
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        CMP     r1, #-1
        BNE     %FT20                   ; [yes, starting at r3]
        SUBS    r3, r3, #8
        BPL     %BT10

        BL      message_writes
        DCB     "M31", 0                ; "No breakpoints set"
        SWIVC   XOS_NewLine
        ALIGN
        EXIT


20 ; Display list

        BL      message_writes
        DCB     "M32", 0                ; "Address     Old data"
        ALIGN
        SWIVC   XOS_NewLine
        EXIT    VS

30      CMP     r1, #-1
        BEQ     %FT60                   ; [no breakpoint entry here]

        MOV     r10, r1
        BL      DisplayHexWord          ; r10 = breakpoint address
        EXIT    VS

        SWI     XOS_WriteS
        DCB     "    ", 0
        ALIGN

        ADDVC   r14, r4, #4
        LDRVC   r10, [r14, r3]
        BLVC    DisplayHexWord          ; r10 = old data
        EXIT    VS

        LDRB    r0, SysIs32bit
        TEQ     r0, #0
        ADREQ   r0, BreakCodeStart      ; Check still B debugger
        ADDEQ   r0, r0, r3              ; each code entry is 8 bytes too
        BLEQ    MakeBranch              ; r1 from up there
        BLNE    MakeMOVPC
        LDR     r14, [r1]
        TEQS    r14, r2
        BEQ     %FT50                   ; [breakpoint present and correct]

        MOV     r14, #-1                ; Clear faulty breakpoint entry
        STR     r14, [r4, r3]           ; Only need to zap address field

        BL      message_writes
        DCB     "M33", 0 ; No newline   ; " : bad breakpoint; cleared."
        ALIGN

50      SWIVC   XOS_NewLine
        EXIT    VS

60      SUBS    r3, r3, #8
        LDRPL   r1, [r4, r3]
        BPL     %BT30

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BreakClr_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGBCL", 0
        ALIGN


BreakClr_Code Entry "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        ADR     r0, BreakClr_Error
        BL      ReadOneParm             ; r7 := parm, r8 state
        BLVS    CopyError
        EXIT    VS

        BIC     r7, r7, #ARM_CC_Mask    ; Can only set at word address in 64M

        ADR     r4, Breaklist
        MOV     r3, #(nbreakpoints-1)*8

        TST     r8, #hasparm
        BEQ     %FT50                   ; [no parm, so prompt]

; Clear particular breakpoint

10      LDR     r1, [r4, r3]
        TEQS    r1, r7
        BEQ     %FT20                   ; [found]
        SUBS    r3, r3, #8
        BPL     %BT10

        ADR     r0, ErrorBlock_Debug_BreakNotFound
        BL      CopyError
        EXIT


20      BL      ClearBreakpoint         ; uses r1,r3,r4
        EXIT


50 ; Clear all breakpoints

        BL      message_writes
        DCB     "M35", 0                ; "Clear all breakpoints? [Y/N]"
        ALIGN

        SWIVC   XOS_Confirm             ; So sexy, huh ? Returns lowercase char
        EXIT    VS
        BLCS    AckEscape
        SWIVC   XOS_NewLine
        EXIT    VS

        ;TEQ     r0, #"y"
        EXIT    NE                      ; [anything else -> go home]


60      LDR     r1, [r4, r3]
        CMP     r1, #-1
        BLNE    ClearBreakpoint         ; uses r1,r3,r4

        SUBS    r3, r3, #8
        BPL     %BT60

        BL      message_writes
        DCB     "M36", 0                ; "All breakpoints cleared"
        ALIGN
        SWIVC   XOS_NewLine
        EXIT


        MakeInternatErrorBlock Debug_BreakNotFound,,M45

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 = breakpoint address
;       r3 = breakpoint number*8
;       r4 -> Breaklist

ClearBreakpoint Entry "r0-r2, r10"

        MOV     r14, #-1                ; Always clear breakpoint entry
        STR     r14, [r4, r3]           ; Only need to zap address field

        LDRB    r0, SysIs32bit
        TEQ     r0, #0
        ADREQ   r0, BreakCodeStart      ; Check that breakpoint was valid
        ADDEQ   r0, r0, r3              ; Each code entry is 8 bytes too
        BLEQ    MakeBranch
        BLNE    MakeMOVPC
        LDR     r14, [r1]
        TEQS    r14, r2
        ADDEQ   r14, r4, #4             ; breakpoint was good, so put data back
        LDREQ   r14, [r14, r3]
        STREQ   r14, [r1]
 [ StrongARM
        ;Do the IMB thingy here
        MOV     r0, #1                  ;Ranged IMB
        MOV     r2, r1
        SWI     XOS_SynchroniseCodeAreas
 ]
        EXIT    EQ

        BL      message_writes
        DCB     "M37", 0                ; "Bad breakpoint at &"
        ALIGN
        MOVVC   r10, r1
;        BICVC   R10,R10,#ARM_CC_Mask
        BLVC    DisplayHexWord
        EXIT    VS
        BL      message_writes
        DCB     "M38", 0                ; "; cleared."
        ALIGN
        SWIVC   XOS_NewLine
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Continue_Code Entry "r6-r11"

        LDR     wp, [r12]

        LDRB    r4, SysIs32bit
        TEQ     r4, #0

        LDR     r14, pc_register        ; Get pc from exception dump
        BICEQ   r14, r14, #ARM_CC_Mask

        ADR     r4, Breaklist           ; Check breakpoint list for pc
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        TEQS    r1, r14
        MOVEQ   r5, #0                  ; [found]
        BEQ     %FT20
        SUBS    r3, r3, #8
        BPL     %BT10

 [ debug
 DLINE "Not continuing from any of current breakpoints"
 ]
        ADR     r0, Registers
        B       %FT90                   ; Continue with this state



20 ; Check branch at breakpoint

        LDRB    r0, SysIs32bit
        TEQ     r0, #0

        ADREQ   r0, BreakCodeStart
        ADDEQ   r0, r0, r3
        BLEQ    MakeBranch
        BLNE    MakeMOVPC
        LDR     r14, [r1]
        TEQ     r14, r2
        BNE     ContinueError1          ; [not kosher]

        BL      message_writes
        DCB     "M39", 0                ; "Continue from breakpoint set at &"
        ALIGN

        MOVVC   r10, r1
;        BICVC   R10,R10,#ARM_CC_Mask
        BLVC    DisplayHexWord
        EXIT    VS

        SWI     XOS_NewLine
        EXIT    VS
        BL      message_writes
        DCB     "M40", 0                ; "Execute out of line? [Y/N] "
        ALIGN

        SWIVC   XOS_Confirm             ; So sexy, huh ? Returns lowercase char
        EXIT    VS                      ; (which for Internationalisation's sake
        BLCS    AckEscape               ; we now ignore, and use the Carry flag
        SWIVC   XOS_NewLine             ; return instead!)
        EXIT    VS

        ;TEQ     r0, #"y"
        EXIT    NE

; Execute instruction out-of-line

        Push    "r1, r3, r4"
        ADR     r8, ExecuteBuffer+12
        ADR     r9, Registers
        LDRB    r0, SysIs32bit
        TEQ     r0, #0
        LDMIA   r9!, {r0-r7}            ; Get + Store first 8 registers
        STMIA   r8!, {r0-r7}
        LDMIA   r9!, {r0-r6}            ; Get next 7 registers
        LDREQ   r14, pc_register
        ANDEQ   r14, r14, #ARM_CC_Mask
        ADR     r7, ExecuteBuffer
        ORREQ   r7, r7, r14             ; dumped pc -> ExecBuffer +mode +flags
        STMIA   r8!, {r0-r7}
        LDRNE   r0, [r9, #4]            ; do CPSR for 32-bit
        STRNE   r0, [r8]
        Pull    "r1, r3, r4"

; See if we can do any better for pc relatives in this version

        ADR     r8, ExecuteBuffer
        ADD     r14, r4, #4
        LDR     r14, [r14, r3]          ; Copy instruction(old data)into buffer
 [ debug
 DREG r14,"Instruction to execute out of line is "
 ]
        AND     r0, r14, #&0F000000     ; If it's a Bxx, correct for new loc'n
        TEQ     r0,      #&0A000000
        LDREQB  r0, SysIs32bit
        TEQEQ   r0, #0                  ; only works for 26-bit, probably
        MOVEQ   r0, r14, LSL #8
        ADDEQ   r0, r0, r1, LSL #6      ; r0 = destination of branch-8
 [ debug
 BNE %FT00
 MOV r0, r0, LSR #6
 DREG r0,"continuing a branch, destination-8 = "
 MOV r0, r0, LSL #6
00
 ]
        SUBEQ   r0, r0, r8, LSL #6
        ANDEQ   r2, r14, #&FF000000     ; Copy condition codes + instruction
        ORREQ   r14, r2, r0, LSR #8     ; Munge back together
 [ debug
 BNE %FT00
 DREG r14,"replacing instruction with "
00
 ]
        STR     r14, ExecuteBuffer

        LDR     r14, =&E51FF004         ; LDR PC,[PC,#-4]
        STR     r14, ExecuteBuffer+4
        ADD     r14, r1, #4             ; address of next instruction in
        STR     r14, ExecuteBuffer+8    ; real program
 [ StrongARM
        ;Best IMB the ExecuteBuffer here
        MOV     r0, #1                  ; Guess what? It's a ranged sync
        ADR     r1, ExecuteBuffer
        ADD     r2, r1, #ExeBufLen
        SWI     XOS_SynchroniseCodeAreas
 ]
        ADR     r0, ExecuteBuffer+12    ; and drop into ...


90 ; Nice simple continuation. r0 -> register state to continue with

        LDRB    r14, SysIs32bit
        TEQ     r14, #0
        BNE     Continue32

        LDR     r14_svc, [r0, #15*4]
        ANDS    r14_svc, r14_svc, #SVC_mode
        BEQ     %FT95                   ; [user mode harder]

        TEQP    r14_svc, #F_bit + I_bit ; Enter correct mode, ints off
        NOP
        LDMIA   r0, {r0-pc}^            ; Restore int state, r0 never banked


95      MOV     r14_svc, r0
        LDMIA   r14_svc, {r0-r12, r13_usr, r14_usr}^
        NOP
        LDR     r14_svc, [r14_svc, #15*4]
        MOVS    pc, r14_svc             ; Jump to instruction in right mode

Continue32

        LDR     r14_svc, [r0, #16*4]
        TST     r14_svc, #2_01111
        BEQ     %FT97                   ; [user mode harder]

        TST     r14_svc, #2_11100
        ORREQ   r1, r14_svc, #&10+F32_bit+I32_bit ; convert 26-bit modes to 32-bit form
        ORRNE   r1, r14_svc, #F32_bit+I32_bit ; otherwise, just ints off
        MSR     CPSR_c, r1              ; Enter correct mode, ints off
        MSR     SPSR_cxsf, r14_svc      ; Set up SPSR ready for return
        LDMIA   r0, {r0-pc}^            ; Restore int state, r0 never banked

97
        MRS     r14_svc, CPSR
        ORR     r14_svc, r14_svc, #I32_bit
        MSR     CPSR_c, r14_svc         ; IRQs off for SPSR use

        LDR     r14_svc, [r0, #16*4]
        MSR     SPSR_cxsf, r14_svc      ; Set up SPSR ready for return

        MOV     r14_svc, r0
        LDMIA   r14_svc, {r0-r12, r13_usr, r14_usr}^
        NOP
        LDR     r14_svc, [r14_svc, #15*4]
        MOVS    pc, r14_svc             ; Jump to instruction in right mode



ContinueError1
        MOV     r14, #-1
        STR     r14, [r4, r3]           ; Only need to zap address field
        BL      message_writes
        DCB     "M41", 0                ; "Bad breakpoint at &"
        ALIGN
        MOVVC   r10, r1
        BLVC    DisplayHexWord
        EXIT    VS
        BL      message_writes
        DCB     "M42", 0                ; "; cleared."
        ALIGN
        SWIVC   XOS_NewLine
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Debug_Code

        LDR     wp, [r12]

; .............................................................................

Debug_Code_Common Entry "r6-r11"

10
        BL      message_writes
        DCB     "M43", 0                ; "Debug*"
        ALIGN

        ADRVC   r0, StringBuffer
        MOVVC   r1, #?StringBuffer-1
        MOVVC   r2, #space
        MOVVC   r3, #255
        SWIVC   XOS_ReadLine
        EXIT    VS
        BCS     %FT50

        SWIVC   XOS_CLI

40      BLVS    PrintError
        B       %BT10

50      BL      AckEscape

        TEQ     r1, #0                  ; Any chars read ?
        EXIT    EQ                      ; VSet, return error

        SWI     XOS_NewLine             ; Need to print a NewLine as we
        SETV                            ; didn't terminate the Iine with CR/LF
        B       %BT40

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

AckEscape Entry "r1, r2"

        MOV     r0, #&7E
        SWI     XOS_Byte

        ADRVC   r0, ErrorBlock_Escape
        BLVC    CopyError
        EXIT

        MakeInternatErrorBlock Escape,,Escape

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PrintError Entry

        ADD     r0, r0, #4
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r10 = number to be displayed
;       r2 = starting bit position

; Out   r0 corrupt if error

DisplayHex Entry "r0, r2"

        CMP     r2, #32
        BHS     %FT20
10      MOV     r0, r10, LSR r2
        AND     r0, r0, #15
        CMPS    r0, #9
        ORRLS   r0, r0, #"0"
        ADDHI   r0, r0, #"A"-10
        SWI     XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS

        SUBS    r2, r2, #4
        BPL     %BT10
        EXIT

20      ; 9 or more digits to display, so we must have received a buffer pointer in r10 instead
        Push    "r10"
        LDR     r10, [r10, #4] ; MSW first
        SUB     r2, r2, #32
        BL      DisplayHex
        LDRVC   r10, [sp]
        LDRVC   r10, [r10] ; then LSW
        MOVVC   r2, #28
        BLVC    DisplayHex
        Pull    "r10"
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Out   r10 corrupt

DisplayHexWord_R9

        MOV     r10, r9

; .............................................................................

DisplayHexWord Entry "r2"

        MOV     r2, #32-4
        BL      DisplayHex
        EXIT

; .............................................................................

DisplayHexHalfword Entry "r2"

        MOV     r2, #16-4
        BL      DisplayHex
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r9 -> core
;       r2 = number of chars to print
;       r6 = access size

; Out   VS: r0 -> error
;       VC: all preserved

DisplayCharacters Entry "r0-r2, r4-r5, r9", 8  ; "r0-r3, r9"

        ADD     r2, r9, r2
10
        MOV     r0, r9
        MOV     r1, sp
        CMP     r6, #8
        ADREQ   lr, %FT14
        BEQ     do_readD
        CMP     r6, #2
        ADR     lr, %FT15
        BLO     do_readB
        BEQ     do_readH
        BHI     do_readW

14      LDMIA   r1, {r1,r5}
15      ADD     r9, r9, r6
        MOV     r4, r1
        MOV     r1, r6
20      AND     r0, r4, #&FF
        CMPS    r0, #delete
        CMPNES  r0, #space-1
        MOVLS   r0, #"."
        SWI     XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        TEQ     r1, #5
        MOVEQ   r4, r5
        MOVNE   r4, r4, LSR #8
        SUBS    r1, r1, #1
        BNE     %BT20

        CMP     r9, r2
        BLO     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r8 = number to display

DisplayDecimalNumber Entry "r0-r2"

        SUB     sp, sp, #16
        MOV     r0, r8
        MOV     r1, sp
        MOV     r2, #16
        SWI     XOS_BinaryToDecimal

        ADD     r2, r2, r1
10      LDRB    r0, [r1], #1
        SWI     XOS_WriteC
        BVS     %FT90
        CMPS    r1, r2
        BLT     %BT10

90      ADD     sp, sp, #16
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r9 = address to consider

MarkBreakpoints Entry "r2, r3"

        ADR     r2, Breaklist
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r14, [r2, r3]
        TEQS    r14, r9
        MOVEQ   r0, #"*"                ; [found]
        BEQ     %FT50
        SUBS    r3, r3, #8
        BPL     %BT10
        MOV     r0, #":"                ; [not found]

50      SWI     XOS_WriteI+space
        SWIVC   XOS_WriteC
        SWIVC   XOS_WriteI+space
        EXIT

; .............................................................................

MarkPC ALTENTRY

        LDRB    r0, SysIs32bit
        LDR     r14, pc_register
        TEQ     r0, #0
        BICEQ   r14, r14, #ARM_CC_Mask
        TEQS    r14, r9
        MOVEQ   r0, #"<"                ; [found]
        MOVNE   r0, #":"                ; [not found]

        B       %BT50                   ; Share some code

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Swap old data back into core, remembering our branches

SwapAllBreakpoints EntryS "r1-r5"

        ADR     r4, Breaklist
        ADD     r5, r4, #4              ; r5 -> old data list to index on
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        CMP     r1, #-1
        LDRNE   r2,  [r1]               ; Get our branch
        LDRNE   r14, [r5, r3]           ; Get old data
        STRNE   r2,  [r5, r3]
        STRNE   r14, [r1]
        SUBS    r3, r3, #8
        BPL     %BT10
        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Code to be relocated into RAM at initialise time

RelocatedCodeStart ROUT

        GBLA    count
count   SETA    0
        WHILE   count < nbreakpoints
        STR     r14, Registers_ROM+14*4 ; Dump current r14 directly
        BL      ClaimBreak              ; pc relative, into RAM code really
count   SETA    count + 1
        WEND

ClaimBreak
        STR     r14, TrapStore_ROM      ; Save id of breakpoint
        ADR     r14, Registers_ROM
        STMIA   r14, {r0-r13}           ; Save registers 0 to 13 in dump area
        LDR     wp, r12Store_ROM
        LDR     pc, JumpStore_ROM       ; Jump to debugger with correct wp

RelocatedCodeEnd ; End of relocated code - next instruction is a patched branch
                 ; to the debugger

 ASSERT RelocatedCodeEnd-RelocatedCodeStart = BreakCodeEnd-BreakCodeStart

TrapStore_ROM   *       (TrapStore - BreakCodeStart) + RelocatedCodeStart
Registers_ROM   *       (Registers - BreakCodeStart) + RelocatedCodeStart
r12Store_ROM    *       (r12Store  - BreakCodeStart) + RelocatedCodeStart
JumpStore_ROM   *       (JumpStore - BreakCodeStart) + RelocatedCodeStart

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; A breakpoint has been hit

BreakTrap ROUT
        MOV     r4, #0
        MRS     r4, CPSR
        TST     r4, #2_11100
        BNE     BreakTrap32

        SWI     XOS_EnterOS             ; And why not too!

        LDR     r1, TrapStore
        AND     r3, r1, #ARM_CC_Mask    ; Save mode and flags
        BIC     r1, r1, #ARM_CC_Mask
        ADR     r0, BreakCodeStart      ; Calculate Breakpoint number we hit
        SUB     r0, r1, r0
        SUB     r0, r0, #8
        ADR     r1, Breaklist
        LDR     r10, [r1, r0]

        LDRB    r2, SysIs32bit
        TEQ     r2, #0

        ORREQ   r10, r10, r3            ; recombine pc+psr for a 26-bit dump
        STREQ   r10, pc_register

        STRNE   r10, pc_register        ; separate pc+psr for a 32-bit dump
        STRNE   r4, psr_register

        BIC     R10,R10,#ARM_CC_Mask

BreakTrapCommonExit
        BL      message_writes
        DCB     "M44", 0
        ALIGN

        BLVC    DisplayHexWord          ; Tee hee, nowhere to go if VS! <<<
        SWIVC   XOS_NewLine

        BLVC    ShowRegs_Code_Common
        BLVC    Debug_Code_Common

        SWI     XOS_NewLine
        SWI     XOS_Exit


; When we're hit in a 32-bit mode
BreakTrap32

        SWI     XOS_EnterOS             ; And why not too!

        LDR     r1, TrapStore
        ADR     r0, BreakCodeStart      ; Calculate Breakpoint number we hit
        SUB     r0, r1, r0
        SUB     r0, r0, #8
        ADR     r1, Breaklist
        LDR     r10, [r1, r0]

        LDRB    r2, SysIs32bit
        TEQ     r2, #0

        BICEQ   r2, r10, #ARM_CC_Mask   ; keep r10 whole for message
        ANDEQ   r4, r4, #ARM_CC_Mask    ; although we can't put it in the dump
        ORREQ   r2, r2, r4
        STREQ   r2, pc_register         ; combine pc+psr for a 26-bit dump

        STRNE   r10, pc_register        ; separate pc+psr for a 32-bit dump
        STRNE   r4, psr_register

        B       BreakTrapCommonExit


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> string
;       r2 -> error to generate if naff syntax (ie. no p1, trailing op or junk)

GetCommandParms_R0

        MOV     r1, r0

; .............................................................................
; In    r1 -> string
;       r2 -> error to generate if naff syntax (ie. no p1, trailing op or junk)
;       r10 = flags: Command_64bitData => arg2 (if present) must be returned in buffer
;       r11 = buffer to hold 64-bit arg2 data if found

; Decodes string of form <addr|reg> [[+|-] <addr|reg>]

; Out   r9 = parm1
;       r8 = parm state
;       r7 = parm2

hasparm         *       2_001
parmfollowed    *       2_010
secondparm      *       2_100

; a         -> a, X
; a b       -> a, b
; a + b     -> a, a+b
; a - b     -> a-b, a
; a + b + c -> a+b, a+b+c
; a - b + c -> a-b, a-b+c

GetCommandParms Entry "r2"

 [ debug
 DSTRING r1, "Command tail "
        BL      %FT00
 DREG r9, "p1 ",cc
 DREG r7, " p2 ",cc
 DREG r8, " state ",,Byte
        EXIT

00
        Entry
 ]

        MOV     r10, r10, LSL #1        ; only the last parameter can be 64-bit
        BL      ReadFirstParm           ; r7 := parm
        EXIT    VS

        TST     r8, #hasparm
        BEQ     %FT99                   ; [no parm1, so it's bad news]

        MOV     r9, r7                  ; r9 := parm1

        TST     r8, #parmfollowed
        EXIT    EQ                      ; [no parm2]

        ORR     r8, r8, #secondparm

        TEQ     r0, #"+"
        TEQNE   r0, #"-"
        BNE     %FT50

        ORR     r8, r8, r0, LSL #8      ; has '+' or '-', so skip it
        ADD     r1, r1, #1

50
        MOV     r10, r10, LSR #1        ; restore the Command_64bitData flag if appropriate
        BL      ReadParm                ; r7 := parm2
        EXIT    VS

        TST     r8, #hasparm            ; [no second parm when there should be]
        BEQ     %FT99                   ; [ie. after operator]

        MOVS    r14, r8, LSR #8
        BEQ     %FT80                   ; [no operator]

        TEQ     r14, #"+"               ; addition ?
        ADDEQ   r7, r9, r7              ; -> a, a+b
        SUBNE   r14, r9, r7             ; subtraction then
        MOVNE   r7, r9
        MOVNE   r9, r14                 ; -> a-b, a

        TST     r8, #parmfollowed
        EXIT    EQ                      ; [no second operator]

        TEQ     r0, #"+"                ; so we can *mi base -offset1 +offset2
        BNE     %FT99                   ;        or *mi base +offset1 +offset2

        Push    "r7, r14"               ; save r7, first operator
        ADD     r1, r1, #1              ; skip '+'
        BL      ReadParm                ; r7 := parm3
        Pull    "r1, r14"
        EXIT    VS

        TEQ     r14, #"+"               ; it does work, honest ...
        MOVEQ   r9, r1                  ; a, a+b -> a+b, a+b+c
        ADD     r7, r9, r7              ; a-b, a -> a-b, a-b+c

                                        ; and fall into ...

80      TST     r8, #parmfollowed
        EXIT    EQ                      ; [no trailing non-blank muck]


99      LDR     r0, [sp]
        SETV
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string

; Out   r7 = value of parm
;       r8 = parm state
;       r0 = next ~space char

ReadFirstParm ROUT

        MOV     r8, #0                  ; nowt so far

; .............................................................................

ReadParm Entry "r2"

 [ debug
 DSTRING r1, "ReadParm "
        BL      %FT00
 DREG r7, "parm ",cc
 DREG r8, ", state "
        EXIT

00
        Entry
 ]
        BIC     r8, r8, #hasparm + parmfollowed ; in all cases

        BL      SkipSpaces
        EXIT    LO

        ORR     r0, r0, #&20            ; Cheap and nasty lowercase

        TEQ     r0, #"r"
        BEQ     %FT50                   ; register

        LDRB    r7, SysIs32bit

        TEQ     r0, #"p"
        BNE     %FT20
        MOV     r0, #"c"                ; Expect 'c'
        TEQ     r7, #0
        LDR     r7, pc_register
        BICEQ   r7, r7, #ARM_CC_Mask    ; knock off psr bits for "pc" but not for "r15"
        B       %FT60

20      TEQ     r0, #"l"
        BNE     %FT30
        MOV     r0, #"r"                ; Expect 'r'
        TEQ     r7, #0
        LDR     r7, Registers + 14*4
        BICEQ   r7, r7, #ARM_CC_Mask    ; knock off psr bits for "lr" but not for "r14"
        B       %FT60

30      TEQ     r0, #"s"
        MOVEQ   r0, #"p"                ; Expect 'p'
        LDREQ   r7, Registers + 13*4
        BEQ     %FT60

        TEQ     r0, #"w"
        MOVEQ   r0, #"p"                ; Expect 'p'
        LDREQ   r7, Registers + 12*4
        BEQ     %FT60


40
        TST     r10, #Command_64bitData
        BNE     %FA47
        MOV     r0, #16                 ; allow any term, read hex
        SWI     XOS_ReadUnsigned
        MOVVC   r7, r2

45      EXIT    VS

        BL      SkipSpaces
        ORR     r8, r8, #hasparm
        ORRCS   r8, r8, #parmfollowed
        EXIT

47      Push    "r1,r3,r4"
        MOV     r0, #16
        ORR     r0, r0, #1 :SHL: 28
        LDR     r4, =&45444957
        SWI     XOS_ReadUnsigned        ; do a 64-bit read to r2,r3
        TST     r4, #1 :SHL: 28         ; old OS with no 64-bit read?
        MOVEQ   r0, #16
        LDREQ   r1, [sp]
        MOVEQ   r3, #0
        SWIEQ   XOS_ReadUnsigned        ; then try again, reading a 32-bit number
        STMIA   r11, {r2,r3}
        MOV     r7, #0
        ADD     sp, sp, #4
        Pull    "r3,r4"
        B       %BA45


50      ADD     r1, r1, #1
        MOV     r0, #(2_001 :SHL: 29) + 10 ; allow any term, read decimal, rest
        MOV     r2, #15
        SWI     XOS_ReadUnsigned

        ADRVC   r14, Registers
        LDRVC   r7, [r14, r2, LSL #2]   ; load register n from dump
        TST     r10, #Command_64bitData
        MOV     lr, #0
        STMNEIA r11, {r7,lr}
        B       %BA45


60      LDRB    r14, [r1, #1]
        ORR     r14, r14, #&20          ; Cheap and nasty lowercase
        TEQ     r14, r0                 ; Expected ?
        BNE     %BT40                   ; give error from ReadUnsniged

        TST     r10, #Command_64bitData
        MOV     lr, #0
        STMNEIA r11, {r7,lr}
        ADD     r1, r1, #2              ; skip 'pc'
        B       %BA45                   ; and skip spaces

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string
;       r0 -> error to generate if parmfollowed

; Out   r7, r8 from ReadFirstParm

ReadOneParm Entry "r0"

        BL      ReadFirstParm           ; r7 := parm
        EXIT    VS

        TST     r8, #parmfollowed
        LDRNE   r0, [sp]
        SETV    NE
        STRVS   r0, [sp]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string

; Out   r0 = first non-space char
;       flags from CMP r0, #space for eol detection. (LO -> r0 = CtrlChar)

SkipSpaces ROUT

10      LDRB    r0, [r1], #1
        CMPS    r0, #space
        BEQ     %BT10
        SUB     r1, r1, #1      ; Leave r1 -> ~space
        MOV     pc, lr          ; r0 = first ~space

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = branch destination
;       r1 = branch location (ie. where it is executed)

; Out   r2 = branch instruction

MakeBranch ROUT

        SUB     r2, r0, r1
        SUB     r2, r2, #8
        MOV     r2, r2, ASR #2
        BIC     r2, r2, #&FF000000
        ORR     r2, r2, #&EA000000      ; BAL instruction
 [ debug
 DREG r0,"Branch instruction to get to ",cc
 DREG r1," from ",cc
 DREG r2," is "
 ]
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r3 = breakpoint number*8

; Out   r2 = instruction
MakeMOVPC ROUT
        ASSERT  DebuggerSpace < &400
        LDR     r2, =&E3A0FF00 + (DebuggerSpace :SHR: 2)
        ADD     r2, r2, r3, LSR #2
        MOV     pc, lr


lookup_r10 Entry r0-r7
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r10
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r10, r2
        EXIT

message_writes
        Entry   r0-r7
        SUB     r0, lr, pc              ; processor independent
        ADD     r0, pc, r0              ; extraction of pc from lr
        SUB     r0, r0, #4
        MOV     r2, r0
10      LDRB    r1, [r2], #1
        TEQS    r1, #0
        BNE     %B10
        SUB     r2, r2, r0
        ADD     r2, r2, #3
        BIC     r2, r2, #3
        ADD     lr, lr, r2
        STR     lr, [sp, #8 * 4]
        B       message_write0_tail

message_write0 Entry r0-r7
message_write0_tail
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMPS    r0, #32
        SWIHS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        EXIT

CopyErrorP1 Entry r1-r7
        BL      open_messagefile
        EXIT    VS
        ADRL    R4,Debug_Title
        B       CopyError0

CopyErrorR2
        MOV     R0,R2

CopyError Entry r1-r7
        BL      open_messagefile
        EXIT    VS
        MOV     R4, #0
CopyError0
        ADR     R1, MessageFile_Block
        ADR     R2, StringBuffer
        MOV     R3, #?StringBuffer
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.Debugger.Messages", 0

        ALIGN

open_messagefile Entry r0-r2
        LDR     r0, MessageFile_Open
        CMPS    r0, #0                  ; clears V
        EXIT    NE
        ADR     R0, MessageFile_Block
        ADR     R1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


        LTORG

      [ standalone
declareresourcefsfiles
        Entry "r0"

        ADR     R0,resourcefsfiles
        SWI     XResourceFS_RegisterFiles   ; ignore errors
        CLRV
        EXIT

resourcefsfiles
	ResourceFile	$MergedMsgs, Resources.Debugger.Messages
	DCD	0
      ]

 [ debug
        InsertDebugRoutines
 ]

        LNK     s.ARMv6
