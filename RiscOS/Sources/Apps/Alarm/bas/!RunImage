REM Copyright 2011 Castle Technology Ltd
REM
REM Licensed under the Apache License, Version 2.0 (the "License");
REM you may not use this file except in compliance with the License.
REM You may obtain a copy of the License at
REM
REM     http://www.apache.org/licenses/LICENSE-2.0
REM
REM Unless required by applicable law or agreed to in writing, software
REM distributed under the License is distributed on an "AS IS" BASIS,
REM WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
REM See the License for the specific language governing permissions and
REM limitations under the License.
REM
REM  > !RunImage
REM
ON ERROR ERROR EXT ERR,LEFT$(REPORT$,240) +" ("+STR$(ERL)+")"
PROCerr_init

PROCinitialise
SYS "OS_ReadMonotonicTime" TO timex%:timex%+=100

WHILE TRUE
 err% =FALSE
 ON ERROR LOCAL :err% =TRUE

 IF err% =TRUE THEN
  ON ERROR :ON ERROR OFF :ERROR ERR,LEFT$(REPORT$,240) +" ("+STR$(ERL)+")"
  PROCerr_report(ERR,REPORT$,%11)
 ELSE
  SYS "XWimp_PollIdle",0,Q%,timex% TO A%
  CASE A% OF
  WHEN 0    :PROCnudge
  WHEN 1    :PROCredraw_browser
  WHEN 2    :PROCopenwindow
  WHEN 3    :cancel%=TRUE
             PROCclosewindow(!Q%)
  WHEN 5    :IF !Q%=m_wind% THEN
              IF alarm_counter%=0 PROCset_timex_for_next_second
              alarm_counter%=global_timeout%
             ENDIF
  WHEN 6    :PROCfix_click(Q%)
             PROCcheckmouse(!Q%,Q%!4,Q%!8,Q%!12,Q%!16)
  WHEN 7    :PROCdecodedrag
  WHEN 8    :CASE TRUE OF
             WHEN FNfix_key(Q%),FNkey(!Q%,Q%!4,Q%!24)
             OTHERWISE
              SYS"Wimp_ProcessKey",Q%!24
             ENDCASE

  WHEN 9    :PROCmenuselect(Q%)
  WHEN 17,18:PROCreceive(A%)
  WHEN 19   :PROCacknowledge
  ENDCASE
 ENDIF
ENDWHILE
END
:
DEFPROCinitialise

PROCmsg_init("Alarm:Messages")
PROCinit_constants

REM this has to be declared here because the increased use
REM of messages has meant that this block is now use
REM practically everywhere
REM Because it is also used for loading templates into (temporarily)
REM we must make sure that it is big enough for the largest template
REM we are going to load, hence FNQsize.
DIM Q% FNQsize

PROCinit_heap_constants
PROCinit_arrays
PROCinit_date_and_time
PROCinit_task
spr_area% =0
PROCinit_templates
PROCinit_config
PROCinit_globals
PROCinit_codevar
PROCinit_timediff
PROCload_alarms_into_memory(ra$)
ENDPROC
:
DEFPROCinit_task
LOCAL E%,E1%,s$
task_id$=FNmsg_0("TaskID")
REM define the block of messages wanted by Alarm
Q%!0=2
Q%!4=3
Q%!8=5
Q%!12=8
Q%!16=10
Q%!20=&500
Q%!24=&501
Q%!28=&502
Q%!32=&400C0
Q%!36=&400C1
Q%!40=&400C2
Q%!44=&400C9
Q%!48=&400CF :REM new Message_FontChanged
Q%!52=0
SYS"Wimp_Initialise",380,&4B534154,task_id$,Q% TO wimpversion%,taskid%
REM work out whether or not a filename was provided on the command line
SYS"OS_GetEnv" TO E%
SYS"OS_ReadArgs","/g,quit/s,/g,/g",E%,Q%,2048
E%=Q%!12
s$=""
IFE% THEN
 E1%=!E% AND &FFFF
 E%+=2
 WHILE E1%
  s$+=CHR$(?E%)
  E%+=1
  E1%-=1
 ENDWHILE
ENDIF
IFs$<>"" ra$=s$
ENDPROC
:
DEFPROCinit_globals
LOCAL f%
SYS"OS_Byte",161,&1C TO ,,f%
IF(f% AND 2)=0 THEN
 REM CMOS has turned DragASprite off
 save_start%=-1
 save_stop%=-1
ELSE
 REM Use DragASprite if available
 SYS"XOS_SWINumberFromString",,"DragASprite_Start" TO save_start%;f%
 IF(f% AND 1) save_start%=-1
 SYS"XOS_SWINumberFromString",,"DragASprite_Stop" TO save_stop%;f%
 IF(f% AND 1) save_stop%=-1
ENDIF
userformat$=FNread_string(setup%,30)
menuhand%=-1
current_action%=-1
setclock_action%=-1
cancel%=FALSE
modified%=FALSE
autosaved%=FALSE
doing_deleting%=FALSE
doing_shutdown%=0
ictime%=-1
alarm_head%=0
alarm_count%=0
alarm_set%=FALSE
user_alarm_set%=FALSE
alarm_original_pointer%=0
alarm_warned%=FALSE
bst_alarm_1%=0
bst_alarm_2%=0
bst_alarm_3%=0
timex%=0
cur_textlen% =0
cur_format$ =""
PROCset_format(format%)
ENDPROC
:
DEFFNtotal_indirect_size
REM Returns the total size of all indirect fields in a
REM template file (which must already have been opened)
LOCAL total%, size%, here%
LOCAL name%

DIM name% 12
$name% = "*"
here%  = 0
total% = 0

SYS "Wimp_LoadTemplate", ,0,,,,name%,0 TO ,,size%,,,,here%
WHILE (here% <> 0)
 total% += size%
 $name% = "*"
 SYS "Wimp_LoadTemplate", ,0,,,,name%,here% TO ,,size%,,,,here%
ENDWHILE
=total%
:
DEFFNicon_indirect(icon%, window%)
REM Returns a pointer to the indirected text area of icon icon%
REM in window window%
LOCAL here%, loop%
loop% = 0
IF (icon% > window%!84) THEN
 = -1
ELSE
 here% = window% + 88
 WHILE (loop% <> icon%)
  here% += 32
  loop% += 1
 ENDWHILE
ENDIF
=here%!20
:
DEFFNiconblock_indirect(icon%, window%)
REM Similar to FNicon_indirect, but returns a pointer to the
REM iconblock corresponding to icon%
LOCAL here%, loop%
loop% = 0
IF (icon% > window%!84) THEN
 = -1
ELSE
 here% = window% + 88
 WHILE (loop% <> icon%)
  here% += 32
  loop% += 1
 ENDWHILE
ENDIF
= here%
:
DEFFNicon_size_indirect(icon%, window%)
REM Returns the size of an indirected icon.
LOCAL here%, loop%
loop% = 0
IF (icon% > window%!84) THEN
 = -1
ELSE
 here% = window% + 88
 WHILE (loop% <> icon%)
  here% += 32
  loop% += 1
 ENDWHILE
ENDIF
= here%!28
:
DEFFNsize_indirect(name$)
LOCAL size%
SYS "Wimp_LoadTemplate",,0,,,,name$,0 TO ,,size%
= size%
:
DEFFNwinsize_indirect (name$)
LOCAL size%
SYS "Wimp_LoadTemplate",,0,,,,name$,0 TO ,size%
= size%
:
DEFPROCopen_templates
LOCAL a%,n$
SYS"OS_Byte",161,&8C TO ,,a%
IF (a%AND1)=1 THEN
 SYS"OS_File",17,r$+"Template3D" TO a%
 IFa%=1 n$="Template3D" ELSE n$="Templates"
ELSE
 n$="Templates"
ENDIF
SYS"Wimp_OpenTemplate",,r$+n$
ENDPROC
:
DEFFNQsize
LOCAL i%,s%,t%
s%=3000 : REM Minimum size for buffer Q%
PROCopen_templates
i%=0
REPEAT
 SYS "Wimp_LoadTemplate",,-1,,,-1,"*"+STRING$(11,CHR$(0)),i% TO ,t%,,,,,i%
 IF i%<>0 AND s%<t% s%=t%
UNTIL i%=0
SYS "Wimp_CloseTemplate"
=s%
:
DEF FNload_template(temp$)
LOCAL ind%,ind_space%,win%
ind% = FNsize_indirect (temp$)
DIM ind_space% ind%
SYS"Wimp_LoadTemplate",,Q%,ind_space%,ind_space% + ind%,-1,temp$,0 TO ,,,,,,r6%
IFr6%=0 ERROR 0, FNmsg_1("Fatal5",temp$)
SYS"Wimp_CreateWindow",,Q% TO win%
=win%
:
DEFPROCinit_templates
LOCAL ind%

PROCopen_templates

REM we fix 4 dialogue windows
PROCfix_init(4)

a_wind% =FNload_template("alarm")
PROCfix_dialogue(a_wind%,FNmsg_0("Fix00"),FNmsg_0("Fix10"),"","")
c_wind% =FNload_template("clock")
PROCfix_dialogue(c_wind%,FNmsg_0("Fix01"),FNmsg_0("Fix10"),"","")
m_wind% =FNload_template("message")
PROCfix_dialogue(m_wind%,"NotUsed!",FNmsg_0("Fix11"),"","")
setup% =FNload_template("setup")
PROCfix_dialogue(setup%,FNmsg_0("Fix01"),FNmsg_0("Fix10"),FNmsg_0("SHlpIA"),FNmsg_0("SHlpIB"))
info% =FNload_template("info")
browser% =FNload_template("browser")
browse1% =FNload_template("browse1")
warning% =FNload_template("warning")
deleting% =FNload_template("deleting")
bstwarn% =FNload_template("outofdates")

save% =FNload_template("save")
!Q% =save%
Q%!4 =2
SYS "Wimp_GetIconState",,Q%
filename%=Q%!28

slow% =FNload_template("slow")

SYS"Wimp_CloseTemplate"

PROCset_string(info%,3,FNmsg_0("_Version"))
!Q%=browser%:Q%!4=2:SYS"Wimp_GetIconState",,Q%:SYS"Wimp_DeleteIcon",,Q%
assembler%!4=Q%!16:REM right hand end of day icon
!Q%=browser%:Q%!4=0:SYS"Wimp_GetIconState",,Q%:SYS"Wimp_DeleteIcon",,Q%
assembler%!8=Q%!16:REM right hand end of date icon
!Q%=browser%:Q%!4=1:SYS"Wimp_GetIconState",,Q%:SYS"Wimp_DeleteIcon",,Q%
assembler%!12=Q%!16:REM right hand end of time icon
ENDPROC
:
DEFPROCinit_constants
LOCAL I%,J%
r$="Alarm:"
def_fn$="Choices:Alarm.Alarms"
ra$=def_fn$
setting%=0
changing%=2
finding%=3
clocking%=4
mess1%=16
mess2%=17
mess3%=18
ENDPROC
:
DEFPROCinit_arrays
LOCAL I%,t%
REM Various alarm pointers are used:
REM 0 : alarm currently being modified by the user
REM 1 : alarm currently being monitored by !Alarm
REM 2 : general scratch pointer
REM 3 : bst copy alarm 1
REM 4 : bst copy alarm 2
DIM alarms%(4)
DIM sin(59),cos(59)
DIM Q1% 1024
DIM Q2% 1024
DIM cur_clock% 6
DIM deftime% 5
DIM buffers% 64
DIM menufree% 256:menuend%=menufree%+256
DIM validation_buffer% 64
DIM menu_ws% 256:menu_curws%=menu_ws%:menu_maxws%=256
REM need to claim one block of an alarm record
REM for the clock setting
DIM t% alarm_SIZE%:alarms%(2)=t%
FOR I%=0 TO 59
 sin(I%)=SINRAD(I%*6)
 cos(I%)=COSRAD(I%*6)
NEXT
SYS"OS_File",17,"Alarm:Code" TO t%,,,,I%
IFt%<>1 PROCok(FNmsg_0("OkayD1"))
DIM assembler% I%
SYS"OS_File",16,"Alarm:Code",assembler%,&80000000:REM Use R2 address and flush I cache
ENDPROC
:
DEFFNread_system_string(v$,default$)
LOCAL P%
SYS"XOS_ReadVarVal",v$,Q%,-1,0,3 TO ,,P%
IF P%=0 :=default$
SYS"XOS_ReadVarVal",v$,Q%,2048,0,3 TO ,,P%
Q%?P%=13
=$Q%
:
DEFPROCread_date_and_time(I%)
LOCAL hr%,mi%,da%,mo%,yr%
REM get the current date and time and store it
REM in the specified alarm record as local ordinals
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCread_date_and_time")
PROCfivebt_to_ordinals(cur_clock%,hr%,mi%,da%,mo%,yr%)
I%!alarm_year%=yr%
I%!alarm_month%=mo%
I%!alarm_date%=da%
I%!alarm_hours%=hr%
I%!alarm_minutes%=mi%
ENDPROC
:
DEFPROCcopy_alarm_to_validated(I%)
REM copy the alarm values into the validated values
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCcopy_alarm_to_validated")
I%!valid_year%=I%!alarm_year%
I%!valid_month%=I%!alarm_month%
I%!valid_date%=I%!alarm_date%
I%!valid_hours%=I%!alarm_hours%
I%!valid_minutes%=I%!alarm_minutes%
ENDPROC
:
DEFPROCswap_alarm_and_validated(I%)
REM swap the values over!
SWAP I%!valid_year%, I%!alarm_year%
SWAP I%!valid_month%, I%!alarm_month%
SWAP I%!valid_date%, I%!alarm_date%
SWAP I%!valid_hours%, I%!alarm_hours%
SWAP I%!valid_minutes%, I%!alarm_minutes%
ENDPROC
:
DEFPROCcopy_validated_to_alarm(I%)
REM copy the validated values into the alarm values
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCcopy_validated_to_alarm")
I%!alarm_year%=I%!valid_year%
I%!alarm_month%=I%!valid_month%
I%!alarm_date%=I%!valid_date%
I%!alarm_hours%=I%!valid_hours%
I%!alarm_minutes%=I%!valid_minutes%
ENDPROC
:
DEFFNhour(I%)
REM return the hours from the specified
REM alarm record as a string formatted by Time10
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNtime")
PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time10"))
:
DEFFNmin(I%)
REM return the minutes from the specified
REM alarm record as a string formatted by Time11
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNtime")
PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time11"))
:
DEFFNam(I%)
REM return the am/pm from the specified
REM alarm record as a string formatted by Time13
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNtime")
PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time13"))
:
DEFFNtime(I%)
REM return the hours and minutes from the specified
REM alarm record as a string formatted by Time01
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNtime")
PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time01"))
:
DEFFNdate(I%)
REM return the date from the specified alarm record
REM as a string formatted by Time02
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNdate")
PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time02"))
:
DEFFNday(I%)
REM return the day of the month from the specified alarm record
REM as a string formatted by Time12
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNdate")
PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time12"))
:
DEFFNmonth(I%)
REM return the month from the specified alarm record
REM as a string formatted by Time03
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNmonth")
PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time03"))
:
DEFFNdow(I%)
REM return the day of the week from the specified alarm record
REM as a string formatted by Time14
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNmonth")
PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time14"))
:
DEFFNyear(I%)
REM return the year from the specified alarm record
REM as a string formatted by Time04
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNyear")
PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time04"))
:
DEFFNread_repeat_day(I%)
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNread_repeat_day")
=(I%?alarm_repeat_rate% AND 7)
:
DEFFNread_repeat_offset(I%)
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNread_repeat_offset")
=(I%?alarm_repeat_rate% DIV 8)
:
DEFPROCwrite_repeat_day(I%,V%)
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCwrite_repeat_day")
I%?alarm_repeat_rate%=(FNread_repeat_offset(I%) << 3) + V%
ENDPROC
:
DEFPROCwrite_repeat_offset(I%,V%)
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCwrite_repeat_offset")
I%?alarm_repeat_rate%=(V% << 3) + FNread_repeat_day(I%)
ENDPROC
:
DEFPROCtell_pinboard(handle%)
REM broadcast Message_WindowClosed for the window
!buffers%=24
buffers%!12=0
buffers%!16=&400CB
buffers%!20=handle%
SYS"Wimp_SendMessage",17,buffers%,0
ENDPROC
:
DEFPROCopen_alarm_wind
LOCAL X%,Y%
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCopen_alarm_wind")
IF wimpversion%>243 THEN
 !Q%=-2
 SYS"Wimp_GetWindowState",,Q%
 Y%=Q%!4-Q%!20
 !Q%=-2:Q%!4=ictime%
 SYS "Wimp_GetIconState",,Q%
 X%=Y%+Q%!16-820
ELSE
 !Q%=-1:Q%!4=ictime%
 SYS "Wimp_GetIconState",,Q%
 X%=Q%!16-820
ENDIF
PROCtell_pinboard(a_wind%)
!Q%=a_wind%
SYS "Wimp_GetWindowState",,Q%
Q%!12=(Q%!12-Q%!4)+X%
Q%!16=140+608
Q%!4=X%
Q%!20=0
Q%!24=0
Q%!28=-1
SYS "Wimp_OpenWindow",,Q%
PROCtoggle_size(a_wind%,alarm_repeating%?alarms%(0)<>0)
ENDPROC
:
DEFPROCopen_setclock_wind
LOCAL X%,Y%
IF wimpversion%>243 THEN
 !Q%=-2
 SYS"Wimp_GetWindowState",,Q%
 Y%=Q%!4-Q%!20
 !Q%=-2:Q%!4=ictime%
 SYS "Wimp_GetIconState",,Q%
 X%=Y%+Q%!16-820
ELSE
 !Q%=-1:Q%!4=ictime%
 SYS "Wimp_GetIconState",,Q%
 X%=Q%!16-820
ENDIF
PROCtell_pinboard(c_wind%)
!Q%=c_wind%
SYS "Wimp_GetWindowState",,Q%
Q%!12=(Q%!12-Q%!4)+X%
Q%!16=(Q%!16-Q%!8)+140
Q%!4=X%
Q%!8=140
REM scroll must be same as in template to work...
REMQ%!20=0
REMQ%!24=0
Q%!28=-1
SYS "Wimp_OpenWindow",,Q%
ENDPROC
:
DEFPROCcreate_setclock_wind(t$,i$)
PROCset_title(c_wind%,t$)
PROCset_string(c_wind%,5,i$)
PROCrefresh_window(c_wind%,alarms%(2))
ENDPROC
:
DEFPROCcreate_alarm_wind(t$,W%,I%)
LOCAL E%,F%,B%
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCcreate_alarm_wind")
B%=(1<<21)+(15<<12)
IF I%?alarm_applalarm% W%=FALSE
IF W% F%=15<<12:E%=11<<12 ELSE F%=0:E%=0
PROCset_title(a_wind%,t$)

PROCrefresh_window(a_wind%,I%)

IF I%?alarm_applalarm% THEN
 PROCset_string(a_wind%,16,FNmsg_0("ActvA5"))
 PROCset_string(a_wind%,17,$(I%+alarm_line1%))
 PROCset_string(a_wind%,18,"")
ELSE
 PROCset_string(a_wind%,16,$(I%+alarm_line1%))
 PROCset_string(a_wind%,17,$(I%+alarm_line2%))
 PROCset_string(a_wind%,18,$(I%+alarm_line3%))
ENDIF
PROCsetstate(a_wind%,16,F%,15<<12)
PROCsetstate(a_wind%,17,F%,15<<12)
PROCsetstate(a_wind%,18,F%,15<<12)
REM urgent toggle
PROCsetstate(a_wind%,5,E%,B%)
IF I%?alarm_urgent% PROCsetstate(a_wind%,5,1<<21,0)
REM repeating alarm toggle
PROCsetstate(a_wind%,19,E%,B%)
REM either every
PROCsetstate(a_wind%,32,E%,B%)
REM or on the
PROCsetstate(a_wind%,33,E%,B%)
PROCset_repeat_flags(W%,I%)
REM task alarm toggle
PROCsetstate(a_wind%,29,E%,B%)
IF I%?alarm_taskalarm% THEN
 PROCsetstate(a_wind%,29,1<<21,0)
 REM disable urgent button if task alarm
 PROCsetstate(a_wind%,5,1<<22,1<<22)
ELSE
 REM enable urgent button if not task alarm
 PROCsetstate(a_wind%,5,0,1<<22)
ENDIF
REM five day week toggle
PROCsetstate(a_wind%,30,E%,B%)
IF I%?alarm_fvdywk% PROCsetstate(a_wind%,30,1<<21,0)
ENDPROC
:
DEFPROCset_repeat_flags(W%,Z%)
REM W% is true if the user can manipulate the values
REM Z% is the alarm index
LOCAL I%,J%,A%,R%,S%
REM IFFNcheck_pointer PROCcheck_pointer(Z%,"PROCset_repeat_flags")
CASE Z%?alarm_repeating% OF
WHEN 0: PROCsetstate(a_wind%,19,0,1<<21)
        PROCsetstate(a_wind%,32,0,1<<21)
        PROCsetstate(a_wind%,33,0,1<<21)
        FOR I%=20 TO 28
         PROCsetstate(a_wind%,I%,1<<22,3<<21)
        NEXT
        FOR I%=34 TO 42
         PROCsetstate(a_wind%,I%,1<<22,3<<21)
        NEXT
        PROCset_string(a_wind%,27,STR$(Z%?alarm_repeat_mult%))
        PROCset_string(a_wind%,35,FNmsg_0("SR"+STR$(FNread_repeat_offset(Z%))+"w"+STR$(FNread_repeat_day(Z%))))
        PROCset_string(a_wind%,38,FNmsg_0("WE"+STR$(FNread_repeat_day(Z%))+"a"+STR$(FNread_repeat_offset(Z%))))
        PROCset_string(a_wind%,41,FNmsg_0("MR"+STR$(Z%?alarm_repeat_mult%)))
WHEN 1: PROCset(19)
        PROCset(32)
        S%=Z%?alarm_repeat_rate%
        J%=0
        FOR I%=20 TO 25
         IF W% A%=11<<12 ELSE A%=0
         IF S% AND (1<<J%) A%+=1<<21
         PROCsetstate(a_wind%,I%,A%,(3<<21)+(15<<12))
         J%+=1
        NEXT
        FOR I%=26 TO 28
         PROCsetstate(a_wind%,I%,0,3<<21)
        NEXT
        FOR I%=34 TO 42
         PROCsetstate(a_wind%,I%,1<<22,3<<21)
        NEXT
        PROCset_string(a_wind%,27,STR$(Z%?alarm_repeat_mult%))
WHEN 2: PROCset(19)
        PROCset(33)
        FOR I%=20 TO 28
         PROCsetstate(a_wind%,I%,1<<22,3<<21)
        NEXT
        FOR I%=34 TO 42
         PROCsetstate(a_wind%,I%,0,3<<21)
        NEXT
        IFZ%?alarm_fvdywk% THEN
         PROCcheck_special_day(Z%)
        ELSE
         PROCset_string(a_wind%,38,FNmsg_0("WE"+STR$(FNread_repeat_day(Z%))+"a"+STR$(FNread_repeat_offset(Z%))))
        ENDIF
        PROCset_string(a_wind%,35,FNmsg_0("SR"+STR$(FNread_repeat_offset(Z%))+"w"+STR$(FNread_repeat_day(Z%))))
        PROCset_string(a_wind%,41,FNmsg_0("MR"+STR$(Z%?alarm_repeat_mult%)))
ENDCASE
ENDPROC
:
DEFPROCsetstate(H%,I%,E%,B%)
!Q%=H%:Q%!4=I%:Q%!8=E%:Q%!12=B%
SYS "Wimp_SetIconState",,Q%
ENDPROC
:
DEFPROCset_title(H%,title$)
!Q%=H%:SYS"Wimp_GetWindowInfo",,Q%
$(Q%!76)=title$
ENDPROC
:
DEFPROCset_string(H%,I%,s$)
LOCAL cur_str$
!Q%=H%:Q%!4=I%:SYS "Wimp_GetIconState",,Q%
cur_str$ =$(Q%!28)
IF cur_str$ <>s$ THEN
 $(Q%!28)=s$
 PROCredraw_icon(H%,I%)
ENDIF
ENDPROC
:
DEFFNread_string(H%,I%)
!Q2%=H%:Q2%!4=I%:SYS "Wimp_GetIconState",,Q2%
=$(Q2%!28)
:
DEFPROCfront(h%)
!Q1%=h%:SYS"Wimp_GetWindowState",,Q1%
Q1%!28=-1:SYS"Wimp_OpenWindow",,Q1%
ENDPROC
:
DEFPROCopenwindow
REM task_buff%  = original open window block
REM Q1% = pane window state block
REM Q2% = edit window state block
IF!Q%=browser% THEN
 REM get current state of pane window
 !Q1%=browse1%:SYS "Wimp_GetWindowState",,Q1%
 REM if edit window is above pane window, open the
 REM edit window behind it
 IF Q1%!28 = Q%!28 Q%!28=browse1%
 REM get current state of edit window
 !Q2%=browser%:SYS "Wimp_GetWindowState",,Q2%
 REM if edit window is moving in the direction of
 REM the pane window, open the pane first
 SYS "Wimp_OpenWindow",,Q%:REM open window & get updated coordinates
 IF Q%!28=-2 THEN
  !Q2%=browser%:SYS "Wimp_GetWindowState",,Q2%
  Q%!28=Q2%!28
 ENDIF
 PROCopen_top_pane(Q%,browse1%)
ELSE
 IF!Q%<>browse1% SYS "Wimp_OpenWindow",,Q%
ENDIF
ENDPROC
:
DEFPROCopen_top_pane(block%,handle%)
REM open a pane window at the top of an edit window
REM this routine uses the block passed to it, so it
REM is necessary to save any values which get corrupted
REM by this routine.
LOCAL h%,y%,x1%,x2%,sx%,sy%
h%=!block%
y%=block%!8
x1%=block%!4
x2%=block%!12
sx%=block%!20
sy%=block%!24
REM now adjust the parameters
REM specify the pane window to be opened
!block%=handle%
REM make the pane open just below the edit window
block%!8=block%!16-52:REM pane_height%
REM don't allow the pane window to scroll
block%!20=0
block%!24=0
SYS "Wimp_OpenWindow",,block%
!block%=h%
block%!4=x1%
block%!12=x2%
block%!8=y%
block%!20=sx%
block%!24=sy%
ENDPROC
:
DEFPROCclosewindow(H%)
LOCAL error%
!Q%=H%:PROCtell_pinboard(H%)
SYS "Wimp_CloseWindow",,Q%
IF H%=browser% !Q%=browse1%:SYS"Wimp_CloseWindow",,Q%
IF H%=setup% THEN
 PROCheap_free("ALRM",alarms%(3)):alarms%(3)=0
 PROCheap_free("ALRM",alarms%(4)):alarms%(4)=0
ENDIF
IF H%=c_wind% setclock_action%=-1
IF H%=a_wind% THEN
 REM following bit relies on the fact that
 REM alarm_original_pointer% and alarms%(1) are pointing
 REM to the correct records!
 IF alarm_original_pointer%<>0 AND alarms%(1)<>0 THEN
  REM IFFNcheck_pointer PROCcheck_pointer(alarm_original_pointer%,"PROCclosewindow(alarm_original_pointer%)")
  REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCclosewindow(1)")
  IF (alarm_original_pointer%=alarms%(1)) AND NOT(cancel%) THEN
   !Q%=m_wind%
   SYS "Wimp_CloseWindow",,Q%
  ENDIF
 ENDIF
 IF current_action%<>-1 PROCcancel_current_action
 IFsetclock_action%=finding% PROCclosewindow(c_wind%)
ENDIF
IF H%=m_wind% THEN
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCclosewindow(1)")
 REM following bit relies on the fact that
 REM alarm_original_pointer% and alarms%(1) are pointing
 REM to the correct records!
 IF alarm_original_pointer%<>0 AND alarms%(1)<>0 THEN
  REM IFFNcheck_pointer PROCcheck_pointer(alarm_original_pointer%,"PROCclosewindow(alarm_original_pointer%)")
  IF (alarm_original_pointer%=alarms%(1)) AND current_action%<>setting% THEN
   !Q%=a_wind%
   SYS "Wimp_CloseWindow",,Q%
   PROCcancel_current_action
  ENDIF
 ENDIF
 IF alarm_repeating%?alarms%(1) THEN
  PROCremove_alarm_from_list(alarms%(1),FALSE)
  PROCsave_repeating_alarm(alarms%(1),alarm_repeat_rate%?alarms%(1),alarm_repeat_mult%?alarms%(1),error%)
 ELSE
  PROCremove_alarm_from_list(alarms%(1),TRUE)
  PROCheap_free("ALRM",alarms%(1))
  alarms%(1)=0
  PROCmodified_alarm_database
 ENDIF
 alarm_warned%=FALSE
 PROCreset_alarm_status
 IFerror% PROCok(FNmsg_0("OkayC3"))
ENDIF
cancel%=FALSE
ENDPROC
:
DEFPROCacknowledge
LOCAL error%
IF Q%!16=&501 AND Q%!12=0 THEN
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCacknowledge(1)")
 PROCremove_alarm_from_list(alarms%(1),FALSE)
 PROCread_date_and_time(alarms%(1))
 PROCsave_repeating_alarm(alarms%(1),1,1,error%)
 IFerror% PROCok(FNmsg_0("OkayC5"))
 alarm_warned%=FALSE
 PROCreset_alarm_status
 PROCok(FNmsg_1("OkayA1",$(alarms%(1)+alarm_line1%)))
ENDIF
ENDPROC
:
DEFPROCtransfer_reply(type%,handle%,ref%,size%,filetype%,name$,q20%,q24%,q28%,q32%)
!Q%=(48+LENname$)ANDNOT3
Q%!12=ref%
Q%!16=type%
Q%!20=q20%
Q%!24=q24%
Q%!28=q28%
Q%!32=q32%
Q%!36=size%
Q%!40=filetype%
$(Q%+44)=name$+CHR$0
SYS"Wimp_SendMessage",17,Q%,handle%
ENDPROC
:
DEFPROCreceive(A%)
LOCAL task_handle%,my_ref%,size%,type%,name$,q20%,q24%,q28%,q32%
CASE Q%!16 OF
WHEN 0     :PROCshutdown
WHEN 2     :task_handle%=Q%!4
            my_ref%=Q%!8
            q20%=Q%!20
            q24%=Q%!24
            q28%=Q%!28
            q32%=Q%!32
            size%=Q%!36
            type%=Q%!40
            name$=FNrtoz(Q%+44)
            PROCsavefile((size%<>-1),name$,FALSE)
            PROCtransfer_reply(3,task_handle%,my_ref%,size%,type%,name$,q20%,q24%,q28%,q32%)
WHEN 3     :task_handle%=Q%!4
            my_ref%=Q%!8
            q20%=Q%!20
            q24%=Q%!24
            q28%=Q%!28
            q32%=Q%!32
            size%=Q%!36
            type%=Q%!40
            name$=FNrtoz(Q%+44)
            IF Q%!20=a_wind% THEN
             PROCset_task_alarm_string
             PROCtransfer_reply(4,task_handle%,my_ref%,size%,type%,name$,q20%,q24%,q28%,q32%)
            ELSE
             IF (Q%!20=-2 OR Q%!20=browser%) AND type%=&AE9 THEN
              PROCload_alarms_into_memory(name$)
              PROCtransfer_reply(4,task_handle%,my_ref%,size%,type%,name$,q20%,q24%,q28%,q32%)
             ENDIF
            ENDIF
WHEN 5     :IF Q%!40=&AE9 THEN
             task_handle%=Q%!4
             my_ref%=Q%!8
             q20%=Q%!20
             q24%=Q%!24
             q28%=Q%!28
             q32%=Q%!32
             size%=Q%!36
             type%=Q%!40
             name$=FNrtoz(Q%+44)
             PROCtransfer_reply(4,task_handle%,my_ref%,size%,type%,name$,q20%,q24%,q28%,q32%)
             PROCload_alarms_into_memory(name$)
            ENDIF
WHEN 8     :IFmodified% THEN
             IF!Q%<>20 THEN
              IF(Q%!20 AND 1)=0 doing_shutdown%=2
             ELSE
              doing_shutdown%=2
             ENDIF
             Q%!12=Q%!8
             SYS"Wimp_SendMessage",19,Q%,Q%!4
             !Q%=warning%:SYS"Wimp_GetWindowState",,Q%
             C%=(scrx1%-(Q%!12-Q%!4)) DIV 2
             D%=(scry1%-(Q%!8-Q%!16)) DIV 2
             SYS"Wimp_CreateMenu",,warning%,C%,D%
            ENDIF
WHEN 10    :PROCsave_desktop_state
WHEN &500  :PROCprocess_appl_alarm(A%)
WHEN &501  :PROCprocess_bst_request
WHEN &502  :PROCfix_help(Q%):PROCdetermine_help
WHEN &400C0:CASE Q%!32 OF
            WHEN 1: CASE Q%!36 OF
                    WHEN 3: PROCsave_setup(&FFF,0,1,FNmsg_0("FN1"))
                    WHEN 4: PROCsave_setup(&AE9,0,2,FNmsg_0("FN1"))
                    ENDCASE
            WHEN 4: PROCsave_setup(&FFF,0,3,FNmsg_0("FN2"))
            WHEN 5: PROCsave_setup(&AE9,0,4,ra$)
            ENDCASE
            SYS"Wimp_CreateSubMenu",,Q%!20,Q%!24,Q%!28
WHEN &400C1,&400CF :cur_format$ ="":PROCgettime
WHEN &400C2:IFQ%!4<>taskid% AND FNrtoz(Q%+28)=task_id$ THEN
             Q%!12=0:Q%!16=0:!Q%=20
             SYS"Wimp_SendMessage",17,Q%,Q%!4
             PROCok(FNmsg_0("OkayB9"))
            ENDIF
WHEN &400C9:IFQ%!20=deleting% THEN
             doing_deleting%=FALSE
            ENDIF
            IFFNalarm_selection_count=1 AND NOT(doing_deleting%) AND doing_shutdown%=0 THEN
             PROCunset_alarms_selection
            ENDIF
            IFQ%!20=save% doing_shutdown%=0
            IFQ%!20=warning% AND doing_shutdown%<>3 AND doing_shutdown%<>1 THEN
             REM 1 or 3 means that we have moved to the save dbox
             doing_shutdown%=0
            ENDIF
ENDCASE
ENDPROC
:
DEFPROCsave_setup(filetype%,filesize%,handle%,icon_name$)
LOCAL b$
b$=STR$~(filetype%)
b$=RIGHT$("000"+b$,3)
save_filetype%=filetype%
save_filesize%=filesize%
REM the handle is used PURELY as a reference by the host program as to
REM what is being saved (ie the host program could be capable of
REM producing more than one file and otherwise won't know)
save_handle%=handle%
!Q2%=save%:Q2%!4=3:SYS"Wimp_GetIconState",,Q2%
$(Q2%!32)="sfile_"+b$
!Q2%=save%:Q2%!4=2:SYS"Wimp_GetIconState",,Q2%
$(Q2%!28)=icon_name$
ENDPROC
:
DEFPROCset_task_alarm_string
LOCAL v$
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCset_task_alarm_string(0)")
v$=FNrtoz(Q%+44)
$(alarms%(0)+alarm_line1%)=LEFT$(v$,40):v$=MID$(v$,41)
$(alarms%(0)+alarm_line2%)=LEFT$(v$,40):v$=MID$(v$,41)
$(alarms%(0)+alarm_line3%)=LEFT$(v$,40)
PROCset_string(a_wind%,16,$(alarms%(0)+alarm_line1%))
PROCset_string(a_wind%,17,$(alarms%(0)+alarm_line2%))
PROCset_string(a_wind%,18,$(alarms%(0)+alarm_line3%))
SYS"Wimp_SetCaretPosition",a_wind%,mess1%,-1,-1,-1,LEN($(alarms%(0)+alarm_line1%))
PROCset(29):alarm_taskalarm%?alarms%(0)=TRUE
PROCsetstate(a_wind%,5,1<<22,1<<22)
ENDPROC
:
DEFPROCsave_desktop_state
LOCAL I%,s$
LOCAL ERROR
ON ERROR LOCAL Q%!12=Q%!8:SYS"Wimp_SendMessage",19,Q%,Q%!4:ENDPROC
I%=Q%!20
BPUT#I%,FNbuild_alarm_options
BPUT#I%,"Run "+FNread_system_string("Alarm$Dir","");
IF ra$=def_fn$ BPUT#I%,10 ELSE BPUT#I%," "+ra$:REM Append alarms file location if non default
ENDPROC
:
DEFFNrtoz(P%)
LOCAL t$
WHILE ?P% t$+=CHR$?P%:P%+=1:ENDWHILE
=t$
:
DEFFNicon_set(w%,i%)
Q%!2000=w%:Q%!2004=i%:SYS"Wimp_GetIconState",,Q%+2000
=((Q%!2024 AND 1<<21)<>0)
:
DEFPROCdetermine_help
LOCAL additional_help$,v%
additional_help$=""
IF Q%!36<-1 ENDPROC
CASE Q%!32 OF
WHEN -2: PROCh("AlarmH2")
WHEN browser%,browse1%: PROCh("AlarmHA")
WHEN  setup%:IF Q%!36=40 Q%!36=-1
             IF Q%!36=24 Q%!26=-1
             IF Q%!36=4  Q%!26=-1
             IF Q%!36=11 Q%!26=-1
             CASE Q%!36 OF
             WHEN-1: PROCh("AlarmHB")
             WHEN 0: IF FNicon_set(setup%,0)  PROCh("SHlp0B") ELSE PROCh("SHlp0A")
             WHEN18: PROCh("SHlpIA")
             WHEN 1: IF FNicon_set(setup%,1)  PROCh("SHlp1B") ELSE PROCh("SHlp1A")
             WHEN31,32,33,34,35,36,37:
                     IF FNicon_set(setup%,Q%!36) PROCh("SHlpHA") ELSE PROCh("SHlpHB")
             WHEN38: PROCh("SHlpGA")
             WHEN39: PROCh("SHlpGB")
             WHEN 2: PROCh("SHlpAA")
             WHEN19: IF FNicon_set(setup%,19) PROCh("SHlp2B") ELSE PROCh("SHlp2A")
             WHEN23: IF FNicon_set(setup%,23) PROCh("SHlp3B") ELSE PROCh("SHlp3A")
             WHEN25: PROCh("SHlp4A")
             WHEN27: PROCh("SHlp6A")
             WHEN26: PROCh("SHlp5A")
             WHEN28: PROCh("SHlp7A")
             WHEN29: PROCh("SHlp8A")
             WHEN30: additional_help$=FNconverttime(cur_clock%,FNread_string(setup%,30))
                     IFadditional_help$<>FNmsg_0("FrmtA4") THEN
                      additional_help$=FNmsg_0("SHlpBB")+"|M"+additional_help$
                     ENDIF
                     PROCh("SHlpBA")
             WHEN 3: IF FNicon_set(setup%,3)  PROCh("SHlp9B") ELSE PROCh("SHlp9A")
             WHEN20: PROCh("ClockA8")     :REM BST start time
             WHEN21: PROCh("ClockA7")
             WHEN22: PROCh("SHlpCA")
             WHEN41: PROCh("ClockB1")
             WHEN42: PROCh("ClockA9")
             WHEN 5: PROCh("ClockB2")     :REM BST start date
             WHEN 6: PROCh("SHlpDA")
             WHEN 7: PROCh("ClockB3")
             WHEN 8: PROCh("ClockB4")     :REM BST start month
             WHEN 9: PROCh("SHlpEA")
             WHEN10: PROCh("ClockB5")
             WHEN49: PROCh("ClockB6")     :REM BST start year
             WHEN48: PROCh("SHlpFA")
             WHEN50: PROCh("ClockB7")
             WHEN47: PROCh("ClockA8")     :REM BST end time
             WHEN46: PROCh("ClockA7")
             WHEN45: PROCh("SHlpCB")
             WHEN44: PROCh("ClockB1")
             WHEN43: PROCh("ClockA9")
             WHEN12: PROCh("ClockB2")     :REM BST end date
             WHEN13: PROCh("SHlpDB")
             WHEN14: PROCh("ClockB3")
             WHEN15: PROCh("ClockB4")     :REM BST end month
             WHEN16: PROCh("SHlpEB")
             WHEN17: PROCh("ClockB5")
             WHEN51: PROCh("ClockB6")     :REM BST end year
             WHEN52: PROCh("SHlpFB")
             WHEN53: PROCh("ClockB7")
             ENDCASE
WHEN a_wind%:REM knock out the textual icons that we don't want to help on
             IF Q%!36=15 Q%!36=-1
             IF Q%!36=43 Q%!36=-1
             IF Q%!36=44 Q%!36=-1
             IFcurrent_action%<>setting% additional_help$=FNmsg_0("HelpE5")
             IF Q%!36=-1 THEN
              CASE current_action% OF
              WHEN setting%:PROCh("AlarmH3")
              WHEN changing%:PROCh("AlarmH5")
              ENDCASE
             ELSE
              CASE Q%!36 OF
              WHEN 0:PROCh("ClockA7")
              WHEN 1:PROCh("ClockA8")

              WHEN 2:PROCh("HelpB7")

              WHEN 3:PROCh("ClockA9")
              WHEN 4:PROCh("ClockB1")
              WHEN 5:IF FNicon_set(a_wind%,5) PROCh("HelpA7") ELSE PROCh("HelpA6")
              WHEN 6:PROCh("ClockB2")
              WHEN 7:PROCh("HelpA9")
              WHEN 8:PROCh("ClockB3")
              WHEN 9:PROCh("ClockB4")
              WHEN 10:PROCh("ClockB5")

              WHEN 11:PROCh("HelpA3")

              WHEN 12:PROCh("ClockB6")
              WHEN 13:PROCh("ClockB7")

              WHEN 14:PROCh("HelpA4")

              WHEN 16:PROCh("HelpB8")
              WHEN 17:PROCh("HelpB8")
              WHEN 18:PROCh("HelpB9")
              WHEN 19:IF FNicon_set(a_wind%,19) PROCh("HelpC2") ELSE PROCh("HelpC1")
              WHEN 20:PROCh("HelpC3")
              WHEN 21:PROCh("HelpC4")
              WHEN 22:PROCh("HelpC5")
              WHEN 23:PROCh("HelpC6")
              WHEN 24:PROCh("HelpC7")
              WHEN 25:PROCh("HelpC8")
              WHEN 26:PROCh("HelpC9")
              WHEN 27:PROCh("HelpD1")
              WHEN 28:PROCh("HelpD2")
              WHEN 29:IF FNicon_set(a_wind%,29) PROCh("HelpE2") ELSE PROCh("HelpE1")
              WHEN 30:IF FNicon_set(a_wind%,30) PROCh("HelpE4") ELSE PROCh("HelpE3")
              WHEN 31:CASE current_action% OF
                       WHEN setting%  :PROCh("HelpD3")
                       WHEN changing% :PROCh("HelpD7")
                      ENDCASE
              WHEN 32:PROCh("HelpF7")
              WHEN 33:PROCh("HelpE6")
              WHEN 34:PROCh("HelpF1")
              WHEN 35:PROCh("HelpF4")
              WHEN 36:PROCh("HelpF1")
              WHEN 37:PROCh("HelpF2")
              WHEN 38:PROCh("HelpF5")
              WHEN 39:PROCh("HelpF2")
              WHEN 40:PROCh("HelpF3")
              WHEN 41:PROCh("HelpF6")
              WHEN 42:PROCh("HelpF3")

              WHEN 46:PROCh("HelpB5")
              WHEN 47:PROCh("HelpB4")
              WHEN 48:PROCh("HelpA5")

              WHEN 49:PROCh("HelpG4")
              WHEN 50:PROCh("HelpG3")
              WHEN 51:PROCh("HelpG1")
              WHEN 52:PROCh("HelpG2")
              ENDCASE
             ENDIF
WHEN c_wind%:CASE Q%!36 OF
             WHEN 0:PROCh("ClockA7")
             WHEN 1:PROCh("ClockA8")
             WHEN 3:PROCh("ClockA9")
             WHEN 4:PROCh("ClockB1")
             WHEN 6:PROCh("ClockB2")
             WHEN 8:PROCh("ClockB3")
             WHEN 9:PROCh("ClockB4")
             WHEN 10:PROCh("ClockB5")
             WHEN 12:PROCh("ClockB6")
             WHEN 13:PROCh("ClockB7")
             OTHERWISE :IF setclock_action%=clocking% THEN
                         CASE Q%!36 OF
                         WHEN -1:PROCh("AlarmH6")
                         WHEN 2:PROCh("ClockA5")
                         WHEN 5:PROCh("ClockA2")
                         WHEN 7:PROCh("ClockA3")
                         WHEN 11:PROCh("ClockQ3")
                         WHEN 14:PROCh("ClockQ4")
                         WHEN 15:IFFNicon_set(c_wind%,15) PROCh("ClockB9") ELSE PROCh("ClockB8")
                         WHEN 46 :PROCh("ClockQ5"):REM dow
                         WHEN 47 :PROCh("ClockA4"):REM month
                         WHEN 48 :PROCh("ClockQ6"):REM 12hr
                         ENDCASE
                        ELSE
                         CASE Q%!36 OF
                         WHEN -1:PROCh("AlarmH7")
                         WHEN 2:PROCh("FindA5")

                         WHEN 5:PROCh("FindA2")
                         WHEN 7:PROCh("FindA3")
                         WHEN 11:PROCh("FindQ3")
                         WHEN 14:PROCh("FindQ4")
                         WHEN 46 :PROCh("FindQ5"):REM dow
                         WHEN 47 :PROCh("FindA4"):REM month
                         WHEN 48 :PROCh("FindQ6"):REM 12hr
                         ENDCASE
                        ENDIF
             ENDCASE
WHEN m_wind%:PROCh("AlarmH8")
WHEN info%:PROCh("AlarmH9")
WHEN save%:CASE Q%!36 OF
           WHEN 0:PROCh("Drg02")
           WHEN 2:PROCh("Drg03")
           WHEN 3:PROCh("Drg04")
           OTHERWISE:PROCh("Drg01")
           ENDCASE
OTHERWISE
 IF wimpversion%>=218 AND Q%!36<>-1 THEN
  SYS"Wimp_GetMenuState",1,Q%+1024,Q%!32,Q%!36
  IF menuhand%=0 THEN
   CASE Q%!1024 OF
   WHEN 0:IF Q%!1028=-1 PROCh("MnuMM1")
   WHEN 1:PROCh("MnuMM3")
   WHEN 2:PROCh("MnuMM4")
   WHEN 3:IFsetclock_action%<>finding% PROCh("MnuMM5") ELSE PROCh("MnuMM7")
   WHEN 4:PROCh("MnuMM6")
   ENDCASE
  ENDIF
  IF menuhand%=3 THEN
   IFcurrent_action%=setting% THEN
    PROCh("MnuFI4")
   ELSE
    CASE Q%!1024 OF
    WHEN 0:PROCh("MnuFI1")
    WHEN 1:PROCh("MnuFI2")
    WHEN 2:IFsetclock_action%<>clocking% PROCh("MnuFI3") ELSE PROCh("MnuFI5")
    ENDCASE
   ENDIF
  ENDIF
  IF menuhand%=1 THEN
   v%=FNalarm_selection_count
   CASE Q%!1024 OF
   WHEN 0:IFcurrent_action%=-1 PROCh("BHlpA1") ELSE PROCgrey_help
   WHEN 1:IFcurrent_action%<>-1 OR v%=0 THEN
           PROCgrey_help
          ELSE
           CASE Q%!1028 OF
           WHEN 0: IFv%=1 THEN
                    PROCh("BHlpB1")
                   ELSE
                    PROCh("BHlpB2")
                   ENDIF
           WHEN 1: IFv%=1 THEN
                    PROCh("BHlpB3")
                   ELSE
                    PROCh("BHlpB4")
                   ENDIF
           WHEN 2: IFv%=1 THEN
                    PROCh("BHlpB9")
                   ELSE
                    PROCh("BHlpBA")
                   ENDIF
           WHEN 3: IFv%=1 THEN
                    PROCh("BHlpB5")
                   ELSE
                    PROCh("BHlpB6")
                   ENDIF
           WHEN 4: IFv%=1 THEN
                    PROCh("BHlpB7")
                   ELSE
                    PROCh("BHlpB8")
                   ENDIF
           OTHERWISE:IFv%=1 THEN
                      PROCh("BHlpA2")
                     ELSE
                      PROCh("BHlpA3")
                     ENDIF
           ENDCASE
          ENDIF
   WHEN 2:IFalarm_head%=0 PROCgrey_help ELSE PROCh("BHlpA4")
   WHEN 3:IFalarm_head%=0 THEN
           PROCh("MnuAM9")
          ELSE
           IFv%=0 THEN
            PROCh("MnuAMA")
           ELSE
            PROCh("BHlpA5")
           ENDIF
          ENDIF
   WHEN 4:IFalarm_head%=0 OR current_action%<>-1 PROCgrey_help ELSE PROCh("BHlpA6")
   WHEN 5:IFcurrent_action%<>-1 PROCgrey_help ELSE PROCh("BHlpA7")
   ENDCASE
  ENDIF
  IF menuhand%=2 THEN
   CASE Q%!1024 OF
   WHEN 0:PROCh("MnuAL1")
   WHEN 1:PROCh("MnuAL2")
   WHEN 2:CASE Q%!1028 OF
          WHEN 0:IF Q%!1032=-1 PROCh("MnuD21") ELSE PROCh("MnuD11")
          WHEN 1:IF Q%!1032=-1 PROCh("MnuD22") ELSE PROCh("MnuD11")
          WHEN 2:IF Q%!1032=-1 PROCh("MnuD23") ELSE PROCh("MnuD11")
          WHEN 3:IF Q%!1032=-1 PROCh("MnuD24") ELSE PROCh("MnuD11")
          WHEN 4:IF Q%!1032=-1 PROCh("MnuD25") ELSE PROCh("MnuD11")
          WHEN 5:IF Q%!1032=-1 PROCh("MnuD26") ELSE PROCh("MnuD11")
          OTHERWISE :PROCh("MnuAL3")
          ENDCASE
   ENDCASE
  ENDIF
 ENDIF
ENDCASE
ENDPROC
:
DEFPROCgrey_help
CASE current_action% OF
WHEN setting%: PROCh("MnuAM6")
WHEN changing%: PROCh("MnuAM8")
OTHERWISE: IFalarm_head%=0 THEN
            PROCh("MnuAM9")
           ELSE
            PROCh("MnuAMA")
           ENDIF
ENDCASE
ENDPROC
:
DEFPROCh(M$)
LOCAL C%
M$=FNmsg_0(M$):IFadditional_help$<>"" M$+="|M"+additional_help$
C%=LENM$+1
Q%!12=Q%!8:Q%!16=&503:$(Q%+20)=M$+CHR$0
!Q%=(24+C%) AND NOT3
SYS"Wimp_SendMessage",17,Q%,Q%!4
ENDPROC
:
DEFFNkey(H%,I%,C%)
IF H% =a_wind% OR H% =c_wind% THEN
 IF H% =a_wind% THEN alarm% =alarms%(0) ELSE alarm% =alarms%(2)
 CASE C% OF
 WHEN &0D,&18A,&19A,&18E,&18F
   PROCrec_fromwin(alarm%,H%)
   PROCrefresh_window(H%,alarm%)
 ENDCASE
ENDIF

IFC%=13 THEN
 CASE H% OF
 WHEN a_wind%,c_wind%,save%,setup%
  Q%!28 =H% OR 1
  SYS "Wimp_GetWindowInfo",,Q% +28
  num_icons% =Q%!(28 +4 +84)

  REM look for default button first
  copy_icons% =0
  WHILE copy_icons% <num_icons%
   Q%!(28 +4) =copy_icons%
   SYS "Wimp_GetIconState",,Q% +28
   IF INSTR(FNvalid(Q%+28 +8),"R6,3") THEN
    Q%!(28 +0) =0
    Q%!(28 +4) =0
    Q%!(28 +8) =%100 :REM select
    Q%!(28 +12) =H%
    Q%!(28 +16) =copy_icons%
    SYS "Wimp_SendMessage",6,Q%+28,H%
    =TRUE
   ENDIF
   copy_icons% +=1
  ENDWHILE

 REM then look for non-default button
  copy_icons% =0
  WHILE copy_icons% <num_icons%
   Q%!(28 +4) =copy_icons%
   SYS "Wimp_GetIconState",,Q% +28
   IF INSTR(FNvalid(Q%+28 +8),"R5,3") THEN
    Q%!(28 +0) =0
    Q%!(28 +4) =0
    Q%!(28 +8) =%100 :REM select
    Q%!(28 +12) =H%
    Q%!(28 +16) =copy_icons%
    SYS "Wimp_SendMessage",6,Q%+28,H%
    =TRUE
   ENDIF
   copy_icons% +=1
  ENDWHILE
 ENDCASE
ENDIF
=FALSE
:
DEFFNvalid(p%)
LOCAL flags%,valid%,str$
REM indirected + text?
flags% =p%!16
IF (flags% AND (%1<<8) +1) =(%1<<8) +1 THEN
 valid% =p%!(20 +4)
 IF valid% <> -1 THEN SYS "XOS_GenerateError",valid% TO str$ :=str$
ENDIF
=""
:
DEFFNlength_icon(H%)
=LEN(FNread_string(a_wind%,H%))
:
DEFPROCdragicon(mousex%,mousey%,handle%,icon%)
LOCAL bx%,by%,ix0%,ix1%,iy0%,iy1%,f$
savewind%=handle%
!Q%=handle%:SYS"Wimp_GetWindowState",,Q%
bx%=Q%!4-Q%!20
by%=Q%!16-Q%!24
!Q%=handle%:Q%!4=icon%:SYS"Wimp_GetIconState",,Q%
ix0%=Q%!8
iy0%=Q%!12
ix1%=Q%!16
iy1%=Q%!20
!Q%=handle%
Q%!4=5
Q%!8=bx%+ix0%
Q%!12=by%+iy0%
Q%!16=bx%+ix1%
Q%!20=by%+iy1%
Q%!24=Q%!8-mousex%
Q%!28=Q%!12-mousey%
Q%!32=scrx1%+Q%!16-mousex%
Q%!36=scry1%+Q%!20-mousey%
IFsave_start%<>-1 THEN
 f$="file_"+RIGHT$("000"+STR$~(save_filetype%),3)
 SYS save_start%,%11000101,1,f$,Q%+8,Q%+24
ELSE
 SYS"Wimp_DragBox",,Q%
ENDIF
ENDPROC
:
DEFPROCdecodedrag
LOCAL h%,i%,mx%,my%,ft%
IFsave_stop%<>-1 SYS save_stop%
SYS"Wimp_GetPointerInfo",,Q%
mx%=!Q%
my%=Q%!4
h%=Q%!12
i%=Q%!16
IF h%=save% ENDPROC
PROCdrag_savefile(h%,i%,mx%,my%)
ENDPROC
:
DEFPROCsavefile(f%,l$,m%)
IF f% THEN
 IF INSTR(l$,".")=0 AND INSTR(l$,":")=0 PROCok(FNmsg_0("OkayC1"))
ENDIF
CASE save_handle% OF
WHEN 1: PROCprint_the_alarms_out(l$,TRUE)
WHEN 2: PROCsave_alarms_to_disc(l$,TRUE,f%,TRUE)
        PROCunset_alarms_selection
WHEN 3: PROCprint_the_alarms_out(l$,FALSE)
WHEN 4: PROCsave_alarms_to_disc(l$,FALSE,f%,TRUE)
        PROCunset_alarms_selection
        PROCopen_browser:REM to adjust the title bar
ENDCASE
IF m% THEN
 IFmenudata% SYS"Wimp_CreateMenu",,menudata%,menux%,menuy%
ELSE
 SYS"Wimp_CreateMenu",,-1
ENDIF
CASE doing_shutdown% OF
WHEN 1: PROCshutdown
WHEN 3: SYS"Wimp_ProcessKey",&1FC
ENDCASE
ENDPROC
:
DEFFNleafname_ptr(f1%)
LOCAL f2%
REPEAT
 f2%=f1%
 f1%+=INSTR($f1%,":")
UNTIL f1%=f2%
REPEAT
 f2%=f1%
 f1%+=INSTR($f1%,".")
UNTIL f1%=f2%
=f1%
:
DEFPROCdrag_savefile(h%,i%,mx%,my%)
LOCAL f1%,ext%
f1%=FNleafname_ptr(filename%)
!Q%=(48+LEN$f1%) AND NOT3
Q%!12=0
Q%!16=1
Q%!20=h%
Q%!24=i%
Q%!28=mx%
Q%!32=my%
Q%!36=0
Q%!40=&FFF
$(Q%+44)=$f1%
?(Q%+44+LEN$(Q%+44))=0
SYS"Wimp_SendMessage",17,Q%,h%,i%
saveref%=Q%!8
ENDPROC
:
DEFPROCdomenu(h%,x%,y%)
LOCAL m1%,m2%,m3%,m4%,m5%,s$,t$
menufree%=menuend%-&440
menu_curws%=menu_ws%
menudata%=0
menuhand%=h%
menux%=x%
menuy%=y%
CASE h% OF
WHEN 0:REM icon menu
       menudata%=FNcrmenu(FNmsg_0("MenuMM"))
       PROCattach(menudata%,0,info%,TRUE)
       IF setclock_action%=finding% PROCset_shade(menudata%,3,1)
WHEN 1:REM browser menu
       m3%=FNalarm_selection_count
       IFm3%<>2 THEN
        s$="BrwsM5":t$="BrwsM6"
       ELSE
        s$="BrwsM3":t$="BrwsM4"
       ENDIF

       menudata%=FNcrmenu(FNmsg_1("BrwsM1",FNmsg_0(s$)))
       m1%=FNcrmenu(FNmsg_2("BrwsM2",FNmsg_0(s$),FNmsg_0(t$)))
       PROCattach(menudata%,1,m1%,TRUE)
         PROCattach(m1%,3,save%,FALSE)
         PROCattach(m1%,4,save%,FALSE)
       PROCattach(menudata%,4,save%,FALSE)
       PROCattach(menudata%,5,save%,FALSE)

       IFm3%=0 THEN
        m3%=FNalarm_hit(menuy%)
        REM ^^^^^^^^ need to allow for the adjustment factor
        REM no longer, menu is now style guide compliant
        IFm3% THEN
         REM IFFNcheck_pointer PROCcheck_pointer(m3%, "PROCdomenu(m3%)")
         IFm3%?alarm_applalarm%=0 THEN
          m3%?alarm_selected%=1
          PROCredraw_alarm(m3%)
         ELSE
          m3%=0
         ENDIF
        ENDIF
        IFm3%=0 THEN
         PROCset_shade(menudata%,1,1)
         PROCset_shade(m1%,0,1)
         PROCset_shade(m1%,1,1)
         PROCset_shade(m1%,2,1)
         PROCset_shade(m1%,3,1)
         PROCset_shade(m1%,4,1)
         PROCset_shade(menudata%,3,1)
        ENDIF
       ENDIF

       IF current_action%<>-1 THEN
        PROCset_shade(menudata%,0,1)
        PROCset_shade(menudata%,1,1)
        PROCset_shade(m1%,0,1)
        PROCset_shade(m1%,1,1)
        PROCset_shade(m1%,2,1)
        PROCset_shade(m1%,3,1)
        PROCset_shade(m1%,4,1)
        PROCset_shade(menudata%,4,1)
        PROCset_shade(menudata%,5,1)
       ENDIF

       IF alarm_head%=0 THEN
        REM this will catch the final case of
        REM no alarms existing
        PROCset_shade(menudata%,2,1)
        PROCset_shade(menudata%,4,1)
       ENDIF
WHEN 2:REM message window menu
       menudata%=FNcrmenu(FNmsg_0("MenuAL"))
       m1%=FNcrmenu(FNmsg_0("MenuD2"))
       PROCattach(menudata%,2,m1%,TRUE)
         m2%=FNcrmenu(FNmsg_0("MenuD1"))
         PROCattach(m1%,0,m2%,TRUE)
         PROCattach(m1%,1,m2%,TRUE)
         PROCattach(m1%,2,m2%,TRUE)
         PROCattach(m1%,3,m2%,TRUE)
         PROCattach(m1%,4,m2%,TRUE)
         PROCattach(m1%,5,m2%,TRUE)
         PROCwriteable(m2%,0,deftime%,4)

         PROCvalid (m2%, 0, "A0-9")

         REM Sodding wimp... We disown the caret here if the change alarm
         REM window is open. Otherwise, if we defer an alarm, the wimp steals
         REM the caret from the change alarm window. We then go, "Ah, our alarm
         REM has been altered, close the change alarm window". We the close
         REM the menu tree, and the wimp tries to give the input focus back
         REM to the change alarm window. BOOM.

         IF current_action% <> setting% THEN
             SYS "Wimp_SetCaretPosition", -1, -1
         ENDIF

WHEN 3: menudata%=FNcrmenu(FNmsg_0("MenuFI"))
        IFcurrent_action%=setting% THEN
         PROCset_shade(menudata%,0,1)
         PROCset_shade(menudata%,1,1)
         PROCset_shade(menudata%,2,1)
        ELSE
         h%=alarms%(0):PROCread_prev_alarm(h%)
         IF h%=0 PROCset_shade(menudata%,0,1)
         h%=alarms%(0):PROCread_next_alarm(h%)
         IF h%=0 PROCset_shade(menudata%,1,1)
         IF setclock_action%=clocking% PROCset_shade(menudata%,2,1)
        ENDIF
ENDCASE
IFmenudata% SYS"Wimp_CreateMenu",,menudata%,menux%,menuy%
ENDPROC
:
DEFPROCcheckmouse(X%,Y%,B%,H%,I%)
LOCAL d$,m$,y$,h$,i$,P%,M%
CASE B% OF
WHEN&400: IFH%=browser% PROCcheck_browser(B%,Y%)
WHEN&100: IFH%=browser% PROCcheck_browser(B%,Y%)
WHEN &40: IFH%=save% PROCdragicon(X%,Y%,H%,I%)
WHEN   2: CASE H% OF
          WHEN       -2: PROCdomenu(0,X%-64,316)
          WHEN browser%: PROCdomenu(1,X%-64,Y%)
          WHEN browse1%: PROCdomenu(1,X%-64,Y%)
          WHEN  m_wind%: $deftime%="1"
                         PROCdomenu(2,X%-64,Y%)
          WHEN  a_wind%: PROCdomenu(3,X%-64,Y%)
          ENDCASE
WHEN   4: CASE H% OF
          WHEN       -2: IFcurrent_action%=setting% PROCfront(a_wind%):PROCok(FNmsg_0("OkayB6"))
                         IFcurrent_action%=changing% PROCfront(a_wind%):PROCok(FNmsg_0("OkayB8"))
                         PROCuser_set_an_alarm
          WHEN browser%: PROCcheck_browser(B%,Y%)
          WHEN  c_wind%: PROCcheck_clock_window(1,-1,H%,I%)
          WHEN  a_wind%: PROCcheck_alarm_window(1,-1,H%,I%)
          WHEN   setup%: PROCcheck_setup_window(1,-1,I%)
          WHEN bstwarn%: SYS"Wimp_CreateMenu",,-1
                         IFI%=2 PROCopen_setup
          WHEN warning%: SYS"Wimp_CreateMenu",,-1
                         REM Quit
                         IFI%=2 THEN
                          modified%=FALSE
                          IFdoing_shutdown%=2 THEN
                           SYS"Wimp_ProcessKey",&1FC
                          ELSE
                           PROCshutdown
                          ENDIF
                         ENDIF
                         REM Save and quit
                         IFI%=3 THEN
                          IFdoing_shutdown%=2 THEN
                           REM global shutdown asked for
                           doing_shutdown%=3
                          ELSE
                           doing_shutdown%=1
                          ENDIF
                          PROCsave_setup(&AE9,0,4,ra$)
                          SYS"Wimp_CreateMenu",,save%,X%,Y%
                         ENDIF
          WHENdeleting%: SYS"Wimp_CreateMenu",,-1
                         IFI%=1 PROCdelete_alarms
          WHEN    save%: IF I%=0 THEN
                          PROCsavefile(TRUE,$filename%,FALSE)
                          ENDPROC
                         ENDIF
          ENDCASE
WHEN   1: CASE H% OF
          WHEN       -2: PROCunset_alarms_selection:PROCopen_browser
          WHEN browser%: PROCcheck_browser(B%,Y%)
          WHEN  c_wind%: PROCcheck_clock_window(-1,1,H%,I%)
          WHEN  a_wind%: PROCcheck_alarm_window(-1,1,H%,I%)
          WHEN   setup%: PROCcheck_setup_window(-1,1,I%)
          WHEN    save%: IF I%=0 THEN
                          PROCsavefile(TRUE,$filename%,TRUE)
                          ENDPROC
                         ENDIF
          ENDCASE
ENDCASE
ENDPROC
:
DEF PROCvalid (menu%, item%, validation$)

    REM Item% numbered from 0 onwards

    REM Better check this menu is indirect before we trample all
    REM over it to give it some validation

    $validation_buffer% = "A0-9"+CHR$0
    !(menu% + 28 + (24 * item%) + 16) = validation_buffer%

ENDPROC
:
DEFPROCdelete_alarms
LOCAL I%,H%,give_error_while_saving%
give_error_while_saving%=TRUE
I%=alarm_head%
WHILE I%
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCdelete_alarms")
 IFI%?alarm_selected% THEN
  H%=I%!alarm_next%
  IFalarms%(1) THEN
   REM there is an active alarm - check it
   IFalarms%(1)=I% PROCtell_pinboard(m_wind%):!Q%=m_wind%:SYS"Wimp_CloseWindow",,Q%
  ENDIF
  PROCremove_alarm_from_list(I%,give_error_while_saving%)
  give_error_while_saving%=FALSE
  PROCheap_free("ALRM",I%)
  I%=H%
 ELSE
  I%=I%!alarm_next%
 ENDIF
ENDWHILE
alarm_warned%=FALSE
PROCmodified_alarm_database
PROCreset_alarm_status
ENDPROC
:
DEFPROCcheck_clock_window(P%,M%,H%,I%)
LOCAL o%
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(2),"PROCcheck_clock_window")
CASE I% OF
REM this section is nearly identical [alarms%(2) instead of (0)]
REM to check_alarm_window - share code?
WHEN 6,8,9,10,12,13,1,0,4,3
 PROCrec_fromwin(alarms%(2),H%)

 CASE I% OF
  WHEN 6: PROCchange_date(alarms%(2),M%,H%)
  WHEN 8: PROCchange_date(alarms%(2),P%,H%)
  WHEN 9: PROCchange_month(alarms%(2),M%,H%)
  WHEN 10:PROCchange_month(alarms%(2),P%,H%)
  WHEN 12:PROCchange_year(alarms%(2),M%,H%)
  WHEN 13:PROCchange_year(alarms%(2),P%,H%)
  WHEN 1: PROCchange_hour(alarms%(2),M%,H%)
  WHEN 0: PROCchange_hour(alarms%(2),P%,H%)
  WHEN 4: PROCchange_min(alarms%(2),M%,H%)
  WHEN 3: PROCchange_min(alarms%(2),P%,H%)
 ENDCASE
WHEN15: PROCcheck_tz
WHEN 5: o%=setclock_action%
        PROCrec_fromwin(alarms%(2),H%)
        REM only close window if SELECT used (minus = -1)
        IFM%=-1 PROCclosewindow(H%):REM resets setclock_action%
        IF o%=finding% THEN
         PROCfind_alarm
        ELSE
         IFalarm_in_dst%<>FNicon_set(c_wind%,15) THEN
          alarm_in_dst%=FNicon_set(c_wind%,15)
          PROCsave_config
         ENDIF
         PROCset_clock_from_alarm_rec(alarms%(2))
         IF alarm_detected% THEN
          !Q%=m_wind%:SYS "Wimp_CloseWindow",,Q%
          PROCreset_alarm_status
         ELSE
          PROCset_timex_for_next_second
         ENDIF
        ENDIF
ENDCASE
ENDPROC
:
DEFPROCcheck_tz
REM When the user toggles the DST button, it is necessary to
REM adjust the clock settings accordingly. This is done by
REM building a GMT 5bt from the local values, changing the
REM CMOS bit, reading the new ordinals and resetting the
REM CMOS bit.
LOCAL hr%,mi%,da%,mo%,yr%
IF alarm_in_dst%=FNicon_set(c_wind%,15) PROCtoggle_tz
PROCalarm_rec_to_fivebt(alarms%(2),buffers%)
PROCtoggle_tz
PROCfivebt_to_ordinals(buffers%,hr%,mi%,da%,mo%,yr%)
IF alarm_in_dst%<>FNicon_set(c_wind%,15) PROCtoggle_tz
alarm_hours%!alarms%(2)=hr%
alarm_minutes%!alarms%(2)=mi%
alarm_date%!alarms%(2)=da%
alarm_month%!alarms%(2)=mo%
alarm_year%!alarms%(2)=yr%
PROCrefresh_window(c_wind%,alarms%(2))
ENDPROC
:
DEFPROCtoggle_tz
LOCAL i%,f%
SYS"OS_Byte",161,&DC TO ,,i%
i%=i% EOR %10000000
SYS"XOS_Byte",162,&DC,i% TO i%;f%
IF(f%AND1) PROCok(FNrtoz(i%+4))
ENDPROC
:
DEF PROCrec_fromwin(I%,H%)
I%!alarm_year% =VAL(FNread_string(H%,2))
I%!alarm_date% =VAL(FNread_string(H%,7))
I%!alarm_hours% =VAL(FNread_string(H%,11))
I%!alarm_minutes% =VAL(FNread_string(H%,14))
IF I%!alarm_year% <1901 THEN I%!alarm_year% =1901
IF I%!alarm_year% >2247 THEN I%!alarm_year% =2247

IF I%!alarm_date% >31 THEN I%!alarm_date% =31
IF I%!alarm_hours% >23 THEN I%!alarm_hours% =23
IF I%!alarm_minutes% >59 THEN I%!alarm_minutes% =59
PROCvalidate_alarm_rec(I%,error%)
ENDPROC
:
DEFPROCcheck_alarm_window(P%,M%,H%,I%)
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCcheck_alarm_window")
IF NOT(alarms%(0)?alarm_applalarm%) THEN
 CASE I% OF
 WHEN 5:alarm_urgent%?alarms%(0)=NOT(alarm_urgent%?alarms%(0))
 WHEN 6,8,9,10,12,13,1,0,4,3
  PROCrec_fromwin(alarms%(0),H%)

  CASE I% OF
   WHEN 6:PROCchange_date(alarms%(0),M%,H%)
   WHEN 8:PROCchange_date(alarms%(0),P%,H%)
   WHEN 9:PROCchange_month(alarms%(0),M%,H%)
   WHEN 10:PROCchange_month(alarms%(0),P%,H%)
   WHEN 12:PROCchange_year(alarms%(0),M%,H%)
   WHEN 13:PROCchange_year(alarms%(0),P%,H%)
   WHEN 1:PROCchange_hour(alarms%(0),M%,H%)
   WHEN 0:PROCchange_hour(alarms%(0),P%,H%)
   WHEN 4:PROCchange_min(alarms%(0),M%,H%)
   WHEN 3:PROCchange_min(alarms%(0),P%,H%)
  ENDCASE
 WHEN 19:
         IFalarm_repeating%?alarms%(0) THEN
          alarm_repeating%?alarms%(0)=0
          alarm_repeat_rate%?alarms%(0)=1
          alarm_repeat_mult%?alarms%(0)=1
          PROCtoggle_size(a_wind%,FALSE)
         ELSE
          IFFNicon_set(a_wind%,33) THEN
           alarm_repeating%?alarms%(0)=2
          ELSE
           alarm_repeating%?alarms%(0)=1
          ENDIF
          PROCtoggle_size(a_wind%,TRUE)
         ENDIF
         PROCset_repeat_flags(TRUE,alarms%(0))
 WHEN 20:alarm_repeat_rate%?alarms%(0)=1:PROCset(20)
 WHEN 21:alarm_repeat_rate%?alarms%(0)=2:PROCset(21)
 WHEN 22:alarm_repeat_rate%?alarms%(0)=4:PROCset(22)
 WHEN 23:alarm_repeat_rate%?alarms%(0)=8:PROCset(23)
 WHEN 24:alarm_repeat_rate%?alarms%(0)=16:PROCset(24)
 WHEN 25:alarm_repeat_rate%?alarms%(0)=32:PROCset(25)
 WHEN 26:PROCchange_mult(M%)
 WHEN 28:PROCchange_mult(P%)
 WHEN 29:alarm_taskalarm%?alarms%(0)=NOT(alarm_taskalarm%?alarms%(0))
         IFalarm_taskalarm%?alarms%(0) THEN
          PROCsetstate(a_wind%,5,1<<22,1<<22)
         ELSE
          PROCsetstate(a_wind%,5,0,1<<22)
         ENDIF
 WHEN 30:alarm_fvdywk%?alarms%(0)=NOT(alarm_fvdywk%?alarms%(0))
         IFalarm_fvdywk%?alarms%(0) PROCcheck_special_day(alarms%(0))
 WHEN 32:IFalarm_repeating%?alarms%(0)<>1 THEN
          alarm_repeating%?alarms%(0)=1
          alarm_repeat_rate%?alarms%(0)=1
          alarm_repeat_mult%?alarms%(0)=1
          PROCset_repeat_flags(TRUE,alarms%(0))
         ENDIF
         PROCset(32)
 WHEN 33:IFalarm_repeating%?alarms%(0)<>2 THEN
          alarm_repeating%?alarms%(0)=2
          alarm_repeat_rate%?alarms%(0)=1
          alarm_repeat_mult%?alarms%(0)=1
          PROCset_repeat_flags(TRUE,alarms%(0))
         ENDIF
         PROCset(33)
 WHEN 34:PROCchange_special_offset(M%)
 WHEN 36:PROCchange_special_offset(P%)
 WHEN 37:PROCchange_special_day(M%)
 WHEN 39:PROCchange_special_day(P%)
 WHEN 40:PROCchange_special_month(M%)
 WHEN 42:PROCchange_special_month(P%)
 ENDCASE
ENDIF
IF I%=31 PROCrec_fromwin(alarms%(0),H%):PROCok_current_action
ENDPROC
:
DEF PROCtoggle_size(win%,flag%)
LOCAL size_x%,size_y%,offscreen%
Q%!0 =win%
SYS "Wimp_GetWindowInfo",,Q% OR 1
Q%!&100 =win%
IF flag% =FALSE THEN
  REM Shrink to nothing. The wimp will sort out the mess, by using
  REM the window's minimum size.
  Q%!(4 +8) =0 :REM Visible area maximum X
  Q%!(4 +4) =Q%!(4 +12) :REM Visible area minimum Y = max Y
ELSE
  size_x% =Q%!(4 +48) -Q%!(4 +40) :REM Work area max X - min X
  size_y% =Q%!(4 +52) -Q%!(4 +44) :REM Work area max Y - min Y
  Q%!(4 +8) = Q%!(4 +0) +size_x% :REM Visible area max X = min X + size_x%
  Q%!(4 +4) = Q%!(4 +12) -size_y% :REM Visible area min Y = max Y - size_y%
ENDIF

SYS "Wimp_OpenWindow",,Q%
REM Forcing window on screen by closing & re-opening it will cause
REM flicker if it's not needed. So we check if it's offscreen
REM first.
IF FNoffscreen(win%) THEN PROCforce_onscreen(win%)
ENDPROC
:
DEF FNoffscreen(win%)
LOCAL XE%,YE%,X%,Y%
SYS "OS_ReadModeVariable",-1,4 TO ,,XE%
SYS "OS_ReadModeVariable",-1,5 TO ,,YE%
SYS "OS_ReadModeVariable",-1,11 TO ,,X%
SYS "OS_ReadModeVariable",-1,12 TO ,,Y%

X% =(X% +1) <<XE%
Y% =(Y% +1) <<YE%
Q%!0 =win%
SYS "Wimp_GetWindowOutline",,Q%

IF (Q%!4) <0 THEN =TRUE
IF (Q%!8) <0 THEN =TRUE
IF (Q%!12) > X% THEN =TRUE
IF (Q%!16) > Y% THEN =TRUE
=FALSE
:
DEF PROCforce_onscreen(win%)
LOCAL caret%
REM do we have caret, if so preserve info
SYS "Wimp_GetCaretPosition",,Q% +&100
caret% =(Q%!&100)=win%

Q%!0 =win%
SYS "Wimp_CloseWindow",,Q%
SYS "Wimp_GetWindowState",,Q%
SYS "Wimp_OpenWindow",,Q%

IF caret% =TRUE THEN
  SYS "Wimp_SetCaretPosition",Q%!&100,Q%!&104,Q%!&108,Q%!&10C,Q%!&110,Q%!&114
ENDIF
ENDPROC
:
DEFPROCcheck_special_day(Z%)
LOCAL J%,dir%
REM IFFNcheck_pointer PROCcheck_pointer(Z%,"PROCcheck_special_day")
IFZ%?alarm_repeating%<>2 ENDPROC
J%=FNread_repeat_day(Z%)
dir%=1
WHILE NOT(FNvalid_day(J%))
 J%+=dir%
 IFJ%=8 THEN
  J%=FNread_repeat_day(Z%)
  dir%=-1
 ENDIF
ENDWHILE
PROCwrite_repeat_day(Z%,J%)
PROCset_string(a_wind%,38,FNmsg_0("WE"+STR$(J%)+"a"+STR$(FNread_repeat_offset(Z%))))
PROCset_string(a_wind%,35,FNmsg_0("SR"+STR$(FNread_repeat_offset(Z%))+"w"+STR$(J%)))
ENDPROC
:
DEFPROCchange_special_offset(V%)
LOCAL D%
D%=FNread_repeat_offset(alarms%(0))
D%+=V%
IF D%>-1 AND D%<6 THEN
 PROCwrite_repeat_offset(alarms%(0),D%)
 PROCset_string(a_wind%,35,FNmsg_0("SR"+STR$(D%)+"w"+STR$(FNread_repeat_day(alarms%(0)))))
 PROCset_string(a_wind%,38,FNmsg_0("WE"+STR$(FNread_repeat_day(alarms%(0)))+"a"+STR$(D%)))
ENDIF
ENDPROC
:
DEFPROCchange_special_day(V%)
LOCAL D%
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCchange_special_day(0)")
D%=FNread_repeat_day(alarms%(0))
D%+=V%
IFalarm_fvdywk%?alarms%(0) THEN
 WHILE NOT(FNvalid_day(D%))
  D%+=V%
  IFD%<0 OR D%>7 D%=FNread_repeat_day(alarms%(0))
 ENDWHILE
ENDIF
IF D%>0 AND D%<8 THEN
 PROCwrite_repeat_day(alarms%(0),D%)
 PROCset_string(a_wind%,38,FNmsg_0("WE"+STR$(D%)+"a"+STR$(FNread_repeat_offset(alarms%(0)))))
 PROCset_string(a_wind%,35,FNmsg_0("SR"+STR$(FNread_repeat_offset(alarms%(0)))+"w"+STR$(D%)))
ENDIF
ENDPROC
:
DEFPROCchange_special_month(V%)
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCchange_special_month(0)")
V%+=alarm_repeat_mult%?alarms%(0)
IF V%>0 AND V%<13 THEN
 alarm_repeat_mult%?alarms%(0)=V%
 PROCset_string(a_wind%,41,FNmsg_0("MR"+STR$(V%)))
ENDIF
ENDPROC
:
DEFPROCset(I%)
PROCsetstate(a_wind%,I%,1<<21,1<<21)
ENDPROC
:
DEFPROCchange_mult(V%)
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCchange_mult(0)")
V%+=alarm_repeat_mult%?alarms%(0)
IF V%>0 AND V%<256 THEN
 alarm_repeat_mult%?alarms%(0)=V%
 PROCset_string(a_wind%,27,STR$(V%))
ENDIF
ENDPROC
:
DEFPROCok_current_action
LOCAL i%
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCok_current_action(0)")
i%=current_action%:current_action%=-1:PROCclosewindow(a_wind%):current_action%=i%
IF current_action%=setting% OR current_action%=changing% THEN
 IF current_action%=changing% THEN
  PROCremove_alarm_from_list(alarm_original_pointer%,FALSE)
  alarm_original_pointer%=0
 ENDIF
 i%=FNheap_claim("ALRM",alarm_SIZE%)
 IFi%=0 PROCout_of_memory
 PROCcopyalarm(alarms%(0),i%)
 PROCheap_free("ALRM",alarms%(0))
 alarms%(0)=0
 PROCstore_alarm_strings(i%)
 PROCsave_alarm(i%)
 alarm_warned%=FALSE
ENDIF
PROCreset_alarm_status
IFcurrent_action%=changing% THEN
 REM see if there is another selected alarm
 i%=alarm_head%
 WHILE i%
  REM IFFNcheck_pointer PROCcheck_pointer(i%,"PROCok_current_action(i%)")
  IFi%?alarm_selected% THEN
   i%?alarm_selected%=0
   PROCredraw_alarm(i%)
   PROCichang(i%)
   ENDPROC
  ELSE
   i%=i%!alarm_next%
  ENDIF
 ENDWHILE
ENDIF
current_action%=-1
ENDPROC
:
DEFPROCcancel_current_action
REM *always* free this alarm block as it was only a copy
PROCheap_free("ALRM",alarms%(0))
alarms%(0)=0
alarm_original_pointer%=0
IFcurrent_action%=changing% THEN
 REM see if there is another selected alarm
 i%=alarm_head%
 WHILE i%
  REM IFFNcheck_pointer PROCcheck_pointer(i%,"PROCcancel_current_action(i%)")
  IFi%?alarm_selected% THEN
   i%?alarm_selected%=0
   PROCredraw_alarm(i%)
   PROCichang(i%)
   ENDPROC
  ELSE
   i%=i%!alarm_next%
  ENDIF
 ENDWHILE
ENDIF
current_action%=-1
ENDPROC
:
DEFPROCstore_alarm_strings(I%)
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCstore_alarm_strings")
$(I%+alarm_line1%)=FNread_string(a_wind%,mess1%)
$(I%+alarm_line2%)=FNread_string(a_wind%,mess2%)
$(I%+alarm_line3%)=FNread_string(a_wind%,mess3%)
ENDPROC
:
DEFPROCrefresh_window(H%,I%)
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCrefresh_window")
IFH%=a_wind% OR H%=c_wind% THEN
 PROCset_string(H%,2,FNyear(I%))
 PROCset_string(H%,47,FNmonth(I%))
 PROCset_string(H%,46,FNdow(I%))
 PROCset_string(H%,7,FNday(I%))
 PROCset_string(H%,11,FNhour(I%))
 PROCset_string(H%,14,FNmin(I%))
 PROCset_string(H%,48,FNam(I%))
 IF H%=a_wind% THEN

  PROCalarm_rec_to_fivebt(I%,buffers%)
  ?cur_time% =3
  SYS "OS_Word",14,cur_time%
  REM zero out seconds, so difference seems sensible
  SYS "Territory_ConvertTimeToOrdinals",-1,cur_time%,cur_ordinals%
  cur_ordinals%!0 =0 :REM cs
  cur_ordinals%!4 =0 :REM s
  SYS "Territory_ConvertOrdinalsToTime",-1,cur_time%,cur_ordinals%

  PROCtime_diff(cur_time%,buffers%,sign%,yr_dif%,day_dif%,hr_dif%,min_dif%)

  IF sign% =-1 THEN PROCset_string(H%,53,"-") ELSE PROCset_string(H%,53,"+")

  PROCset_string(H%,51,STR$(yr_dif%))
  PROCset_string(H%,52,STR$(day_dif%))
  PROCset_string(H%,50,STR$(hr_dif%))
  PROCset_string(H%,49,RIGHT$("0"+STR$(min_dif%),2))
 ENDIF
ELSE
 REM refresh setup dialogue
 IFI%=alarms%(3) THEN
  PROCset_string(setup%,22,FNtime(I%))
  PROCset_string(setup%,6,FNdate(I%))
  PROCset_string(setup%,9,FNmonth(I%))
  PROCset_string(setup%,48,FNyear(I%))
 ELSE
  PROCset_string(setup%,45,FNtime(I%))
  PROCset_string(setup%,13,FNdate(I%))
  PROCset_string(setup%,16,FNmonth(I%))
  PROCset_string(setup%,52,FNyear(I%))
 ENDIF
ENDIF
ENDPROC
:
DEFPROCredraw_icon(H%,I%)
PROCsetstate(H%,I%,0,0)
ENDPROC
:
DEFPROCchange_hour(I%,V%,H%)
LOCAL error%
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCchange_hour")
I%!alarm_hours%+=V%
PROCvalidate_alarm_rec(I%,error%)
PROCrefresh_window(H%,I%)
ENDPROC
:
DEFPROCchange_min(I%,V%,H%)
LOCAL error%
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCchange_min")
I%!alarm_minutes%+=V%
PROCvalidate_alarm_rec(I%,error%)
PROCrefresh_window(H%,I%)
ENDPROC
:
DEFPROCchange_year(I%,V%,H%)
LOCAL error%
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCchange_year")
I%!alarm_year%+=V%
PROCvalidate_alarm_rec(I%,error%)
PROCrefresh_window(H%,I%)
ENDPROC
:
DEFPROCchange_month(I%,V%,H%)
LOCAL error%
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCchange_month")
I%!alarm_month%+=V%
PROCvalidate_alarm_rec(I%,error%)
PROCrefresh_window(H%,I%)
ENDPROC
:
DEFPROCchange_date(I%,V%,H%)
LOCAL error%
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCchange_date")
I%!alarm_date%+=V%
PROCvalidate_alarm_rec(I%,error%)
PROCrefresh_window(H%,I%)
ENDPROC
:
DEFPROCshutdown
LOCAL C%,D%
IFmodified% THEN
 !Q%=warning%:SYS"Wimp_GetWindowState",,Q%
 C%=(scrx1%-(Q%!12-Q%!4)) DIV 2
 D%=(scry1%-(Q%!8-Q%!16)) DIV 2
 SYS"Wimp_CreateMenu",,warning%,C%,D%
 ENDPROC
ENDIF
PROCmsg_end
PROCdel_codevar
SYS"Wimp_CloseDown"
END
ENDPROC
:
DEFPROCnudge
LOCAL U%
PROCgettime
PROCredraw_icon(-1,ictime%)
IF alarm_set% THEN
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCnudge(1)")
 U%=alarm_urgent%?alarms%(1)
 IF NOT(alarm_detected%) PROCcheck_date_and_time(U%)
 IF FNalarm_sounding(U%) THEN
  VDU 7
  IF alarm_counter%>0 alarm_counter%-=1
 ENDIF
ENDIF
IF secs_used% OR FNalarm_sounding(U%) THEN
 PROCset_timex_for_next_second
ELSE
 SYS "OS_ReadMonotonicTime" TO timeslip%
 U%=VAL(FNconverttime(cur_clock%,"%SE"))
 timeslip%-=timex%
 timex%+=timeslip% - (timeslip% MOD 100) + 100*(60-U%)
ENDIF
ENDPROC
:
DEFPROCset_timex_for_next_second
SYS "OS_ReadMonotonicTime" TO timeslip%
timeslip%-=timex%
timex%+=timeslip% - (timeslip% MOD 100) + 100
ENDPROC
:
DEFFNalarm_sounding(U%)
IFNOTalarm_detected%             :=FALSE
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"FNalarm_sounding(1)")
IFalarm_applalarm%?alarms%(1) :=FALSE
IFsilent_alarm% AND (U%=0)       :=FALSE
IFalarm_counter%=0               :=FALSE
=TRUE
:
DEFFNalarm_gone_off(ptr%)
LOCAL hr%,mi%,da%,mo%,yr%
REM IFFNcheck_pointer PROCcheck_pointer(ptr%,"FNalarm_gone_off")
PROCfivebt_to_ordinals(cur_clock%,hr%,mi%,da%,mo%,yr%)
IFyr% < ptr%!valid_year%    :=FALSE
IFyr% > ptr%!valid_year%    :=TRUE
IFmo% < ptr%!valid_month%   :=FALSE
IFmo% > ptr%!valid_month%   :=TRUE
IFda% < ptr%!valid_date%    :=FALSE
IFda% > ptr%!valid_date%    :=TRUE
IFhr% < ptr%!valid_hours%   :=FALSE
IFhr% > ptr%!valid_hours%   :=TRUE
IFmi% < ptr%!valid_minutes% :=FALSE
=TRUE
:
DEFPROCcheck_date_and_time(U%)
LOCAL t$,Y%,y%,e%,error%
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCcheck_date_and_time(1)")

IFNOT(FNalarm_gone_off(alarms%(1))) ENDPROC

REM ensure that all of the icons are clear ... (#2 isn't used)
PROCset_string(m_wind%,0,"")
PROCset_string(m_wind%,1,"")
PROCset_string(m_wind%,3,"")
PROCset_string(m_wind%,4,"")
PROCset_string(m_wind%,5,"")
PROCset_string(m_wind%,6,"")
PROCset_string(m_wind%,7,"")
PROCset_string(m_wind%,8,"")
alarm_detected%=TRUE
alarm_counter%=global_timeout%
IF alarm_applalarm%?alarms%(1) PROCbroadcast_appl_alarm:ENDPROC
IF alarm_taskalarm%?alarms%(1) PROCactivate_task_alarm:ENDPROC
Y%=92
PROCalarm_rec_to_fivebt(alarms%(1),buffers%)
t$=FNconverttime(buffers%,FNmsg_0("ActvA1"))
PROCset_string(m_wind%,0,t$)
REM ***** buffers% shouldn't have been altered since three lines above
t$=FNconverttime(buffers%,FNmsg_0("ActvA6"))
PROCset_string(m_wind%,1,t$)
CASE alarm_repeating%?alarms%(1) OF
WHEN 0: y%=3
WHEN 1: e%=FNheap_claim("ALRM",alarm_SIZE%)
        IFe%=0 PROCout_of_memory
        PROCcopyalarm(alarms%(1),e%)
        PROCincrement_alarm(e%,e%?alarm_repeat_rate%,e%?alarm_repeat_mult%,error%)
        IFerror% THEN
         PROCset_string(m_wind%,3,FNmsg_0("OkayC7"))
         PROCset_string(m_wind%,4,FNmsg_0("OkayC8"))
         PROCset_string(m_wind%,5,"")
        ELSE
         PROCalarm_rec_to_fivebt(e%,buffers%)
         t$=FNconverttime(buffers%,FNmsg_0("ActvA2"))
         PROCset_string(m_wind%,3,t$)
         t$=FNconverttime(buffers%,FNmsg_0("ActvA6"))
         PROCset_string(m_wind%,4,t$)
         PROCset_string(m_wind%,5,"")
        ENDIF
        Y%+=120
        y%=6
        PROCheap_free("ALRM",e%)
        e%=0
WHEN 2: e%=FNheap_claim("ALRM",alarm_SIZE%)
        IFe%=0 PROCout_of_memory
        PROCcopyalarm(alarms%(1),e%)
        PROCincrement_special_alarm(e%,e%?alarm_repeat_rate%,e%?alarm_repeat_mult%,error%)
        IFerror% THEN
         PROCset_string(m_wind%,3,FNmsg_0("OkayC7"))
         PROCset_string(m_wind%,4,FNmsg_0("OkayC8"))
         PROCset_string(m_wind%,5,"")
        ELSE
         PROCalarm_rec_to_fivebt(e%,buffers%)
         t$=FNconverttime(buffers%,FNmsg_0("ActvA2"))
         PROCset_string(m_wind%,3,t$)
         t$=FNconverttime(buffers%,FNmsg_0("ActvA6"))
         PROCset_string(m_wind%,4,t$)
         PROCset_string(m_wind%,5,"")
        ENDIF
        Y%+=120
        y%=6
        PROCheap_free("ALRM",e%)
        e%=0
ENDCASE
PROCset_string(m_wind%,y%,$(alarms%(1)+alarm_line1%))
PROCset_string(m_wind%,y%+1,$(alarms%(1)+alarm_line2%))
PROCset_string(m_wind%,y%+2,$(alarms%(1)+alarm_line3%))
IF $(alarms%(1)+alarm_line3%)<>"" THEN
 Y%+=160
ELSE IF $(alarms%(1)+alarm_line2%)<>"" THEN
      Y%+=120
     ELSE IF $(alarms%(1)+alarm_line1%)<>"" Y%+=80
     ENDIF
ENDIF
IF U% THEN
 PROCset_title(m_wind%,FNmsg_0("ActvA3"))
ELSE
 PROCset_title(m_wind%,FNmsg_0("ActvA4"))
ENDIF

REM change for nested button bar
Y% +=100

PROCtell_pinboard(m_wind%)
!Q%=m_wind%
SYS "Wimp_GetWindowState",,Q%
Q%!8=Q%!16-Y%
Q%!28=-1
SYS "Wimp_OpenWindow",,Q%
ENDPROC
:
DEFPROCactivate_task_alarm
LOCAL e$,e%,error%
REM IFFNcheck_pointer IF current_action%<>-1 PROCcheck_pointer(alarms%(0),"PROCactivate_task_alarm(0)")
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCactivate_task_alarm(1)")
e$=$(alarms%(1)+alarm_line1%)+$(alarms%(1)+alarm_line2%)+$(alarms%(1)+alarm_line3%)
IF (alarms%(0)=alarms%(1)) AND current_action%<>setting% THEN
 !Q%=a_wind%
 SYS "Wimp_CloseWindow",,Q%
 PROCcancel_current_action
ENDIF
IF alarm_repeating%?alarms%(1) THEN
 PROCremove_alarm_from_list(alarms%(1),FALSE)
 PROCsave_repeating_alarm(alarms%(1),alarm_repeat_rate%?alarms%(1),alarm_repeat_mult%?alarms%(1),error%)
ELSE
 PROCremove_alarm_from_list(alarms%(1),TRUE)
 PROCheap_free("ALRM",alarms%(1))
 alarms%(1)=0
 PROCmodified_alarm_database
ENDIF
alarm_warned%=FALSE
PROCreset_alarm_status
e%=FNexecute_task_alarm(e$)
IF NOTe% SYS"Wimp_StartTask",e$
IFerror% PROCok(FNmsg_0("OkayC6"))
ENDPROC
:
DEFFNexecute_task_alarm(e$)
LOCAL ERROR
ON ERROR LOCAL :=FALSE
OSCLI("Filer_Run "+e$)
=TRUE
:
DEFPROCok(e$)
ERROR errok%,e$
ENDPROC
:
DEFPROCfatal(e$)
REM PROCheap_dump("adfs::4.HeapDump","")
ERROR errfatal%,e$
ENDPROC
:
DEFPROCwarning(r$)
LOCAL null%
IFalarm_warned% ENDPROC
alarm_warned%=TRUE
null% =FNerr_box(1,r$,1)
ENDPROC
:
DEFFNiconbar
LOCAL I%,A%,priority%
PROCprepare_icon
SYS "OS_SpriteOp",256+24,icons%,"-time" TO ,,A%
IF ictime%=-1 THEN
 !buffers%=-7
 priority% =&10000000
ELSE
 !buffers%=-4
 priority% =ictime%
ENDIF

buffers%!4=0
 IF FNanalogue THEN
 buffers%!8=-14
ELSE
 buffers%!8=0
ENDIF
buffers%!12=icon_width%
IF FNanalogue THEN
 buffers%!16=buffers%!8+icon_width%+4
ELSE
 buffers%!16=68
ENDIF
buffers%!20=%00000111000000000011000100010010
buffers%!24=A%
buffers%!28=icons%
buffers%!32=0
SYS "Wimp_CreateIcon",priority%,buffers% TO I%
IF ictime%<>-1 AND wimpversion%>=222 THEN
 !buffers%=-1
 buffers%!4=ictime%
 SYS "Wimp_DeleteIcon",,buffers%
ENDIF
=I%
:
DEFPROCprepare_icon
LOCAL W%,X%,Y%,Z%,C%,D%
Q%!0=4
Q%!4=5
Q%!8=11
Q%!12=12
Q%!16=-1
SYS "OS_ReadVduVariables",Q%,Q%+20
dx%=(Q%!20)
dy%=(Q%!24)
scrx1%=(Q%!28+1) <<dx%
scry1%=(Q%!32+1) <<dy%
IF FNanalogue THEN
 icon_width% =116
 C%=icon_width%/2
 SYS "OS_ReadModeVariable",MODE ,5 TO ,,Z%
 IF Z%=1 THEN X%=60:Y%=20 ELSE X%=30:Y%=12
 icons% =FNmake_sprite("-time",C%+1,X%,Y%,TRUE)
 SYS "OS_SpriteOp",&11D,icons%,"-time"
 SYS "OS_SpriteOp",&13D,icons%,"-time",0 TO W%,X%,Y%,Z%
 GCOL 0,128
 TINT 3,0
 CLG
 GCOL 0,63
 TINT 2,&FF
 CIRCLE FILL C%,C%,C%-1
ELSE
 icons% =FNmake_sprite("-time",icon_width% >>>dx%,icon_height% >>> dy%,MODE,FALSE)
 SYS "OS_SpriteOp",&13C,icons%,"-time",0 TO W%,X%,Y%,Z%
ENDIF

SYS "OS_SpriteOp",W%,X%,Y%,Z%
ENDPROC
:
DEF FNmake_sprite(name$,x%,y%,mode%,mask%)
LOCAL depth%,pixel_bits%,row_size%,size%
IF spr_area% >0 THEN PROCheap_free("SPRT",spr_area%)

IF mode% <128 THEN
 SYS "OS_ReadModeVariable",mode%,3 TO ,,depth%
 CASE depth% OF
 WHEN 1       :depth% =0
 WHEN 3       :depth% =1
 WHEN 15      :depth% =2
 WHEN 63,255  :depth% =3
 WHEN 65535   :depth% =4
 WHEN -1      :depth% =5
 ENDCASE
ELSE
 depth% =mode%!12
ENDIF

pixel_bits% =1<<depth%

row_size% =x% *pixel_bits%
REM round up to nearest word
row_size% +=31
row_size% =row_size% AND &FFFFFFE0

size% =((row_size% *y%) /8)
IF mask% THEN size% =size% *2
size% +=16 +44

spr_area% =FNheap_claim("SPRT",size%)
!spr_area%=size%:spr_area%!4=0:spr_area%!8=16:spr_area%!12=16
SYS "OS_SpriteOp",&109,spr_area%

SYS "OS_SpriteOp",256+15,spr_area%,name$,0,x%,y%,mode%
=spr_area%
:
DEF PROCrect(colour%,x%,y%,w%,h%,thickness%)
SYS "Wimp_SetColour",colour%
RECTANGLE FILL x%,y%,thickness%,h%
RECTANGLE FILL x%,y%,w%,thickness%
RECTANGLE FILL x%,y% +h% -thickness%,w%,thickness%
RECTANGLE FILL x% +w% -thickness%,y%,thickness%,h%
ENDPROC
:
DEFPROCclock(t$)
LOCAL T%,I%,H%,M%,S%,R%,X%,Y%
H%=VAL(LEFT$(t$,2))
M%=VAL(MID$(t$,4,2))
S%=VAL(RIGHT$(t$,2))
R%=icon_width%/2-1
X%=icon_width%/2:Y%=X%
CLS
IF user_alarm_set% THEN GCOL 11 ELSE GCOL 8
IF R%>150 THEN
 T%=R%-(R%>>5)-8
 FOR I%=0 TO 59
  POINT X%+T%*sin(I%),Y%+T%*cos(I%)
 NEXT
ENDIF
IF R%>50 THEN
 T%=R%-(R%>>4)
 FOR I%=0 TO 59 STEP 5
  T%=R%-(R%>>4)
  RECTANGLE FILL X%+T%*sin(I%)-(R%>>5),Y%+T%*cos(I%)-(R%>>5),R%>>4
 NEXT
ENDIF
IF user_alarm_set% THEN GCOL 14 ELSE GCOL 15
CIRCLE X%,Y%,R%
PROChands(H%,M%,S%,R%,X%,Y%)
ENDPROC
:
DEFPROChands(H%,M%,S%,R%,X%,Y%)
GCOL 4
IF INSTR(format$,"~AH") THEN PROChand(H%*5+M%DIV 12,X%,Y%,R%-(R%>>1))
IF INSTR(format$,"~AM") THEN PROChand(M%,X%,Y%,R%-(R%>>2))
IF INSTR(format$,"~AS") THEN
 GCOL 11
 MOVE X%,Y%
 DRAW BY (R%-(R%>>4))*sin(S%MOD 60),(R%-(R%>>4))*cos(S%MOD 60)
 GCOL 11
 CIRCLE FILL X%,Y%,R%>>4
ENDIF
ENDPROC
:
DEFPROChand(A%,X%,Y%,R%)
LOCAL T%
T%=(R%>>1)/cos(1)
MOVE X%+sin((A%+1) MOD 60)*T%,Y%+cos((A%+1) MOD 60)*T%
MOVE X%,Y%
PLOT 117,X%+sin((A%+60-1) MOD 60)*T%,Y%+cos((A%+60-1) MOD 60)*T%
ENDPROC
:
DEFPROCgettime
LOCAL t$,T%,W%,X%,Y%,Z%
t$ =FNconvertextras(format$)

?cur_clock%=3:SYS "OS_Word",14,cur_clock%
t$=FNconverttime(cur_clock%,t$)

textlen% =FNchksum_textlen(t$)

IF cur_format$ <> format$ OR cur_textlen% <> textlen% THEN
 icon_height% =68
 SYS "Wimp_TextOp",1,t$,0 TO len%
 icon_width% =len% +40

 REM Seperating this code into 2 (see IF font% =0 section below)
 REM isn't ideal, but is the only way to deal with an issue RO6.06
 REM has with 16 colour modes (the text 'bounces' due to changes
 REM in the y size)
 REM Doing it this way caches the value on every mode/font change
 SYS "Wimp_ReadSysInfo",8 TO font%
 IF font% >0 THEN
  SYS "Font_CharBBox",font%,ASC("0"),1<<4 TO ,,miny%,,maxy%
  fontysize% =maxy% -1
 ENDIF

 ictime%=FNiconbar

 cur_format$ =format$
 cur_textlen% =textlen%
ENDIF

SYS  "OS_SpriteOp",&13C,icons%,"-time",0 TO W%,X%,Y%,Z%
VDU 5
IF FNanalogue THEN
 t$=FNconverttime(cur_clock%,"%24:%MI:%SE")

 PROCclock(t$)
ELSE
 IF user_alarm_set% THEN C%=11:D%=14 ELSE C%=8:D%=15
 PROCrect(C%,0,0,icon_width% -1,icon_height% -1,3)
 PROCrect(D%,4,4,icon_width% -1-8,icon_height% -1 -8,3)
 REM clear whole plinth
 SYS "Wimp_SetColour",0
 RECTANGLE FILL 8,8,icon_width% -1 -16,icon_height% -1 -16

 REM Unfortunately this has to be done every display (see above)
 SYS "Wimp_ReadSysInfo",8 TO font%
 IF font% =0 THEN
  fontysize% =30
  REM why wimp_textop doesn't do this is a mystery
  VDU 23,17,7,%110,16 >>>dx%;32 >>>dy%|
 ENDIF

 SYS "Wimp_TextOp",0,0,&FFFFFF00 :SYS "Wimp_TextOp",&00000002,t$,-1,-1,20,(68 -fontysize%) /2
ENDIF
SYS "OS_SpriteOp",W%,X%,Y%,Z%
ENDPROC
:
DEFFNconvertextras(f$)
REM expand system variables
REM if we exceed max basic string length then an empty string is returned
SYS "OS_GSTrans",f$,STRING$(255,"*"),254 TO ,f$
=f$
:
DEF FNanalogue
=INSTR(format$,"~AH") OR INSTR(format$,"~AM") OR INSTR(format$,"~AS")
:
DEFFNchksum_textlen(t$)
LOCAL check%
check% =0
WHILE t$ >""
 c$ =LEFT$(t$,1) :t$ =MID$(t$,2)

 CASE c$ OF
 WHEN "0","1","2","3","4","5","6","7","8","9"
  check% +=1
 WHEN "W","X"
  check% +=&100
 WHEN ",",".",":",";"
  check% +=&10000
 OTHERWISE
  check% +=&1000000
 ENDCASE
ENDWHILE
=check%
:
DEFPROCinit_codevar
LOCAL len%,R%,P%,free_code%,buffer%,end_code%

REM bugfix:
REM If you run a second copy of Alarm 2.76+, once one is already
REM running. It will create & delete the Alarm$Free variable.
REM If the first copy of Alarm is displaying Alarm$Free on the
REM iconbar - then it will suddenly disappear.

REM To prevent this - we check if Alarm$Free is already defined.
REM If so we don't bother re-creating it.

SYS "XOS_ReadVarVal","Alarm$Free",0,-1,0 TO ,,len%
IF len% < 0
  REM Already defined
ELSE
  FOR R% =0 TO 2 STEP 2
  P% =Q%
  [OPT R%
   .free_code%
    MOV pc,r14 ;no write
    STMFD r13!,{r14}
  
    MVN r0,#0 ;=-1
    MVN r1,#0 ;=-1
    SWI "XWimp_SlotSize"
  
    MOV r0,r2
    ADR r1,buffer%
    MOV r2,#16
    SWI "XOS_ConvertFileSize"
  
    SUB r2,r1,r0 ;len =term -buf start
    LDMFD r13!,{pc}
   .buffer%
    EQUS STRING$(16,"*")
    ALIGN
   .end_code%
  ]
  NEXT
  SYS "OS_SetVarVal","Alarm$Free",free_code%,end_code% -free_code%,0,16
ENDIF  
ENDPROC
:
DEFPROCdel_codevar
SYS "XOS_SetVarVal","Alarm$Free",0,-1,0,16
ENDPROC
:
DEFPROCuser_set_an_alarm
alarm_original_pointer%=0
IFalarms%(0)=0 alarms%(0)=FNheap_claim("ALRM",alarm_SIZE%)
IFalarms%(0)=0 PROCout_of_memory
alarm_prev%!alarms%(0)=0
alarm_next%!alarms%(0)=0
alarm_fileptr%!alarms%(0)=0
PROCread_date_and_time(alarms%(0))
$(alarms%(0)+alarm_line1%)=""
$(alarms%(0)+alarm_line2%)=""
$(alarms%(0)+alarm_line3%)=""
alarm_urgent%?alarms%(0)=FALSE
alarm_applalarm%?alarms%(0)=FALSE
alarm_repeating%?alarms%(0)=0
alarm_taskalarm%?alarms%(0)=FALSE
alarm_fvdywk%?alarms%(0)=fivedayweek%
alarm_repeat_mult%?alarms%(0)=1
alarm_repeat_rate%?alarms%(0)=1
alarm_selected%?alarms%(0)=0
PROCcreate_alarm_wind(FNmsg_0("TitlA1"),TRUE,alarms%(0))
PROCfix_sethelp(a_wind%,0,FNmsg_0("HelpD3"))
PROCfix_sethelp(a_wind%,1,FNmsg_0("HelpIB"))
PROCopen_alarm_wind
SYS"Wimp_SetCaretPosition",a_wind%,mess1%,-1,-1,-1,FNlength_icon(mess1%)
REM if we get this far, we must be setting an alarm :-)
current_action%=setting%
ENDPROC
:
DEFPROCmenuselect(menus%)
LOCAL C%,D%,got_adjust%,ftype%,found%,con%,null%,taskname$
SYS"Wimp_GetPointerInfo",,buffers%
IF (buffers%!8 AND 1) AND menuhand%<>2 got_adjust%=TRUE ELSE got_adjust%=FALSE
CASE menuhand% OF
WHEN 0: REM icon menu
        CASE !menus% OF
        WHEN 1:PROCunset_alarms_selection:PROCopen_browser
        WHEN 2:PROCopen_setup
        WHEN 3:SYS "XOS_File",23,"BootResources:Configure.!TimeSetup" TO ,,,,,,ftype%
               IF ftype% =8192 THEN
                found% =FALSE
                con% =0
                WHILE FNenum_tasks(con%,null%,taskname$,null%,null%)
                 IF taskname$ ="TimeSetup" THEN found% =TRUE
                ENDWHILE

                IF NOT found% THEN SYS "XWimp_StartTask","/BootResources:Configure.!TimeSetup"
               ELSE
                setclock_action%=clocking%
                PROCread_date_and_time(alarms%(2))
                PROCsetstate(c_wind%,15,0,1<<23):REM "undelete" the icon
                SYS"Territory_ReadTimeZones",-1 TO ,C%
                PROCset_string(c_wind%,15,FNrtoz(C%))
                SYS"OS_Byte",161,&DC TO ,,C%
                alarm_in_dst%=((C% AND %10000000)<>0)
                IFalarm_in_dst% PROCsetstate(c_wind%,15,1<<21,1<<21) ELSE PROCsetstate(c_wind%,15,0,1<<21)
                PROCcreate_setclock_wind(FNmsg_0("TitlA4"),FNmsg_0("IconA4"))
                PROCfix_setbutton(c_wind%,0,FNmsg_0("IconA4"))
                PROCfix_sethelp(c_wind%,0,FNmsg_0("ClockA2"))
                PROCfix_sethelp(c_wind%,1,FNmsg_0("ClockIB"))
                PROCopen_setclock_wind
               ENDIF
        WHEN 4:PROCshutdown
        ENDCASE
WHEN 1: REM browser menu
        CASE !menus% OF
        WHEN 0:PROCuser_set_an_alarm
        WHEN 1:CASE menus%!4 OF
               WHEN 0: C%=alarm_head%
                       WHILE C%
                        REM IFFNcheck_pointer PROCcheck_pointer(C%,"PROCmenuselect(C%,0)")
                        IFC%?alarm_selected% THEN
                         C%?alarm_selected%=0
                         PROCredraw_alarm(C%)
                         PROCichang(C%)
                         C%=0
                        ELSE
                         C%=C%!alarm_next%
                        ENDIF
                       ENDWHILE
               WHEN 1: IFalarm_confirm% THEN
                        IFFNalarm_selection_count=1 THEN
                         PROCset_string(deleting%,3,FNmsg_0("BrwsT3"))
                        ELSE
                         PROCset_string(deleting%,3,FNmsg_0("BrwsT4"))
                        ENDIF
                        doing_deleting%=TRUE
                        !Q%=deleting%:SYS"Wimp_GetWindowState",,Q%
                        C%=(scrx1%-(Q%!12-Q%!4)) DIV 2
                        D%=(scry1%-(Q%!8-Q%!16)) DIV 2
                        SYS"Wimp_CreateMenu",,deleting%,C%,D%
                        got_adjust%=FALSE
                       ELSE
                        PROCdelete_alarms
                       ENDIF
               WHEN 2: REM copy alarms ...
                       SYS"Hourglass_On"
                       C%=alarm_head%
                       WHILE C%
                        REM IFFNcheck_pointer PROCcheck_pointer(C%,"PROCmenuselect(C%,2)")
                        IFC%?alarm_selected% THEN
                         C%?alarm_selected%=0
                         D%=FNheap_claim("ALRM",alarm_SIZE%)
                         IFD%=0 PROCout_of_memory
                         PROCcopyalarm(C%,D%)
                         PROCsave_alarm(D%)
                         C%=alarm_head%:REM start at the beginning again
                        ELSE
                         C%=C%!alarm_next%
                        ENDIF
                       ENDWHILE
                       alarm_warned%=FALSE
                       PROCunset_alarms_selection:REM neat way for forcing a redraw
                       SYS"Hourglass_Off"
               ENDCASE
        WHEN 2:SYS"Hourglass_On":PROCselect_all_alarms:SYS"Hourglass_Off"
        WHEN 3:PROCunset_alarms_selection
        WHEN 5:REM since <Alarm$Dir>.Alarms is the default
               REM we can safely save the alarms away
               PROCsave_alarms_to_disc(ra$,FALSE,TRUE,TRUE)
               PROCunset_alarms_selection
               PROCopen_browser
        ENDCASE
WHEN 2: REM alarm message menu
        CASE !menus% OF
        WHEN 0:PROCclosewindow(m_wind%)
        WHEN 1:REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCmenuselect(alarms%(1))")
               alarm_repeating%?alarms%(1)=0:PROCclosewindow(m_wind%)
        WHEN 2:CASE menus%!4 OF
               WHEN 0:PROCdefer(1)
               WHEN 1:PROCdefer(2)
               WHEN 2:PROCdefer(4)
               WHEN 3:PROCdefer(8)
               WHEN 4:PROCdefer(16)
               WHEN 5:PROCdefer(32)
               ENDCASE
        ENDCASE
WHEN 3: REM alarm find menu
        C%=alarms%(0):REM pointer to current alarm
        CASE !menus% OF
        WHEN 0:PROCread_prev_alarm(C%)
               PROCichang(C%)
        WHEN 1:PROCread_next_alarm(C%)
               PROCichang(C%)
        WHEN 2:setclock_action%=finding%
               PROCread_date_and_time(alarms%(2))
               PROCsetstate(c_wind%,15,1<<23,1<<23):REM "delete" the icon
               PROCcreate_setclock_wind(FNmsg_0("TitlA5"),FNmsg_0("IconA5"))
               PROCfix_setbutton(c_wind%,0,FNmsg_0("IconA5"))
               PROCfix_sethelp(c_wind%,0,FNmsg_0("FindA2"))
               PROCfix_sethelp(c_wind%,1,FNmsg_0("FindIB"))
               PROCopen_setclock_wind
        ENDCASE
ENDCASE

IF got_adjust% PROCdomenu(menuhand%,menux%,menuy%)
ENDPROC
:
DEFPROCichang(i%)
REM IFFNcheck_pointer PROCcheck_pointer(i%,"PROCichang")
alarm_original_pointer%=i%
IFalarms%(0)=0 alarms%(0)=FNheap_claim("ALRM",alarm_SIZE%)
IFalarms%(0)=0 PROCout_of_memory
PROCcopyalarm(alarm_original_pointer%,alarms%(0))
!Q%=a_wind%:SYS "Wimp_CloseWindow",,Q%
PROCcreate_alarm_wind(FNmsg_0("TitlA3"),TRUE,alarms%(0))
PROCfix_sethelp(a_wind%,0,FNmsg_0("HelpD7"))
PROCfix_sethelp(a_wind%,1,FNmsg_0("HelpIC"))
PROCopen_alarm_wind
IF NOT(alarm_applalarm%?alarms%(0)) THEN
 SYS"Wimp_SetCaretPosition",a_wind%,mess1%,-1,-1,-1,FNlength_icon(mess1%)
ENDIF
current_action%=changing%
ENDPROC
:
DEFPROCcopyalarm(from%,to%)
LOCAL i%
REM IFFNcheck_pointer PROCcheck_pointer(from%,"PROCcopyalarm (from)")
REM IFFNcheck_pointer PROCcheck_pointer(to%,"PROCcopyalarm (to)")
FORi%=0 TO alarm_SIZE%-1
 to%?i%=from%?i%
NEXT
to%!alarm_fileptr%=0
ENDPROC
:
DEFPROCdefer(R%)
LOCAL S%,e%,error%
S%=VAL($deftime%)
IF S%<=0 THEN ENDPROC
e%=FNheap_claim("ALRM",alarm_SIZE%)
IFe%=0 PROCout_of_memory
PROCcopyalarm(alarms%(1),e%)
REM if we are deferring by any amount less then
REM a day, reset it to the current date and time
IFR%<4 PROCread_date_and_time(e%)
e%?alarm_repeating%=0
e%?alarm_repeat_rate%=1
e%?alarm_repeat_mult%=1
PROCsave_repeating_alarm(e%,R%,S%,error%)
REM we will report the error NOW so that
REM the alarm message window does not get closed
IFerror% PROCok(FNmsg_0("OkayC4"))
alarm_warned%=FALSE
PROCclosewindow(m_wind%)
ENDPROC
:
DEFPROCformat_error(e$)
PROCset_format(3)
PROCok(FNmsg_1("OkayA8",e$))
ENDPROC
:
DEFPROCset_format(F%)
format%=F%
IF format%=1 THEN format$="~AH:~AM:~AS":icon_width%=116:icon_height% =34
IF format%=2 THEN format$="~AH:~AM":icon_width%=116:icon_height% =34
IF format%=3 THEN format$="%24~IN%MI"
IF format%=4 THEN format$="%24:%MI:%SE"

IF format%=5 THEN format$=userformat$

secs_used%=FNseconds_used(format$)
PROCset_timex_for_next_second
ENDPROC
:
DEFFNupper(s$)
LOCAL I%,j$
FOR I%=1 TO LENs$
 j$=MID$(s$,I%,1)
 IF j$>="a" AND j$<="z" MID$(s$,I%,1)=CHR$(ASC(j$)-32)
NEXT
=s$
:
DEFFNcrmenu(menu$)
LOCAL M%,m$,I%,maxlen%
IF (menufree%+28>menuend%) PROCfatal(FNmsg_0("Fatal2"))
menuptr%=menufree%
I%=0
maxlen%=0
IF LEFT$(menu$,1)="#" I%=1:menutitle$=FNpar(",") ELSE menutitle$=""
IF wimpversion% < 316 OR LENmenutitle$ <= 12 THEN
  $menuptr%=LEFT$(menutitle$,12)
ELSE
  menuptr%!0 = FNworkspace (LEN(menutitle$)+1)
  menuptr%!4 = -1
  menuptr%!8 = LENmenutitle$
  $(menuptr%!0) = menutitle$
ENDIF
menuptr%?12=7
menuptr%?13=2
menuptr%?14=7
menuptr%?15=0
menuptr%!16=196
menuptr%!20=44
menuptr%!24=0
menuptr%+=28
REPEAT
 item$=FNpar(",")
 IF maxlen% < LEN(item$) THEN
   maxlen% = LENitem$
 ENDIF
 PROCmenuitem(item$)
UNTIL item$=""
M%=menufree%
IF wimpversion% < 316 OR LENmenutitle$ <= 12 THEN
  IF LEN(LEFT$(menutitle$, 12)) > maxlen% THEN
    maxlen% = LEN(LEFT$(menutitle$, 12))
  ENDIF
ELSE
  M%!28=M%!28 OR 256
  IF LEN(menutitle$) > maxlen% THEN
    maxlen% = LEN(menutitle$)
  ENDIF
ENDIF
M%!16=(maxlen% + 1) * 16
menufree%=menuptr%
=M%
:
DEFPROCmenuitem(text$)
LOCAL I%,F%,L%
IF text$="" menuptr%!-24=(menuptr%!-24)OR &80:ENDPROC
IF (menuptr%+24>menuend%) PROCfatal(FNmsg_0("Fatal2"))
F%=&00
IF RIGHT$(text$,1)="#" text$=LEFT$(text$):F%+=&02
IF RIGHT$(text$,1)="@" text$=LEFT$(text$):F%+=&08
menuptr%!0=F%
menuptr%!4=-1
menuptr%!8=&07000021
IF LEFT$(text$,1)="$" THEN
 !menuptr%+=&04
 menuptr%!8+=&100
 menuptr%!16=-1
 text$=STRING$(16, " ")
ELSE
 IF LENtext$<=12 THEN
  $(menuptr%+12)=text$
 ELSE
  I%=FNworkspace(LEN(text$)+1):$I%=text$
  menuptr%!12=I%:menuptr%!16=-1:menuptr%!20=LENtext$+1
  menuptr%!8=menuptr%!8 OR &100
 ENDIF
ENDIF
menuptr%+=24
ENDPROC
:
DEFPROCattach(menu%,item%,ptr%,traverse%)
menu%+=28+item%*24
IF traverse% !menu%=!menu% OR (1<<4)
menu%!4=ptr%
ENDPROC
:
DEFPROCwriteable(menu%,item%,ptr%,size%)
LOCAL M%,L%
IF wimpversion% < 306 OR (LEN($menu%) <= 12) THEN
        M%=LEN$menu%-3
ELSE
        M%=LEN$!menu%-3
ENDIF
L%=size%:IF L%>16 L%=16
IF L%>M% M%=L%
menu%!16=(M%*8+6)*2
menu%+=28+item%*24
menu%!12=ptr%
menu%!20=size%
ENDPROC
:
DEFFNpar(sep$)
LOCAL L%
L%=I%+1
I%=INSTR(menu$+sep$,sep$,L%)
=MID$(menu$,L%,I%-L%)
:
DEFPROCset_shade(menuhandle%,item%,value%)
IF -((menuhandle%!(28+8+24*item%) AND &400000)=&400000)<>value% THEN
 menuhandle%!(28+8+24*item%)=menuhandle%!(28+8+24*item%)EOR &400000
ENDIF
ENDPROC
:
DEFPROCtick(menuhandle%,item%)
menuhandle%!(28+24*item%)=menuhandle%!(28+24*item%)EOR 1
ENDPROC
:
DEFFNworkspace(L%)
IF menu_curws%+L%>menu_ws%+menu_maxws% PROCfatal(FNmsg_0("Fatal3"))
menu_curws%+=L%
=menu_curws%-L%
:
DEFFNopen(name$,action%)
LOCAL C%
LOCAL ERROR
ON ERROR LOCAL :=-1
SYS"OS_Find",%1100+action%,name$ TO C%
=C%
:
DEFFNclose(handle%)
LOCAL ERROR
ON ERROR LOCAL :=-1
SYS"OS_Find",0,handle%
=0
:
DEFPROCincrement_special_alarm(I%,R%,S%,RETURN error%)
LOCAL J%
LOCAL day%            :REM day that alarm is required to go off on
LOCAL offset%         :REM offset into month that alarm is required
LOCAL required_date%  :REM calculated date for this month
LOCAL hours%, minutes%, dayofmonth%, month%, year%
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCincrement_special_alarm")

REM extract values from alarm settings
day%=R% AND 7
offset%=R% DIV 8

REM ensure that alarm is started from tomorrow
hours%=I%!alarm_hours%
minutes%=I%!alarm_minutes%
dayofmonth%=I%!alarm_date%+1
month%=I%!alarm_month%
year%=I%!alarm_year%

REM calculate required date for THIS month
required_date%=FNcalculate_special_date_required(I%,day%,offset%,error%)
IFerror% ENDPROC

REM if we are past that date, we must be repeating properly
REM so add on the required number of months and try again
IFrequired_date%<dayofmonth% THEN
 month%+=S%
 year%=I%!alarm_year%
 WHILE month%>FNmonthsinyear(year%) month%-=FNmonthsinyear(year%):year%+=1:ENDWHILE
 required_date%=FNcalculate_special_date_required(I%,day%,offset%,error%)
 IFerror% ENDPROC
ENDIF

I%!alarm_date%=required_date%
I%!alarm_month%=month%
I%!alarm_year%=year%
PROCvalidate_alarm_rec(I%,error%)
ENDPROC
:
DEFFNcalculate_special_date_required(I%,day%,offset%,RETURN error%)
LOCAL required_date%  :REM calculated date for this month
LOCAL first_day_month%:REM first day for this month
LOCAL last_day_month% :REM last day for this month
LOCAL yr%,mn%,dy%
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNcalculate_special_date_required")

yr%=year%:mn%=month%:dy%=1

PROCvalidate_ordinals(hours%,minutes%,dy%,mn%,yr%,error%)
IFerror% ENDPROC
PROCordinals_to_fivebt(buffers%,hours%,minutes%,dy%,mn%,yr%)
first_day_month%=VAL(FNconverttime(buffers%,"%WN"))

mn%+=1
PROCvalidate_ordinals(hours%,minutes%,dy%,mn%,yr%,error%)
IFerror% ENDPROC
PROCordinals_to_fivebt(buffers%,hours%,minutes%,dy%,mn%,yr%)
last_day_month%=VAL(FNconverttime(buffers%,"%WN"))-1
IFlast_day_month%=0 last_day_month%=7

CASE offset% OF
WHEN 0: REM first occurence in month
        required_date%=1
        IFday%<first_day_month% required_date%+=(7-first_day_month%)+day%
        IFday%>first_day_month% required_date%+=(day%-first_day_month%)
WHEN 1: REM second occurence in month
        required_date%=8
        IFday%<first_day_month% required_date%+=(7-first_day_month%)+day%
        IFday%>first_day_month% required_date%+=(day%-first_day_month%)
WHEN 2: REM third occurence in month
        required_date%=15
        IFday%<first_day_month% required_date%+=(7-first_day_month%)+day%
        IFday%>first_day_month% required_date%+=(day%-first_day_month%)
WHEN 3: REM last occurence in month
        required_date%=FNdaysinmonth(month%,year%)
        IFday%>last_day_month% required_date%-=7
        required_date%-=(last_day_month%-day%)
WHEN 4: REM penultimate occurence in month
        required_date%=FNdaysinmonth(month%,year%)-7
        IFday%>last_day_month% required_date%-=7
        required_date%-=(last_day_month%-day%)
WHEN 5: REM third to last occurence in month
        required_date%=FNdaysinmonth(month%,year%)-14
        IFday%>last_day_month% required_date%-=7
        required_date%-=(last_day_month%-day%)
ENDCASE
=required_date%
:
DEFPROCincrement_alarm(I%,R%,S%,RETURN error%)
LOCAL J%,K%,day%
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCincrement_alarm")

day%=FNday_of_week(I%)

IF R% AND 1 THEN
 IF I%?alarm_fvdywk% THEN
  REM number of minutes in a day = 1440
  WHILE S%>=1440
   I%!alarm_date%+=1
   S%-=1440
   REPEAT
    day%=(day% + 1) MOD 7
    IF(global_weekwork% AND (1<<day%))=0 I%!alarm_date%+=1:S%-=1440
   UNTIL (global_weekwork% AND (1<<day%))<>0
  ENDWHILE
 ENDIF
 I%!alarm_minutes%+=S%
ENDIF

IF R% AND 2 THEN
 IF I%?alarm_fvdywk% THEN
  REM number of hours in a day = 24
  WHILE S%>=24
   I%!alarm_date%+=1
   S%-=24
   REPEAT
    day%=(day% + 1) MOD 7
    IF(global_weekwork% AND (1<<day%))=0 I%!alarm_date%+=1:S%-=24
   UNTIL (global_weekwork% AND (1<<day%))<>0
  ENDWHILE
 ENDIF
 I%!alarm_hours%+=S%
ENDIF

IF R% AND 4 THEN
 IF I%?alarm_fvdywk% THEN
  FOR J%=1 TO S%
   I%!alarm_date%+=1
   REPEAT
    day%=(day% + 1) MOD 7
    IF(global_weekwork% AND (1<<day%))=0 I%!alarm_date%+=1:J%+=1
   UNTIL (global_weekwork% AND (1<<day%))<>0
  NEXT
 ELSE
  I%!alarm_date%+=S%
 ENDIF
ENDIF

IF R% AND 8  I%!alarm_date%+=S%*7

IF R% AND 16 I%!alarm_month%+=S%

IF R% AND 32 I%!alarm_year%+=S%

PROCvalidate_alarm_rec(I%,error%)
IF I%?alarm_fvdywk% THEN
 WHILE NOTerror% AND NOTFNvalid_day_of_week(I%)
  I%!alarm_date%+=1
  PROCvalidate_alarm_rec(I%,error%)
 ENDWHILE
ENDIF
ENDPROC
:
DEFPROCfind_alarm
LOCAL i%,last%
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(2),"PROCfind_alarm(2)")
PROCread_first_alarm(i%)
REM IFFNcheck_pointer PROCcheck_pointer(i%,"PROCfind_alarm(i%)")
WHILE FNrec1_less_than_rec2(i%,alarms%(2))
 last%=i%
 PROCread_next_alarm(i%)
 REM if we've run out of alarms, go back to the last one
 REM and write over the find match so we can get out
 REM of the loop
 IFi%=0 i%=last%:PROCcopyalarm(i%,alarms%(2))
ENDWHILE
PROCichang(i%)
ENDPROC
:
DEFFNrec1_less_than_rec2(rec1%,rec2%)
IFrec1%!alarm_year%    > rec2%!alarm_year%    :=FALSE
IFrec1%!alarm_year%    < rec2%!alarm_year%    :=TRUE
IFrec1%!alarm_month%   > rec2%!alarm_month%   :=FALSE
IFrec1%!alarm_month%   < rec2%!alarm_month%   :=TRUE
IFrec1%!alarm_date%    > rec2%!alarm_date%    :=FALSE
IFrec1%!alarm_date%    < rec2%!alarm_date%    :=TRUE
IFrec1%!alarm_hours%   > rec2%!alarm_hours%   :=FALSE
IFrec1%!alarm_hours%   < rec2%!alarm_hours%   :=TRUE
IFrec1%!alarm_minutes% < rec2%!alarm_minutes% :=TRUE
=FALSE
:
DEFFNrec1_equal_rec2(rec1%,rec2%)
IFrec1%!alarm_year%    <> rec2%!alarm_year%    :=FALSE
IFrec1%!alarm_month%   <> rec2%!alarm_month%   :=FALSE
IFrec1%!alarm_date%    <> rec2%!alarm_date%    :=FALSE
IFrec1%!alarm_hours%   <> rec2%!alarm_hours%   :=FALSE
IFrec1%!alarm_minutes% <> rec2%!alarm_minutes% :=FALSE
=TRUE
:
DEFPROCprocess_appl_alarm(A%)
CASE Q%!20 OF
WHEN 0,1:PROCset_appl_alarm
WHEN 2:PROCcancel_appl_alarm
OTHERWISE: PROCack_appl_alarm(1,FNmsg_0("ApplA1"))
ENDCASE
PROCreset_alarm_status
ENDPROC
:
DEFPROCack_appl_alarm(E%,e$)
LOCAL C%
IF A%<>18 ENDPROC
C%=LEN(e$)+1
Q%!12=Q%!8
Q%!20=E%
$(Q%+24)=e$+CHR$(0)
!Q%=(24+C%) AND NOT3
SYS"Wimp_SendMessage",17,Q%,Q%!4
ENDPROC
:
DEFPROCset_appl_alarm
LOCAL year%,month%,dayofmonth%,hour%,minute%,I%,J%,ptr%
ptr%=FNheap_claim("ALRM",alarm_SIZE%)
IFptr%=0 PROCout_of_memory
IF Q%!20=1 THEN
 |buffers%=|(Q%+24)
 PROCfivebt_to_ordinals(buffers%,hour%,minute%,dayofmonth%,month%,year%)
ELSE
 year%=Q%!24 AND &FFFF
 month%=Q%?26
 dayofmonth%=Q%?27
 hour%=Q%?28
 minute%=Q%?29
ENDIF
ptr%!alarm_hours%=hour%
ptr%!alarm_minutes%=minute%:REM bug fix to allow application alarms to work
ptr%!alarm_date%=dayofmonth%
ptr%!alarm_month%=month%
ptr%!alarm_year%=year%
I%=30
WHILE Q%?I% I%+=1:ENDWHILE
Q%?I%=13:$(ptr%+alarm_line1%)=$(Q%+30)
IF LEN($(ptr%+alarm_line1%))>40 THEN
 PROCheap_free("ALRM",ptr%)
 PROCack_appl_alarm(2,FNmsg_0("ApplA2"))
 ENDPROC
ENDIF
I%+=1:J%=I%
WHILE Q%?I% I%+=1:ENDWHILE
Q%?I%=13:$(ptr%+alarm_line2%)=$(Q%+J%)
IF LEN($(ptr%+alarm_line2%))>40 THEN
 PROCheap_free("ALRM",ptr%)
 PROCack_appl_alarm(3,FNmsg_0("ApplA3"))
 ENDPROC
ENDIF
$(ptr%+alarm_line3%)=""
ptr%?alarm_repeating%=0
ptr%?alarm_applalarm%=TRUE
ptr%?alarm_taskalarm%=FALSE
ptr%?alarm_fvdywk%=FALSE
ptr%?alarm_urgent%=FALSE
PROCsave_alarm(ptr%)
alarm_warned%=FALSE
PROCack_appl_alarm(0,"")
ENDPROC
:
DEFPROCbroadcast_appl_alarm
LOCAL I%
REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCbroadcast_appl_alarm(1)")
Q%!12=0
Q%!16=&501
$(Q%+20)=$(alarms%(1)+alarm_line1%)+CHR$(0)
I%=21+LEN($(alarms%(1)+alarm_line1%))
$(Q%+I%)=$(alarms%(1)+alarm_line2%)+CHR$(0)
I%+=LEN($(alarms%(1)+alarm_line2%))+1
!Q%=(I%+4) AND NOT3
SYS"Wimp_SendMessage",18,Q%,0
ENDPROC
:
DEFPROCreset_alarm_status
LOCAL U%
PROCread_first_alarm(alarms%(1))
PROCgettime
PROCredraw_icon(-1,ictime%)
PROCset_timex_for_next_second
ENDPROC
:
DEFPROCpoll_error
LOCAL R%
SYS"Wimp_ReportError",A%,1,task_id$ TO ,R%
ENDPROC
:
DEFPROCinit_date_and_time
width_am%=0
width_we%=1
width_w3%=2
width_dy%=3
width_st%=4
width_mo%=5
width_m3%=6
width_tz%=7
DIM widths%(7)
?cur_clock%=3:SYS "OS_Word",14,cur_clock%
SYS"Territory_ReadCalendarInformation",-1,cur_clock%,Q2%
widths%(width_am%)=Q2%!16
widths%(width_we%)=Q2%!20
widths%(width_w3%)=Q2%!24
widths%(width_dy%)=Q2%!28
widths%(width_st%)=Q2%!32
widths%(width_mo%)=Q2%!36
widths%(width_m3%)=Q2%!40
widths%(width_tz%)=Q2%!44
ENDPROC
:
DEFFNseconds_used(s$)
LOCAL I%
WHILE s$ >""
 cmp$ =FNupper(LEFT$(s$,4))
 IF LEFT$(cmp$,1) ="<" THEN =TRUE
 IF LEFT$(cmp$,2) ="%Z" THEN cmp$ ="%"+MID$(cmp$,3)

 CASE LEFT$(cmp$,3) OF
 WHEN "%SE","~AS","~IN"
  =TRUE
 ENDCASE
 s$ =MID$(s$,2)
ENDWHILE

=FALSE
:
DEFFNwidth(s$)
LOCAL W%,M%,I%,a$,A%,c$
W%=0
WHILE s$<>""
 I%=INSTR(s$,"%")
 IFI%=0 THEN
  W%+=LENs$
  s$=""
 ELSE
  W%+=I%-1
  s$=MID$(s$,I%+1)
  IFLEFT$(s$,1)="%" THEN
   W%+=1
   s$=MID$(s$,2)
  ELSE
   IFFNupper(LEFT$(s$,1))="Z" s$=MID$(s$,2)
   c$=FNupper(LEFT$(s$,2)):s$=MID$(s$,3)
   CASE c$ OF
    WHEN "CS": W%+=2
    WHEN "SE": W%+=2
    WHEN "MI": W%+=2
    WHEN "12": W%+=2
    WHEN "24": W%+=2
    WHEN "AM": W%+=widths%(width_am%)
    WHEN "PM": W%+=widths%(width_am%)
    WHEN "WE": W%+=widths%(width_we%)
    WHEN "W3": W%+=widths%(width_w3%)
    WHEN "WN": W%+=1
    WHEN "DY": W%+=widths%(width_dy%)
    WHEN "ST": W%+=widths%(width_st%)
    WHEN "MO": W%+=widths%(width_mo%)
    WHEN "M3": W%+=widths%(width_m3%)
    WHEN "MN": W%+=2
    WHEN "CE": W%+=2
    WHEN "YR": W%+=2
    WHEN "WK": W%+=2
    WHEN "DN": W%+=3
    WHEN "TZ": W%+=widths%(width_tz%)

    WHEN "AH","AM","AS": W% =1

    OTHERWISE: PROCformat_error(FNmsg_1("FrmtA1",c$))
   ENDCASE
  ENDIF
 ENDIF
ENDWHILE
=W%
:
REM code to deal with claiming and releasing memory from the heap for alarms
:
DEFPROCinit_heap_constants
LOCAL ws%
ws%=0
REM
REM ****** WARNING!
REM ****** If you make ANY changes to the following workspace usage,
REM ****** it must be mirrored in the browser source code
REM ****** WARNING!
REM
       alarm_next%=FNws_claim(ws%,4)  :REM ptr to next alarm in this linked list
       alarm_prev%=FNws_claim(ws%,4)  :REM ptr to previous alarm in list
    alarm_fileptr%=FNws_claim(ws%,4)  :REM ptr to alarm in data file
       alarm_year%=FNws_claim(ws%,4)  :REM *local* year for alarm to go off on
      alarm_month%=FNws_claim(ws%,4)  :REM *local* month for alarm to go off on
       alarm_date%=FNws_claim(ws%,4)  :REM *local* date for alarm to go off on
      alarm_hours%=FNws_claim(ws%,4)  :REM *local* hours for alarm to go off on
    alarm_minutes%=FNws_claim(ws%,4)  :REM *local* minutes for alarm to go off on
       valid_year%=FNws_claim(ws%,4)  :REM validated *local* year for alarm to go off on
      valid_month%=FNws_claim(ws%,4)  :REM validated *local* month for alarm to go off on
       valid_date%=FNws_claim(ws%,4)  :REM validated *local* date for alarm to go off on
      valid_hours%=FNws_claim(ws%,4)  :REM validated *local* hours for alarm to go off on
    valid_minutes%=FNws_claim(ws%,4)  :REM validated *local* minutes for alarm to go off on
      alarm_line1%=FNws_claim(ws%,41) :REM line 1 of the alarm text
      alarm_line2%=FNws_claim(ws%,41) :REM line 2 of the alarm text
      alarm_line3%=FNws_claim(ws%,41) :REM line 3 of the alarm text
  alarm_repeating%=FNws_claim(ws%,1)  :REM is this a repeating alarm?
alarm_repeat_rate%=FNws_claim(ws%,1)  :REM repeat rate for this alarm
alarm_repeat_mult%=FNws_claim(ws%,1)  :REM repeat multiplier for this alarm
     alarm_urgent%=FNws_claim(ws%,1)  :REM is this an urgent alarm?
  alarm_applalarm%=FNws_claim(ws%,1)  :REM is this an application alarm?
  alarm_taskalarm%=FNws_claim(ws%,1)  :REM is this a task alarm?
     alarm_fvdywk%=FNws_claim(ws%,1)  :REM does this alarm fit into a working week?
   alarm_selected%=FNws_claim(ws%,1)  :REM has this alarm been selected on the viewer?
       alarm_SIZE%=FNws_claim(ws%,1)

SYS"OS_ReadMemMapInfo" TO heap_psize%
SYS"OS_GetEnv" TO ,heap_start%
heap_size%=0
REM PROCheap_increase now gets defered to the first heap claim
ENDPROC
:
DEFFNws_claim(RETURN ws%, size_required%)
ws%+=size_required%
=(ws%-size_required%)
:
DEFPROCheap_reset
LOCAL slot%
IFheap_size%>0 THEN
 SYS"Wimp_SlotSize",-1,-1 TO slot%
 SYS"Wimp_SlotSize",slot%-heap_size%,-1
 heap_size%=0
ENDIF
ENDPROC
:
DEFFNheap_increase
LOCAL slot%
SYS"Wimp_SlotSize",-1,-1 TO slot%
SYS"Wimp_SlotSize",slot%+heap_psize%,-1
IFheap_size%=0 THEN
 SYS"XOS_Heap",0,heap_start%,,heap_psize% TO ;slot%
 IF(slot% AND 1) PROCok(FNmsg_1("OkayD2",STR$(heap_psize%/1024)))
ELSE
 SYS"XOS_Heap",5,heap_start%,,heap_psize% TO ;slot%
 IF(slot% AND 1) :=FALSE
ENDIF
heap_size%+=heap_psize%
=TRUE
:
DEFFNheap_freespace
LOCAL f%
IFheap_size%=0 THEN =0
SYS"OS_Heap",1,heap_start% TO ,,f%
=f%
:
DEFFNheap_ident_num(v$)
LOCAL i%,j%
FORi%=0 TO 3
 j%=j% OR ASC(MID$(v$,i%+1,1))<<(i%*8)
NEXT
=j%
:
DEFFNheap_claim(ident$,size%)
LOCAL p%,f%
REM need to add 4 extra bytes 'cos if the block needs
REM extending then the first word gets trampled on
size%+=4
f%=TRUE
WHILE size%>=FNheap_freespace AND f%=TRUE
 f%=FNheap_increase
ENDWHILE
REM claim the block and store the ident
SYS"XOS_Heap",2,heap_start%,,size% TO ,,p%;f%
IF(f%AND1) :=0
!p%=FNheap_ident_num(ident$)
p%+=4
=p%
:
DEFPROCheap_free(ident$,block%)
LOCAL r0%,f%
IFblock% THEN
 block%-=4
 IF!block%<>FNheap_ident_num(ident$) PROCfatal(FNmsg_1("BNF", ident$))
 SYS"XOS_Heap",3,heap_start%,block% TO r0%;f%
 IF(f% AND 1) PROCfatal(FNmsg_2("ODD1", ident$, FNrtoz(r0%+4)))
 SYS"XOS_Heap",1,heap_start% TO ,,,f%
 IF(f%+16)=heap_size% PROCheap_reset
ENDIF
ENDPROC
:
DEFFNheap_extend(ident$,block%,size%)
LOCAL p%,current%,i%,f%
block%-=4
IF!block%<>FNheap_ident_num(ident$) PROCfatal(FNmsg_1("BNE", ident$))
REM find out how big this block is
SYS"OS_Heap",6,heap_start%,block% TO ,,,current%
REM check that there is enough space in the heap for a duplicate of this block
f%=TRUE
WHILE (current%+size%)>=FNheap_freespace AND f%=TRUE
 f%=FNheap_increase
ENDWHILE
SYS"OS_Heap",4,heap_start%,block%,size% TO ,,p%
=p%+4
:
REM DEFPROCheap_dump(filename$,comment$)
REM LOCAL c%,free%,hwm%,end%,hpd%,ptr%,nfree%,nused%,tmp%
REM LOCAL ERROR
REM ON ERROR LOCAL BPUT#c%,REPORT$:CLOSE#c%:SYS"OS_File",18,filename$,&FFF:ENDPROC
REM hpd%=heap_start%
REM c%=OPENUP(filename$)
REM IFc%=0 THEN
REM  c%=OPENOUT(filename$)
REM ELSE
REM  PTR#c%=EXT#c%
REM ENDIF
REM IFcomment$<>"" BPUT#c%,comment$
REM IFc% THEN
REM  IF!hpd%<>&70616548 ERROR 1,"No 'Heap' string"
REM  free%=hpd%+4+hpd%!4
REM  hwm%=hpd%+hpd%!8
REM  end%=hpd%+hpd%!12
REM  IFhwm%>end% ERROR 1,"Heap top > heap end"
REM  ptr%=hpd%+16
REM  BPUT#c%,"Describing heap at "+FNheap_hex(hpd%,8)
REM  BPUT#c%,"Free offset = "+FNheap_hex(hpd%!4,8)
REM  BPUT#c%," HWM offset = "+FNheap_hex(hpd%!8,8)
REM  BPUT#c%," END offset = "+FNheap_hex(hpd%!12,8)
REM  BPUT#c%,""
REM  REPEAT
REM   CASE TRUE OF
REM   WHEN ptr%=hwm%:
REM    nfree%+=1
REM    BPUT#c%,"Last block at "+FNheap_hex(ptr%,8)+"; "+FNheap_hex(end%-ptr%,8)+" free"
REM    ptr%=end%
REM   WHEN ptr%=free%:
REM    nfree%+=1
REM    BPUT#c%,"Free block at "+FNheap_hex(ptr%,8)+"; "+FNheap_hex(!ptr%,8)+" offset; "+FNheap_hex(ptr%!4,8)+" free"
REM    free%=ptr%+!ptr%
REM    ptr%+=ptr%!4
REM   OTHERWISE:
REM    nused%+=1
REM    BPUT#c%,"Used block at "+FNheap_hex(ptr%,8)+"; "+FNheap_hex(!ptr%,8)+" offset; "+FNheap_hex(!ptr%,8)+" used, ";
REM    tmp%=ptr%+4
REM    BPUT#c%,CHR$(tmp%?0)+CHR$(tmp%?1)+CHR$(tmp%?2)+CHR$(tmp%?3)
REM    ptr%+=!ptr%
REM   ENDCASE
REM   IF (ptr%>end%) OR (ptr%<hpd%+16) ERROR 1,"Link outside heap"
REM  UNTIL ptr%=end%
REM  PROCheap_show(c%,"used",nused%)
REM  PROCheap_show(c%,"free",nfree%)
REM  CLOSE#c%
REM  SYS"OS_File",18,filename$,&FFF
REM ENDIF
REM ENDPROC
REM :
REM DEFPROCheap_show(c%,n$,d%)
REM BPUT#c%,"There w";
REM IFd%=1 BPUT#c%,"as"; ELSE BPUT#c%,"ere";
REM BPUT#c%," "+STR$(d%)+" "+n$+" block";
REM IFd%=1 BPUT#c%,"." ELSE BPUT#c%,"s."
REM ENDPROC
REM :
REM DEFFNheap_hex(A%,B%)
REM =RIGHT$("00000000"+STR$~(A%),B%)
:
REM code to deal with loading and saving alarms, both
REM to disc and to memory
:
DEFPROCload_alarms_into_memory(f$)
REM
REM Load all of the alarms from the file
REM into a linked list of records
REM
LOCAL c%,ptr%,this_rec%,B%,m%,old_autosave%,p%,matched%,this_autosave%,null%
IFf$="" THEN
 REM to catch stupid situations
 PROCreset_alarm_status
 REM IFra$=def_fn$ OR ra$="" ra$=FNmsg_0("FN2")
 IF ra$="" ra$=FNmsg_0("FN2")
ELSE
 old_autosave%=alarm_autosave%
 this_autosave%=alarm_autosave%
 IFalarm_head%=0 THEN
  this_autosave%=TRUE
  REM if no alarms loaded yet, and we're using the default file,
  REM revert to the old default name so that lower down, we replace
  REM it with the NEW default name
  REM IFra$=def_fn$ ra$=FNmsg_0("FN2")
 ENDIF
 alarm_autosave%=FALSE
 m%=modified%
 c%=FNopen(f$,&40)
 IFc%>0 THEN
  SYS"OS_Args",254,c% TO B%
  IF(B% AND 1<<6)=0 THEN
   CLOSE#c%
   c%=0
  ENDIF
 ENDIF
 IFc%>0 THEN
  IFBGET#c%=&41 AND BGET#c%=&4C AND BGET#c%=&52 AND BGET#c%=&4D THEN
   SYS"Hourglass_On"
   REPEAT
    INPUT#c%,ptr%
    IFptr%<>-1 THEN
     this_rec%=FNheap_claim("ALRM",alarm_SIZE%)
     IFthis_rec%=0 CLOSE#c%:PROCout_of_memory
     PTR#c%=ptr%
     INPUT#c%,B%
     IFB%=100 THEN
      PTR#c%=ptr%+15
      this_rec%!alarm_next%=0
      this_rec%!alarm_prev%=0
      this_rec%!alarm_fileptr%=ptr%
      B%=BGET#c%*256+BGET#c%
      this_rec%!alarm_year%=B%
      this_rec%!alarm_month%=BGET#c%
      this_rec%!alarm_date%=BGET#c%
      this_rec%!alarm_hours%=BGET#c%
      this_rec%!alarm_minutes%=BGET#c%
      this_rec%?alarm_urgent%=BGET#c%
      INPUT#c%,$(this_rec%+alarm_line1%)
      INPUT#c%,$(this_rec%+alarm_line2%)
      INPUT#c%,$(this_rec%+alarm_line3%)
      PTR#c%=ptr%+148
      B%=BGET#c%
      this_rec%?alarm_applalarm%=((B% AND 1)=1)
      this_rec%?alarm_repeating%=0
      IF(B% AND 2)=2   this_rec%?alarm_repeating%=1
      IF(B% AND 16)=16 this_rec%?alarm_repeating%=2
      this_rec%?alarm_taskalarm%=((B% AND 4)=4)
      this_rec%?alarm_fvdywk%=((B% AND 8)=8)
      this_rec%?alarm_repeat_rate%=BGET#c%
      this_rec%?alarm_repeat_mult%=BGET#c%
      this_rec%?alarm_selected%=0
      IFthis_rec%?alarm_applalarm% THEN
       REM check for duplicates of application alarms
       p%=alarm_head%
       WHILE p%
        IF p%?alarm_applalarm% THEN
         matched%=TRUE
         IFthis_rec%!alarm_year%<>p%!alarm_year% matched%=FALSE
         IFthis_rec%!alarm_month%<>p%!alarm_month% matched%=FALSE
         IFthis_rec%!alarm_date%<>p%!alarm_date% matched%=FALSE
         IFthis_rec%!alarm_hours%<>p%!alarm_hours% matched%=FALSE
         IFthis_rec%!alarm_minutes%<>p%!alarm_minutes% matched%=FALSE
         IFthis_rec%?alarm_urgent%<>p%?alarm_urgent% matched%=FALSE
         IF$(this_rec%+alarm_line1%)<>$(p%+alarm_line1%) matched%=FALSE
         IF$(this_rec%+alarm_line2%)<>$(p%+alarm_line2%) matched%=FALSE
         IF$(this_rec%+alarm_line3%)<>$(p%+alarm_line3%) matched%=FALSE
         IFthis_rec%?alarm_repeating%<>p%?alarm_repeating% matched%=FALSE
         IFthis_rec%?alarm_taskalarm%<>p%?alarm_taskalarm% matched%=FALSE
         IFthis_rec%?alarm_fvdywk%<>p%?alarm_fvdywk% matched%=FALSE
         IFthis_rec%?alarm_repeat_rate%<>p%?alarm_repeat_rate% matched%=FALSE
         IFthis_rec%?alarm_repeat_mult%<>p%?alarm_repeat_mult% matched%=FALSE
        ELSE
         matched%=FALSE
        ENDIF
        IFmatched% THEN
         PROCheap_free("ALRM",this_rec%)
         this_rec%=0
         p%=0
        ELSE
         p%=p%!alarm_next%
        ENDIF
       ENDWHILE
      ENDIF
      IFthis_rec%<>0 THEN
       PROCsave_alarm(this_rec%)
       IFthis_rec%?alarm_applalarm% AND $(this_rec%+alarm_line1%)=task_id$ THEN
        CASE LEFT$($(this_rec%+alarm_line2%),1) OF
        WHEN "1": bst_alarm_1%=this_rec%
        WHEN "2": bst_alarm_2%=this_rec%
        WHEN "3": bst_alarm_3%=this_rec%
        ENDCASE
       ENDIF
      ENDIF
     ENDIF
     REM set the file pointer ready for the loop around
     PTR#c%=ptr%+5
    ENDIF
    SYS"Hourglass_Percentage",PTR#c%*100/EXT#c%
   UNTIL ptr%=-1
   SYS"Hourglass_Off"
   c%=FNclose(c%)
   IFra$=FNmsg_0("FN2") ra$=f$
   IFf$=ra$ AND m%=FALSE AND this_autosave%=TRUE THEN
    REM A consequence of using PROCsave_alarm is that
    REM it marks the modified flag, so if we are loading
    REM the default file and we hadn't set anything yet
    REM then we can clear the flag
    REM
    REM Note that this_autosave% is forced to true if
    REM this is the first alarm file (since we could
    REM load it multiple times) otherwise the global
    REM autosave value is used
    modified%=FALSE
    PROCset_title(browser%,f$)
   ENDIF
  ELSE
   c%=FNclose(c%)
   PROCok(FNmsg_1("OkayA3",f$))
  ENDIF
 ELSE
  REM IFra$=def_fn$ OR ra$="" ra$=FNmsg_0("FN2")
  IFra$="" ra$=FNmsg_0("FN2")
  REM just check that the file actually exists
  SYS"XOS_File",17,f$ TO c%;B%
  IF (B% AND 1)=0 AND c%<>0 THEN
   null% =FNerr_box(1,FNmsg_1("File07",f$),1)
  ENDIF
 ENDIF
 alarm_autosave%=old_autosave%
 REM IFbst_alarm_1%=0 AND bst_alarm_2%<>0 AND alarm_in_dst%=FALSE alarm_in_dst%=TRUE:PROCsave_config
 REM IFbst_alarm_2%=0 AND bst_alarm_3%<>0 AND alarm_in_dst%=TRUE alarm_in_dst%=FALSE:PROCsave_config
 IFbst_alarm_3%<>0 THEN
  PROCcheck_for_daylight_saving_time($(bst_alarm_3%+alarm_line2%))
  PROCsave_config
 ENDIF
ENDIF
PROCadjust_browser_size
PROCreset_alarm_status
ENDPROC
:
DEFPROCsave_alarms_to_disc(f$,selection%,safe%,give_error%)
REM
REM Save all of the alarms in the linked
REM list to disc.
REM
LOCAL c%,p%,prev%,prev1%,prev2%,doit%
LOCAL r0%,r2%,r3%,r4%,f%
LOCAL o$
autosaved%=FALSE
IFf$="" ENDPROC

o$=f$ : REM Save original file name

REM if the filename begins "choices:" then we have
REM to change to using "<choices$write>", and also
REM check for the presence of a directory called
REM Alarm in it...
IF FNupper(f$)=FNupper(def_fn$) THEN
 f$="<Choices$Write>.Alarm"
 SYS "XOS_File",8,f$,0
 f$=f$+".Alarms"
ENDIF

REM since we are about to create a new Alarms file,
REM stomp on the existing one first to see if we
REM get a more interesting error
SYS"XOS_File",17,f$ TO r0%,,r2%,r3%,r4%;f%
IF(f%AND1) THEN
 IFgive_error% THEN
  null% =FNerr_box(1,FNmsg_1("File06",FNrtoz(r0%+4)),1)
 ENDIF
 ENDPROC
ENDIF

REM if we found a file with the same name, create
REM a file with the same name, load/exec/length
REM attributes

REM if we DIDN'T find a file with the same name,
REM try to create a typed empty file

IF r0%=1 THEN
 SYS"XOS_File",7,f$,r2%,r3%,0,r4% TO r0%;f%
ELSE
 SYS"XOS_File",11,f$,&AE9 TO r0%;f%
ENDIF

IF(f%AND1) THEN
 IFgive_error% THEN
  null% =FNerr_box(1,FNmsg_1("File06",FNrtoz(r0%+4)),1)
 ENDIF
 ENDPROC
ENDIF

SYS"Hourglass_On"
c%=FNopen(f$,&80)
IF c%>0 THEN
 SYS"OS_Args",254,c% TO p%
 IF(p% AND 1<<7)=0 THEN
  CLOSE#c%
  c%=-2
 ENDIF
ENDIF
IF c%>0 THEN
 IFNOT(selection%) AND (safe%) THEN
  modified%=FALSE
  PROCset_title(browser%,o$)
  ra$=o$:REM make this the main alarm file (use original file name)
 ENDIF
 BPUT#c%,&41
 BPUT#c%,&4C
 BPUT#c%,&52
 BPUT#c%,&4D
 IFalarm_head%=0 THEN
  PRINT#c%,-1
 ELSE
  PRINT#c%,14
 ENDIF
 PRINT#c%,-1
 p%=alarm_head%

 REM prev% is a pointer to the previous record written to
 prev%=-1
 WHILE p%
  REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCsave_alarms_to_disc")
  IF selection% THEN
   IFp%?alarm_selected% THEN
    doit%=TRUE
   ELSE
    doit%=FALSE
   ENDIF
  ELSE
   doit%=TRUE
  ENDIF

  IF doit% THEN
   prev1%=PTR#c%
   IFprev%<>-1 THEN
    PTR#c%=prev%+5
    PRINT#c%,prev1%
    PTR#c%=prev1%
   ENDIF
   PROCsave_record(c%,p%,-1,prev%)
   prev%=prev1%
  ENDIF
  p%=p%!alarm_next%
 ENDWHILE
 c%=FNclose(c%)
 IFc% THEN
  PROCsatd_err(FNmsg_0("File01"))
 ELSE
  SYS"OS_File",18,f$,&AE9
  autosaved%=TRUE
 ENDIF
ELSE
 IFc%=-2 THEN
  PROCsatd_err(FNmsg_0("File04"))
 ELSE
  PROCwarning(FNmsg_1("File02", REPORT$))
 ENDIF
ENDIF
REM there won't be any instances of duplicated
REM warnings here, so we can reset the flags now
alarm_warned%=FALSE
SYS"Hourglass_Off"
ENDPROC
:
DEFPROCsave_record(c%,p%,next%,prev%)
LOCAL b%,p1%
REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCsave_record")
p1%=PTR#c%
p%!alarm_fileptr%=p1%
PRINT#c%,100
PRINT#c%,next%
PRINT#c%,prev%
b%=p%!alarm_year%
BPUT#c%,(b% >> 8) AND 255
BPUT#c%,(b% AND 255)
BPUT#c%,p%?alarm_month%
BPUT#c%,p%?alarm_date%
BPUT#c%,p%?alarm_hours%
BPUT#c%,p%?alarm_minutes%
BPUT#c%,p%?alarm_urgent%
PRINT#c%,$(p%+alarm_line1%)
PRINT#c%,$(p%+alarm_line2%)
PRINT#c%,$(p%+alarm_line3%)
PTR#c%=p1%+148
b%=0
IF p%?alarm_applalarm%   b%+=1
IF p%?alarm_repeating%=1 b%+=2
IF p%?alarm_taskalarm%   b%+=4
IF p%?alarm_fvdywk%      b%+=8
IF p%?alarm_repeating%=2 b%+=16
BPUT#c%,b%
BPUT#c%,p%?alarm_repeat_rate%
BPUT#c%,p%?alarm_repeat_mult%
ENDPROC
:
DEFPROCsatd_err(f$)
PROCwarning(FNmsg_1("File03", f$))
ENDPROC
:
DEFPROCprint_the_alarms_out(f$,selection%)
REM
REM Print out the details of all of the
REM alarms to the file f$
REM
LOCAL C%,B%,Z$,Y$,Y1$,Y2$,doit%
C%=OPENOUT(f$)
B%=alarm_head%
WHILE B%
 REM IFFNcheck_pointer PROCcheck_pointer(B%,"PROCprint_the_alarms_out")
 IFselection% THEN
  IFB%?alarm_selected% doit%=TRUE ELSE doit%=FALSE
 ELSE
  doit%=TRUE
 ENDIF
 IF doit% THEN
  PROCalarm_rec_to_fivebt(B%,buffers%)
  Y$=FNconverttime(buffers%,FNmsg_0("PrntA7"))
  IF Y$<>Z$ THEN
   REM ensure that we only print the date ONCE
   IF Z$<>"" THEN
    REM separate dates with a blank line
    BPUT#C%,""
   ENDIF
   BPUT#C%,Y$
   Z$=Y$
  ENDIF
  Y$=FNconverttime(buffers%,FNmsg_0("PrntA6"))
  BPUT#C%,Y$+STRING$(12-LENY$," ");
  IF B%?alarm_applalarm% THEN
   BPUT#C%,FNmsg_1("PrntA1", $(B%+alarm_line1%))
  ELSE
   IF B%?alarm_taskalarm% THEN
    BPUT#C%,FNmsg_0("PrntA2")
    BPUT#C%,STRING$(12," ")+$(B%+alarm_line1%)+$(B%+alarm_line2%)+$(B%+alarm_line3%)
   ELSE
    IF LEN($(B%+alarm_line1%))+LEN($(B%+alarm_line2%))+LEN($(B%+alarm_line3%))=0 THEN
     BPUT#C%,FNmsg_0("PrntB7")
    ELSE
     IF $(B%+alarm_line1%)<>"" BPUT#C%,$(B%+alarm_line1%)
     IF $(B%+alarm_line2%)<>"" BPUT#C%,STRING$(12," ")+$(B%+alarm_line2%)
     IF $(B%+alarm_line3%)<>"" BPUT#C%,STRING$(12," ")+$(B%+alarm_line3%)
    ENDIF
    IF B%?alarm_urgent% BPUT#C%,STRING$(12," ")+FNmsg_0("PrntA3")
   ENDIF
   CASE B%?alarm_repeating% OF
   WHEN 0: IF B%?alarm_fvdywk% BPUT#C%,STRING$(12," ")+FNmsg_0("PrntB8")
   WHEN 1: CASE B%?alarm_repeat_rate% OF
           WHEN 1: Y$=FNmsg_0("PrntB1")
           WHEN 2: Y$=FNmsg_0("PrntB2")
           WHEN 4: Y$=FNmsg_0("PrntB3")
           WHEN 8: Y$=FNmsg_0("PrntB4")
           WHEN 16:Y$=FNmsg_0("PrntB5")
           WHEN 32:Y$=FNmsg_0("PrntB6")
           ENDCASE
           IF B%?alarm_fvdywk% THEN
            BPUT#C%,STRING$(12," ")+FNmsg_2("PrntA4", STR$(B%?alarm_repeat_mult%), Y$)
           ELSE
            BPUT#C%,STRING$(12," ")+FNmsg_2("PrntA5", STR$(B%?alarm_repeat_mult%), Y$)
           ENDIF
   WHEN 2: Y$=FNmsg_0("SR"+STR$(FNread_repeat_offset(B%))+"w"+STR$(FNread_repeat_day(B%)))
           Y1$=FNmsg_0("WE"+STR$(FNread_repeat_day(B%))+"a"+STR$(FNread_repeat_offset(B%)))
           Y2$=FNmsg_0("MR"+STR$(B%?alarm_repeat_mult%))
           BPUT#C%,STRING$(12," ")+FNmsg_3("PrntB9", Y$, Y1$, Y2$)
           IFB%?alarm_fvdywk% BPUT#C%,STRING$(12," ")+FNmsg_0("PrntB8")
   ENDCASE
  ENDIF
 ENDIF
 B%=B%!alarm_next%
ENDWHILE
CLOSE#C%
SYS"OS_File",18,f$,&FFF
ENDPROC
:
DEFPROCread_first_alarm(RETURN I%)
REM
REM Set the pointer I% to point
REM to the first alarm
REM
LOCAL error%
alarm_set%=FALSE
user_alarm_set%=FALSE
alarm_detected%=FALSE
IFalarm_head% THEN
 I%=alarm_head%
 WHILE (I%<>0) AND (user_alarm_set%=FALSE)
  IFI%?alarm_applalarm%=FALSE user_alarm_set%=TRUE
  I%=I%!alarm_next%
 ENDWHILE
 I%=alarm_head%
 IFFNvalid_day_of_week(I%)=FALSE THEN
  REM the next alarm we are looking at doesn't fall
  REM onto a valid day of the week, so pull the
  REM date backwards until it does
  PROCcopy_alarm_to_validated(I%)
  REPEAT:I%!alarm_date%-=1:PROCvalidate_alarm_rec(I%,error%):UNTIL FNvalid_day_of_week(I%)
  PROCswap_alarm_and_validated(I%)
  REM so the originally set date and time is in alarm_*
  REM while the validated version is in valid_*
 ELSE
  REM ok - the day of the week is valid - just ensure
  REM that the valid version is up to date
  PROCcopy_alarm_to_validated(I%)
 ENDIF
 alarm_set%=TRUE
ENDIF
ENDPROC
:
DEFPROCread_prev_alarm(RETURN I%)
REM
REM Point to the previous alarm
REM
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCread_prev_alarm")
REPEAT
 I%=I%!alarm_prev%
 IFI%=0 ENDPROC
UNTIL I%?alarm_applalarm%=0
ENDPROC
:
DEFPROCread_next_alarm(RETURN I%)
REM
REM Point to the next alarm
REM
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCread_next_alarm")
REPEAT
 I%=I%!alarm_next%
 IFI%=0 ENDPROC
UNTIL I%?alarm_applalarm%=0
ENDPROC
:
DEFPROCcancel_appl_alarm
REM
REM Attempt to cancel the specified application
REM alarm from the linked list
REM
LOCAL I%,J%,name$,ident$,E%,res%
I%=24
WHILE Q%?I% I%+=1:ENDWHILE
Q%?I%=13:name$=$(Q%+24)
IF LEN(name$)>40 PROCack_appl_alarm(2,FNmsg_0("ApplA2")):ENDPROC
I%+=1:J%=I%
WHILE Q%?I% I%+=1:ENDWHILE
Q%?I%=13:ident$=$(Q%+J%)
IF LEN(ident$)>40 PROCack_appl_alarm(3,FNmsg_0("ApplA3")):ENDPROC
J%=0
E%=alarm_head%
res%=-1
WHILE E%
 REM IFFNcheck_pointer PROCcheck_pointer(E%,"PROCcancel_appl_alarm")
 IF name$=$(E%+alarm_line1%) AND ident$=$(E%+alarm_line2%) AND E%?alarm_applalarm% THEN
  res%=E%
  E%=0
 ELSE
  E%=E%!alarm_next%
 ENDIF
ENDWHILE
IFres%=-1 THEN
 PROCack_appl_alarm(4,FNmsg_0("ApplA4"))
ELSE
 PROCremove_alarm_from_list(res%,TRUE)
 alarm_warned%=FALSE
 PROCheap_free("ALRM",res%)
 PROCmodified_alarm_database
 PROCreset_alarm_status
 PROCack_appl_alarm(0,"")
ENDIF
ENDPROC
:
DEFPROCremove_alarm_from_list(p%,give_error_while_saving%)
REM
REM Deletes the specified alarm record
REM from the linked list
REM
LOCAL prev%,next%,c%,n1%,p1%,f%
REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCremove_alarm_from_list(p%)")
prev%=p%!alarm_prev%:p%!alarm_prev%=0
next%=p%!alarm_next%:p%!alarm_next%=0
REM IFFNcheck_pointer IFprev% PROCcheck_pointer(prev%,"PROCremove_alarm_from_list(prev)")
REM IFFNcheck_pointer IFnext% PROCcheck_pointer(next%,"PROCremove_alarm_from_list(next)")
IFalarm_head%=p% alarm_head%=next%
IFnext% next%!alarm_prev%=prev%
IFprev% prev%!alarm_next%=next%
IFalarm_autosave% AND p%!alarm_fileptr%<>0 AND ra$<>"" THEN
 IFra$=FNmsg_0("FN2") THEN
  PROCwarning(FNmsg_0("File05"))
  ENDPROC
 ENDIF
 PROCsave_alarms_to_disc(ra$, FALSE, TRUE, give_error_while_saving%)
ENDIF
ENDPROC
:
DEFPROCmodified_alarm_database
IFautosaved% THEN
 autosaved%=FALSE
ELSE
 modified%=TRUE
ENDIF
PROCadjust_browser_size
!Q%=browser%:SYS"Wimp_GetWindowState",,Q%
IF(Q%!32 AND (1<<16)) PROCopen_browser
ENDPROC
:
DEFPROCsave_alarm(ptr%)
REM
REM Links the specified record into
REM the correct order of the linked list
REM
LOCAL C%,p%,q%,f%
REM IFFNcheck_pointer PROCcheck_pointer(ptr%,"PROCsave_alarm")
REM if the working week flag is set and it isn't a repeating
REM alarm, turn the flag off
IF ptr%?alarm_repeating%=0 THEN
 ptr%?alarm_fvdywk%=FALSE
ENDIF
IFalarm_head%=0 THEN
 REM simple case!
 alarm_head%=ptr%
 ptr%!alarm_next%=0
 ptr%!alarm_prev%=0
ELSE
 REM slightly more difficult case!
 C%=alarm_head%
 p%=0
 WHILE C%
  REM IFFNcheck_pointer PROCcheck_pointer(C%,"PROCsave_alarm")
  REM do the comparisons separately (rather than
  REM IF less OR equal) to save time since
  REM if less, then can't be equal!
  f%=FNrec1_less_than_rec2(C%,ptr%)
  IFf%=FALSE f%=FNrec1_equal_rec2(C%,ptr%)
  IFf% THEN
   REM the alarm we are pointing to is before
   REM the one we want to insert
   p%=C%
   C%=C%!alarm_next%
  ELSE
   C%=0
  ENDIF
 ENDWHILE
 IF p%=0 THEN
  REM IFFNcheck_pointer PROCcheck_pointer(alarm_head%,"PROCsave_alarm(alarm_head%)")
  REM insert at the head of the list
  ptr%!alarm_next%=alarm_head%
  ptr%!alarm_prev%=0
  REM alarm_head% can't be zero ...
  alarm_head%!alarm_prev%=ptr%
  alarm_head%=ptr%
 ELSE
  REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCsave_alarm(p%)")
  REM insert into the chain
  REM p% is pointing to the record that should
  REM be BEFORE this one
  ptr%!alarm_prev%=p%
  ptr%!alarm_next%=p%!alarm_next%
  p%!alarm_next%=ptr%
  p%=ptr%!alarm_next%
  IFp% THEN
   REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCsave_alarm(p% 1)")
   p%!alarm_prev%=ptr%
  ENDIF
 ENDIF
ENDIF
PROCmodified_alarm_database
IFalarm_autosave% AND ra$<>"" THEN
 IFra$=FNmsg_0("FN2") THEN
  PROCwarning(FNmsg_0("File05"))
 ELSE
  PROCsave_alarms_to_disc(ra$,FALSE,TRUE,TRUE)
 ENDIF
ENDIF
ENDPROC
:
DEFFNfind_free_record(C%)
LOCAL i%,j%,p%
PTR#C%=4
INPUT#C%,i%
INPUT#C%,j%
IF j%=-1 THEN
 IF i%=-1 p%=14 ELSE p%=EXT#C%
ELSE
 p%=j%
 PTR#C%=j%+5
 INPUT#C%,j%
 PTR#C%=9
 PRINT#C%,j%
ENDIF
=p%
:
DEFPROCopen_slow_increment_warning
LOCAL reason%
PROCopen_window(slow%)
SYS "Wimp_Poll", 932209, Q% TO reason%
IF reason%=1 THEN
 SYS "Wimp_RedrawWindow",, Q% TO left%
 WHILE left%
  SYS "Wimp_GetRectangle",, Q% TO left%
 ENDWHILE
ENDIF
ENDPROC
:
DEFPROCsave_repeating_alarm(I%,R%,S%,RETURN error%)
LOCAL P%,Z%,ptr%, open%, dotpos%, left%
P%=0:Z%=0:dotpos%=0
open%=FALSE
REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCsave_repeating_alarm")
SYS"Hourglass_On"
ptr%=FNheap_claim("ALRM",alarm_SIZE%)
IFptr%=0 PROCout_of_memory
PROCread_date_and_time(ptr%)
CASE I%?alarm_repeating% OF
WHEN 0,1:
          REPEAT
              P%=(P%+1)MOD 100
              IF P%=0 AND NOT open% PROCopen_slow_increment_warning:open%=TRUE
              PROCincrement_alarm(I%,R%,S%,error%)
          UNTIL FNrec1_less_than_rec2(ptr%,I%) OR error%
WHEN   2:
          REPEAT
              P%=(P%+1)MOD 100
              IF P%=0 AND NOT open% PROCopen_slow_increment_warning:open%=TRUE
              PROCincrement_special_alarm(I%,R%,S%,error%)
          UNTIL FNrec1_less_than_rec2(ptr%,I%) OR error%
ENDCASE
IFNOT(error%) PROCsave_alarm(I%)
PROCheap_free("ALRM",ptr%)
SYS"Hourglass_Off"
IF open% PROCclose_window(slow%):open%=FALSE
ENDPROC
:
DEF PROCclose_window (handle%)
!Q%  = handle%
SYS "Wimp_CloseWindow",, Q%
ENDPROC
:
DEF PROCopen_window (handle%)
    LOCAL c%,d%
    LOCAL mc_dx%,mc_dy%,mc_sw%,mc_sh%,scrx%,scry%
    LOCAL x2%, y2%, x1%, y1%

    Q%!0  = handle%

    SYS "Wimp_GetWindowState",, Q%
    IF (Q%!32 AND 65536)=0 THEN
      REM only do this if the window isn't open!
      REM centre the window on the screen
      SYS"OS_ReadModeVariable", -1,  4 TO ,,mc_dx%
      mc_dx% = 1 << mc_dx%
      SYS"OS_ReadModeVariable", -1, 5  TO ,,mc_dy%
      mc_dy% = 1 << mc_dy%
      SYS"OS_ReadModeVariable", -1, 11 TO ,,mc_sw%
      mc_sw% += 1
      SYS"OS_ReadModeVariable", -1, 12 TO ,,mc_sh%
      mc_sh% += 1
      scrx% = mc_sw% * mc_dx%
      scry% = mc_sh% * mc_dy%

      x1% = (scrx% - (Q%!12 - Q%!4 )) DIV 2
      y1% = (scry% - (Q%!8  - Q%!16)) DIV 2
      x2% = x1% + (Q%!12 - Q%!4 )
      y2% = y1% + (Q%!8  - Q%!16)

      Q%!4  = x1%
      Q%!8  = y2%
      Q%!12 = x2%
      Q%!16 = y1%
    ENDIF
    REM but always at the top of the stack ...
    Q%!28 = -1
    REM Open the window...
    SYS "Wimp_OpenWindow",, Q%
ENDPROC
:
REM DEFFNcheck_pointer
REM =TRUE
REM :
REM DEFPROCcheck_pointer(p%,r$)
REM REM Code to check that the value in p%
REM REM is actually a pointer to an ALRM
REM REM block.
REM REM
REM REM Note that we now have to make an exception
REM REM if the pointer is alarms%(2) since that
REM REM record is now DIMed and not taken from
REM REM the heap.
REM IFp%=alarms%(2) ENDPROC
REM LOCAL slot%
REM LOCAL ERROR
REM ON ERROR LOCAL RESTORE ERROR:PROCfatal("Bad ALRM pointer (&"+STR$~(p%)+") passed to "+r$+"; "+REPORT$)
REM IFp%<heap_start% THEN
REM  RESTORE ERROR
REM  PROCfatal("Bad low pointer ("+STR$~(p%)+"/"+STR$~(heap_start%)+") passed to "+r$)
REM ENDIF
REM IFp%>(heap_start%+heap_size%) THEN
REM  RESTORE ERROR
REM  PROCfatal("Bad high pointer ("+STR$~(p%)+"/"+STR$~(heap_start%+heap_size%)+") passed to "+r$)
REM ENDIF
REM IFp%!-4<>FNheap_ident_num("ALRM") THEN
REM  RESTORE ERROR
REM  PROCfatal("Bad ALRM pointer (&"+STR$~(p%)+") passed to "+r$)
REM ENDIF
REM ENDPROC
:
REM setup code
:
DEFPROCopen_setup
LOCAL Y%,X%
REM ensure that the window has the right settings
IFsilent_alarm% THEN
 PROCsetstate(setup%,0,1<<21,1<<21)
ELSE
 PROCsetstate(setup%,0,0,1<<21)
ENDIF
IFfivedayweek% THEN
 PROCsetstate(setup%,1,1<<21,1<<21)
 Y%=0
ELSE
 PROCsetstate(setup%,1,0,1<<21)
 Y%=1<<22
ENDIF
FORX%=1 TO 7
 IFFNvalid_day(X%) THEN
  PROCsetstate(setup%,30+X%,Y%+(1<<21),3<<21)
 ELSE
  PROCsetstate(setup%,30+X%,Y%,3<<21)
 ENDIF
NEXT
IFglobal_timeout%=-1 THEN
 PROCsetstate(setup%,38,1<<21,1<<21)
 PROCsetstate(setup%,39,0,1<<21)
 PROCsetstate(setup%,2,1<<22,1<<22)
ELSE
 PROCsetstate(setup%,38,0,1<<21)
 PROCsetstate(setup%,39,1<<21,1<<21)
 PROCset_string(setup%,2,STR$(global_timeout%))
 PROCsetstate(setup%,2,0,1<<22)
ENDIF
IFalarm_autosave% PROCsetstate(setup%,19,1<<21,1<<21) ELSE PROCsetstate(setup%,21,0,1<<21)
IFalarm_confirm%  PROCsetstate(setup%,23,1<<21,1<<21) ELSE PROCsetstate(setup%,25,0,1<<21)
SYS"Territory_ReadTimeZones",-1 TO X%,Y%
PROCset_string(setup%,3,FNmsg_2("TZSwtch",FNrtoz(X%),FNrtoz(Y%)))
PROCset_string(setup%,30,userformat$)
FORX%=1 TO 5
 IFformat%=X% THEN
  PROCsetstate(setup%,24+X%,1<<21,1<<21)
 ELSE
  PROCsetstate(setup%,24+X%,0,1<<21)
 ENDIF
NEXT
IFformat%<>5 PROCsetstate(setup%,30,1<<22,1<<22) ELSE PROCsetstate(setup%,30,0,1<<21)
PROCstartup_bst_alarms
IFbst_alarm_3% THEN
 PROCenable_bst
ELSE
 PROCdisable_bst
ENDIF
!Q%=setup%:SYS"Wimp_GetWindowState",,Q%
IF(Q%!32 AND (1<<16))=0 THEN
 REM window was already closed,
 REM so we can quite happily move it
 IF wimpversion%>243 THEN
  !Q1%=-2
  SYS"Wimp_GetWindowState",,Q1%
  Y%=Q1%!4-Q1%!20
  !Q1%=-2:Q1%!4=ictime%
  SYS"Wimp_GetIconState",,Q1%
  X%=Y%+Q1%!16-1034
 ELSE
  !Q1%=-1:Q1%!4=ictime%
  SYS"Wimp_GetIconState",,Q1%
  X%=Q1%!16-1034
 ENDIF
 Q%!12=(Q%!12-Q%!4)+X%
 Q%!16=728+140
 Q%!8=140
 Q%!4=X%
 Q%!20=0
 Q%!24=0
ELSE
 PROCtell_pinboard(setup%)
ENDIF
REM we want to force it to the top
Q%!28=-1
SYS"Wimp_OpenWindow",,Q%
IFglobal_timeout%<>-1 THEN
 SYS"Wimp_SetCaretPosition",setup%,2,-1,-1,-1,LEN(FNread_string(setup%,2))
ELSE
 IFformat%=5 SYS"Wimp_SetCaretPosition",setup%,30,-1,-1,-1,LEN(FNread_string(setup%,30))
ENDIF
ENDPROC
:
DEFPROCstartup_bst_alarms
LOCAL hh3%,mi3%,dd3%,mm3%,yy3%
LOCAL hh4%,mi4%,dd4%,mm4%,yy4%
LOCAL s$
REM always set up the BST business as it makes
REM life simpler when the user toggles it on and
REM off.
IFbst_alarm_3% THEN
 s$=MID$($(bst_alarm_3%+alarm_line2%),2)
 dd3%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
 mm3%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
 dd4%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
 mm4%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
 yy3%=VAL(LEFT$(s$,4)):s$=MID$(s$,5)
 IFs$<>"" THEN
  yy4%=VAL(LEFT$(s$,4)):s$=MID$(s$,5)
  hh3%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
  mi3%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
  hh4%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
  mi4%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
 ELSE
  yy4%=yy3%:hh3%=1:mi3%=0:hh4%=1:mi4%=0
 ENDIF
ELSE
 PROCfivebt_to_ordinals(cur_clock%,hh4%,mi4%,dd4%,mm4%,yy4%)
 hh3%=hh4%
 mi3%=mi4%
 dd3%=dd4%
 mm3%=mm4%
 yy3%=yy4%
ENDIF
alarms%(3)=FNheap_claim("ALRM",alarm_SIZE%)
IFalarms%(3)=0 PROCout_of_memory
PROCinitialise_bst_alarm(alarms%(3),hh3%,mi3%,dd3%,mm3%,yy3%)
alarms%(4)=FNheap_claim("ALRM",alarm_SIZE%)
IFalarms%(4)=0 PROCout_of_memory
PROCinitialise_bst_alarm(alarms%(4),hh4%,mi4%,dd4%,mm4%,yy4%)
PROCset_string(setup%,22,FNtime(alarms%(3)))
PROCset_string(setup%,6,FNdate(alarms%(3)))
PROCset_string(setup%,9,FNmonth(alarms%(3)))
PROCset_string(setup%,48,FNyear(alarms%(3)))
PROCset_string(setup%,45,FNtime(alarms%(4)))
PROCset_string(setup%,13,FNdate(alarms%(4)))
PROCset_string(setup%,16,FNmonth(alarms%(4)))
PROCset_string(setup%,52,FNyear(alarms%(4)))
ENDPROC
:
DEFPROCprocess_bst_request
LOCAL s$,C%,D%,error%
s$=FNrtoz(Q%+20)
IFs$=task_id$ THEN
 s$=FNrtoz(Q%+21+LENs$)
 Q%!12=Q%!8:SYS"Wimp_SendMessage",19,Q%,Q%!4
 CASE LEFT$(s$,1) OF
 WHEN "1": alarm_in_dst%=TRUE:PROCsave_config
           PROCsetstate(c_wind%,15,1<<21,1<<21)
           PROCremove_alarm_from_list(bst_alarm_1%,TRUE)
           PROCheap_free("ALRM",bst_alarm_1%)
           PROCmodified_alarm_database
           PROCreset_alarm_status
           bst_alarm_1%=0
 WHEN "2": alarm_in_dst%=FALSE:PROCsave_config
           PROCsetstate(c_wind%,15,0,1<<21)
           PROCremove_alarm_from_list(bst_alarm_2%,TRUE)
           PROCheap_free("ALRM",bst_alarm_2%)
           PROCmodified_alarm_database
           PROCreset_alarm_status
           bst_alarm_2%=0
 WHEN "3": !Q%=bstwarn%:SYS"Wimp_GetWindowState",,Q%
           C%=(scrx1%-(Q%!12-Q%!4)) DIV 2
           D%=(scry1%-(Q%!8-Q%!16)) DIV 2
           SYS"Wimp_CreateMenu",,bstwarn%,C%,D%
           PROCremove_alarm_from_list(bst_alarm_3%,FALSE)
           PROCsave_repeating_alarm(bst_alarm_3%,4,1,error%)
           PROCreset_alarm_status
           IFerror% PROCok(FNmsg_0("OkayC3"))
 ENDCASE
ENDIF
ENDPROC
:
DEFPROCinitialise_bst_alarm(ptr%,hh%,mi%,dd%,mm%,yy%)
REM IFFNcheck_pointer PROCcheck_pointer(ptr%,"PROCinitialise_bst_alarm")
ptr%!alarm_prev%=0
ptr%!alarm_next%=0
ptr%!alarm_fileptr%=0
ptr%!alarm_year%=yy%
ptr%!alarm_month%=mm%
ptr%!alarm_date%=dd%
ptr%!alarm_hours%=hh%
ptr%!alarm_minutes%=mi%
$(ptr%+alarm_line1%)=task_id$
$(ptr%+alarm_line2%)=""
$(ptr%+alarm_line3%)=""
ptr%?alarm_urgent%=FALSE
ptr%?alarm_applalarm%=TRUE
ptr%?alarm_repeating%=0
ptr%?alarm_taskalarm%=FALSE
ptr%?alarm_fvdywk%=FALSE
ptr%?alarm_repeat_mult%=1
ptr%?alarm_repeat_rate%=1
ptr%?alarm_selected%=0
ENDPROC
:
DEFPROCvalidate_bst_alarms(which%)
REM it is important that the first alarm (alarms%(3))
REM is always BEFORE the second alarm (alarms%(4))
REM IFwhich%=3 THEN
REM  REM alarm 3 changed. if it is now > alarm 4,
REM  REM make alarm 4 equal to alarm 3
REM  IF FNrec1_less_than_rec2(alarms%(4),alarms%(3)) THEN
REM   alarm_hours%!alarms%(4)=alarm_hours%!alarms%(3)
REM   alarm_minutes%!alarms%(4)=alarm_minutes%!alarms%(3)
REM   alarm_date%!alarms%(4)=alarm_date%!alarms%(3)
REM   alarm_month%!alarms%(4)=alarm_month%!alarms%(3)
REM   alarm_year%!alarms%(4)=alarm_year%!alarms%(3)
REM  ENDIF
REM ELSE
REM  REM alarm 4 changed. if it is now < alarm 3,
REM  REM make alarm 3 equal to alarm 4
REM  IF FNrec1_less_than_rec2(alarms%(4),alarms%(3)) THEN
REM   alarm_hours%!alarms%(3)=alarm_hours%!alarms%(4)
REM   alarm_minutes%!alarms%(3)=alarm_minutes%!alarms%(4)
REM   alarm_date%!alarms%(3)=alarm_date%!alarms%(4)
REM   alarm_month%!alarms%(3)=alarm_month%!alarms%(4)
REM   alarm_year%!alarms%(3)=alarm_year%!alarms%(4)
REM  ENDIF
REM ENDIF
REM PROCrefresh_window(setup%,alarms%(3))
REM PROCrefresh_window(setup%,alarms%(4))
ENDPROC
:
DEFPROCset_bst_alarms
LOCAL s$,fudge%
s$=FNdigits(2,alarm_date%!alarms%(3))+FNdigits(2,alarm_month%!alarms%(3))
s$+=FNdigits(2,alarm_date%!alarms%(4))+FNdigits(2,alarm_month%!alarms%(4))
s$+=FNdigits(4,alarm_year%!alarms%(3))+FNdigits(4,alarm_year%!alarms%(4))
s$+=FNdigits(2,alarm_hours%!alarms%(3))+FNdigits(2,alarm_minutes%!alarms%(3))
s$+=FNdigits(2,alarm_hours%!alarms%(4))+FNdigits(2,alarm_minutes%!alarms%(4))
IFbst_alarm_1% OR bst_alarm_2% OR bst_alarm_3% THEN
 IF$(bst_alarm_3%+alarm_line2%)="3"+s$ ENDPROC:REM nothing has changed
 IFbst_alarm_1% PROCremove_alarm_from_list(bst_alarm_1%,TRUE):bst_alarm_1%=0
 IFbst_alarm_2% PROCremove_alarm_from_list(bst_alarm_2%,TRUE):bst_alarm_2%=0
 IFbst_alarm_3% PROCremove_alarm_from_list(bst_alarm_3%,TRUE):bst_alarm_3%=0
ENDIF
alarm_warned%=FALSE
bst_alarm_3%=FNheap_claim("ALRM",alarm_SIZE%)
IFbst_alarm_3%=0 PROCout_of_memory
REM BST alarm 3 is the BST reminder alarm.
REM It needs to go off 11 months after the FIRST
REM BST alarm ... which might not necessarily be
REM BST alarm 1 :-)
IF FNrec1_less_than_rec2(alarms%(4),alarms%(3)) THEN
 PROCcopyalarm(alarms%(4),bst_alarm_3%)
ELSE
 PROCcopyalarm(alarms%(3),bst_alarm_3%)
ENDIF
bst_alarm_3%!alarm_month%+=11
$(bst_alarm_3%+alarm_line2%)="3"+s$
PROCvalidate_alarm_rec(bst_alarm_3%,fudge%)
PROCsave_alarm(bst_alarm_3%)
REM
REM we now need to determine whether or
REM not we are currently in DST
REM
PROCcopy_alarm_to_validated(alarms%(3))
PROCcopy_alarm_to_validated(alarms%(4))
PROCcheck_for_daylight_saving_time("3"+s$)

IFNOT(FNalarm_gone_off(alarms%(3))) THEN
 bst_alarm_1%=alarms%(3):alarms%(3)=0
 $(bst_alarm_1%+alarm_line2%)="1"+s$
 PROCsave_alarm(bst_alarm_1%)
ELSE
 PROCheap_free("ALRM",alarms%(3)):alarms%(3)=0
ENDIF

IFNOT(FNalarm_gone_off(alarms%(4))) THEN
 bst_alarm_2%=alarms%(4):alarms%(4)=0
 $(bst_alarm_2%+alarm_line2%)="2"+s$
 PROCsave_alarm(bst_alarm_2%)
ELSE
 PROCheap_free("ALRM",alarms%(4)):alarms%(4)=0
ENDIF
ENDPROC
:
REM This procedure checks to see whether or not we should be
REM configured for DST. Since RISC OS 3.10, it is no longer a
REM simple matter of seeing whether alarm 1 has expired then
REM alarm 2 has expired because alarm 1 can now come AFTER
REM alarm 2.
REM
REM s$ is the string held in alarm line 2. It allows us to
REM check the alarm dates even after both alarm 1 and alarm 2
REM have expired
DEFPROCcheck_for_daylight_saving_time(s$)
LOCAL dd3%,mm3%,yy3%,hh3%,mi3%
LOCAL dd4%,mm4%,yy4%,hh4%,mi4%
LOCAL old_alarm3%, old_alarm4%
old_alarm3%=alarms%(3):old_alarm4%=alarms%(4)
s$=MID$(s$,2):REM lose the alarm identifier digit
dd3%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
mm3%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
dd4%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
mm4%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
yy3%=VAL(LEFT$(s$,4)):s$=MID$(s$,5)
IFs$<>"" THEN
 yy4%=VAL(LEFT$(s$,4)):s$=MID$(s$,5)
 hh3%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
 mi3%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
 hh4%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
 mi4%=VAL(LEFT$(s$,2)):s$=MID$(s$,3)
ELSE
 yy4%=yy3%:hh3%=1:mi3%=0:hh4%=1:mi4%=0
ENDIF
alarms%(3)=FNheap_claim("ALRM",alarm_SIZE%)
IFalarms%(3)=0 PROCout_of_memory
PROCinitialise_bst_alarm(alarms%(3),hh3%,mi3%,dd3%,mm3%,yy3%)
alarms%(4)=FNheap_claim("ALRM",alarm_SIZE%)
IFalarms%(4)=0 PROCout_of_memory
PROCinitialise_bst_alarm(alarms%(4),hh4%,mi4%,dd4%,mm4%,yy4%)
PROCcopy_alarm_to_validated(alarms%(3))
PROCcopy_alarm_to_validated(alarms%(4))

IFFNalarm_gone_off(alarms%(3)) THEN
 IFFNalarm_gone_off(alarms%(4)) THEN
  REM both gone off
  IF FNrec1_less_than_rec2(alarms%(4),alarms%(3)) THEN
   alarm_in_dst%=TRUE
  ELSE
   alarm_in_dst%=FALSE
  ENDIF
 ELSE
  REM started alarm gone off
  alarm_in_dst%=TRUE
 ENDIF
ELSE
 IFFNalarm_gone_off(alarms%(4)) THEN
  REM not started, but have ended?
  alarm_in_dst%=FALSE
 ELSE
  REM not started or ended
  IF FNrec1_less_than_rec2(alarms%(4),alarms%(3)) THEN
   alarm_in_dst%=TRUE
  ELSE
   alarm_in_dst%=FALSE
  ENDIF
 ENDIF
ENDIF

PROCheap_free("ALRM",alarms%(3)):alarms%(3)=0
PROCheap_free("ALRM",alarms%(4)):alarms%(4)=0
alarms%(3)=old_alarm3%:alarms%(4)=old_alarm4%
ENDPROC
:
DEFFNdigits(size%,val%)
LOCAL s$
=RIGHT$(STRING$(size%,"0")+STR$(val%),size%)
:
DEFPROCcheck_setup_window(P%,M%,I%)
LOCAL i%
CASE I% OF
WHEN  1: FORi%=1 TO 7
          IFFNicon_set(setup%,1) THEN
           PROCsetstate(setup%,30+i%,0,1<<22)
          ELSE
           PROCsetstate(setup%,30+i%,1<<22,1<<22)
          ENDIF
         NEXT
WHEN  3: IFFNicon_set(setup%,3) PROCenable_bst ELSE PROCdisable_bst

WHEN 20: PROCchange_hour(alarms%(3),M%,setup%)
WHEN 21: PROCchange_hour(alarms%(3),P%,setup%)
WHEN 41: PROCchange_min(alarms%(3),M%,setup%)
WHEN 42: PROCchange_min(alarms%(3),P%,setup%)
WHEN  5: PROCchange_date(alarms%(3),M%,setup%)
WHEN  7: PROCchange_date(alarms%(3),P%,setup%)
WHEN  8: PROCchange_month(alarms%(3),M%,setup%)
WHEN 10: PROCchange_month(alarms%(3),P%,setup%)
WHEN 49: PROCchange_year(alarms%(3),M%,setup%)
WHEN 50: PROCchange_year(alarms%(3),P%,setup%)

WHEN 47: PROCchange_hour(alarms%(4),M%,setup%)
WHEN 46: PROCchange_hour(alarms%(4),P%,setup%)
WHEN 44: PROCchange_min(alarms%(4),M%,setup%)
WHEN 43: PROCchange_min(alarms%(4),P%,setup%)
WHEN 12: PROCchange_date(alarms%(4),M%,setup%)
WHEN 14: PROCchange_date(alarms%(4),P%,setup%)
WHEN 15: PROCchange_month(alarms%(4),M%,setup%)
WHEN 17: PROCchange_month(alarms%(4),P%,setup%)
WHEN 51: PROCchange_year(alarms%(4),M%,setup%)
WHEN 53: PROCchange_year(alarms%(4),P%,setup%)

WHEN 18: PROCok_save_option(P%)
WHEN 25: PROCsetstate(setup%,25,1<<21,1<<21)
WHEN 26: PROCsetstate(setup%,26,1<<21,1<<21)
WHEN 27: PROCsetstate(setup%,27,1<<21,1<<21)
WHEN 28: PROCsetstate(setup%,28,1<<21,1<<21)
WHEN 29: PROCsetstate(setup%,29,1<<21,1<<21)
         PROCsetstate(setup%,30,0,1<<22)
WHEN 38: PROCsetstate(setup%,38,1<<21,1<<21)
         PROCsetstate(setup%,2,1<<22,1<<22)
         SYS"Wimp_GetCaretPosition",,Q%
         IF!Q%=setup% AND Q%!4=2 SYS"Wimp_SetCaretPosition",-1
WHEN 39: PROCsetstate(setup%,39,1<<21,1<<21)
         PROCsetstate(setup%,2,0,1<<22)
ENDCASE
IFI%=25 ORI%=26 ORI%=27 ORI%=28 THEN
 PROCsetstate(setup%,30,1<<22,1<<22)
 SYS"Wimp_GetCaretPosition",,Q%
 IF!Q%=setup% AND Q%!4=30 SYS"Wimp_SetCaretPosition",-1
ENDIF
IFI%=20 ORI%=21 ORI%=41 ORI%=42 ORI%=5 ORI%=7 ORI%=8 ORI%=10 ORI%=49 ORI%=50 THEN
 PROCvalidate_bst_alarms(3)
ENDIF
IFI%=47 ORI%=46 ORI%=44 ORI%=43 ORI%=12 ORI%=14 ORI%=15 ORI%=17 ORI%=51 ORI%=53 THEN
 PROCvalidate_bst_alarms(4)
ENDIF
ENDPROC
:
DEFPROCok_save_option(P%)
LOCAL j%,i%
silent_alarm%=FNicon_set(setup%,0)
fivedayweek%=FNicon_set(setup%,1)
j%=0
FORi%=0 TO 6
 IFFNicon_set(setup%,31+i%) j%+=(1<<i%)
NEXT
IFj%=0 THEN
 PROCok(FNmsg_0("OkayC9"))
ELSE
 global_weekwork%=j%
ENDIF
IFFNicon_set(setup%,38) THEN
 global_timeout%=-1
ELSE
 global_timeout%=VAL(FNread_string(setup%,2))
ENDIF
IFalarm_autosave%<>FNicon_set(setup%,19) THEN
 alarm_autosave%=FNicon_set(setup%,19)
 IFalarm_autosave% THEN
  REM changing from FALSE to TRUE, so save the database
  IFmodified% AND ra$<>"" PROCsave_alarms_to_disc(ra$,FALSE,TRUE,TRUE):autosaved%=FALSE
 ELSE
  REM changing from TRUE to FALSE, clear autosaved flag
  autosaved%=FALSE
 ENDIF
ENDIF
alarm_confirm%=FNicon_set(setup%,23)
IFFNicon_set(setup%,3) THEN
 PROCset_bst_alarms
ELSE
 PROCheap_free("ALRM",alarms%(3)):alarms%(3)=0
 PROCheap_free("ALRM",alarms%(4)):alarms%(4)=0
 IFbst_alarm_1% OR bst_alarm_2% OR bst_alarm_3% THEN
  IFbst_alarm_1% PROCremove_alarm_from_list(bst_alarm_1%,TRUE):bst_alarm_1%=0
  IFbst_alarm_2% PROCremove_alarm_from_list(bst_alarm_2%,TRUE):bst_alarm_2%=0
  IFbst_alarm_3% PROCremove_alarm_from_list(bst_alarm_3%,TRUE):bst_alarm_3%=0
  PROCmodified_alarm_database
 ENDIF
ENDIF
PROCreset_alarm_status
IFFNicon_set(setup%,25) THEN
 IFformat%<>1 PROCset_format(1)
ELSE
 IFFNicon_set(setup%,26) THEN
  IFformat%<>2 PROCset_format(2)
 ELSE
  IFFNicon_set(setup%,27) THEN
   IFformat%<>3 PROCset_format(3)
  ELSE
   IFFNicon_set(setup%,28) THEN
    IFformat%<>4 PROCset_format(4)
   ELSE
    IFFNicon_set(setup%,29) THEN
     IFformat%<>5 OR userformat$<>FNread_string(setup%,30) THEN
      userformat$=FNread_string(setup%,30)
      IFFNwidth(userformat$)>80 THEN
       PROCformat_error(FNmsg_0("FrmtA2"))
      ELSE
       IFFNwidth(userformat$)<1 THEN
        PROCformat_error(FNmsg_0("FrmtA3"))
       ELSE
        PROCset_format(5)
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF
ENDIF
REM only close the window if SELECT was used
IFP%=1 THEN
 !Q%=setup%:SYS"Wimp_CloseWindow",,Q%
ELSE
 REM need to reload the BST alarms
 PROCstartup_bst_alarms
ENDIF
PROCsave_config
ENDPROC
:
DEFPROCenable_bst
PROCsetstate(setup%,3,1<<21,1<<21)
PROCsetstate(setup%,20,0,3<<21):PROCsetstate(setup%,21,0,3<<21):PROCsetstate(setup%,22,0,3<<21)
PROCsetstate(setup%,41,0,3<<21):PROCsetstate(setup%,42,0,3<<21)
PROCsetstate(setup%, 5,0,3<<21):PROCsetstate(setup%, 6,0,3<<21):PROCsetstate(setup%, 7,0,3<<21)
PROCsetstate(setup%, 8,0,3<<21):PROCsetstate(setup%, 9,0,3<<21):PROCsetstate(setup%,10,0,3<<21)
PROCsetstate(setup%,49,0,3<<21):PROCsetstate(setup%,48,0,3<<21):PROCsetstate(setup%,50,0,3<<21)

PROCsetstate(setup%,47,0,3<<21):PROCsetstate(setup%,46,0,3<<21):PROCsetstate(setup%,45,0,3<<21)
PROCsetstate(setup%,44,0,3<<21):PROCsetstate(setup%,43,0,3<<21)
PROCsetstate(setup%,12,0,3<<21):PROCsetstate(setup%,13,0,3<<21):PROCsetstate(setup%,14,0,3<<21)
PROCsetstate(setup%,15,0,3<<21):PROCsetstate(setup%,16,0,3<<21):PROCsetstate(setup%,17,0,3<<21)
PROCsetstate(setup%,51,0,3<<21):PROCsetstate(setup%,52,0,3<<21):PROCsetstate(setup%,53,0,3<<21)
ENDPROC
:
DEFPROCdisable_bst
PROCsetstate(setup%,3,0,1<<21)
PROCsetstate(setup%,20,1<<22,3<<21):PROCsetstate(setup%,21,1<<22,3<<21):PROCsetstate(setup%,22,1<<22,3<<21)
PROCsetstate(setup%,41,1<<22,3<<21):PROCsetstate(setup%,42,1<<22,3<<21)
PROCsetstate(setup%, 5,1<<22,3<<21):PROCsetstate(setup%, 6,1<<22,3<<21):PROCsetstate(setup%, 7,1<<22,3<<21)
PROCsetstate(setup%, 8,1<<22,3<<21):PROCsetstate(setup%, 9,1<<22,3<<21):PROCsetstate(setup%,10,1<<22,3<<21)
PROCsetstate(setup%,49,1<<22,3<<21):PROCsetstate(setup%,48,1<<22,3<<21):PROCsetstate(setup%,50,1<<22,3<<21)

PROCsetstate(setup%,47,1<<22,3<<21):PROCsetstate(setup%,46,1<<22,3<<21):PROCsetstate(setup%,45,1<<22,3<<21)
PROCsetstate(setup%,44,1<<22,3<<21):PROCsetstate(setup%,43,1<<22,3<<21)
PROCsetstate(setup%,12,1<<22,3<<21):PROCsetstate(setup%,13,1<<22,3<<21):PROCsetstate(setup%,14,1<<22,3<<21)
PROCsetstate(setup%,15,1<<22,3<<21):PROCsetstate(setup%,16,1<<22,3<<21):PROCsetstate(setup%,17,1<<22,3<<21)
PROCsetstate(setup%,51,1<<22,3<<21):PROCsetstate(setup%,52,1<<22,3<<21):PROCsetstate(setup%,53,1<<22,3<<21)
ENDPROC
:
DEFPROCinit_config
LOCAL i%,j%
SYS"OS_Byte",161,&DC TO ,,i%
IF(i% AND %111)=0 i%=%00001001
format%=(i% AND %111)
 alarm_confirm%=((i% AND %1000)<>0)
alarm_autosave%=((i% AND %10000)<>0)
   fivedayweek%=((i% AND %100000)<>0)
  silent_alarm%=((i% AND %1000000)<>0)
  alarm_in_dst%=((i% AND %10000000)<>0)
$Q1%=FNread_system_string("Alarm$Options","")
REM format is -timeout value -weekwork days -format string
SYS"XOS_ReadArgs","timeout/k,weekwork/k,format/k",Q1%,Q%,2048 TO ;i%
IF(i% AND 1) THEN !Q%=0:Q%!4=0:Q%!8=0
REM timeout
IF!Q% THEN
 global_timeout%=VAL(FNrtoz(!Q%))
ELSE
 global_timeout%=10
ENDIF
REM working week
IFQ%!4 THEN
 global_weekwork%=VAL(FNrtoz(Q%!4))
ELSE
 ?cur_clock%=3:SYS "OS_Word",14,cur_clock%
 SYS"Territory_ReadCalendarInformation",-1,cur_clock%,Q2%
 global_weekwork%=0
 FORi%=1 TO 7
  IFi%>=Q2%!0 AND i%<=Q2%!4 global_weekwork%+=(1<<(i%-1))
 NEXT
ENDIF
REM user format
IFQ%!8 THEN
 PROCset_string(setup%,30,FNrtoz(Q%!8))
ELSE
 PROCset_string(setup%,30,"%z12:%mi:%se %pm. %zdy/%zmn/%yr")
ENDIF
IFglobal_timeout%=-1 THEN
 PROCset_string(setup%,2,"10")
 PROCsetstate(setup%,38,1<<21,1<<21)
 PROCsetstate(setup%,39,0,1<<21)
ELSE
 PROCset_string(setup%,2,STR$(global_timeout%))
 PROCsetstate(setup%,38,0,1<<21)
 PROCsetstate(setup%,39,1<<21,1<<21)
ENDIF
j%=global_weekwork%
FORi%=1 TO 7
 IF(j% AND 1) THEN
  PROCsetstate(setup%,30+i%,1<<21,1<<21)
 ELSE
  PROCsetstate(setup%,30+i%,0,1<<21)
 ENDIF
 j%=j%>>1
NEXT
alarm_counter%=global_timeout%
ENDPROC
:
DEFPROCsave_config
LOCAL cmos%,cli$,cli2$,i%,opt_file$,f%
cmos%=format%
IFalarm_confirm%  cmos%=cmos% OR %1000
IFalarm_autosave% cmos%=cmos% OR %10000
IFfivedayweek%    cmos%=cmos% OR %100000
IFsilent_alarm%   cmos%=cmos% OR %1000000
IFalarm_in_dst%   cmos%=cmos% OR %10000000
cli$ =FNbuild_alarm_options
SYS"OS_CLI",cli$

REM for obey file we must double every % otherwise it will change
REM "%24" into "4" as it think's %2 is a cli parameter
cli2$ =""
WHILE cli$ >""
 IF ASC(cli$) =37 THEN cli2$ +="%"
 cli2$ +=LEFT$(cli$,1)
 cli$ =MID$(cli$,2)
ENDWHILE

opt_file$ ="<Choices$Write>.Boot.Predesk.Alarm"
SYS "XOS_Find",&80,opt_file$ TO i%;f%
IF(f%AND1) THEN
 PROCok(FNrtoz(i%+4))
ELSE
 BPUT#i%,cli2$
 CLOSE#i%
 SYS "XOS_File",18,opt_file$,&FEB
ENDIF

SYS"XOS_Byte",162,&DC,cmos% TO i%;f%
IF(f%AND1) THEN PROCok(FNrtoz(i%+4))
ENDPROC
:
DEFFNbuild_alarm_options
LOCAL s$,q$,form$,fix_form$,c$
q$ =CHR$(34)
s$="Set Alarm$Options"
s$+=" -timeout "+q$+STR$(global_timeout%)+q$
s$+=" -weekwork "+STR$(global_weekwork%)
form$ =FNread_string(setup%,30)
fix_form$ =""

REM we need to change '<' to '|<' to preserve variable names
WHILE form$ >""
 c$ =LEFT$(form$,1)
 form$ =MID$(form$,2)

 IF c$ ="<" THEN fix_form$ +="|"
 fix_form$ +=c$
ENDWHILE
s$+=" -format "+q$+fix_form$+q$
=s$
:
REM browser code
:
DEFPROCopen_browser
LOCAL Y%,X%,W%,s$
!Q%=browser%:SYS"Wimp_GetWindowInfo",,Q%
!Q1%=browser%:SYS"Wimp_CloseWindow",,Q1%
!Q1%=browse1%:SYS"Wimp_CloseWindow",,Q1%
s$=$(Q%!76)
IFmodified% THEN
 IFRIGHT$(s$,1)<>"*" s$+=" *"
ELSE
 IFRIGHT$(s$,1)="*" s$=LEFT$(s$,LEN(s$)-2)
ENDIF
$(Q%!76)=s$
IF(Q%!32 AND (1<<16))=0 THEN
 REM window was already closed,
 REM so we can quite happily move it
 IF wimpversion%>243 THEN
  !Q1%=-2
  SYS"Wimp_GetWindowState",,Q1%
  Y%=Q1%!4-Q1%!20
  !Q1%=-2:Q1%!4=ictime%
  SYS"Wimp_GetIconState",,Q1%
  X%=Y%+Q1%!16-820
 ELSE
  !Q1%=-1:Q1%!4=ictime%
  SYS"Wimp_GetIconState",,Q1%
  X%=Q1%!16-820
 ENDIF
 IFalarm_count%=0 THEN
  Y%=48+52
 ELSE
  IFalarm_count%>20 THEN
   Y%=20*48+52
  ELSE
   Y%=alarm_count%*48+52
  ENDIF
 ENDIF
 Q%!12=(Q%!12-Q%!4)+X%
 Q%!16=Y%+172
 Q%!8=172
 Q%!4=X%
 Q%!20=0
 Q%!24=0
ELSE
 PROCtell_pinboard(browser%)
ENDIF
REM we want to force it to the top
Q%!28=-1
SYS"Wimp_OpenWindow",,Q%
PROCopen_top_pane(Q%,browse1%)
ENDPROC
:
DEFPROCadjust_browser_size
LOCAL l%,x%,p%,n%
REM first of all, zip through the list, counting the number of alarms
REM and working out how wide the window is going to be
alarm_count%=0
p%=alarm_head%
WHILE p%
 REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCadjust_browser_size")
 alarm_count%+=1
 IFp%?alarm_taskalarm% THEN
  l%=LEN(FNmsg_1("BrwsA1", $(p%+alarm_line1%)+$(p%+alarm_line2%)+$(p%+alarm_line3%)))
 ELSE
  IFp%?alarm_applalarm% THEN
   l%=LEN(FNmsg_1("BrwsA5", $(p%+alarm_line1%)))
  ELSE
   l%=LEN($(p%+alarm_line1%))
   IF$(p%+alarm_line2%)<>"" l%+=1+LEN($(p%+alarm_line2%))
   IF$(p%+alarm_line3%)<>"" l%+=1+LEN($(p%+alarm_line3%))
  ENDIF
 ENDIF
 IFl%>x% x%=l%
 p%=p%!alarm_next%
ENDWHILE
x%+=30:REM date and time bit
IFx%<70 x%=70
x%=x%*16+16
assembler%!16=x%
n%=alarm_count%*48
n%=-(n%+52)
!Q%=0:Q%!4=n%:Q%!8=x%:Q%!12=0:SYS"Wimp_SetExtent",browser%,Q%
!Q%=0:Q%!4=-52:Q%!8=x%:Q%!12=0:SYS"Wimp_SetExtent",browse1%,Q%
ENDPROC
:
DEFPROCredraw_browser
LOCAL more%
SYS"Wimp_RedrawWindow",,Q% TO more%
PROCupdate_browser(Q%,more%)
ENDPROC
:
DEFPROCupdate_browser(buff%,more%)
LOCAL A%,B%,C%,D%
A%=more%
B%=buff%
C%=alarm_head%
D%=msg_desc%
CALLassembler%
ENDPROC
:
REM DEFPROCnew_update_browser(buff%,more%)
REM LOCAL p%,x%,y%,y1%,y2%,i%
REM WHILE more%
REM  p%=alarm_head%
REM  x%=buff%!4-buff%!20
REM  y%=buff%!16-buff%!24-52:REM height of pane
REM  y1%=(y%-buff%!40) DIV 48
REM  y2%=(y%-buff%!32) DIV 48
REM  IFy1%<0 THEN
REM   y1%=0
REM  ENDIF
REM  IFy2%>=y1% THEN
REM   y%=-52
REM   IF y1% THEN
REM    FORi%=0 TO y1%-1
REM     y%-=48
REM     IFp% THEN
REM      p%=p%!alarm_next%
REM     ELSE
REM      REM if we've run out of pointers
REM      REM there isn't any point in staying in
REM      REM this loop
REM      i%=y1%
REM     ENDIF
REM    NEXT
REM   ENDIF
REM   FORi%=y1% TO y2%
REM    IFp% THEN
REM     PROCcreate_entry(y%,p%)
REM     IFp% p%=p%!alarm_next%
REM    ENDIF
REM   NEXT
REM  ENDIF
REM  SYS"Wimp_GetRectangle",,buff% TO more%
REM ENDWHILE
REM ENDPROC
REM :
REM DEFPROCcreate_entry(RETURN y%,p%)
REM LOCAL s$,t$,u$,v$
REM PROCalarm_rec_to_fivebt(p%,buffers%)
REM IFp%?alarm_taskalarm% THEN
REM  s$=" "+FNmsg_1("BrwsA1", $(p%+alarm_line1%)+$(p%+alarm_line2%)+$(p%+alarm_line3%))
REM ELSE
REM  IFp%?alarm_applalarm% THEN
REM   s$=" "+FNmsg_1("BrwsA5", $(p%+alarm_line1%))
REM  ELSE
REM   s$=" "+$(p%+alarm_line1%)
REM   IF$(p%+alarm_line2%)<>""
REM    s$+=" "+$(p%+alarm_line2%)
REM   ENDIF
REM   IF$(p%+alarm_line3%)<>""
REM    s$+=" "+$(p%+alarm_line3%)
REM   ENDIF
REM  ENDIF
REM ENDIF
REM t$=FNconverttime(buffers%,FNmsg_0("BrwsA2"))
REM u$=FNconverttime(buffers%,FNmsg_0("BrwsA3"))
REM v$=FNconverttime(buffers%,FNmsg_0("BrwsA4"))
REM PROCplot_icon(t$,0,            assembler%!4, &17006131):REM left justified
REM PROCplot_icon(u$,assembler%!4, assembler%!8, &17006331):REM right justified
REM PROCplot_icon(v$,assembler%!8, assembler%!12,&17006331):REM right justified
REM PROCplot_icon(s$,assembler%!12,assembler%!16,&17006131):REM left justified
REM y%-=48
REM ENDPROC
REM :
REM DEFPROCplot_icon(s$,left%,right%,mask%)
REM $Q2%=s$
REM !Q1%=left%
REM Q1%!4=y%-48
REM Q1%!8=right%
REM Q1%!12=y%
REM Q1%!16=mask%
REM IFp%?alarm_selected% THEN
REM  Q1%!16=Q1%!16 OR (1<<21)
REM ENDIF
REM Q1%!20=Q2%
REM Q1%!24=-1
REM Q1%!28=LEN($Q2%)+1
REM SYS"Wimp_PlotIcon",,Q1%
REM ENDPROC
:
DEFPROCcheck_browser(B%,Y%)
LOCAL i%
i%=FNalarm_hit(Y%)
IFi% THEN
 REM IFFNcheck_pointer PROCcheck_pointer(i%,"PROCcheck_browser")
 IFi%?alarm_applalarm% i%=0
ENDIF
CASE B% OF
WHEN 1024: IFi% THEN
            IFi%?alarm_selected%=0 THEN
             PROCunset_alarms_selection
             i%?alarm_selected%=1
             PROCredraw_alarm(i%)
            ENDIF
           ELSE
            IFFNalarm_selection_count PROCunset_alarms_selection
           ENDIF
WHEN  256: IFi% THEN
            i%?alarm_selected%=1-i%?alarm_selected%
            PROCredraw_alarm(i%)
           ENDIF
WHEN    4: IF current_action%=changing% PROCfront(a_wind%):PROCok(FNmsg_0("OkayA2"))
           IF current_action%=setting% PROCfront(a_wind%):PROCok(FNmsg_0("OkayA4"))
           i%=alarm_head%
           WHILE i%
            IFi%?alarm_selected% THEN
             i%?alarm_selected%=0
             PROCredraw_alarm(i%)
             PROCichang(i%)
             i%=0
            ELSE
             i%=i%!alarm_next%
            ENDIF
           ENDWHILE
ENDCASE
ENDPROC
:
DEFFNalarm_hit(y%)
LOCAL p%,i%,q%
!Q1%=browser%:SYS"Wimp_GetWindowState",,Q1%
y%-=Q1%!16-Q1%!24-52
i%=0
q%=0
p%=alarm_head%
WHILE p%
 REM IFFNcheck_pointer PROCcheck_pointer(p%,"FNalarm_hit")
 i%-=48
 IF(y%>i%) AND (y%<i%+48) THEN
  q%=p%
  p%=0
 ELSE
  p%=p%!alarm_next%
 ENDIF
ENDWHILE
=q%
:
DEFPROCselect_all_alarms
LOCAL C%
C%=alarm_head%
WHILE C%
 REM IFFNcheck_pointer PROCcheck_pointer(C%,"PROCselect_all_alarms")
 IFC%?alarm_applalarm%=0 C%?alarm_selected%=1
 C%=C%!alarm_next%
ENDWHILE
!Q%=browser%
Q%!4=0
Q%!8=-(alarm_count%*48+52)
Q%!12=assembler%!16
Q%!16=0
REM SYS"Wimp_UpdateWindow",,Q% TO C%
REM PROCupdate_browser(Q%,C%)
SYS"Wimp_ForceRedraw",!Q%,Q%!4,Q%!8,Q%!12,Q%!16
ENDPROC
:
DEFPROCunset_alarms_selection
LOCAL p%
p%=alarm_head%
WHILE p%
 REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCunset_alarms_selection")
 IFp%?alarm_selected% p%?alarm_selected%=0
 p%=p%!alarm_next%
ENDWHILE
!Q%=browser%
Q%!4=0
Q%!8=-(alarm_count%*48+52)
Q%!12=assembler%!16
Q%!16=0
REM SYS"Wimp_UpdateWindow",,Q% TO p%
REM PROCupdate_browser(Q%,p%)
SYS"Wimp_ForceRedraw",!Q%,Q%!4,Q%!8,Q%!12,Q%!16
ENDPROC
:
DEFPROCredraw_alarm(pointer%)
LOCAL p%,y%
p%=alarm_head%
y%=-52
WHILE p%
 IFp%=pointer% THEN
  !Q%=browser%
  Q%!4=0
  Q%!8=y%-48
  Q%!12=assembler%!16
  Q%!16=y%
  REM SYS"Wimp_UpdateWindow",,Q% TO p%
  REM PROCupdate_browser(Q%,p%)
  SYS"Wimp_ForceRedraw",!Q%,Q%!4,Q%!8,Q%!12,Q%!16
  p%=0
 ENDIF
 y%-=48
 IFp% p%=p%!alarm_next%
ENDWHILE
ENDPROC
:
DEFFNalarm_selection_count
LOCAL m2%,m3%
m3%=0
m2%=alarm_head%
WHILE m2% AND m3%<2
 REM IFFNcheck_pointer PROCcheck_pointer(m2%,"FNalarm_selection_count")
 IFm2%?alarm_selected% m3%+=1
 m2%=m2%!alarm_next%
ENDWHILE
=m3%
:
REM internationalisation support
:
DEFFNmonthsinyear(year%)
REM catch bad years. This is safe to do here!
IFyear%<1901 year%=1901
IFyear%>2247 year%=2247
REM first of all, build a five byte time
PROCordinals_to_fivebt(buffers%,1,1,1,1,year%)
REM now get the number of months in this year
SYS"Territory_ReadCalendarInformation",-1,buffers%,Q2%
=Q2%!8
:
DEFFNdaysinmonth(month%,year%)
REM catch bad years. This is safe to do here!
IFyear%<1901 year%=1901
IFyear%>2247 year%=2247
REM first of all, build a five byte time
PROCordinals_to_fivebt(buffers%,1,1,1,month%,year%)
REM now find out how many days there are in this month
SYS"Territory_ReadCalendarInformation",-1,buffers%,Q2%
=Q2%!12
:
DEFFNvalid_day(D%)
D%-=1
IF(global_weekwork% AND (1<<D%)) :=TRUE
=FALSE
:
DEFFNvalid_day_of_week(I%)
LOCAL J%
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNvalid_day_of_week")
IF I%?alarm_fvdywk% THEN
 IF(global_weekwork% AND (1<<FNday_of_week(I%)))=0 =FALSE
ENDIF
=TRUE
:
REM Territory manager returns day numbers as 1 = Sunday to
REM 7 = Saturday.
REM This function returns them as 0 = Sunday to 6 = Saturday.
DEFFNday_of_week(I%)
REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNday_of_week")
PROCalarm_rec_to_fivebt(I%,buffers%)
SYS"Territory_ConvertTimeToOrdinals",-1,buffers%,Q2%
=Q2%!28-1
:
DEFFNconverttime(B%,form$)
LOCAL T%,F%,f$,tst$
f$ =""
WHILE form$ >""
 tst$ =LEFT$(form$,3)
 IF tst$ ="~IN" THEN
  IF VAL(FNconverttime(B%,"%SE")) MOD 2 =0 THEN
   f$ +="."
  ELSE
   f$ +=":"
  ENDIF
  form$ =MID$(form$,4)
 ELSE
  f$ +=LEFT$(form$,1)
  form$ =MID$(form$,2)
 ENDIF
ENDWHILE
SYS "XTerritory_ConvertDateAndTime",-1,B%,Q1%,81,f$+CHR$13+CHR$0 TO ,T%;F%
IF(F% AND 1) THEN
 $Q1%=FNmsg_0("FrmtA4")
ELSE
 ?T%=13
ENDIF
=$Q1%
:
DEFPROCfivebt_to_ordinals(fivebt%,RETURN hr%,RETURN mi%,RETURN da%,RETURN mo%,RETURN yr%)
SYS"Territory_ConvertTimeToOrdinals",-1,fivebt%,Q2%
mi%=Q2%!8
hr%=Q2%!12
da%=Q2%!16
mo%=Q2%!20
yr%=Q2%!24
ENDPROC
:
REM what follows is the OLD fivebt to ordinals
REM LOCAL t$
REM t$=FNconverttime(fivebt%,"%CE%YR%MN%DY%24%MI")
REM yr%=VAL(LEFT$(t$,4))
REM mo%=VAL(MID$(t$,5,2))
REM da%=VAL(MID$(t$,7,2))
REM hr%=VAL(MID$(t$,9,2))
REM mi%=VAL(MID$(t$,11,2))
REM ENDPROC
:
DEFPROCalarm_rec_to_fivebt(ptr%,fivebt%)
LOCAL hr%,mi%,da%,mo%,yr%
REM IFFNcheck_pointer PROCcheck_pointer(ptr%,"PROCalarm_rec_to_fivebt")
hr%=ptr%!alarm_hours%
mi%=ptr%!alarm_minutes%
da%=ptr%!alarm_date%
mo%=ptr%!alarm_month%
yr%=ptr%!alarm_year%
PROCordinals_to_fivebt(fivebt%,hr%,mi%,da%,mo%,yr%)
ENDPROC
:
DEFPROCordinals_to_fivebt(fivebt%,hr%,mi%,da%,mo%,yr%)
!Q2%=0
Q2%!4=0
Q2%!8=mi%
Q2%!12=hr%
Q2%!16=da%
Q2%!20=mo%
Q2%!24=yr%
SYS"Territory_ConvertOrdinalsToTime",-1,fivebt%,Q2%
ENDPROC
:
DEFPROCset_clock_from_alarm_rec(ptr%)
REM IFFNcheck_pointer PROCcheck_pointer(ptr%,"PROCset_clock_from_alarm_rec")
PROCalarm_rec_to_fivebt(ptr%,Q2%)
SYS"Territory_SetTime",Q2%
ENDPROC
:
DEFPROCvalidate_alarm_rec(ptr%,RETURN error%)
LOCAL hr%,mi%,da%,mo%,yr%
REM IFFNcheck_pointer PROCcheck_pointer(ptr%,"PROCvalidate_alarm_rec")
hr%=ptr%!alarm_hours%
mi%=ptr%!alarm_minutes%
da%=ptr%!alarm_date%
mo%=ptr%!alarm_month%
yr%=ptr%!alarm_year%
PROCvalidate_ordinals(hr%,mi%,da%,mo%,yr%,error%)
ptr%!alarm_hours%=hr%
ptr%!alarm_minutes%=mi%
ptr%!alarm_date%=da%
ptr%!alarm_month%=mo%
ptr%!alarm_year%=yr%
ENDPROC
:
DEFPROCvalidate_ordinals(RETURN hr%,RETURN mi%,RETURN dy%,RETURN mo%,RETURN yr%,RETURN error%)
IFyr%>2247 yr%=2247:error%=TRUE:ENDPROC
WHILE mi%<0 mi%+=60:hr%-=1:ENDWHILE
WHILE mi%>59 mi%-=60:hr%+=1:ENDWHILE
WHILE hr%<0 hr%+=24:dy%-=1:ENDWHILE
WHILE hr%>23 hr%-=24:dy%+=1:ENDWHILE
WHILE dy%<1 mo%-=1:dy%+=FNdaysinmonth(mo%,yr%):ENDWHILE
WHILE dy%>FNdaysinmonth(mo%,yr%)
 dy%-=FNdaysinmonth(mo%,yr%)
 mo%+=1
 WHILEmo%>FNmonthsinyear(yr%) mo%-=FNmonthsinyear(yr%):yr%+=1:ENDWHILE
ENDWHILE
WHILE mo%<1 yr%-=1:mo%+=FNmonthsinyear(yr%):ENDWHILE
WHILE mo%>FNmonthsinyear(yr%) mo%-=FNmonthsinyear(yr%):yr%+=1:ENDWHILE
IF yr%<1901 yr%=1901
IF yr%>2247 yr%=2247:error%=TRUE
ENDPROC
:
DEFPROCout_of_memory
REM not a lot we can do except give a 'nice' error and quit
PROCfatal(FNmsg_0("OkayD3"))
ENDPROC
:
DEFFNenum_tasks(RETURN context%,RETURN th%,RETURN taskname$,RETURN slotsize%,RETURN flags%)
SYS "TaskManager_EnumerateTasks",context%,Q%,16 TO context%
IF context% <0 THEN =FALSE
th% =!Q%
SYS "XOS_GenerateError",Q%!4 TO taskname$
slotsize% =Q%!8
flags% =Q%!12
=TRUE

REM >>>>>>>>>>>>>>>>>>>
REM fixlib 0.00
DEF PROCfix_init(num_wins%)
fix_num% =0
DIM fix_info%(num_wins% -1,2)
DIM fix_help$(num_wins% -1,1)
ENDPROC

DEF PROCfix_dialogue(RETURN win%,ok_but$,can_but$,ok_help$,can_help$)
fix_help$(fix_num%,0) =ok_help$
fix_help$(fix_num%,1) =can_help$
!Q% =win%
SYS "Wimp_GetWindowInfo",,Q%
SYS "Wimp_DeleteWindow",,Q%

bar_size% =100

Q%!(4 +4) -=bar_size%

Q%!(4 +44) -=bar_size%

Q%!(4 +68) +=bar_size% <<16

num_icons% =Q%!(4+84)
iconp% =Q% +4 +88
icon_num% =0
found% =FALSE
WHILE num_icons% >0
 flags% =iconp%!16
 REM indirected + text?
 IF (flags% AND (%1<<8) +1) =(%1<<8) +1 THEN
  valid% =iconp%!(20 +4)
  IF valid% <> -1 THEN
   SYS "XOS_GenerateError",valid% TO str$
  ELSE
   str$ =""
  ENDIF

  IF INSTR(str$,"R5,3") >0 OR INSTR(str$,"R6,3") >0 THEN
   REM delete icon
   iconp%!16 =iconp%!16 OR (%1<<23)
   fix_info%(fix_num%,1) =icon_num%
   found% =TRUE
   num_icons% =1
  ENDIF
 ENDIF

 icon_num% +=1
 num_icons% -=1
 iconp% +=32
ENDWHILE
IF found% =FALSE THEN ok_but$ =""

SYS "Wimp_CreateWindow",,Q% +4 TO win%
fix_info%(fix_num%,0) =win%

REM now create embedded window
REM set maxy, to miny +barsize
Q%!(4 +12) =(Q%!(4 +4)) +bar_size%
Q%!(4 +16) =0 :REM scroll x offset
Q%!(4 +20) =0 :REM scroll y offset

REM window to open behind
Q%!(4+24) =-1

REM set work area size
Q%!(4 +44) = -bar_size%
Q%!(4 +68) = 0:REM(Q%!(4 +68) AND &FFFF) OR bar_size%<<16

REM check for 3d window borders
IF (Q%!(4+28) AND (%101<<28)) =0 THEN
  REM compensate for 3d border x-coord
  Q%!4 +=4
  Q%!12 -=4:REM-=8
  REM compensate for 3d border y-coord
  Q%!8 +=4
  bar_size% -=4
ENDIF
::bar_size% +=2
REM remove black window border
Q%?(4+32) =&FF

work_width% =Q%!(4 +48)
REM window flags
Q%!(4+28) =(1<<4) +(1<<31)

REM icons
Q%!(4+84) =3 :REM 3 icons
iconptr% =Q% +4+88

x% =work_width% -24
PROCbar_divicon(iconptr%,0,0,size_div%)
bar_size% -=size_div%
y% =-(size_div% +(bar_size% -54) DIV 2)

PROCbar_icon(iconptr%,x%,y%,ok_but$,"R6,3")
PROCbar_icon(iconptr%,x%,y%,can_but$,"R5,3")

SYS "Wimp_CreateWindow",,Q% +4 TO bar%
fix_info%(fix_num%,2) =bar%

!Q% =bar%
SYS "Wimp_OpenWindow",,Q%,&4B534154,win%,(%010101010101<<16) AND NOT 1

fix_num% +=1
ENDPROC

DEF PROCbar_icon(RETURN iconptr%,RETURN x%,y%,text$,valid$)
LOCAL tx%

IF text$ ="" THEN
  tx% =0
  PROCbar_icon(iconptr%,tx%,0,"!","R3,5")
  ENDPROC
ENDIF

IF INSTR(valid$,"R6") THEN
  width% =200
  depth% =68
  y% +=8
ELSE
  width% =184
  depth% =52
ENDIF
x% -=width%

iconptr%!0 =x% :REM min x
iconptr%!4 =y% -depth% :REM min y
iconptr%!8 =x% +width% :REM max x
iconptr%!12 =y% :REM max y

iconptr%!16 =(1<<28)+(7<<24) +(3<<12)+(1<<8) +(%1111<<2) + 1

DIM text% 31, valid% LEN(valid$)
$text% =text$ :$valid% =valid$
iconptr%!(20 +0) =text%
iconptr%!(20 +4) =valid%
iconptr%!(20 +8) =32

iconptr% +=32
x% -=20 :REM set up for next icon
ENDPROC
:
DEFPROCbar_divicon(RETURN iconptr%,x%,y%,RETURN height%)
LOCAL mode%,yeig%

REM if divider doesn't exist then height =0
SYS "XWimp_SpriteOp",40,,"divider" TO ,,,,height%,,mode%
SYS "XOS_ReadModeVariable",mode%,5 TO ,,yeig%
height% =height% <<yeig%

iconptr%!0 =x% :REM min x
iconptr%!4 =y% -height% :REM min y
iconptr%!8 =1280 :REM max x
iconptr%!12 =y% :REM max y

iconptr%!16 =1<<1
$(iconptr% +20) ="divider"

iconptr% +=32
ENDPROC
:
DEFPROCfix_click(Q%)
LOCAL bar_count%,parent%

REM find parent
REM leave iconbar alone!
IF (Q%!12) <1 THEN ENDPROC

Q%!20 =Q%!12
SYS "Wimp_GetWindowState",,Q%+20,&4B534154 TO ,,,parent%

bar_count% =0
WHILE bar_count% <fix_num%
  IF parent% =fix_info%(bar_count%,0) THEN

    FOR i% =0 TO 16 STEP 4
      Q%!(20+i%) =Q%!i%
    NEXT
    Q%!32 =parent% :REM win h

    REM menu pressed, if so send to parent
    IF Q%!8 =%010 THEN
      Q%!36 =-1    :REM icon h
      SYS "Wimp_SendMessage",6,Q% +20,parent%
    ELSE
      CASE (Q%!16) -1 OF
      WHEN 1:
        REM if CANCEL, send close message
        SYS "Wimp_SendMessage",3,Q% +20 +12,parent%

      WHEN 0:
        REM if OKAY
        Q%!36 =fix_info%(bar_count%,1) :REM icon h
        SYS "Wimp_SendMessage",6,Q% +20,parent%
      ENDCASE
    ENDIF

  ENDIF
  bar_count% +=1
ENDWHILE
ENDPROC
:
DEF PROCfix_help(Q%)
LOCAL pos%,icon%
IF FNfix_trans(Q%!32,2,pos%) THEN
  icon% =(Q%!36) -1
  IF icon% >-1 AND icon% <2 THEN
    help$ =fix_help$(pos%,icon%)
    Q%!(40 +0) =(24 +LEN(help$) +1) AND NOT 3
    Q%!(40 +12) =Q%!8
    Q%!(40 +16) =&503 :REM Message_HelpReply
    $(Q% +40 +20) =help$+CHR$(0)
    SYS "Wimp_SendMessage",17,Q% +40,Q%!4
  ENDIF
ENDIF
ENDPROC
:
DEF PROCfix_sethelp(win%,icon%,help$)
LOCAL pos%
IF FNfix_trans(win%,0,pos%) THEN
  fix_help$(pos%,icon%) =help$
ENDIF
ENDPROC
:
DEF PROCfix_setbutton(win%,icon%,button$)
LOCAL bar%
IF FNfix_trans(win%,0,pos%) THEN
  bar% =fix_info%(pos%,2)
  PROCset_string(bar%,icon% +1,button$)
ENDIF
ENDPROC
:
DEF FNfix_trans(win%,type%,RETURN bar_count%)
bar_count% =0
WHILE bar_count% <fix_num%
  IF win% =fix_info%(bar_count%,type%) THEN =TRUE

  bar_count% +=1
ENDWHILE
=FALSE
:
DEF FNfix_key(Q%)
IF FNfix_trans(Q%!0,0,null%) THEN
  CASE Q%!24 OF
  WHEN &01B,&1A2
    REM escape or CTRL+f2
    REM close current window
    SYS "Wimp_SendMessage",3,Q%,!Q%
    =TRUE
  ENDCASE
ENDIF
=FALSE

REM >>>>>>>>>>>>>>>>>>>
REM subtime 0.00
DEF PROCinit_timediff
DIM cur_time% 4,copy_first% 7,copy_second% 7,cur_ordinals% 35,first_ordinals% 35,sub_time% 63

P% =sub_time%
[OPT 2
LDMIA r0,{r2,r4}
LDMIA r1,{r3,r5}
SUBS  r2,r3,r2
SBC   r4,r5,r4
STMIA r0,{r2,r4}

CMP   r0,#0 ;clrv
MOV   pc,r14
]
ENDPROC

DEF PROCtime_diff(first%,second%,RETURN sign%,RETURN yrs%,RETURN days%,RETURN hrs%,RETURN mins%)
LOCAL A%,B%

copy_first%!0 =first%!0
copy_first%!4 =first%?4
copy_second%!0 =second%!0
copy_second%!4 =second%?4

A% =copy_first%
B% =copy_second%
CALL sub_time%

IF copy_first%?5 =&FF THEN
  REM subtract from 0 to negate
  copy_second%!0 =0
  copy_second%!4 =0
  CALL sub_time%
  sign% =-1
ELSE
  sign% =0
ENDIF

SYS "Territory_ConvertTimeToUTCOrdinals",,copy_first%,first_ordinals%
yrs% =(first_ordinals%!&18) -1900
days% =(first_ordinals%!&20) -1
hrs% =(first_ordinals%!&C)
mins% =(first_ordinals%!&8)

ENDPROC
REM >>>>>>>>>>>>>>>>>>>
REM msglib 0.01
DEFPROCmsg_init(N$)
REM LOCAL ERROR
REM ON ERROR LOCAL RESTORE ERROR:ERROR 0,"Cannot find messages file"
DIM msg_text% 256
SYS "OS_Module",6,,,17+LEN(N$) TO ,,msg_desc%
$(msg_desc%+16)=N$
SYS "MessageTrans_OpenFile",msg_desc%,msg_desc%+16,0
ENDPROC
:
DEFFNmsg_0(T$)
=FNmsg_4(T$,"","","","")
:
DEFFNmsg_1(T$,S$)
=FNmsg_4(T$,S$,"","","")
:
DEFFNmsg_2(T$,S0$,S1$)
=FNmsg_4(T$,S0$,S1$,"","")
:
DEFFNmsg_3(T$,S0$,S1$,S2$)
=FNmsg_4(T$,S0$,S1$,S2$,"")
:
DEFFNmsg_4(T$,S0$,S1$,S2$,S3$)
LOCAL F%,L%,eb%
SYS "XMessageTrans_Lookup",msg_desc%,T$,msg_text%,256,S0$,S1$,S2$,S3$ TO eb%,,,L%;F%
IF F% AND 1 THEN=T$
msg_text%?L%=13
=$msg_text%
:
DEFPROCmsg_end
IFmsg_desc% THEN
  SYS"MessageTrans_CloseFile",msg_desc%
  SYS"OS_Module",7,,msg_desc%
ENDIF
ENDPROC
REM >>>>>>>>>>>>>>>>>>>
REM errlib 0.01
DEF PROCerr_init
errok% =1
errfatal% =3
ENDPROC

DEF PROCerr_report(err%,errortext$,flags%)
LOCAL OKC%,wimpver%
SYS "XWimp_DragBox",,-1
IF err% =&108D5 OR err% =&108D4 THEN ENDPROC

IF err% =errok% THEN flags% =flags% AND NOT %10
IF err% =errfatal% THEN flags% =(3 <<9) +(%10)
IF flags% AND %10 THEN flags% =flags% OR (3<<9)

OKC% =flags% AND %11
IF OKC% =%11 THEN errortext$ =FNmsg_2("Unexp",LEFT$(errortext$,230 -LEN(FNmsg_0("Unexp"))),STR$(ERL))
IF OKC% =%10 THEN errortext$ =FNmsg_2("Fatal",LEFT$(errortext$,230 -LEN(FNmsg_0("Fatal"))),STR$(ERL))

REM if wimp>350 then replace Cancel with Quit
SYS "Wimp_ReadSysInfo",7 TO wimpver%
IF wimpver% >350 AND (flags% AND %10) >0 THEN
  errortext$ =FNmsg_0("ErrBut")+"{"+LEFT$(errortext$,240 -LEN(FNmsg_0("ErrBut")))

  flags% =flags% AND NOT %10
ENDIF

IF FNerr_box(err%,errortext$,flags%) >1 THEN PROCshutdown
ENDPROC

REM Error categories (at <<9)
REM 0 as 2 (error)
REM 1 information report (information)= just tell user something
REM 2 error report (warning) = tell user about problem, but app will continue
REM 3 program report (program) = an error that should not occur and may require app to quit
REM 4 question report (question) = ask user question (ie DCS)
REM 5 do not use (user 1)
REM 6 do not use (user 2)
DEF FNerr_box(err%,but_msg$,flags%)
LOCAL pos%,but$,err$,taskh%,task$,errf%,v%
pos% =INSTR(but_msg$,"{") :IF pos% THEN pos% -=1

but$ =MID$(but_msg$,0,pos%)
err$ =MID$(but_msg$,INSTR(but_msg$,"{") +1)
err$ =CHR$(err% >>24)+CHR$(err% >>16)+CHR$(err% >>8)+CHR$(err%) +LEFT$(err$,251)

SYS "XWimp_ReadSysInfo",5 TO taskh%;errf%
SYS "XTaskManager_TaskNameFromHandle",taskh% TO task$;v%
errf% =errf% OR v%

IF errf% AND %1 THEN task$ ="Unknown task"

IF but$ >"" THEN
  SYS "Wimp_ReportError",err$,(1<<8) +flags%,task$,,,but$ TO ,ans%
ELSE
  SYS "Wimp_ReportError",err$,(1<<8) +flags%,task$ TO ,ans%
ENDIF
=ans%
