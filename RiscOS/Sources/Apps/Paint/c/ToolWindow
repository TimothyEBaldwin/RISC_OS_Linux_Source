/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* > c.ToolWindow
 *
 *  Paint: Arthur 2 sprite editor
 *   Sprite tool window handling
 *
 *  Author: A.P. Thompson
 *
 * Upgraded to RISCOSlib - DAHE - 16 Aug 1989
 *  DAHE, 28 Aug  89 - internationalisation
 *  DAHE, 13 Sept 89 - get round static data init. problem for module version
 *  JAB,  30 Oct  90 - Now brings the toolbox to the front if it is already
 *                     open
 *  JAB,  26 Feb  91 - added better interactive help for the tool window
 */

#include <assert.h>
#include <ctype.h>
#include <stdint.h>
#include <string.h>
#include <swis.h>
#include "Global/FileTypes.h"
#include "Global/Sprite.h"
#include "bbc.h"
#include "colourtran.h"
#include "dbox.h"
#include "dboxquery.h"
#include "help.h"
#include "werr.h"
#include "wimpt.h"
#include "wimp.h"
#include "template.h"
#include "event.h"
#include "visdelay.h"
#include "xferrecv.h"
#include "jpeg.h"
#include "xfersend.h"

#include "main.h"
#include "Menus.h"
#include "PSprite.h"
#include "SprWindow.h"
#include "ToolWindow.h"
#include "Tools.h"
#include "ftrace.h"
#include "guard.h"
#include "CnPDrag.h"
#include "Colours.h"

/**********************
 * Static variables   *
 **********************/

tools_template tools_tool_template;
tools_brush_pane_template tools_brushpane_template;
wimp_w toolwindow_handle;
wimp_w tools_brushpane_handle = 0;
toolwindow_block *toolwindow_current_tool;
int toolwindow_current_mode = 0;

static toolwindow_block *toolarray [tools_COUNT];
static void init_toolarray (void)
{ /* Required to generate relocatable code */
  toolarray [0]  = NULL;
  toolarray [1]  = &tools_pixelpaint;
  toolarray [2]  = &tools_spraycanpaint;
  toolarray [3]  = &tools_floodfillpaint;
  toolarray [4]  = &tools_linepaint;
  toolarray [5]  = &tools_ellipseoutlinepaint;
  toolarray [6]  = &tools_ellipsepaint;
  toolarray [7]  = &tools_circleoutlinepaint;
  toolarray [8]  = &tools_circlepaint;
  toolarray [9]  = &tools_trianglepaint;
  toolarray [10] = &tools_arcpaint;
  toolarray [11] = &tools_segmentpaint;
  toolarray [12] = &tools_sectorpaint;
  toolarray [13] = &tools_camerapaint;
  toolarray [14] = &tools_scissorpaint;
  toolarray [15] = &tools_textpaint;
  toolarray [16] = &tools_grabberpaint;
  toolarray [17] = &tools_rectanglepaint;
  toolarray [18] = &tools_rectangleoutlinepaint;
  toolarray [19] = &tools_parallelogrampaint;
  toolarray [20] = &tools_parallelogramoutlinepaint;
  toolarray [21] = &tools_brushpaint;
}

static char recent_user_brush [NAME_LIMIT + 1];
static main_sprite *brushpane_icon_sprites [tools_MAX_BRUSH_ICONS];
static int num_user_brushes = 0;
static int num_brushpane_icons = 0;
static int selected_brushpane_icon = -1;
static int number_of_builtin_brushes = -1;

static char *onlydigits  = "A0-9;Kt";
static char *allkeys = "Kndt";
static char *allowtab = "Kt";
static char *onlydigitsallkeys = "A0-9;Kndt";
static char *decimaldigitsallkeys = "A0-9.;Kndt";

static void destroy_brush_pane (void);

static void make_brush_pane (void);

static unsigned int slider_set (unsigned int, int, int, int, char *);

/********************************
 * Set text field in toolwindow *
 ********************************/

static void setdescription (void)

{ wimp_icon descicon;
  wimpt_noerr (wimp_get_icon_info (toolwindow_handle, tools_DESC_ICON,
      &descicon));
  strcpy (descicon.data.indirecttext.buffer,
         msgs_lookup (toolwindow_current_tool->description));
  wimpt_noerr (wimp_set_icon_state (toolwindow_handle, tools_DESC_ICON,
      (wimp_iconflags) 0, (wimp_iconflags) 0));
}

static void set_tool_caret (int i)

{ wimp_caretstr grabcar;
  wimp_icon descicon;

  grabcar.w = toolwindow_handle;
  grabcar.i = i;
  grabcar.x = grabcar.y = grabcar.height = -1;

  /* put caret at end of string */
  wimpt_noerr (wimp_get_icon_info (toolwindow_handle, i, &descicon));
  grabcar.index = strlen (descicon.data.indirecttext.buffer);

  wimpt_noerr (wimp_set_caret_pos (&grabcar));
}

static wimp_wind *drop_wind;

static wimp_i createicon_ind (int n, int selected, char *buffer, int len,
    char *valid)

{ wimp_icreate icreate;
  wimp_i icon;

  icreate.w = toolwindow_handle;
  icreate.i = * (wimp_icon *) ( (char *)&drop_wind [1] + n * sizeof (wimp_icon));
  if (buffer)
  { icreate.i.flags = (wimp_iconflags) (icreate.i.flags | wimp_INDIRECT);
    icreate.i.data.indirecttext.buffer = buffer;
    icreate.i.data.indirecttext.validstring = valid;
    icreate.i.data.indirecttext.bufflen = len;
  }
  if (selected)
    icreate.i.flags = (wimp_iconflags) (icreate.i.flags | wimp_ISELECTED);
  wimpt_noerr (wimp_create_icon (&icreate, &icon));
  return icon;
}

static wimp_i createicon (int n, int selected)

{ return createicon_ind (n, selected, 0, 0, 0);
}

static void extend_tools (void)

{ wimp_wstate state;

  wimpt_noerr (wimp_get_wind_state (toolwindow_handle, &state));
  state.o.box.y0 = state.o.box.y1 - (drop_wind->box.y1 - drop_wind->box.y0);
  wimpt_noerr (wimp_open_wind (&state.o));
}

static void munge_window (void)

{ int caretgrab = -1;

  if (toolwindow_current_tool == &tools_textpaint)
  { drop_wind = template_syshandle ("tool_text");
    extend_tools ();
    tools_icons [0] = createicon (0, 0);
    tools_icons [1] = createicon_ind (1, 0, tools_text_buffer, 256, allowtab);
    tools_icons [2] = createicon (6, 0);
    tools_icons [3] = createicon_ind (2, 0, tools_text_xsize, 5, onlydigits);
    tools_icons [4] = createicon (7, 0);
    tools_icons [5] = createicon_ind (3, 0, tools_text_ysize, 5, onlydigits);
    tools_icons [6] = createicon (5, 0);
    tools_icons [7] = createicon_ind (4, 0, tools_text_xspace, 5, onlydigits);
    caretgrab = 1;

    /* now enable nulls for all sprites */
    menus_restart_tool ();
  }
  else if (toolwindow_current_tool == &tools_floodfillpaint)
  { drop_wind = template_syshandle ("tool_fill");
    extend_tools ();
    tools_icons [0] = createicon (0, tools_flood_local);
    tools_icons [1] = createicon (1, !tools_flood_local);
  }
  else if (toolwindow_current_tool == &tools_scissorpaint ||
      toolwindow_current_tool == &tools_camerapaint)
  { drop_wind = template_syshandle ("tool_cut");
    extend_tools ();
    tools_icons [0] = createicon (0, !tools_exporting_sprite);
    tools_icons [1] = createicon (1, tools_exporting_sprite);
  }
  else if (toolwindow_current_tool == &tools_grabberpaint)
  { drop_wind = template_syshandle ("tool_grab");
    extend_tools ();
    tools_icons [0] = createicon (0, tools_grabber_wrap);
  }
  else if (toolwindow_current_tool == &tools_spraycanpaint)
  { drop_wind = template_syshandle ("tool_spray");
    extend_tools ();
    tools_icons [0] = createicon (2, 0);
    tools_icons [1] = createicon_ind (0, 0, tools_spray_density, 4,
        onlydigits);
    tools_icons [2] = createicon (3, 0);
    tools_icons [3] = createicon_ind (1, 0, tools_spray_radius, 4,
        onlydigits);
    caretgrab = 1;
  }
  else if (toolwindow_current_tool ==  &tools_brushpaint)
  { char *newbrushsprite;

    drop_wind = template_syshandle ("tool_brush");
    extend_tools ();
    tools_icons [tools_bicon_YScText] = createicon (10, 0);
    tools_icons [tools_bicon_YNScBox] = createicon (6, 0);
    tools_icons [tools_bicon_XScText] = createicon (9, 0);
    tools_icons [tools_bicon_XNScBox] = createicon (3, 0);
    tools_icons [tools_bicon_XNScaleMUp] = createicon (21, 0);
    tools_icons [tools_bicon_XNScaleMDown] = createicon (22, 0);
    tools_icons [tools_bicon_XNScaleDUp] = createicon (23, 0);
    tools_icons [tools_bicon_XNScaleDDown] = createicon (24, 0);
    tools_icons [tools_bicon_YNScaleMUp] = createicon (25, 0);
    tools_icons [tools_bicon_YNScaleMDown] = createicon (26, 0);
    tools_icons [tools_bicon_YNScaleDUp] = createicon (27, 0);
    tools_icons [tools_bicon_YNScaleDDown] = createicon (28, 0);
    tools_icons [tools_bicon_BrushText] = createicon (11, 0);
    tools_icons [tools_bicon_NameText] = createicon (13, 0);
    tools_icons [tools_bicon_UseNew] = createicon (0, 0);
    tools_icons [tools_bicon_UseGCOL] = createicon (2, tools_brush_use_gcol == 1);
    tools_icons [tools_bicon_UseStamp] = createicon (19, tools_brush_use_gcol == 0);
    tools_icons [tools_bicon_UseTint] = createicon (20, tools_brush_use_gcol == 2);
    tools_icons [tools_bicon_OpacText] = createicon (14, 0);
    tools_icons [tools_bicon_OpacBrdr] = createicon (16, 0);
    tools_icons [tools_bicon_OpacBgnd] = createicon (17, 0);
    tools_icons [tools_bicon_OpacBar] = createicon (18, 0);
    tools_icons [tools_bicon_Opacity] = createicon_ind (15, 0, tools_brush_nopacity,
        5, decimaldigitsallkeys);
    /* Fade the opacity slider if BlendTable / InverseTable unavailable */
    if (!HaveBlendTable())
    { wimpt_noerr (wimp_set_icon_state (toolwindow_handle, tools_icons [tools_bicon_Opacity],
          wimp_INOSELECT, wimp_INOSELECT));
      wimpt_noerr (wimp_set_icon_state (toolwindow_handle, tools_icons [tools_bicon_OpacBar],
          wimp_INOSELECT, wimp_INOSELECT));
      tools_brush_opacity = 1000;
    }
    /* Position the opacity slider correctly */
    tools_brush_opacity = slider_set (tools_brush_opacity,
        tools_bicon_OpacBar, tools_bicon_OpacBgnd,
        tools_bicon_Opacity, tools_brush_nopacity);
    /* SMC: Look up default brush name in Messages file. */
    newbrushsprite = msgs_lookup (tools_newbrushsprite);
    /* But keep it in our own indirected buffer */
    if (newbrushsprite != tools_newbrushsprite)
    { strncpy (tools_newbrushsprite, newbrushsprite, NAME_LIMIT);
      tools_newbrushsprite [NAME_LIMIT] = '\0';
    }
    tools_icons [tools_bicon_NewName] = createicon_ind(12, 0, tools_newbrushsprite, 13, allkeys);
    tools_icons [tools_bicon_XNScaleM] = createicon_ind(5, 0, tools_brush_nxscalem, 3, onlydigitsallkeys);
    tools_icons [tools_bicon_XNScaleD] = createicon_ind(4, 0, tools_brush_nxscaled, 3, onlydigitsallkeys);
    tools_icons [tools_bicon_YNScaleM] = createicon_ind(7, 0, tools_brush_nyscalem, 3, onlydigitsallkeys);
    tools_icons [tools_bicon_YNScaleD] = createicon_ind(8, 0, tools_brush_nyscaled, 3, onlydigitsallkeys);

    strncpy (tools_newbrushsprite, tools_brushsprite, 13);
#if 0
    /* These duplicate strings never seemed to be used for anything: */
    strncpy (tools_brush_nxscalem, tools_brush_cxscalem, 3);
    strncpy (tools_brush_nxscaled, tools_brush_cxscaled, 3);
    strncpy (tools_brush_nyscalem, tools_brush_cyscalem, 3);
    strncpy (tools_brush_nyscaled, tools_brush_cyscaled, 3);
    strncpy (tools_brush_nopacity, tools_brush_copacity, 3);
#endif
    caretgrab = tools_bicon_NewName;

    make_brush_pane ();

    /* now enable nulls for all sprites */
    menus_restart_tool ();
  }

  if (caretgrab >= 0) set_tool_caret (tools_icons [caretgrab]);
}

static void readscale (char *in, int *res, char *out)

{ sscanf (in, "%d", res);
  if (*res == 0) *res = 1;
  strcpy (out, in);
}

/**********************************************************************
 *                                                                    *
 *  Window event handler for sprite tool windows.                     *
 *                                                                    *
 **********************************************************************/

static void demunge_window (int really)

{ int iconlim = 0;

  if (toolwindow_current_tool == &tools_textpaint)
    iconlim = 8;
  else if (toolwindow_current_tool == &tools_spraycanpaint)
    iconlim = 4;
  else if (toolwindow_current_tool == &tools_brushpaint)
  { iconlim = tools_bicon_Max;
    destroy_brush_pane ();
    if (really) psprite_free_brush_blocks ();
  }
  else if (toolwindow_current_tool == &tools_floodfillpaint ||
      toolwindow_current_tool == &tools_scissorpaint ||
      toolwindow_current_tool == &tools_camerapaint)
    iconlim = 2;
  else if (toolwindow_current_tool == &tools_grabberpaint)
    iconlim = 1;

  if (iconlim != 0)
  { int i;

    for (i = 0; i < iconlim; i++)
      wimpt_noerr (wimp_delete_icon (toolwindow_handle, tools_icons [i]));
    drop_wind = &tools_tool_template.t;
    extend_tools ();
  }
}

static void set_tool_window_state (void)

{ int i;

  for (i=1; i <= tools_COUNT; i++)
    wimpt_noerr (wimp_set_icon_state (toolwindow_handle, i,
        toolarray [i] == toolwindow_current_tool?
            wimp_ISELECTED: (wimp_iconflags) 0,
        wimp_ISELECTED));

  for (i=0; i <= 3; i++)
    wimpt_noerr (wimp_set_icon_state (toolwindow_handle,
        i + tools_MODE_ICON_BASE,
        i == toolwindow_current_mode? wimp_ISELECTED: (wimp_iconflags) 0,
        wimp_ISELECTED));

  demunge_window (0);
  munge_window ();
  setdescription ();
}

void toolwindow_stop_all_tools (void)

  /*Stop the tool in all sprite windows. Actually, stop it in all sprite
    blocks, not just those with open windows (J R C, 6th Dec 1993).*/

{ main_window *w;
  main_sprite *s;

  ftracef0 ("toolwindow_stop_all_tools\n");

  for (w = main_windows; w != NULL; w = w->link)
    if (w->tag == main_window_is_file)
      for (s = w->data->file.sprites; s != NULL; s = s->link)
        toolwindow_current_tool->stop_action (s);
}

void toolwindow_readbrushscale (void)

{ ftracef0 ("readbrushscale\n");
  readscale (tools_brush_nxscalem, &tools_brushscale.scale_xmul,
      tools_brush_cxscalem);
  readscale (tools_brush_nxscaled, &tools_brushscale.scale_xdiv,
      tools_brush_cxscaled);
  readscale (tools_brush_nyscalem, &tools_brushscale.scale_ymul,
      tools_brush_cyscalem);
  readscale (tools_brush_nyscaled, &tools_brushscale.scale_ydiv,
      tools_brush_cyscaled);
}

void toolwindow_readbrushmode (void)

{ ftracef0 ("readbrushmode\n");
  if (toolwindow_handle == 0)
    return;
  /* Reads Shape / Stamp / Tint */
  wimp_icon shape, /*stamp,*/ tint;
  wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
            tools_icons [tools_bicon_UseGCOL], &shape));
  /*wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
            tools_icons [tools_bicon_UseStamp], &stamp));*/
  wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
            tools_icons [tools_bicon_UseTint], &tint));

  if ((shape.flags & wimp_ISELECTED) != 0)
    tools_brush_use_gcol = 1;
  else if ((tint.flags & wimp_ISELECTED) != 0)
    tools_brush_use_gcol = 2;
  else /* Stamp mode: */
    tools_brush_use_gcol = 0;
}

static int get_number_of_builtin_brushes (void)
{ /* Messages tells us how many built-in brush sprites are supplied in
     the Paint:Sprites file, capped at a maximum of
     tools_MAX_BUILTIN_BRUSHES for the brush menu */
  if (number_of_builtin_brushes < 0)
  { int num_sys_brushes;
    char *msg = msgs_lookup ("BRUSHCOUNT");
    if (!msg || strcmp (msg, "BRUSHCOUNT") == 0)
      num_sys_brushes = 4;
    else
      num_sys_brushes = atoi (msg);

    number_of_builtin_brushes = MIN(num_sys_brushes, tools_MAX_BUILTIN_BRUSHES);
  }
  return number_of_builtin_brushes;
}

static void set_number_of_builtin_brushes (int number)
{ number_of_builtin_brushes = number;
}

static char *get_first_builtin_brush (void)
{ /* Messages also tells us the name of the first brush sprite. They need
     to all be adjacent to one another in the sprite file. */
  char *brush_name = msgs_lookup ("BRUSH1ST");
  if (!brush_name || strcmp (brush_name, "BRUSH1ST") == 0)
    brush_name = "brush";
  return brush_name;
}

static BOOL Matches (char *a, char *b)

{ ftracef0 ("Matches\n");
  while (*a || *b)
  { if (tolower (*a++) != tolower (*b++))
      return 0;
  }
  return 1;
}

void performbrushGOaction (void)

{ main_sprite *newbrushsprite_ptr, *oldbrushsprite_ptr;
  char oldbrushsprite [NAME_LIMIT + 1];
  char *newbrushsprite;
  main_sprite *sprite_ptr = NULL;
  int i, num_sys_brushes;
  int prev_brushpane_icon = selected_brushpane_icon;
  BOOL alreadyseen = FALSE;
  os_error *error = NULL;

  ftracef0 ("performbrushGOaction\n");
  oldbrushsprite_ptr = tools_brushsprite_ptr;
  strcpy (oldbrushsprite, tools_brushsprite);

  /* SMC: Look up default brush name in Messages file. */
  newbrushsprite = msgs_lookup (tools_newbrushsprite);
  ftracef2 ("newbrushsprite: '%s' tools_newbrushsprite: '%s'\n", newbrushsprite, tools_newbrushsprite);

  /* We'll check if this brush sprite name is already on the menu, in a clunky way */
  num_sys_brushes = get_number_of_builtin_brushes ();
  if (num_sys_brushes > num_brushpane_icons)
  { /* We're in trouble. This function's been called before the brush pane
       has been built, most likely. */
    ftracef2 ("num_sys_brushes: %d num_brushpane_icons: %d\n", num_sys_brushes, num_brushpane_icons);
    return;
  }

  /* Check all the built-in brushes that we put on the menu */
  /* Don't use psprite_find() here because it breaks Paint if the user
     decides to open and close Paint's own Sprites file or possibly
     other sprites with the same names as the built-in brushes. */
  for (i = 0; i < num_sys_brushes; i++)
  { psprite_info sinfo;
    sprite_ptr = brushpane_icon_sprites[i];
    if (sprite_ptr == NULL)
      break;
    psprite_read_full_info (sprite_ptr, &sinfo);
    if (Matches (sinfo.name, newbrushsprite))
    { alreadyseen = TRUE;
      selected_brushpane_icon = i;
      break;
    }
  }

  /* Check any user brush */
  if (!alreadyseen && num_user_brushes > 0 &&
      Matches (recent_user_brush, newbrushsprite))
  { alreadyseen = TRUE;
    selected_brushpane_icon = num_sys_brushes;
  }

  /* If this is a newly seen brush sprite, replace the user brush icon */
  if (!alreadyseen)
  { newbrushsprite_ptr = psprite_find (newbrushsprite, "PntE5a");
    if (newbrushsprite_ptr == NULL)
    { ftracef1 ("Brush sprite %s cannot be found.\n", newbrushsprite);
      return;
    }
    if ((!psprite_havealphamasks () && psprite_hasalphamask (newbrushsprite_ptr)) ||
        (!psprite_havealphachannels () && psprite_hasalphachannel (newbrushsprite_ptr)))
    { error = main_error ("PntWJ");
      wimpt_complain (error);
      goto finish;
    }
    strncpy (recent_user_brush, newbrushsprite, NAME_LIMIT);
    recent_user_brush [NAME_LIMIT] = '\0';
    if (num_user_brushes == 0)
    { num_user_brushes = 1;
      num_brushpane_icons++;
    }
    selected_brushpane_icon = num_sys_brushes;
    brushpane_icon_sprites [selected_brushpane_icon] = newbrushsprite_ptr;
    ftracef0 ("Newly seen user brush added\n");
  }
  else
  { /* Otherwise make sure we use the existing sprite, not a new one */
    newbrushsprite_ptr = brushpane_icon_sprites [selected_brushpane_icon];
  }

#if 0
  /* This shouldn't ever be needed. The user text is always left unchanged. */
  ftracef0 ("calling main_force_redraw\n");
  main_force_redraw (toolwindow_handle);
#endif

  tools_remove_brush ();  /* do before corrupting brushsprite_ptr! */

  ftracef0 ("calling psprite_free_brush_blocks\n");
  wimpt_noerr (psprite_free_brush_blocks ());

  tools_brushsprite_ptr = newbrushsprite_ptr;
  strcpy (tools_brushsprite, tools_newbrushsprite);

  ftracef0 ("calling psprite_set_brush_colour_translations\n");
  error = psprite_set_brush_colour_translations ();
  if (wimpt_complain (error) != NULL)
    goto finish;

  tools_delete_brushmouse_sprite ();
  if (psprite_hasalphamask (tools_brushsprite_ptr) ||
      psprite_hasalphachannel (tools_brushsprite_ptr))
  { /*The EOR plot to draw and erase the brush under the mouse pointer
      won't work with alpha sprites, so convert to on/off mask.*/
    error = tools_make_brushmouse_sprite ();
    if (error != NULL)
      goto finish;
  }

  /*Moved to after psprite_set_brush_colour_translations - less state to
    restore. J R C 5th Jul 1994*/
  toolwindow_readbrushscale ();

  ftracef0 ("calling tools_replace_brush\n");
  tools_replace_brush ();

finish:
  if (error != NULL)
  { tools_brushsprite_ptr = oldbrushsprite_ptr;
    strcpy (tools_brushsprite, oldbrushsprite);
    wimpt_noerr (psprite_set_brush_colour_translations ());
    selected_brushpane_icon = prev_brushpane_icon;
  }
}

/********************************
 * Brush window pane functions  *
 ********************************/

static void destroy_brush_pane (void)

{ ftracef0 ("destroy_brush_pane\n");
  main_delete_window (tools_brushpane_handle);
  tools_brushpane_handle = 0;
}

static void draw_brush_pane_icon (int i, wimp_redrawstr *rds)

{ main_sprite *sprite = brushpane_icon_sprites [i];
  int x0 = tools_BRUSH_ICON_STRIDE * i + tools_BRUSH_ICON_MARGIN;
  int y1 = -(tools_BRUSH_ICON_MARGIN + tools_BRUSH_ICON_BORDER + tools_BRUSH_ICON_PADDING);
  int y0 = y1 - tools_BRUSH_ICON_SIZE - tools_BRUSH_ICON_BORDER - tools_BRUSH_ICON_PADDING;
  sprite_info infoblock;
  psprite_info sinfo;
  main_scaling_block iconsize;
  BOOL hasSize, selected;
  
  ftracef0 ("draw_brush_pane_icon\n");

  if (i < 0 || i >= num_brushpane_icons)
  { ftracef1 ("Error: brush pane index %d out of range.\n", i);
    return;
  }
  if (sprite == NULL)
  { ftracef2 ("Error: brushpane icon sprite at %d is NULL. num brushpane icons: %d\n", i, num_brushpane_icons);
    return;
  }

  hasSize = !psprite_read_size (sprite, &infoblock);

  psprite_read_full_info (sprite, &sinfo);

  if (hasSize)
  { int iconwidth = tools_BRUSH_ICON_SIZE;
    int iconheight = tools_BRUSH_ICON_SIZE;
    int iconOuterWidth = 2 * (tools_BRUSH_ICON_BORDER +
        tools_BRUSH_ICON_PADDING) + tools_BRUSH_ICON_SIZE;
    int iconOuterHeight = iconOuterWidth;
    int spritewidth, spriteheight; /* sizes after scaling */

    /* Scale the sprite to fit into the brush pane icon, if it's too big */
    iconsize.scale_xmul =
    iconsize.scale_xdiv =
    iconsize.scale_ymul =
    iconsize.scale_ydiv = 1;

    ftracef4 ("Brush sprite '%s' height: %d mode ymul: %d in pixels: %d\n",
        sinfo.name, infoblock.height, sprite->mode.scale_ymul,
        (infoblock.height / sprite->mode.scale_ymul));

    if (infoblock.width > iconwidth)
    { iconsize.scale_ymul =
      iconsize.scale_xmul = iconwidth;
      iconsize.scale_ydiv =
      iconsize.scale_xdiv = infoblock.width;
    }

    if (infoblock.height * iconsize.scale_ymul > iconsize.scale_ydiv * iconheight)
    /* Y dimension larger - it governs scale */
    { iconsize.scale_ymul =
      iconsize.scale_xmul = iconheight;
      iconsize.scale_ydiv =
      iconsize.scale_xdiv = infoblock.height;
    }

    spritewidth = infoblock.width * iconsize.scale_xmul / iconsize.scale_xdiv;
    spriteheight = infoblock.height * iconsize.scale_ymul / iconsize.scale_ydiv;
    if (spritewidth <= 0 || spritewidth > iconwidth)
      spritewidth = iconwidth;
    if (spriteheight <= 0 || spriteheight > iconheight)
      spriteheight = iconheight;

    selected = selected_brushpane_icon == i;

    x0 += rds->box.x0 - rds->scx;
    y0 += rds->box.y1 - rds->scy;
    wimpt_noerr (wimp_setcolour (selected ? 4 : 0));

    bbc_move (x0, y0);
    bbc_plot (bbc_SolidBoth + bbc_MoveCursorRel, 0, iconOuterHeight);
    /* Triangle fill at relative coordinates */
    bbc_plot (bbc_TriangleFill + bbc_DrawRelFore, iconOuterWidth, 0);
    wimpt_noerr (wimp_setcolour (selected ? 0 : 4));
    bbc_plot (bbc_SolidBoth + bbc_MoveCursorRel, 0, -iconOuterHeight);
    bbc_plot (bbc_TriangleFill + bbc_DrawRelFore, -iconOuterWidth, 0);
    wimpt_noerr (wimp_setcolour (selected ? 2 : 1));
    bbc_move (x0 + tools_BRUSH_ICON_BORDER, y0 + tools_BRUSH_ICON_BORDER);
    /* Rectangle fill at relative coordinates */
    bbc_plot (bbc_RectangleFill + bbc_DrawRelFore, tools_BRUSH_ICON_SIZE + 2 * tools_BRUSH_ICON_PADDING,
        tools_BRUSH_ICON_SIZE + 2 * tools_BRUSH_ICON_PADDING);
    ftracef5 ("y0: %d rds->box.y1: %d rds->scy: %d rds->box.y0: %d y1: %d\n",
        y0, rds->box.y1, rds->scy, rds->box.y0, y1);

    /* Move inside the icon's borders and padding to plot the brush sprite */
    x0 += tools_BRUSH_ICON_BORDER + tools_BRUSH_ICON_PADDING +
        tools_BRUSH_ICON_SIZE / 2 - spritewidth / 2;
    y0 += tools_BRUSH_ICON_BORDER + tools_BRUSH_ICON_PADDING +
        tools_BRUSH_ICON_SIZE / 2 - spriteheight / 2;
    wimpt_noerr (psprite_plot_scaled (x0, y0, sprite,
        &iconsize, (/*selected ? 3 :*/ 0)));
  }
}

static void get_brush_pane_icon_bbox (int index, wimp_box *bbox)

{ int x_eig = bbc_vduvar (bbc_XEigFactor);
  int y_eig = bbc_vduvar (bbc_YEigFactor);

  bbox->x0 = tools_BRUSH_ICON_STRIDE * index + tools_BRUSH_ICON_MARGIN - (1 << x_eig);
  bbox->x1 = bbox->x0 + tools_BRUSH_ICON_SIZE + 2 *
      (tools_BRUSH_ICON_BORDER + tools_BRUSH_ICON_PADDING) + (2 << x_eig);
  bbox->y0 = -tools_BRUSH_ICON_MARGIN - tools_BRUSH_ICON_SIZE - 2 *
      (tools_BRUSH_ICON_BORDER + tools_BRUSH_ICON_PADDING) - (1 << y_eig);
  bbox->y1 = -tools_BRUSH_ICON_MARGIN + (2 << y_eig);
}

/* bbox in work area coords */
static void update_brush_pane_icon (int index, wimp_box *bbox)

{ wimp_redrawstr rds;
  int more, dummy;
  os_error *e;
  wimp_paletteword palette_grey; /* To clear the background */

  rds.w = tools_brushpane_handle;
  rds.box = *bbox;
  palette_grey.word = (int)0xdfdfdf00; /* background_colour */

  for (e = wimp_update_wind (&rds,&more);
       !e && more;
       e = wimp_get_rectangle (&rds, &more))
  { /* Clear background to grey */
    wimpt_noerr (colourtran_setGCOL (palette_grey, 1 << 7, 0, &dummy));
    bbc_clg ();
    draw_brush_pane_icon (index, &rds);
  }
}

static void update_brush_pane_icons (int lasticon, int thisicon)

{ ftracef0 ("update_brush_pane_icons\n");
  wimp_box bbox;
  if (lasticon >= 0 && lasticon < num_brushpane_icons)
  { get_brush_pane_icon_bbox (lasticon, &bbox);
    update_brush_pane_icon (lasticon, &bbox);
  }
  if (thisicon >= 0 && thisicon < num_brushpane_icons)
  { get_brush_pane_icon_bbox (thisicon, &bbox);
    update_brush_pane_icon (thisicon, &bbox);
  }
}

static int get_brush_pane_icon_index (char *spritename)

{ char sname [NAME_LIMIT + 1];
  int len, i;
  if (spritename == NULL || strlen (spritename) < 1)
    return -1;
  ftracef1 ("get_brush_pane_icon_index for '%s'\n", spritename);

  for (i = 0; i < num_brushpane_icons; i++)
  { main_sprite *sprite = brushpane_icon_sprites [i];
    if (sprite != NULL)
    { os_error *error;
      if ((error = sprite_getname (sprite->file->spritearea, sname,
            (len = NAME_LIMIT + 1, &len), sprite->spriteno + 1)) != NULL)
      { ftracef1 ("Error getting brush sprite name: %s\n", error->errmess);
        break;
      }
      sname [len] = '\0';
      if (Matches (spritename, sname))
        return i;
    }
  }
  return -1;
}

static int scroll_to_brush_pane_icon (int index)

{ wimp_box bbox;
  wimp_wstate state;
  int scrollx, panewidth, iconcentre;
  ftracef0 ("scroll_to_brush_pane_icon\n");

  /* First see if the icon's already visible */
  get_brush_pane_icon_bbox (index, &bbox);

  wimpt_noerr (wimp_get_wind_state (tools_brushpane_handle, &state));
  panewidth = state.o.box.x1 - state.o.box.x0;
  scrollx = state.o.x;
  ftracef4 ("state.o.x: %d box.x0: %d box.x1: %d width: %d.\n", scrollx,
      state.o.box.x0, state.o.box.x1, panewidth);
  ftracef3 ("icon index: %d x0: %d x1: %d.\n", index, bbox.x0, bbox.x1);

  if (bbox.x0 >= scrollx && bbox.x0 < scrollx + panewidth &&
      bbox.x1 > scrollx && bbox.x1 <= scrollx + panewidth)
  { ftracef1 ("Brush icon %d already visible. No scrolling needed.\n", index);
    return scrollx;
  }

  /* Scroll the right amount to centre the icon. If it's past the right *
   * hand end, the WIMP should prevent scrolling too far. */
  iconcentre = (bbox.x0 + bbox.x1) / 2;
  scrollx = iconcentre - panewidth / 2;
  ftracef3 ("To scroll to icon: %d with centre x: %d, new scroll x is: %d.\n", index, iconcentre, scrollx);
  if (scrollx < 0)
    scrollx = 0;
  return scrollx;
}

static void brush_change_text (char *newname)

{ ftracef1 ("brush_change_text '%s'\n", newname);
  /* Update the Name text icon */
  wimp_caretstr caret;
  wimp_i nameicon = tools_icons [tools_bicon_NewName];
  int oldlen = strlen (tools_newbrushsprite);

  strncpy (tools_newbrushsprite, newname, NAME_LIMIT);
  tools_newbrushsprite [NAME_LIMIT] = '\0';

  if (toolwindow_handle == 0) return;

  /* Reposition the caret if necessary */
  wimpt_noerr (wimp_get_caret_pos (&caret));
  if (caret.w == toolwindow_handle && caret.i == nameicon)
  { /* See if it's at the very end of the string, if so, move to end of
      new string! */
    int len = strlen (tools_newbrushsprite);
    if (caret.index > len || caret.index >= oldlen)
      caret.index = len;
    caret.height = -1;  /* calc from index */
    wimpt_noerr (wimp_set_caret_pos (&caret));
  }
  /* Make the Wimp redraw the writeable icon */
  wimpt_noerr (wimp_set_icon_state (toolwindow_handle, nameicon, 0, 0));
}

static void brush_pane_event_handler (wimp_eventstr *e, void *handle)

{ handle = handle;
  switch (e->e)
  { case wimp_EKEY:
      wimp_processkey (e->data.key.chcode);
    break;

    case wimp_EOPEN:
      wimpt_complain (wimp_open_wind (&e->data.o));
    break;

    case wimp_EREDRAW:
    { int more, y0, y1;
      wimp_redrawstr rds;

      rds.w = e->data.o.w;
      wimpt_noerr (wimp_redraw_wind (&rds, &more));
      ftracef4 ("visible area ((%d, %d), (%d, %d))\n",
          rds.box.x0, rds.box.y0, rds.box.x1, rds.box.y1);

      /* To clear the background */
      wimp_paletteword palette_grey;
      palette_grey.word = (int)0xdfdfdf00; /* background_colour */

      y1 = -tools_BRUSH_ICON_MARGIN;
      y0 = y1 - tools_BRUSH_ICON_SIZE - 2 * (tools_BRUSH_ICON_PADDING + tools_BRUSH_ICON_BORDER);

      /* Paint always has a brush selected, so force one */
      if (selected_brushpane_icon < 0)
      { /* Defaults to the second brush, currently "circle" */
        selected_brushpane_icon = 1;
        if (selected_brushpane_icon >= num_brushpane_icons)
          selected_brushpane_icon = num_brushpane_icons - 1;
      }

      while (more)
      { int i, dummy;

        /* Clear background to grey */
        wimpt_noerr (colourtran_setGCOL (palette_grey, 1 << 7, 0, &dummy));
        bbc_clg ();

        for (i = 0; i < num_brushpane_icons; i++)
        { /* now do clipping */
          int x0 = tools_BRUSH_ICON_STRIDE * i + tools_BRUSH_ICON_MARGIN;
          int x1 = x0 + tools_BRUSH_ICON_SIZE + 2 * (tools_BRUSH_ICON_PADDING + tools_BRUSH_ICON_BORDER);

          if (main_CLIPS (&rds.g, x0 + rds.box.x0 - rds.scx,
                                  y0 + rds.box.y1 - rds.scy,
                                  x1 + rds.box.x0 - rds.scx,
                                  y1 + rds.box.y1 - rds.scy))
          { draw_brush_pane_icon (i, &rds);
          }
        }
        wimpt_noerr (wimp_get_rectangle (&rds, &more));
      }
    }
    break;

    case wimp_EBUT:
    { wimp_wstate state;
      wimp_box bbox;
      int mx = e->data.but.m.x, my = e->data.but.m.y;
      int i, x, y;
      int lasticon = selected_brushpane_icon;

      wimpt_noerr (wimp_get_wind_state (tools_brushpane_handle, &state));

      /* convert to work extent coordinates */
      x =   mx - state.o.box.x0 + state.o.x;
      y = -(my - state.o.box.y1 + state.o.y);

      if (y <= tools_BRUSH_ICON_MARGIN ||
          y > tools_BRUSH_ICON_STRIDE - tools_BRUSH_ICON_MARGIN)
        break;
      else
      { /* Work out which brush icon the click was over */
        i = x / tools_BRUSH_ICON_STRIDE;
        if (i < 0 || i >= num_brushpane_icons)
          i = -1;

        /* Reject the click if it was on the left or right margin */
        x = x % tools_BRUSH_ICON_STRIDE;
        if (x <= tools_BRUSH_ICON_MARGIN ||
            x > tools_BRUSH_ICON_STRIDE - tools_BRUSH_ICON_MARGIN)
          break;
        else
          selected_brushpane_icon = i;
      }
      get_brush_pane_icon_bbox (lasticon, &bbox);

      if (lasticon >= 0 && lasticon < num_brushpane_icons)
        update_brush_pane_icon (lasticon, &bbox);
      if (selected_brushpane_icon >= 0 && selected_brushpane_icon < num_brushpane_icons)
      { char sname [NAME_LIMIT + 1];
        os_error *error;
        int len, oldlen;
        wimp_icon shape, tint;
        main_sprite *sprite = brushpane_icon_sprites [selected_brushpane_icon];

        /* Update the brush name text as well */
        get_brush_pane_icon_bbox (selected_brushpane_icon, &bbox);
        update_brush_pane_icon (selected_brushpane_icon, &bbox);
        oldlen = strlen (tools_newbrushsprite);
        if (sprite == NULL)
        { ftracef1 ("Error: brushpane icon sprite at %d is NULL\n", selected_brushpane_icon);
          break;
        }
        len = NAME_LIMIT + 1;
        error = sprite_getname (sprite->file->spritearea, sname, &len, sprite->spriteno + 1);
        if (error != NULL)
        { ftracef1 ("Error getting brush sprite name: %s\n", error->errmess);
          break;
        }
        sname [len] = '\0';
        /* Update the brush name text icon */
        brush_change_text (sname);

        /* Clicks on a brush pane icon should actually apply the brush choice */
        wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
                  tools_icons [tools_bicon_UseGCOL], &shape));
        wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
                  tools_icons [tools_bicon_UseTint], &tint));

        if ((shape.flags & wimp_ISELECTED) != 0)
          tools_brush_use_gcol = 1;
        else if ((tint.flags & wimp_ISELECTED) != 0)
          tools_brush_use_gcol = 2;
        else /* Stamp mode: */
          tools_brush_use_gcol = 0;

        performbrushGOaction ();
      }
    }
    break;

    case wimp_ECLOSE:
      ftracef0 ("Close brushes pane window\n");
      destroy_brush_pane ();
    break;

    case wimp_ESEND:
    case wimp_ESENDWANTACK:
      switch (e->data.msg.hdr.action)
      { case wimp_MDATASAVE:
          ftracef0 ("Error: Unexpected MDATASAVE message on brushes pane!\n");
        break;

        case wimp_MDATALOAD:
        { char *name;
          int type;

          type = xferrecv_checkinsert (&name);    /* sets up reply */
          if (type == FileType_Sprite || type == FileType_JPEG)
          { int ok;
            main_window *window = main_new_window (TRUE);

            ftracef1 ("Loading file \"%s\"\n", name);
            visdelay_begin ();
            ok = Load_File (window, name, 1, 0);
            visdelay_end ();
            if (ok > 0)
            { xferrecv_insertfileok ();
              toolwindow_brush_pane_add_sprite (window->data->file.sprites, TRUE);
            }
            else
              main_window_delete (window);
          }
        }
        break;

        case wimp_MHELPREQUEST:
          main_help_message ("PntHTQ", e);
        break;
      }
    break;
  }
  menus_insdel_frig ();
}

static void open_brush_pane (wimp_openstr *toolwinopenptr,
                             wimp_openstr *brushpaneopenptr,
                             int scrolltoicon, BOOL bringtofront)

{ static int scx = -1;
  wimp_wstate toolwinstate, brushpanestate;
  wimp_redrawstr extent;
  int offsetx = 12, offsety = -100, width, height, toolswidth;
  wimp_icon nameIcon, brushIcon;

  ftracef0 ("open_brush_pane\n");
  if (tools_brushpane_handle == 0)
    return;
  if (toolwinopenptr == NULL)
  { wimpt_noerr (wimp_get_wind_state (toolwindow_handle, &toolwinstate));
    toolwinopenptr = &toolwinstate.o;
  }
  if (brushpaneopenptr == NULL)
  { wimpt_noerr (wimp_get_wind_state (tools_brushpane_handle, &brushpanestate));
    brushpaneopenptr = &brushpanestate.o;
  }
  brushpaneopenptr->w = tools_brushpane_handle;

  /* We'll position the brushes pane relative to the other icons */
  wimpt_noerr (wimp_get_icon_info ((wimp_w)toolwindow_handle,
      tools_icons [tools_bicon_NewName], &nameIcon));
  wimpt_noerr (wimp_get_icon_info ((wimp_w)toolwindow_handle,
      tools_icons [tools_bicon_BrushText/*NameText*/], &brushIcon));
  offsetx = nameIcon.box.x0;
  offsety = brushIcon.box.y0;
  toolswidth = tools_tool_template.t.box.x1 - tools_tool_template.t.box.x0;
  width = tools_brushpane_template.t.box.x1 - tools_brushpane_template.t.box.x0;
  height = tools_brushpane_template.t.box.y1 - tools_brushpane_template.t.box.y0;
  /* Calculate the window extent based on the number of icons, with lower limit
     given by window width */
  extent.w      = brushpaneopenptr->w;
  extent.box.y1 = 0;
  extent.box.y0 = -height;
  extent.box.x0 = 0;
  extent.box.x1 = num_brushpane_icons * tools_BRUSH_ICON_STRIDE;
  if (extent.box.x1 < width)
    extent.box.x1 = width;

  ftracef2 ("Resetting brush pane window extent to (%d, %d)\n",
      extent.box.x1, extent.box.y0);

  wimpt_noerr (wimp_set_extent (&extent));

  brushpaneopenptr->box.x0 = toolwinopenptr->box.x0 + offsetx;
  brushpaneopenptr->box.y0 = toolwinopenptr->box.y1 + offsety;
  brushpaneopenptr->box.x1 = brushpaneopenptr->box.x0 + width;
  brushpaneopenptr->box.y1 = brushpaneopenptr->box.y0 + height;

  if (toolwinopenptr->behind == tools_brushpane_handle)
  { if (bringtofront)
      brushpaneopenptr->behind = -1; /* Note: it's not necessarily at the very front! Any way to interrogate the whole window stack? */
  }
  else
  { brushpaneopenptr->behind = (bringtofront)? -1 : toolwinopenptr->behind;
    toolwinopenptr->behind = tools_brushpane_handle;
  }

  brushpaneopenptr->y = 0;
  if (scrolltoicon >= 0)
  { int x = scroll_to_brush_pane_icon (scrolltoicon);
    if (x >= 0)
      brushpaneopenptr->x = x;
  }
  else
    scx = brushpaneopenptr->x;

  if (wimpt_complain (wimp_open_wind (brushpaneopenptr)) == 0)
  { ftracef0 ("Opened brushes window pane\n");
  }
}

static void make_brush_pane (void)

{ char *brush_name;
  int i, num_sys_brushes = 0;
  main_sprite *sprite_ptr;
  int panewidth, max_brush_index;
  wimp_box last_bbox;

  ftracef0 ("make_brush_pane\n");

  /* Reset so number of built-in brushes will be read from Messages */
  set_number_of_builtin_brushes (-1);
  num_sys_brushes = get_number_of_builtin_brushes ();
  brush_name = get_first_builtin_brush ();

  /* Go find the first brush sprite */
  sprite_ptr = psprite_find (brush_name, NULL);
  if (sprite_ptr == NULL)
  { werr (TRUE, msgs_lookup ("PntEO"));
    return;
  }

  num_brushpane_icons = 0;

  for (i = 0; i < MIN(num_sys_brushes, tools_MAX_BUILTIN_BRUSHES); i++)
  { if ((!psprite_hasalphamask (sprite_ptr) || psprite_havealphamasks ()) &&
        (!psprite_hasalphachannel (sprite_ptr) || psprite_havealphachannels ()))
    { brushpane_icon_sprites [num_brushpane_icons] = sprite_ptr;
      num_brushpane_icons++;
    }
    sprite_ptr = sprite_ptr->link;
    if (sprite_ptr == NULL)
      break;
  }
  max_brush_index = num_brushpane_icons;
  if (num_brushpane_icons < num_sys_brushes)
    set_number_of_builtin_brushes (num_brushpane_icons);

  /* Add the last user brush, if any. Mustn't have duplicates *
   * or invalid characters! */
  if (num_user_brushes > 0 && num_brushpane_icons < tools_MAX_BRUSH_ICONS)
  { sprite_ptr = psprite_find (recent_user_brush, NULL);
    brushpane_icon_sprites [num_brushpane_icons] = sprite_ptr;
    if (sprite_ptr == NULL)
    { ftracef1("Couldn't find user brush sprite %s for popup menu.\n",
          recent_user_brush);
    }
    else
      num_brushpane_icons++;
  }

  if (tools_brushpane_handle != 0)
    destroy_brush_pane ();

  /* As the number of brushes is fixed when there's a user brush, we don't
     want a scroll bar if they all fit on the screen */
  get_brush_pane_icon_bbox (max_brush_index, &last_bbox);
  panewidth = tools_brushpane_template.t.box.x1 - tools_brushpane_template.t.box.x0;
  if (last_bbox.x0 >= 0 && last_bbox.x0 <  panewidth &&
      last_bbox.x1 >  0 && last_bbox.x1 <= panewidth)
    tools_brushpane_template.t.flags &= ~wimp_WHSCR;
  else
    tools_brushpane_template.t.flags |= wimp_WHSCR;

  ftracef0 ("Create brushes window pane\n");
  if (main_create_window (&tools_brushpane_template.t, &tools_brushpane_handle,
                          &brush_pane_event_handler, NULL) == 0)
    return; /* Failed to create it */

  open_brush_pane (NULL, NULL, -1, FALSE);
}

void toolwindow_brush_pane_add_sprite (main_sprite *sprite, BOOL selectit)

{ char *brush_name;
  int index;
  int oldlen;
  psprite_info sinfo;
  int lasticon = selected_brushpane_icon;

  ftracef0 ("toolwindow_brush_pane_add_sprite\n");
  if (sprite == NULL)
  { ftracef0 ("Error: Null sprite passed to toolwindow_brush_pane_add_sprite.\n");
    return;
  }

  if ((!psprite_havealphamasks () && psprite_hasalphamask (sprite)) ||
      (!psprite_havealphachannels () && psprite_hasalphachannel (sprite)))
  { wimpt_complain (main_error ("PntWJ"));
    return;
  }

  psprite_read_full_info (sprite, &sinfo);
  brush_name = sinfo.name;
  oldlen = strlen (tools_newbrushsprite);
  if (selectit)
  { strncpy (tools_newbrushsprite, brush_name, NAME_LIMIT);
    tools_newbrushsprite [NAME_LIMIT] = '\0';
  }

  index = get_brush_pane_icon_index (brush_name);
  if (index >= 0)
  { os_error err;

    err.errnum = 0;
    sprintf (err.errmess, msgs_lookup ("PntWI"), brush_name);
    if (selectit)
      selected_brushpane_icon = index;
    ftracef0 (err.errmess);
    wimpt_complain (&err);
  }
  else
  { /* If this is a newly seen brush sprite, set the user brush to it */
    int num_sys_brushes = num_brushpane_icons - num_user_brushes;

    strncpy (recent_user_brush, brush_name, NAME_LIMIT);
    recent_user_brush [NAME_LIMIT] = '\0';
    if (num_user_brushes == 0)
    { num_user_brushes = 1;
      num_brushpane_icons++;
    }
    index = num_sys_brushes;
    if (selectit)
      selected_brushpane_icon = index;
    brushpane_icon_sprites [index] = sprite;
    ftracef2 ("num_user_brushes: %d num_brushpane_icons: %d\n",
        num_user_brushes, num_brushpane_icons);
  }

  if (selectit)
  { wimp_icon shape, /*stamp,*/ tint;

    wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
              tools_icons [tools_bicon_UseGCOL], &shape));
    wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
              tools_icons [tools_bicon_UseTint], &tint));

    if ((shape.flags & wimp_ISELECTED) != 0)
      tools_brush_use_gcol = 1;
    else if ((tint.flags & wimp_ISELECTED) != 0)
      tools_brush_use_gcol = 2;
    else /* Stamp mode: */
      tools_brush_use_gcol = 0;

    performbrushGOaction ();

    /* Reposition the caret if necessary and redraw the text icon */
    brush_change_text (tools_newbrushsprite);
  }
  open_brush_pane (NULL, NULL, selected_brushpane_icon, FALSE);

  update_brush_pane_icons (lasticon, index);
  if (index != selected_brushpane_icon && selected_brushpane_icon >= 0)
  { wimp_box bbox;
    get_brush_pane_icon_bbox (selected_brushpane_icon, &bbox);
    update_brush_pane_icon (selected_brushpane_icon, &bbox);
  }
}

/***********************************************************
 * Checks if a deleted sprite was used as a brush, if so   *
 * it's removed from the brushes pane.                     *
 ***********************************************************/

void toolwindow_brush_check_deletion (main_sprite *sprite)

{ BOOL delcurrentbrush = FALSE, redrawneeded = FALSE;
  BOOL selectedindexchanged = FALSE;
  int num_sys_brushes;

  ftracef0 ("tools_brush_check_deletion\n");
  if (sprite == NULL)
  { ftracef0 ("Sprite for deletion was NULL\n");
    return;
  }
  ftracef2 ("num_user_brushes: %d num_brushpane_icons: %d\n",
      num_user_brushes, num_brushpane_icons);
  if (tools_brushsprite_ptr != NULL)
    delcurrentbrush = (psprite_address (sprite) == psprite_address (tools_brushsprite_ptr));

  num_sys_brushes = get_number_of_builtin_brushes ();

  /* Check if it's the user brush that's been deleted */
  if (num_user_brushes > 0)
  { main_sprite *brush_sprite = brushpane_icon_sprites [num_sys_brushes];
    if (brush_sprite == sprite)
    { redrawneeded = TRUE;
      num_user_brushes = 0;
      brushpane_icon_sprites [num_sys_brushes] = NULL;
      num_brushpane_icons--;
      if (selected_brushpane_icon >= num_sys_brushes)
      { selected_brushpane_icon = 1;
        delcurrentbrush = TRUE;
      }
    }
  }

  ftracef2 ("num_user_brushes: %d num_brushpane_icons: %d\n",
      num_user_brushes, num_brushpane_icons);

  /* If the current brush got deleted, change back to the default one */
  if (delcurrentbrush)
  { /* Update the brush name text with default brush name from Messages */
    brush_change_text (msgs_lookup ("circle"));

   /* Brushes with alpha have a separate sprite for the mouse pointer */
   if (tools_brushmouse_ptr != NULL) tools_delete_brushmouse_sprite ();

    /* As we're selecting a different brush, apply any other settings */
    if (toolwindow_handle != 0)
    { wimp_icon shape, tint;
      wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
                tools_icons [tools_bicon_UseGCOL], &shape));
      wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
                tools_icons [tools_bicon_UseTint], &tint));

      if ((shape.flags & wimp_ISELECTED) != 0)
        tools_brush_use_gcol = 1;
      else if ((tint.flags & wimp_ISELECTED) != 0)
        tools_brush_use_gcol = 2;
      else /* Stamp mode: */
        tools_brush_use_gcol = 0;
    }

    performbrushGOaction ();
    selectedindexchanged = TRUE;
  }
  /* If the selected brush moved, we need to scroll to it */
  if (selectedindexchanged)
    open_brush_pane (NULL, NULL, selected_brushpane_icon, FALSE);

  if (redrawneeded && tools_brushpane_handle != 0)
  { /* Just redraw the entire pane */
    main_force_redraw (tools_brushpane_handle);
  }
}

/***********************************************************
 * Checks if a renamed sprite was used as a brush, if so   *
 * the brush pane and Name box will be updated.            *
 ***********************************************************/

void toolwindow_brush_check_rename (main_sprite *sprite, char *newname)

{ int num_sys_brushes = get_number_of_builtin_brushes ();

  ftracef0 ("toolwindow_brush_check_rename\n");
  if (sprite == NULL)
  { ftracef0 ("Sprite for rename was NULL\n");
    return;
  }

  if (num_user_brushes > 0)
  { main_sprite *brush_sprite = brushpane_icon_sprites [num_sys_brushes];
    if (brush_sprite == sprite)
    { /* Rename */
      strncpy (recent_user_brush, newname, NAME_LIMIT);
      recent_user_brush [NAME_LIMIT] = '\0';
      /* Was this the selected brush? */
      if (num_sys_brushes == selected_brushpane_icon)
      { /* Update the name text icon */
        brush_change_text (newname);
      }
    }
  }
}

static void slider_validate (int textIcon)

{ wimp_caretstr caret;

  ftracef0 ("slider_validate\n");
  if (toolwindow_current_tool != &tools_brushpaint) return;
  wimp_get_caret_pos (&caret);
  if (caret.w == toolwindow_handle)
  { if (caret.i != tools_icons [tools_bicon_Opacity])
    { char opacity [6];
      int value = tools_brush_opacity;

      if (value > 1000)
        value = 1000;
      if (value == 1000)
        strcpy (opacity, "100");
      else
        sprintf (opacity, "%d.%d", value / 10, value % 10);
      /* If the above text is different from the user input, correct it */
      if (strcmp (opacity, tools_brush_nopacity) != 0)
      { wimp_i txticon = tools_icons [textIcon];
        strcpy (tools_brush_nopacity, opacity);
        /* Make the Wimp redraw the writeable icon */
        wimpt_noerr (wimp_set_icon_state (toolwindow_handle, txticon, 0, 0));
      }
    }
  }
}

static unsigned int slider_update (int mx, int barIcon, int bgndIcon, int textIcon, char *textString)

{ ftracef0 ("slider_update\n");
  wimp_wstate wstate;
  wimp_icon bgndicon, baricon;
  int dx, width, max, x_eig;
  unsigned int value = 0;

  wimpt_noerr (wimp_get_wind_state (toolwindow_handle, &wstate));
  mx -= wstate.o.box.x0 + wstate.o.x;
  wimpt_noerr (wimp_get_icon_info (toolwindow_handle, tools_icons [bgndIcon], &bgndicon));
  width = bgndicon.box.x1 - bgndicon.box.x0;
  dx = mx - bgndicon.box.x0;
  wimpt_noerr (wimp_get_icon_info (toolwindow_handle, tools_icons [barIcon], &baricon));
  if (dx > width)
    dx = width;
  else if (dx < 0)
    dx = 0;
  /* Update value */
  /* Subtract 2 pixels so pixels for 0th and max value fall
     well inside the bounds of the icon */
  x_eig = bbc_vduvar (bbc_XEigFactor);
  max = width - (2 << x_eig);
  if (dx > max)
    dx = max;
  if (max > 0)
  { wimp_i txticon = tools_icons [textIcon];
    value = (unsigned int)(1000 * dx / max);
    /* Update the text */
    if (value < 1000)
      sprintf (textString, "%d.%d", value / 10, value % 10);
    else
      strcpy (textString, "100");
    /* Make the Wimp redraw the writeable icon */
    wimpt_noerr (wimp_set_icon_state (toolwindow_handle, txticon, 0, 0));
    /* If we set max or 0, make sure the bar will reflect that */
    if (value == 1000)
      dx = width;
    else if (value == 0)
      dx = 0;
  }

  baricon.box.x1 = baricon.box.x0 + dx;
  wimpt_noerr (os_swix6 (Wimp_ResizeIcon, toolwindow_handle,
      tools_icons [barIcon], baricon.box.x0,
      baricon.box.y0, baricon.box.x1, baricon.box.y1));
  wimp_redrawstr rds;
  rds.w = toolwindow_handle;
  rds.box = bgndicon.box;
  wimp_force_redraw (&rds);
  return value;
}

static unsigned int slider_set (unsigned int value, int barIcon, int bgndIcon, int textIcon, char *textString)

{ wimp_wstate wstate;
  wimp_icon bgndicon, baricon;
  int dx, width, max, x_eig;
  BOOL textChanged = FALSE;

  ftracef0 ("slider_set\n");
  wimpt_noerr (wimp_get_wind_state (toolwindow_handle, &wstate));
  wimpt_noerr (wimp_get_icon_info (toolwindow_handle, tools_icons [bgndIcon], &bgndicon));
  width = bgndicon.box.x1 - bgndicon.box.x0;
  wimpt_noerr (wimp_get_icon_info (toolwindow_handle, tools_icons [barIcon], &baricon));
  /* Correct value if invalid */
  if (value > 1000)
  { value = 1000;
    textChanged = TRUE;
  }
  /* Subtract 2 pixels so pixels for 0th and max value fall
     well inside the bounds of the icon */
  x_eig = bbc_vduvar (bbc_XEigFactor);
  max = width - (2 << x_eig);
  dx = (int)value * max / 1000;
  if (dx > width)
    dx = width;
  else if (dx < 0)
    dx = 0;
  if (dx > max)
    dx = max;
  if (textChanged)
  { wimp_i txticon = tools_icons [textIcon];
    /* Update the text */
    if (value < 1000)
      sprintf (textString, "%d.%d", value / 10, value % 10);
    else strcpy (textString, "100");
    /* Make the Wimp redraw the writeable icon */
    wimpt_noerr (wimp_set_icon_state (toolwindow_handle, txticon, 0, 0));
  }
  /* If we set max or 0, make sure the bar will reflect that */
  if (value == 1000)
    dx = width;
  else if (value == 0)
    dx = 0;

  baricon.box.x1 = baricon.box.x0 + dx;
  wimpt_noerr (os_swix6 (Wimp_ResizeIcon, toolwindow_handle,
      tools_icons [barIcon], baricon.box.x0,
      baricon.box.y0, baricon.box.x1, baricon.box.y1));
  wimp_redrawstr rds;
  rds.w = toolwindow_handle;
  rds.box = bgndicon.box;
  wimp_force_redraw (&rds);

  return value;
}

static BOOL slider_drag_processor  (wimp_eventstr *event, void *handle)

{ wimp_i icon = event->data.but.m.i;
  if (event->e != wimp_EUSERDRAG)
    return FALSE;
  ftracef0("slider_drag_processor\n");
  win_remove_unknown_event_processor (slider_drag_processor, handle);

  if (toolwindow_handle == 0)
  { ftracef0 ("Error: toolwindow_handle NULL in drag processor.\n");
    return TRUE;
  }

  ftracef0("Slider user drag event received.\n");

  if (toolwindow_current_tool == &tools_brushpaint &&
      (icon == tools_icons [tools_bicon_OpacBar] ||
       icon == tools_icons [tools_bicon_OpacBgnd]) &&
       HaveBlendTable())
  { /* Update the slider */
    int mx = event->data.but.m.x;
    ftracef2 ("slider null prev opacity: %d prev text: %s\n", tools_brush_opacity, tools_brush_nopacity);
    tools_brush_opacity = slider_update (mx, tools_bicon_OpacBar,
        tools_bicon_OpacBgnd, tools_bicon_Opacity, tools_brush_nopacity);
    ftracef2 ("slider null new opacity: %d prev text: %s\n", tools_brush_opacity, tools_brush_nopacity);
  }

  return TRUE;
}

static void sprite_tool_event_handler (wimp_eventstr *e, void *handle)

{ handle = handle;
  static wimp_w prevnullholder = -1;
  static int dragging_icon = -1;

  switch (e->e)
  { case wimp_ENULL:
    { static int lasticon;
      static int lastmx;
      if (dragging_icon > -1)
      { wimp_mousestr mouse;
        wimpt_complain (wimp_get_point_info (&mouse));
        /* If the mouse button's released, stop the drag */
        if (!(mouse.bbits & (wimp_BDRAGLEFT | wimp_BDRAGRIGHT | wimp_BLEFT | wimp_BRIGHT)))
        { /* Stop tracking */
          main_claim_idle (prevnullholder);
          dragging_icon = -1;
          lasticon = -1;
          lastmx = -1;
          break;
        }

        if (toolwindow_current_tool == &tools_brushpaint &&
            HaveBlendTable() &&
            (mouse.i == tools_icons [tools_bicon_OpacBar] ||
            mouse.i == tools_icons [tools_bicon_OpacBgnd]) &&
            (lasticon == -1 || lasticon == tools_icons [tools_bicon_OpacBar] ||
            lasticon == tools_icons [tools_bicon_OpacBgnd]) &&
            (lastmx == -1 || lastmx != mouse.x))
        { /* Update the slider */
          tools_brush_opacity = slider_update (mouse.x,
                  tools_bicon_OpacBar, tools_bicon_OpacBgnd,
                  tools_bicon_Opacity, tools_brush_nopacity);
        }
        lasticon = mouse.i;
        lastmx = mouse.x;
      }
      else
      { /* Stop tracking */
        main_claim_idle (prevnullholder);
        dragging_icon = -1;
        lasticon = -1;
        lastmx = -1;
      }
    }
    break;

    case wimp_EKEY:
      if (e->data.key.chcode == 13)
      { wimp_caretstr caret;
        wimp_get_caret_pos (&caret);
        if (caret.w == toolwindow_handle && caret.i != -1)
        { wimp_icon istate;

          caret.i++;

          while (TRUE)
          { if (wimp_get_icon_info (toolwindow_handle, caret.i, &istate) ||
             (istate.flags & wimp_IDELETED) != 0)
            { if (toolwindow_current_tool == &tools_brushpaint)
              { int lasticon = selected_brushpane_icon;
                wimp_icon shape, /*stamp,*/ tint;
                wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
                          tools_icons [tools_bicon_UseGCOL], &shape));
                /*wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
                          tools_icons [tools_bicon_UseStamp], &stamp));*/
                wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
                          tools_icons [tools_bicon_UseTint], &tint));

                if ((shape.flags & wimp_ISELECTED) != 0)
                  tools_brush_use_gcol = 1;
                else if ((tint.flags & wimp_ISELECTED) != 0)
                  tools_brush_use_gcol = 2;
                else /* Stamp mode: */
                  tools_brush_use_gcol = 0;
                performbrushGOaction ();
                update_brush_pane_icons (lasticon, selected_brushpane_icon);
                /* Also scroll to the newly selected icon if it's not visible */
                open_brush_pane (NULL, NULL, selected_brushpane_icon, FALSE);
              }
              caret.i = 0;
            }
            else if ( (istate.flags & wimp_IBTYPE*15) ==
                wimp_IBTYPE*wimp_BWRITABLE)
            { ftracef1 ("Picked icon %d for caret\n", caret.i);
              set_tool_caret (caret.i);
              break;
            }
            caret.i++;
          }
        }
        else
          ftracef0 ("!!!!!!!!!CR can't have been for us!!!!!!!\n");
      }
      else
      { wimp_processkey (e->data.key.chcode);
        if (toolwindow_current_tool == &tools_brushpaint)
        { wimp_caretstr caret;
          wimp_get_caret_pos (&caret);
          if (caret.w == toolwindow_handle)
          { if (caret.i ==
                tools_icons [tools_bicon_NewName])
            { /* If the user typed a brush name, scroll to that icon on the
                 brush pane, if it's present */
              char brushname [NAME_LIMIT + 1];
              int  i;
              strncpy (brushname, tools_newbrushsprite, NAME_LIMIT);
              brushname [NAME_LIMIT] = '\0';
              i = get_brush_pane_icon_index (brushname);
              if (i >= 0)
                open_brush_pane (NULL, NULL, i, FALSE);
            }
            else if (caret.i == tools_icons [tools_bicon_Opacity] && HaveBlendTable())
            { int s, n, d = 0;
              const char *decimal;
              ftracef1 ("Opacity typed '%s'\n", tools_brush_nopacity);
              decimal = strstr (tools_brush_nopacity, ".");
              if (decimal != NULL && strlen (decimal) > 1)
              { if (sscanf (decimal + 1, "%1d%n", &d, &n) < 1 || n == 0)
                  d = 0;
              }
              if (sscanf (tools_brush_nopacity, "%d%n", &s, &n) != 1 ||
                  n == 0)
              { ftracef3 ("Opacity. decimal: %s s: %d n: %d\n", (decimal)?decimal:"", s, n);
                s = 0;
              }
              /* Convert the percentage to fixed-point per-thousand */
              s = s * 10 + d;

              /* Update the slider */
              tools_brush_opacity = slider_set (s, tools_bicon_OpacBar,
                                                   tools_bicon_OpacBgnd,
                                                   tools_bicon_Opacity,
                                                   tools_brush_nopacity);
            }
            else if (caret.i == tools_icons [tools_bicon_XNScaleM] ||
                     caret.i == tools_icons [tools_bicon_XNScaleD] ||
                     caret.i == tools_icons [tools_bicon_YNScaleM] ||
                     caret.i == tools_icons [tools_bicon_YNScaleD])
            { tools_remove_brush ();
              toolwindow_readbrushscale ();
              tools_replace_brush ();
            }
          }
        }
      }
      slider_validate (tools_bicon_Opacity);
    break;

    case wimp_EOPEN:
      wimpt_complain (wimp_open_wind (&e->data.o));

      /* Now reopen the brush pane if necessary */
      open_brush_pane (&e->data.o, NULL, -1, FALSE);
    break;

    case wimp_EREDRAW:
    { int more;
      wimp_redrawstr rds;

      rds.w = e->data.o.w;
      wimpt_noerr (wimp_redraw_wind (&rds, &more));
      while (more)
        wimpt_noerr (wimp_get_rectangle (&rds, &more));
    }
    break;

    case wimp_EBUT:
#if 0
      if (toolwindow_current_tool == &tools_brushpaint) /* TODO Or the spray can */
      { /* Enable the opacity controls whenever the tool window is clicked *
         because it's shared across sprites so some may support opacity */
        wimpt_noerr (wimp_set_icon_state (toolwindow_handle, tools_icons [tools_bicon_Opacity],
            0, wimp_INOSELECT));
        wimpt_noerr (wimp_set_icon_state (toolwindow_handle, tools_icons [tools_bicon_OpacBar],
            0, wimp_INOSELECT));
      }
#endif
      if (e->data.but.m.bbits & (wimp_BDRAGLEFT | wimp_BDRAGRIGHT))
      { if (toolwindow_current_tool == &tools_brushpaint &&
              HaveBlendTable() &&
              e->data.but.m.i == tools_icons [tools_bicon_OpacBar] ||
              e->data.but.m.i == tools_icons [tools_bicon_OpacBgnd])
        { /* Update the slider */
          wimp_dragstr drag;
          ftracef0("Opacity slider drag detected.\n");
          wimp_wstate ws;
          wimp_w claimer;
          wimp_icon bgndicon;
          int width;
          int mx = e->data.but.m.x;
          wimpt_noerr (wimp_get_wind_state (toolwindow_handle, &ws));
          wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
              tools_icons [tools_bicon_OpacBgnd], &bgndicon));
          width = bgndicon.box.x1 - bgndicon.box.x0;
          drag.box.x0 = mx;
          drag.box.x1 = mx;
          drag.box.y0 = bgndicon.box.y0 + ws.o.box.y1 - ws.o.y;
          drag.box.y1 = bgndicon.box.y1 + ws.o.box.y1 - ws.o.y - 4;
          drag.parent.x0 = bgndicon.box.x0 + ws.o.box.x0 - ws.o.x;
          drag.parent.x1 = bgndicon.box.x1 + ws.o.box.x0 - ws.o.x -
                           2 * bbc_vduvar (bbc_XEigFactor);
          drag.parent.y0 = bgndicon.box.y0 + ws.o.box.y1 - ws.o.y;
          drag.parent.y1 = bgndicon.box.y1 + ws.o.box.y1 - ws.o.y -
                           2 * bbc_vduvar (bbc_YEigFactor);
          drag.window = toolwindow_handle;
          drag.type = wimp_USER_HIDDEN;
          dragging_icon = e->data.but.m.i;
          claimer = win_idle_event_claimer ();
          if (claimer != toolwindow_handle)
            prevnullholder = claimer;
          main_claim_idle (toolwindow_handle);
          os_swix4 (Wimp_DragBox, 0, &drag, 0, 0);
          win_add_unknown_event_processor (slider_drag_processor, (void *)toolwindow_handle);
        }
      }
      else if (e->data.but.m.bbits & (wimp_BLEFT | wimp_BRIGHT))
      { ftracef1 ("Icon %d clicked\n", e->data.but.m.i);

        /*Wind up the previous tool, if it needs it.*/
        if (toolwindow_current_tool == &tools_brushpaint)
        { BOOL adjust = (e->data.but.m.bbits & wimp_BRIGHT) != 0;

          if (e->data.but.m.i == tools_icons [tools_bicon_UseNew])
          { int lasticon = selected_brushpane_icon;
            wimp_icon shape, tint;
            wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
                      tools_icons [tools_bicon_UseGCOL], &shape));
            wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
                      tools_icons [tools_bicon_UseTint], &tint));

            if ((shape.flags & wimp_ISELECTED) != 0)
              tools_brush_use_gcol = 1;
            else if ((tint.flags & wimp_ISELECTED) != 0)
              tools_brush_use_gcol = 2;
            else /* Stamp mode: */
              tools_brush_use_gcol = 0;

            performbrushGOaction ();
            /* scroll to the newly selected icon if it's not visible */
            open_brush_pane (NULL, NULL, selected_brushpane_icon, FALSE);

            update_brush_pane_icons (lasticon, selected_brushpane_icon);
          }
          else if ((e->data.but.m.i == tools_icons [tools_bicon_OpacBar] ||
                    e->data.but.m.i == tools_icons [tools_bicon_OpacBgnd]) &&
                   HaveBlendTable())
          { /* Update the slider */
            int mx = e->data.but.m.x;
            tools_brush_opacity = slider_update (mx, tools_bicon_OpacBar,
                    tools_bicon_OpacBgnd, tools_bicon_Opacity,
                    tools_brush_nopacity);
          } /* Next handle the scale x / y arrow buttons */
          else if (e->data.but.m.i >= tools_icons [tools_bicon_XNScaleMUp] &&
                   e->data.but.m.i <= tools_icons [tools_bicon_YNScaleDDown])
          { wimp_i texticon = 0;
            tools_remove_brush ();
            toolwindow_readbrushscale ();
            if (e->data.but.m.i == tools_icons [tools_bicon_XNScaleMUp])
            { if (adjust && tools_brushscale.scale_xmul > 1)
                tools_brushscale.scale_xmul--;
              else if (!adjust && tools_brushscale.scale_xmul < 99)
                tools_brushscale.scale_xmul++;
              sprintf (tools_brush_nxscalem, "%d", tools_brushscale.scale_xmul);
              texticon = tools_icons [tools_bicon_XNScaleM];
            }
            else if (e->data.but.m.i == tools_icons [tools_bicon_XNScaleMDown])
            { if (!adjust && tools_brushscale.scale_xmul > 1)
                tools_brushscale.scale_xmul--;
              else if (adjust && tools_brushscale.scale_xmul < 99)
                tools_brushscale.scale_xmul++;
              sprintf (tools_brush_nxscalem, "%d", tools_brushscale.scale_xmul);
              texticon = tools_icons [tools_bicon_XNScaleM];
            }
            else if (e->data.but.m.i == tools_icons [tools_bicon_XNScaleDUp])
            { if (adjust && tools_brushscale.scale_xdiv > 1)
                tools_brushscale.scale_xdiv--;
              else if (!adjust && tools_brushscale.scale_xdiv < 99)
                tools_brushscale.scale_xdiv++;
              sprintf (tools_brush_nxscaled, "%d", tools_brushscale.scale_xdiv);
              texticon = tools_icons [tools_bicon_XNScaleD];
            }
            else if (e->data.but.m.i == tools_icons [tools_bicon_XNScaleDDown])
            { if (!adjust && tools_brushscale.scale_xdiv > 1)
                tools_brushscale.scale_xdiv--;
              else if (adjust && tools_brushscale.scale_xdiv < 99)
                tools_brushscale.scale_xdiv++;
              sprintf (tools_brush_nxscaled, "%d", tools_brushscale.scale_xdiv);
              texticon = tools_icons [tools_bicon_XNScaleD];
            }
            else if (e->data.but.m.i == tools_icons [tools_bicon_YNScaleMUp])
            { if (adjust && tools_brushscale.scale_ymul > 1)
                tools_brushscale.scale_ymul--;
              else if (!adjust && tools_brushscale.scale_ymul < 99)
                tools_brushscale.scale_ymul++;
              sprintf (tools_brush_nyscalem, "%d", tools_brushscale.scale_ymul);
              texticon = tools_icons [tools_bicon_YNScaleM];
            }
            else if (e->data.but.m.i == tools_icons [tools_bicon_YNScaleMDown])
            { if (!adjust && tools_brushscale.scale_ymul > 1)
                tools_brushscale.scale_ymul--;
              else if (adjust && tools_brushscale.scale_ymul < 99)
                tools_brushscale.scale_ymul++;
              sprintf (tools_brush_nyscalem, "%d", tools_brushscale.scale_ymul);
              texticon = tools_icons [tools_bicon_YNScaleM];
            }
            else if (e->data.but.m.i == tools_icons [tools_bicon_YNScaleDUp])
            { if (adjust && tools_brushscale.scale_ydiv > 1)
                tools_brushscale.scale_ydiv--;
              else if (!adjust && tools_brushscale.scale_ydiv < 99)
                tools_brushscale.scale_ydiv++;
              sprintf (tools_brush_nyscaled, "%d", tools_brushscale.scale_ydiv);
              texticon = tools_icons [tools_bicon_YNScaleD];
            }
            else if (e->data.but.m.i == tools_icons [tools_bicon_YNScaleDDown])
            { if (!adjust && tools_brushscale.scale_ydiv > 1)
                tools_brushscale.scale_ydiv--;
              else if (adjust && tools_brushscale.scale_ydiv < 99)
                tools_brushscale.scale_ydiv++;
              sprintf (tools_brush_nyscaled, "%d", tools_brushscale.scale_ydiv);
              texticon = tools_icons [tools_bicon_YNScaleD];
            }
            /* Make the Wimp redraw the writeable icon */
            wimpt_noerr (wimp_set_icon_state (toolwindow_handle, texticon, 0, 0));
            tools_replace_brush ();
          }
        }
        else if (toolwindow_current_tool == &tools_floodfillpaint)
        { wimp_icon i;
          wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
              tools_icons [0], &i));

          tools_flood_local = (i.flags & wimp_ISELECTED) != 0;
        }
        else if (toolwindow_current_tool == &tools_scissorpaint ||
            toolwindow_current_tool == &tools_camerapaint)
        { wimp_icon i;
          BOOL oldstate = tools_exporting_sprite;
          wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
              tools_icons [1], &i));

          tools_exporting_sprite = (i.flags & wimp_ISELECTED) != 0;
          if (tools_exporting_sprite != oldstate)
            toolwindow_stop_all_tools ();
        }
        else if (toolwindow_current_tool == &tools_grabberpaint)
        { wimp_icon i;
          wimpt_noerr (wimp_get_icon_info (toolwindow_handle,
              tools_icons [0], &i));
          tools_grabber_wrap = (i.flags & wimp_ISELECTED) != 0;
        }

        /*Set up the new tool.*/
        if (e->data.but.m.i > 0 && e->data.but.m.i < tools_COUNT)
        { demunge_window (1);
          toolwindow_stop_all_tools ();

          toolwindow_current_tool = toolarray [e->data.but.m.i];

          if (toolwindow_current_tool == &tools_textpaint)
            tools_get_default_text_size ();

          wimpt_noerr (wimp_set_icon_state (toolwindow_handle,
              e->data.but.m.i, wimp_ISELECTED, wimp_ISELECTED));
            /* might have been ADJUST: make sure icon selected */
          setdescription ();

          if (toolwindow_current_tool == &tools_brushpaint)
          { main_sprite *oldbrushsprite_ptr = tools_brushsprite_ptr;
            /* SMC: Now look up brush name in Messages file. */
            if ((tools_brushsprite_ptr =
                psprite_find (msgs_lookup (tools_brushsprite), NULL)) != NULL)
              psprite_set_brush_colour_translations ();

              tools_delete_brushmouse_sprite ();
              if (psprite_hasalphamask (tools_brushsprite_ptr) ||
                  psprite_hasalphachannel (tools_brushsprite_ptr))
              { /*The EOR plot to draw and erase the brush under the mouse pointer
                  won't work with alpha sprites, so convert to on/off mask.*/
                 tools_make_brushmouse_sprite ();
              }
          }

          munge_window ();
        }
        else if (e->data.but.m.i >= tools_MODE_ICON_BASE &&
            e->data.but.m.i < tools_MODE_ICON_BASE + 4)
        { toolwindow_current_mode = e->data.but.m.i - tools_MODE_ICON_BASE;
          ftracef1 ("Selected %s mode\n",
              toolwindow_current_mode == 0? "Set":
              toolwindow_current_mode == 1? "OR":
              toolwindow_current_mode == 2? "AND":
              toolwindow_current_mode == 3? "EOR": "*** BUG!!! ***");
          wimpt_noerr (wimp_set_icon_state (toolwindow_handle,
              e->data.but.m.i, wimp_ISELECTED, wimp_ISELECTED));
              /*might have been ADJUST: make sure icon selected*/
        }
        else if (toolwindow_current_tool != &tools_grabberpaint &&
            e->data.but.m.i >= tools_MODE_ICON_BASE + 4 &&
            e->data.but.m.i < tools_MODE_ICON_BASE + 6)
        { ftracef1 ("Selected %s mode\n",
              e->data.but.m.i == tools_MODE_ICON_BASE + 4? "Local":
              "Export");
          wimpt_noerr (wimp_set_icon_state (toolwindow_handle,
              e->data.but.m.i, wimp_ISELECTED, wimp_ISELECTED));
               /*might have been ADJUST: make sure icon selected*/
        }
        slider_validate (tools_bicon_Opacity);
      }

    break;

    case wimp_ECLOSE:
      ftracef0 ("Close tool window\n");
      demunge_window (0);
      main_delete_window (toolwindow_handle);
      toolwindow_handle = 0;
      main_current_options.tools.show_tools = FALSE;
    break;

    case wimp_ESEND:
    case wimp_ESENDWANTACK:
      if (e->data.msg.hdr.action == wimp_MHELPREQUEST)
      { wimp_mousestr m;

        static char *Tokens [] =
          { "PntHT1", "PntHT2", "PntHTD", "PntHT7", "PntHTF",
            "PntHTJ", "PntHTE", "PntHTI", "PntHTA", "PntHTG",
            "PntHTK", "PntHTL", "PntHT4", "PntHT5", "PntHTH",
            "PntHT6", "PntHTB", "PntHT8", "PntHTC", "PntHT9",
            "PntHT3",     NULL,     NULL, "PntHTM", "PntHTN",
            "PntHTO", "PntHTP"
          };

        ftracef1 ("Help request on tool window: %d\n",
            e->data.msg.data.helprequest.m.i);
        wimpt_complain (wimp_get_point_info (&m));

        main_help_message
        ( 1 <= m.i && m.i <= 27 && Tokens [m.i - 1] != NULL?
            Tokens [m.i - 1]:
            "PntH1",
          e
        );
      }
    break;
  }

  menus_insdel_frig ();
}


/****************************************************
 *   Close tool window without affecting options    *
 ****************************************************/

extern void toolwindow_close ( void )

{ ftracef0 ("Called user function to close tool window\n");

  if (toolwindow_handle != NULL) /* ie: if it is open */
  { if (main_windows->link == NULL) /* only close if there are no active
        windows */
    { demunge_window (0);
      main_delete_window (toolwindow_handle);
      toolwindow_handle = 0;
    }
  }
}


/****************************************************
 *  Force display of sprite tool window             *
 ****************************************************/

void toolwindow_display (BOOL atpointer)

{ wimp_openstr  wopener;
  wimp_mousestr mouse;

  if (toolwindow_handle == 0)
  { ftracef0 ("Create tool window\n");
    if (main_create_window (&tools_tool_template.t, &toolwindow_handle,
        &sprite_tool_event_handler, NULL) == 0)
      return; /* Failed to create it */

    wopener.w = toolwindow_handle;

    if (atpointer)
    { /* Open window under pointer */
      wimpt_noerr (wimp_get_point_info (&mouse));
      wopener.box.x1  = (tools_tool_template.t.box.x1 -
          tools_tool_template.t.box.x0)/2;
      wopener.box.x0  = mouse.x - wopener.box.x1;
      wopener.box.x1 += mouse.x;
      wopener.box.y1  = (tools_tool_template.t.box.y1 -
          tools_tool_template.t.box.y0)/2;
      wopener.box.y0  = mouse.y - wopener.box.y1;
      wopener.box.y1 += mouse.y;
    }
    else
      wopener.box = tools_tool_template.t.box;

    wopener.behind = -1;
    wopener.x = 0;
    wopener.y = 0;

    if (wimpt_complain (wimp_open_wind (&wopener)) == 0)
    { /* Window opened OK - set it up */
      munge_window ();
      set_tool_window_state ();
      ftracef0 ("Opened tool window\n");
    }
    /* else: failed to open: leave window existent but undisplayed */
  }
  else
  {  /* if it is already open then bring it to the front */
    wimp_wstate tool_state;
    wimpt_noerr (wimp_get_wind_state (toolwindow_handle, &tool_state));
    tool_state.o.behind = -1;
    wimpt_noerr (wimp_open_wind (&tool_state.o));

    /* Bring the brushes pane in front too if necessary */
    open_brush_pane (&tool_state.o, NULL, -1, TRUE);
  }
}

void toolwindow_init (void)

{ toolwindow_handle = 0;
  toolwindow_current_tool   = &tools_pixelpaint;
  init_toolarray ();
}
