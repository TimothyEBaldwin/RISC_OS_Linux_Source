; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
; Assembly veneer for dealing with TickerV fast
; Based on code generated by Norcroft C 5.06
;
; It is designed to minimise the load on the system - it is a
; Bad Thing (TM) to use TickerV, but I don't think there is much
; choice for elegant operation of the Internet stack. As a compromise,
; I have recrafted the tick_handler routine from unixenv.c into
; assembler that can run directly in IRQ mode on TickerV.

NETISR_CALLO    *       1

                ^       0
tv_sec          #       4
tv_usec         #       4

                ^       0
c_next          #       4
c_arg           #       4
c_func          #       4
c_time          #       4


        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:APCS.<APCS>

        AREA    TickEntry,CODE,READONLY

; The TickerV entry point - we arrive in IRQ mode with IRQs disabled.

        EXPORT  tick_entry
tick_entry
        Push    "r0-r2, lr"
        LDR     r2,[r12]
        LDR     r2,[r2,#8]
        LDR     r0,P_time
        ADD     r0,r2,r0
        LDR     r1,[r0,#tv_usec]
        ADD     r1,r1,#&0710
        ADD     r1,r1,#&2000         ; time.tv_usec += 10000
        STR     r1,[r0,#tv_usec]
        SUBS    lr,r1,#&000F4000
        CMPGE   lr,#&240             ; if time.tv_usec >= 1000000
        BLT     %F1
        MOV     r1,#0
        STR     r1,[r0,#tv_usec]     ;   time.tv_usec = 0
        LDR     r1,[r0,#tv_sec]      ;   time.tv_sec ++;
        ADD     r1,r1,#1
        STR     r1,[r0,#tv_sec]
1       MOV     r0,#0                ; r0=needtocall
        LDR     r1,P_calltodo
        ADD     r1,r2,r1             ; sort out relocations
        LDR     r1,[r1,#c_next]      ; r1=calltodo->c_next
        TEQS    r1,#0
        Pull    "r0-r2, pc",EQ
0                                    ; while (r1)
        LDR     r2,[r1,#c_time]
        SUBS    r2,r2,#1             ; decrement r1->c_time
        STR     r2,[r1,#c_time]
        BGT     break                ; if r1->c_time>0 end loop
        BEQ     break_with_sched     ; if r1->c_time==0 do schednetisr
        MOV     r0,#1                ; set needtocall
        LDR     r1,[r1,#c_next]      ; r1=r1->c_next
        TEQS    r1,#0
        BNE     %B0
        B       break_with_sched
break
        TEQS    a1,#0                ; check needtocall
        Pull    "r0-r2, pc",EQ

break_with_sched
        LDR     a3,[r12]
        LDR     a3,[a3,#8]
        ; This code corresponds to:
        ; schednetisr(NETISR_CALLO); which is a macro:
        ; netisr |= 1<<NETISR_CALLO;
        LDR     a1,P_netisr
        ADD     a1,a3,a1
        LDR     a2,[a1]
        ORR     a2,a2,#(1:SHL:NETISR_CALLO)
        STR     a2,[a1]
        ; setsoftnet();
        ; if (callbackflag != 0) then return doing nowt
        LDR     a1,P_callbackflag
        ADD     a1,a3,a1
        LDR     a2,[a1]
        TEQS    a2,#0
        Pull    "a1-a3, pc",NE
        ; callbackflag = 1;
        MOV     a2,#1
        STR     a2,[a1]
        ; callback(CALLB_CALLB);
        ; struct callback_record *cbptr = callbacks + CALLB_CALLB
        LDR     a1,P_callbacks
        ADD     a1,a3,a1            ; Now a1->callback[CALLB_CALLB]
        ; cbptr->cb_outstanding++;
        LDR     a2,[a1,#4]
        ADD     a2,a2,#1
        STR     a2,[a1,#4]
        ; os_add_callback(cbptr->cb_entry, module_wsp);
        LDR     a1,[a1,#0]
        MOV     a2,r12
        ; Right, guff to change up into SVC mode to call this SWI.
        ; This is okay because R12 isn't needed from now on.
        [ {CONFIG}=26
        MOV     r12,pc                  ; R12 holds PC and PSR
        AND     r12,r12,#3              ; Extract current mode bits
        EOR     r12,r12,#3              ; R8 = current mode EOR SVC
        TEQP    r12,pc                  ; Enter SVC
        NOP
        |
        MRS     r12,CPSR
        ORR     lr,r12,#3
        MSR     CPSR_c,lr
        ]
        Push    "lr"                    ; Save R14_SVC (in case in IRQ mode)
        SWI     XOS_AddCallBack
        Pull    "lr"                    ; Restore R14_SVC
        [ {CONFIG}=26
        TEQP    r12,pc                  ; Restore mode, preserving flags
        NOP
        |
        MSR     CPSR_c,r12
        ]
        Pull    "a1-a3, pc",VC
        ; if an error
        ; callbackflag=0;
        LDR     a1,P_callbackflag
        ADD     a1,a3,a1
        MOV     a2,#0
        STR     a2,[a1]
        ; callbackerr=1;
        LDR     a1,P_callbackerr
        ADD     a1,a3,a1
        MOV     a2,#1
        STR     a2,[a1]

        Pull    "a1-a3, pc"

P_time
        IMPORT  kerneltime
        DCD     kerneltime

P_calltodo
        IMPORT  calltodo
        DCD     calltodo

P_netisr
        IMPORT  netisr
        DCD     netisr

P_callbackflag
        IMPORT  callbackflag
        DCD     callbackflag

P_callbacks
        IMPORT  callbacks
        DCD     callbacks

P_callbackerr
        IMPORT  callbackerr
        DCD     callbackerr


        ; Extracted from ARM Architecture Reference
        EXPORT  ntohl
ntohl                                   ; a1 = A , B , C , D
      [ NoARMv6
        EOR     a2, a1, a1, ROR #16     ; a2 = A^C,B^D,C^A,D^B
        BIC     a2, a2, #&ff0000        ; a2 = A^C, 0 ,C^A,D^B
        MOV     a1, a1, ROR #8          ; a1 = D , A , B , C
        EOR     a1, a1, a2, LSR #8      ; a1 = D , C , B , A
      |
        REV     a1, a1                  ; a1 = D , C , B , A
      ]
        Return  ,LinkNotStacked

        END
