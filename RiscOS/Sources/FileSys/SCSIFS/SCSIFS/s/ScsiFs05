; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;>ScsiFs05

 [ Dev
PHEX
 SavePSR R4
 [ :LNOT: IrqDebug
 MOV    R3, #IRQsema
 LDR    R3, [R3]
 TEQS   R3, #0
 BNE    PHEXIT1         ;return if IRQ thread
 ]
 MOV    R3, LR
 [ No32bitCode
 ASSERT SVC_mode=3
 ORR    R0, LR, #SVC_mode
 TEQP   PC, R0          ;go to SVC mode preserving flags
 nop
 |
 MRS R0, CPSR
 ORR R0, R0, #SVC26_mode :OR: I32_bit
 MSR CPSR_c, R0
 ]
 Push   "LR"
 [ SpoolOff
 BL     SpoolOff
 ]
 MOV    R1, #32-4
PHLOOP
 MOV    R0, R2, LSR R1
 AND    R0, R0, #&F
 CMPS   R0, #10
 ADDCC  R0, R0, #"0"
 ADDCS  R0, R0, #"A"-10
 SWI    OS_WriteC
 SUBS   R1, R1, #4
 BPL    PHLOOP
 MOV    R0, #" "
 SWI    OS_WriteC
 [ SpoolOff
 BL     SpoolOn
 ]
 Pull   "LR"
 RestPSR R4,,cf
 MOV    PC, R3
PHEXIT1
 RestPSR R4,,f
 MOV    PC, LR


 [ SpoolOff
SpoolOff
 Push   "R0-R3,LR"
 SavePSR R3
 MOV    R0, #3
 MOV    R1, #&10
 MOV    R2, #&EF
 SWI    OS_Byte
 RestPSR R3,,f
 Pull   "R0-R3,PC"

SpoolOn
 Push   "R0-R3,LR"
 SavePSR R3
 MOV    R0, #3
 MOV    R1, #0
 MOV    R2, #&EF
 SWI    OS_Byte
 RestPSR R3,,f
 Pull   "R0-R3,PC"
 ]

Mess1                   ;R0,R1,LR stacked
 SavePSR R0             ;save PSR
 MOV    R1, LR          ;save link
 [ :LNOT: IrqDebug
 MOV    LR, #IRQsema
 LDR    LR, [LR]
 TEQS   LR, #0
 MOVNE  PC, R1          ;skip if IRQ thread, return NE
 ]
 BIC    LR, R0, #3
 [ No32bitCode
 ORR    LR, LR, #SVC_mode :OR: Z_bit
 TEQP   PC, LR          ;go to supervisor mode, preserve FI, set EQ
 nop                    ;delay for mode change
 |
 ORR    LR, LR, #Z_bit
 ORR    LR, LR, #SVC26_mode :OR: I32_bit
 MSR    CPSR_cf, LR
 ]
 Push    "LR"
 [ SpoolOff
 BL      SpoolOff
 ]
 MOV    PC, R1

 [ F
TubeWrHexWord ROUT
 SavePSR R4
 MOV    R3, LR
 MOV    R1, #32-4
05
 MOV    R0, R2, LSR R1
 AND    R0, R0, #&F
 CMPS   R0, #10
 ADDCC  R0, R0, #"0"
 ADDCS  R0, R0, #"A"-10
 BL     TubeChar        ;(R0)
 SUBS   R1, R1, #4
 BPL    %BT05
 MOV    R0, #" "
 BL     TubeChar        ;(R0)
 RestPSR R4,,f
 MOV    PC, R3

           ^ 0, R1
R1_status  # 4
R1_data    # 4
TubeAddress * &3340000 + (0*&4000)      ;podule 0

TubeChar ROUT
 Push   "R1,LR"
 LDR    R1, =TubeAddress
10
 LDRB   LR, R1_status
 TSTS   LR, #&40
 BEQ    %BT10
 STRB   R0, R1_data
 Pull   "R1,PC"
 ]
 ]

; ====
; SetV
; ====

SetV
  [ No32bitCode
 ORRS   PC, LR, #V_bit
  |
 Push   "LR"
 SETPSR V_bit, LR
 Pull   "PC"
  ]


; ========
; SetVOnR0
; ========

SetVOnR0
  [ No32bitCode
 CMPS   R0, #0
 BICEQS PC, LR, #V_bit
 ORRNES PC, LR, #V_bit
  |
 Push   "LR"
 MRS    LR, CPSR
 CMPS   R0, #0
 BICEQ  LR, LR, #V_bit
 ORRNE  LR, LR, #V_bit
 MSR    CPSR_f, LR
 Pull   "PC"
  ]


; ======
; Divide
; ======

; entry: R0=Numerator, R1=Denominator
; exit:  R0=Result, R1=Remainder

Divide  ROUT
 Push   "R2,LR"

 MOV    LR, R1          ;temp = den
 CMPS   LR, R0, LSR #1  ;shift temp left unless it would be > num
10
 MOVLS  LR, LR, LSL #1
 CMPLS  LR, R0, LSR #1
 BLS    %BT10
 MOV    R2, #0          ;init result
20
 CMPS   R0, LR          ;if subtraction possible
 SUBCS  R0, R0, LR      ; do it
 ADC    R2, R2, R2      ;shift bit into result
 MOV    LR, LR, LSR #1  ;move temp right
 CMPS   LR, R1          ;loop if not done
 BHS    %BT20

 MOV    R1, R0          ;mod
 MOV    R0, R2          ;div

 Pull   "R2,PC"


; =============
; ReadCMOSflags
; =============

;read the CMOS byte containing number of drives, default drive & dir/no dir bit

; exit R0,V result
;  R2 = full byte
;  R4 = number of drives
;  R5 = default drive
 [ FloppySupport
;  R3 = number of removable media drives (floppies)
;  R4 = number of fixed media drives (winnies)
 ]
ReadCMOSflags ROUT
 Push   "R1,LR"
 MOV    R0, #OsbyteReadCMOS
 MOV    R1, #CMOSflags
 SWI    XOS_Byte                ;(R0-R2->R0-R2,V)
 MOVVS  R2, #2_01000001         ;default NoDir, one drive
 BVS    %FT95
 [ FloppySupport
 MOV    R3, R2, LSR #6
 ]
 AND    R4, R2, #2_00000111
 CMPS   R4, #4
 MOVHI  R4, #1
 AND    R5, R2, #2_00111000
 MOV    R5, R5, LSR #3
 [ FloppySupport
 |
 CMPS   R5, R4
 MOVHS  R5, #0
 ADD    R5, R5, #4
 ]
95
 [ HotPlug
 MOV    R3, #4
 MOV    R4, #4
 ]
 Pull   "R1,PC"

; ===============
; ReadMapSizeCMOS
; ===============

; exit R0,V if error, R6 map size bytes

ReadMapSizeCMOS ROUT
 Push   "R1-R3,LR"
 MOV    R0, #OsbyteReadCMOS
 MOV    R3, #3*8
 MOV    R6, #0
10
 MOV    R1, #MapSizeCMOS
 ADD    R1, R1, R3, LSR #3
 SWI    XOS_Byte        ;(R0-R2->R0-R2,V)
 BVS    %FT95
 ORR    R6, R6, R2, LSL R3
 SUBS   R3, R3, #8
 BPL    %BT10
 [ Debug2
 wrhex  R6
 mess   ,"MAP SIZES",NL
 ]
95
 Pull   "R1-R3,PC"


; ============
; ReadFileCMOS
; ============

; exit R0,V result
;  R5 = extra file buffers in K

ReadFileCMOS ROUT
 Push   "R1,R2,R4,LR"
 MOV    R0, #OsbyteReadCMOS
 MOV    R1, #FileCMOS
 SWI    XOS_Byte        ;(R0-R2->R0-R2,V)
 MOVVC  R5, R2
 TEQS   R5, #1
 BNE    %FT10
 BL     DefaultCacheSize   ;->R4
 MOV    R5, R4, LSR #10
10
 MOVVS  R5, #0
 Pull   "R1,R2,R4,PC"


; ===========
; ReadDirCMOS
; ===========

; exit R0,V result
;  R4 = dir cache size in bytes

ReadDirCMOS
 Push   "R1,R2,LR"
 MOV    R0, #OsbyteReadCMOS
 MOV    R1, #DirCMOS
 SWI    XOS_Byte        ;(R0-R2->R0-R2,V)
 MOVVS  R2, #0
 MOVS   R4, R2, LSL #10
 BLEQ   DefaultCacheSize   ;->R4
 Pull   "R1,R2,PC"


; ================
; DefaultCacheSize
; ================

; exit R4 default size

DefaultCacheSize ROUT
 Push   "R0-R3,R5-R7,LR"
 MOV    R0, #0
 MOV    R1, #0
 MOV    R2, #0
 MOV    R3, #0
 Push   "R0-R3"
 Pull   "R4-R7"         ;R0-R7 now zero
 SWI    XOS_SetEnv      ;returns RAM size in R2
 MOV    R4, R2, LSR #8
 CMPS   R4, #255*1024
 MOVHI  R4, #255*1024
 CLRV
 Pull   "R0-R3,R5-R7,PC"


; ==========
; SkipSpaces
; ==========

; entry R1 -> char
; exit
;  R0 char
;  R1 -> char after first non space char
;  C set <=> terminator

SkipSpaces ROUT
 Push   "LR"
10
 LDRB   R0, [R1], #1
 TEQS   R0, #" "
 BEQ    %BT10
 CMPS   R0, #DeleteChar
 RSBNES LR, R0, #" "-1
 Pull   "PC"


; =============
; ParseAnyDrive
; =============

;doesn't check if drive is allowed by configure

ParseAnyDrive ROUT
 Push   "LR"

; Entry: R1-> string
; Exit:  R1-> first char after
 [ FloppySupport
;  good => R0 drive number, V=0
 |
;  good => R0 drive number-4, V=0
 ]
;  bad  => R0 -> error, V=1

 BL     SkipSpaces      ;(R1->R0,R1,C)
 BCS    %FT10           ;reject nul string
 LDRB   LR, [R1]
 CMPS   LR, #DeleteChar
 RSBNES LR, LR, #" "    ;check terminated
 BCC    %FT10           ;not terminated

 CMPS   R0, #"a"
 SUBHS  R0, R0, #"a"-"A"
 CMPS   R0, #"A"
 SUBHS  R0, R0, #"A"-"0"
 [ FloppySupport
 SUBS   R0, R0, #"0"
 RSBCSS LR, R0, #7
 |
 SUBS   R0, R0, #"4"
 RSBCSS LR, R0, #3
 ]
 Pull   "PC",CS
10
 baddr  R0, BadDriveErrBlk
 BL     SetV
 Pull   "PC"


; =====
; WrDec
; =====

; write a space followed by a zero supressed decimal number

; entry R0 number

; exit if error V set, R0 result

WrDec   ROUT
 Push   "R0,R1,LR"
 MOV    R1, #10
 BL     Divide          ;(R0,R1->R0,R1)
 TEQS   R0, #0
 BEQ    %FT10
 BL     WrDec           ;(R0->R0,V)
 B      %FT20
10
 MOV    R0, #" "
 SWI    XOS_WriteC      ;(R0->R0,V)
20
 ADDVC  R0,R1,#"0"
 SWIVC  XOS_WriteC      ;(R0->R0,V)
95
 STRVS  R0,[SP]
 Pull   "R0,R1,PC"

 [ AutoDetect
MapDevToDrv ROUT
 Push   "R2,R3,LR"
 MOV    R2, #0
01
 mapDrvToDevLo R3, R2
 TEQ    R3, R1
 ADDNE  R2, R2, #1
 TEQNE  R2, #8
 BNE    %BT01
 MOV    R1, R2
 Pull   "R2,R3,PC"

; In:

; In:
;  R0 = device ID
;  R2 = device ID mask      (we scan all devices with ID AND R2 = R0)
;  R3 = configured number of removable media drives
;  R4 = configured number of fixed media drives
; Out:
;  R3 = actual number of removable media drives (<= entry R3)
;  R4 = actual number of fixed media drives     (<= entry R4)
;  Drive -> Device mappings filled in
ScanDrives2
        Push    "R0-R2,R5-R8,LR"
        SUB     StkPtr, StkPtr, #16
 [ Debug7
        wrhex   R0
        wrhex   R2
        wrhex   R3
        wrhex   R4
        mess    ,">ScanDrives",NL
 ]
        MOV     R1, #0
        MOV     R5, #0
        MOV     R6, #0
ScanLoop
        TEQ     R3, R5
        TEQEQ   R4, R6
        BEQ     ScanFinished

        LDR     LR, [StkPtr, #16+0*4]           ; check we fall within the mask
        LDR     R8, [StkPtr, #16+2*4]
        AND     R8, R1, R8
        TEQ     R8, LR
        BNE     ScanNext

 [ HotPlug
        MOV     R8, R1                          ; check we've not already
        BL      MapDevToDrv                     ; spotted this drive
        TEQ     R1, #8
        MOV     R1, R8
        BNE     ScanNext
 ]

        ; I don't use SCSI_Initialise 2 as it will report errors from
        ; the READ CAPACITY command (likely at start-up). Instead,
        ; do just an INQUIRY command manually.
 [ Debug7
        wrhex   R1
        mess    ,"Inquiry",NL
 ]
        Push    "R0-R5"
        ORR     R0, R1, #CTL_TXREAD
        MOV     R1, #6
        ADR     R2, CDB_Inquiry
        ADD     R3, StkPtr, #6*4
        MOV     R4, #5
        MOV     R5, #100
        MOV     R8, R12
        SWI     XSCSI_Op
        TEQ     R4, #0
        Pull    "R0-R5"
        BVS     ScanNextDev
        BNE     ScanNextDev
ScanCheck
        LDRB    LR, [StkPtr, #0]
 [ Debug7
        wrhex   LR
        mess    ,"Type",NL
 ]
        TEQ     LR, #DevDirectAccess
      [ OpticalMemorySupport
        TEQNE   LR, #DevOpticalMemory
      ]
        BNE     ScanNext
      [ FloppySupport
        LDRB    LR, [StkPtr, #1]
        TST     LR, #&80                ; Removable bit
        BNE     AddRemovable
      ]
AddFixed
 [ Debug7
        wrhex   R6
        mess    ,"Adding fixed",NL
 ]
 [ HotPlug
        MOV     R0, #4
        BL      MapInDevice
        ADDNE   R6, R6, #1
 |
        CMP     R6, R4
        BHS     ScanNext
        ADD     LR, R6, #4
        DrvRecPtr R0, LR
        STDevNo R1,R0, LR
        ADD     R6, R6, #1
 ]
      [ FloppySupport
        B       ScanNext
AddRemovable
 [ Debug7
        wrhex   R5
        mess    ,"Adding removable",NL
 ]
 [ HotPlug
        MOV     R0, #0
        BL      MapInDevice
        ADDNE   R5, R5, #1
 |
        CMP     R5, R3
        BHS     ScanNext
        DrvRecPtr R0, R5
        STDevNo R1,R0, LR
        ADD     R5, R5, #1
 ]
      ]
ScanNext
        ADD     R1, R1, #&20            ; move to next LUN
        TST     R1, #&100
        BEQ     ScanLoop
ScanNextDev
        AND     R1, R1, #&1F
        ADD     R1, R1, #1              ; move to next device/card
        TST     R1, #&20
        BEQ     ScanLoop

        MOV     R3, R5
        MOV     R4, R6
ScanFinished
        ADD     StkPtr, StkPtr, #16
 [ Debug7
        wrhex   R3
        wrhex   R4
        mess    ,"<ScanDrives",NL
 ]
        Pull    "R0-R2,R5-R8,PC"

ScanDrives
        Push    "R0,R2,LR"
        MOV     R0,#0
        MOV     R2,#0
        BL      ScanDrives2
        Pull    "R0,R2,PC"

CDB_Inquiry
        DCB     &12     ; INQUIRY
        DCB     0
        DCB     0
        DCB     0
        DCB     5
        DCB     0
        ALIGN
 ]

 [ HotPlug

 [ {TRUE}

CDB_Inquiryfull
        DCB     &12     ; INQUIRY
        DCB     0
        DCB     0
        DCB     0
        DCB     36
        DCB     0
        ALIGN


; check if this drive is 'disabled'. A drive is 'disabled' if its
; inquiry string from offset 8 to offset 31 inclusive matches one
; in file Boot:Choices.SCSIFS.Hide
;   otherwise it is allowed.
; in : R1=driveID
; out: EQ if not allowed, else NE
CheckDriveAllowed ROUT
        Push    "R0-R5,R8,LR"
 [ Debug7
        wrhex   R1
        mess    ,"MapInDrive",NL
 ]
        ORR     R0, R1, #CTL_TXREAD
        MOV     R1, #6
        ADR     R2, CDB_Inquiryfull
        SUB     StkPtr, StkPtr, #36 + 44
        MOV     R3, StkPtr
        MOV     R4, #36
        MOV     R5, #100
        MOV     R8, R12
        SWI     XSCSI_Op
        BVS     CDANotAllowed           ; wont allow drive if error
        TEQ     R4, #0
        BNE     CDANotAllowed           ; wont allow if no full enquiry response
        Push    "R3"
        ADR     R0, BootPath
        MOV     R1, R3
        MOV     r2, #-1
        MOV     R3, #0
        MOV     R4, #0
        SWI     XOS_ReadVarVal          ; does it exist?
        TEQ     R2, #0
        Pull    "R3", EQ             ; no
        BEQ     CDAAllowed
; the Boot: path exists.. look for our choices.Hide file
        MOV     R0, #&4f                ; 4f open R/O no path
        ADR     R1, ChoicesHide
        SWI     XOS_Find
                                        ; choices didnt open
        Pull    "R3", VS                ; no
        BVS     CDAAllowed
        MOV     R1, R0                  ; file handle

lp0     MOV     R0, #4                  ; use current pointer
        LDR     R2, [StkPtr]            ; buffer space after enquiry data
        MOV     R3, #1                  ; first byte
        SWI     XOS_GBPB                ; read first byte
        TEQ     R3,#0                   ; all read?
        BNE     goteof                  ; incomplete line .. file end reached
        LDR     R5, [StkPtr]            ; buffer space after enquiry data
        LDRB    R5, [R5]
        TEQ     R5, #'|'                ; a comment line?
        BNE     lp1
lp2     MOV     R0, #4                  ; use current pointer
        LDR     R2, [StkPtr]            ; buffer space after enquiry data
        MOV     R3, #1                  ; first byte
        SWI     XOS_GBPB                ; read first byte
        TEQ     R3,#0                   ; all read?
        BNE     goteof                  ; incomplete line .. file end reached
        LDR     R5, [StkPtr]            ; buffer space after enquiry data
        LDRB    R5, [R5]
        TEQ     R5, #10                 ; end line?
        BNE     lp2                     ; no.. go there
        B       lp0                     ; back for next line
lp1     MOV     R0, #4                  ; use current pointer
        MOV     R3, #8 + 16 + 4         ; rest of enquiry data + 1 linefeed
        SWI     XOS_GBPB                ; read first line
        TEQ     R3,#0                   ; all read?
        BNE     goteof                  ; incomplete line .. file end reached
        SUB     R2, R2, #5              ; point to last word of enq data read
        LDR     R4, [StkPtr]            ; buffer space after enquiry data
        SUB     R4, R4, #4              ; last word of this enq data

 [ Debug7
        wrhex   R2
        wrhex   R4
        mess    ,"MapInDrive",NL
 ]

        MOV     R5, #8 + 16 + 4

cmpr    LDR     R0, [R2], #-4           ; compare strings
        LDR     R3, [R4], #-4
        TEQ     R0, R3
        BNE     lp0                     ; not a match.. try next
        SUBS    R5, R5, #4
        BGT     cmpr                    ; loop
                                        ; match found
        MOV     R0, #0
        SWI     XOS_Find                ; close the file again
        Pull    "R3"
        B       CDANotAllowed

goteof  MOV     R0, #0
        SWI     XOS_Find                ; close the file again
        Pull    "R3"

CDAAllowed
        ADD     StkPtr, StkPtr, #36 + 44
        TEQ     PC, #0
        Pull    "R0-R5,R8,PC"           ; exit NE.. allowed

CDANotAllowed
        ADD     StkPtr, StkPtr, #36 + 44
        TEQ     R0, R0
        Pull    "R0-R5,R8,PC"           ; exit EQ.. not allowed

BootPath
        =       "Boot$Path",0
ChoicesHide
        =       "Boot:Choices.SCSIFS.Hide",0
        ALIGN
 ]





; In: R0 = 0 or 4 (indicating drive number range)
;     R1 = device number
; Out: NE if found a slot
MapInDevice
        Push    "R0,R1,R3,R5,LR"
        BL      CheckDriveAllowed
        Pull    "R0,R1,R3,R5,PC",EQ        ; Exit (with EQ)
10
        DrvRecPtr R5,R0
        mapDrvToDevLo R3,R0,R5
        CMP     R3, #-1
        BNE     %FT60
        STDevNo R1,R5, LR
        MOV     R1, R0
        MOV     R0, #Upcall_DriveAdded
        BL      UpcallDrive             ; issue an upcall
        MOV     R0, R1
        TEQ     PC,#0
        Pull    "R0,R1,R3,R5,PC"        ; Exit (with NE)

60      ADD     R0, R0, #1
        TST     R0, #3
        BNE     %BT10
        Pull    "R0,R1,R3,R5,PC"        ; Exit (with EQ)

ServiceAttachDetach
        getSB
        ASSERT  Service_SCSIAttached:AND:1 = 0
        ASSERT  Service_SCSIDetached:AND:1 = 1
        TST     R1, #1
        BEQ     DoAttached
        BNE     DoDetached

                ^       0
ACBD_DevID      #       4
ACBD_DevIDMask  #       4
ACBD_SB         #       4
AttachedCBDataSz # 0

; In: R0 = device number
;     R2 = device number mask
; Note the parameters (in an allocated block) to deal with on a callback
DoAttached      ROUT
        Push    "R0-R2,LR"
        LDRB    R0, Dieing
        TEQ     R0, #0
        Pull    "R0-R2,PC",NE

        MOV     R0, #ModHandReason_Claim
        MOV     R3, #AttachedCBDataSz
        SWI     XOS_Module
        Pull    "R0-R2,PC",VS
        LDR     R0, [StkPtr, #0]
        LDR     LR, [StkPtr, #8]
        STR     R0, [R2, #ACBD_DevID]
        STR     LR, [R2, #ACBD_DevIDMask]
        STR     SB, [R2, #ACBD_SB]
        LDRB    R0, AttCBCount
        ADD     R0, R0,#1
        CMP     R0, #&100
        MOVGE   R0, #&ff
        STRB    R0, AttCBCount
        ADR     R0, DoAttachedCallback
        MOV     R1, R2
        SWI     XOS_AddCallBack
        Pull    "R0-R2,PC"

DoAttachedCallback  ROUT
        Push    "R0,R2,R3,R4,LR"
        Push    "R12"
        LDR     R0,[R12, #ACBD_DevID]
        LDR     R2,[R12, #ACBD_DevIDMask]
        LDR     SB,[R12, #ACBD_SB]
        LDRB    LR, Dieing
        TEQ     LR, #0
        BNE     %ft1                       ; no point in attaching if dieing
        MOV     R3,#4
        MOV     R4,#4
        BL      ScanDrives2
        MOV     R0,#ModHandReason_Free
1
        Pull    "R2"
        LDRB    R0, AttCBCount
        SUBS    R0,R0,#1
        STRGEB  R0, AttCBCount
        MOV     R0,#ModHandReason_Free
        SWI     XOS_Module
        Pull    "R0,R2,R3,R4,PC"

; In: R0 = device number
;     R2 = device number mask
; Note the parameters (in an allocated block) to deal with on a callback
DoDetached
        Push    "R0-R2,LR"
        LDRB    R0, Dieing
        TEQ     R0, #0
        Pull    "R0-R2,PC",NE
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #AttachedCBDataSz
        SWI     XOS_Module
        Pull    "R0-R2,PC",VS
        LDR     R0, [StkPtr, #0]
        LDR     LR, [StkPtr, #8]
        STR     R0, [R2, #ACBD_DevID]
        STR     LR, [R2, #ACBD_DevIDMask]
        STR     SB, [R2, #ACBD_SB]
        LDRB    R0, DetCBCount
        ADD     R0,R0,#1
        CMP     R0, #&100
        MOVGE   R0, #&ff
        STRB    R0, DetCBCount
        ADR     R0, DoDetachedCallback
        MOV     R1, R2
        SWI     XOS_AddCallBack
        Pull    "R0-R2,PC"

; In: R0 = device number
;     R2 = device number mask
DoDetachedCallback
        Push    "R0-R5,LR"
        Push    "R12"
        LDR     R0,[R12, #ACBD_DevID]
        LDR     R2,[R12, #ACBD_DevIDMask]
        LDR     SB,[R12, #ACBD_SB]
        LDRB    LR, Dieing
        TEQ     LR, #0
        BNE     %ft90                      ; no point in attaching if dieing
        MOV     R1,#&FF                 ; loop over all device numbers
10      AND     LR,R1,R2
        TEQ     LR,R0                   ; if the device number fits the mask
        BNE     %FT80
        MOV     R3,#7                   ; then loop over all drives
20
        DrvRecPtr R5,R3
        mapDrvToDevLo LR,R3,R5
        TEQ     LR,R1                   ; if this drive maps to the device
        BNE     %FT70                   ; unmap it

        MOV     LR,#-1                  ; clear the device field
        STDevNo LR,R5, R4
        LDRB    LR, [R5,#DrvFlags]
        ORR     LR, LR, #LostUnitAtn
        STRB    LR, [R5,#DrvFlags]
        sbaddr  R5, BlockSizes-4
        MOV     LR, #0                  ; blank the block size
        STRB    LR, [R5, R3]
        Push    "R0,R1,R8"
        MOV     R0, #2                  ; release it (just in case)
        MOV     R8, R12
        SWI     XSCSI_Reserve
        MOV     R0, #Upcall_DriveRemoved
        MOV     R1, R3
        BL      UpcallDrive             ; issue an upcall
        Pull    "R0,R1,R8"

70      SUBS    R3,R3,#1
        BPL     %BT20

80      SUBS    R1,R1,#1
        BPL     %BT10
90
        LDRB    R0, DetCBCount
        SUBS    R0,R0,#1
        STRGEB  R0, DetCBCount
        MOV     R0,#ModHandReason_Free
        Pull    "R2"
        SWI     XOS_Module
        Pull    "R0-R5,PC"

; In: R0 = upcall number
;     R1 = drive number
UpcallDrive
        Push    "R0-R2,LR"
        ADR     R2, SCSIPath_Template   ; issue an upcall (drive removed)
        LDMIA   R2, {R2, LR}
        Push    "R2, LR"
        ADD     R2, R1, #"0"
        STRB    R2, [StkPtr, #6]
        MOV     R1, StkPtr
        SWI     XOS_UpCall
        ADDS    StkPtr, StkPtr, #8      ; clear V
        Pull    "R0-R2,PC"

SCSIPath_Template
        =       "SCSI::n",0             ; 2 words
 ]

 LNK    s.ScsiFs15
