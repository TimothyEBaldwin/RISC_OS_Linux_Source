; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >Adfs10

; registers on entry:
; R1  - operation code
; R2  - disc address in bytes from 0
; R3  - store address in bytes, maybe -> list of A-L pairs.
; R4  - total bytes to transfer, (in foreground)
; R5  - disc record
; R6  - defect list
; R12 - static base
; R13 - a full descending stack pointer
; R14 - return link

; operation code:
;    bits 0-3 are the operation:
;        0 - Verify      - the HDC CheckData command
;        1 - Read        - read data into store
;        2 - Write       - write data to disc
;        3 - ReadId
;        4 - WriteTrack  - format a track
;        5 - Seek        - seek for some reason
;        6 - Restore     - restore to track zero
;        ... unknown opcode ...
;       15 - Specify     - set up the hardware.
;
;    bits 4-8 flags
;    bit 4
;    bit 5 address in RAM is a pointer to address-length pairs.
;    bit 6 poll escape every so often, and quit if set.
;    bit 7 timeout of some sort - not implemented for winnies!
;    bit 8 continue transfer in background afterwards until find 0 length pair
;
; Those operations which don't transfer data still take a disc address in
; bytes and use it to define the track to be formatted, track to read Ids
; from, cylinder to seek to or whatever.
; The number of bytes should be set to 512 for ops 3 and 4, 0 for 5 and 6.
;
; If bit 5 is set, the address register points to a list of address length
; pairs, both in bytes.  The lengths will be rounded up to blocks, ie we
; subtract 256 every transfer until the answer is 0 or negative.  The byte
; count supplied is the actual 'boss', so if you don't supply enough A/L
; pairs it'll go wrong.  The last block (according to the byte count) will
; be exactly transfered, like in the ordinary RAM case.
;
;
;
; on exit:
; R0  - completion code
; R2-R4 updated to reflect how far we got in the transfer
; R1,R5-R13 - preserved
;
; completion code is byte value in R0:
;   0 <=> OK.
;
; The data transfer code is copied down into an area of RAM in the static
; storage area, so that it will run faster than it would from ROM.
;
; Defect skipping:  It is possible to skip defects when doing operations
; 0,1,2 (Verify, Read, Write) by providing in R8 the address of a suitable
; list of bad addresses.  If there were bad blocks at say (cylinder 4, head 0
; block 6) and (cyl 6, head 3, block 0) ie addresses when freshly formatted
; 4*4*32+0*32+6 = &20600 in bytes and 6*4*32+3*32+0 = &36000 in bytes, make
; a list containing R8 ->   &20600
;                           &36000
;                        &0FFFFFFF ; for instance, just a big number
;
; then when a request starting at addresses &20600 to &35E00 is made it'll be
; incremented by one to skip the bad area, mapping to blocks &207..&35F on the
; physical disc.  A request starting at address &35F00 and up will be
; incremented by 2 to map onto &36100 up.  The code does split up long
; requests into several shorter ones, so you can say "Read from &20000 up to
; &40000" in one go and the bad blocks will be missed out. (and the last block
; read from the disc is physical block &401, which is logical block &3FF)
;
; If R6 doesn't contain a good address (TSTS R6, #&FC000003 => NE) no defect
; skipping is performed, so supply -1 for instance to turn defect skipping off.
;
; NB if in future anyone wants to do hoopy things like guess where the client
; will want to read next and seek there in advance, it'll still all work,
; though when the actual transfer is performed, an extra step may be needed
; to get to the right track, as seek(&3FF00) may take us to the cylinder before
; the one where logical block &3FF lives, at physical block
; &3FF + (number of defects before &3FF).  All clear?
;

StartOfTheWholeThing ROUT

;************************************************************************
;*                                                                      *
;*               H A R D W A R E   D E F I N I T I O N                  *
;*                                                                      *
;************************************************************************

; Where's the hardware?
HDC             RN R11
                ^ 0, HDC
HDCBase         # 0

HDCcommand      *   0 + HDCBase ;WRITE
HDCparameter    *   4 + HDCBase ;WRITE
HDCdataRead     *   8 + HDCBase ;READ

HDCstatus       * &20 + HDCBase ;READ
POL     bit 1+8         ;polling
ABN     bit 2+8         ;abnormal end
DER     bit 3+8         ;drive error
SED     bit 4+8         ;seek end
CED     bit 5+8         ;command end
CPR     bit 6+8         ;command parameter rejection
BSY     bit 7+8         ;busy

HDCresult       * &24 + HDCBase ;READ
HDCdataWrite    * &28 + HDCBase ;WRITE


 [ A1            ; irq bits attached to the HDC
WinnieBits  * &08
 |
DataReqBit  * &10
IntReqBit   * &08
WinnieBits  * DataReqBit + IntReqBit
 ]
WinPodIRQrequest bit 0

; Only use the fact that it's requesting something, look in HDCstatus for what.

; now a number of HDC commands

CAbort          * &F0
CCheckData      * &48
CCheckDrive     * &28
CFormat         * &A3
CPollingOn      * &10
;CPollingOff     * &18
CRead           * &40
CReadId         * &60
CRestore        * &C8
CSeek           * &C0
CSpecify        * &E8
CWrite          * &87
CRecall         * &08

MaxCyls         * 1024  ;the most the HDC can handle

                GBLS    WinIrqRegs
WinIrqRegs      SETS    """R4-R10,PC"""

;************************************************************************
;*                                                                      *
;*         C O D E   S T A R T   -   M I N O R   R O U T I N E S        *
;*                                                                      *
;************************************************************************

; ================
; TestEscapeStatus
; ================

; test escape and return if set, corrupts R0

TestEscapeStatus ROUT
 LDR    R0, opCode
 TSTS   R0, #NoEscape    ;are we ignoring escapes ?
 MOVNES PC, R14
 MOV    R0, #0
 LDRB   R0, [R0, #ESC_Status]
 TSTS   R0, #EscapeBit
 MOVEQS PC, R14
 MOV    R0, #IntEscapeErr
 STRB   R0, completion
 B      ContigEnded


; =======
; DoAbort
; =======

;corrupts R0 and flags

DoAbort ROUT
 [ Debug2
 mess   ,"DoAbort",NL
 ]
 LDR    R0, HDCstatus
 TSTS   R0, #CED :OR: SED :OR: DER
 [ Debug6
 Push   LR
 MOVNE  R0, #"a"
 MOVEQ  R0, #"A"
 BL     TubeChar
 Pull   "LR"
 ]
 [ Debug2
 mess   NE, "DONE",NL
 ]
 BNE    %FT30

 MOV    R0, #CAbort :SHL: 16
 STR    R0, HDCcommand
20
 LDR    R0, HDCstatus
 TSTS   R0, #CED :OR: SED :OR: DER :OR: ABN
 BEQ    %BT20
;fall through to GetResult
30
 [ Debug2
 mess   ,"ABORTED",NL
 ]

; =========
; GetResult
; =========

; GetResult
; Get the result of a command into R0
; exit R0 status byte >> 2, NE <=> error
GetResult ROUT
 LDRB   R0, HDCresult

 [ F
 Push   "R0-R2"
 [ Debug2
 mess   ,"*results"
 wrhex  R0
 ]
 MOV    R0, #&FF
 ORR    R0, R0, #&FF00 ; gets &FFFF in R0

 LDR    R1, HDCresult
 LDR    R2, HDCresult
 AND    R1, R1, R0
 ORR    R1, R1, R2, ASL #16
; STR    R1, results
 [ Debug2
 wrhex  R1
 ]

 LDR    R1, HDCresult
 LDR    R2, HDCresult
 AND    R1, R1, R0
 ORR    R1, R1, R2, ASL #16
; STR    R1, results + 4
 [ Debug2
 wrhex  R1
 ]

 LDR    R1, HDCresult
 LDR    R2, HDCresult
 AND    R1, R1, R0
 ORR    R1, R1, R2, ASL #16
; STR    R1, results + 8
 [ Debug2
 wrhex  R1
 ]

 LDR    R1, HDCresult
 AND    R1, R1, R0
; STR    R1, results + 12
 [ Debug2
 wrhex  R1
 mess   ,NL
 ]
 Pull   "R0-R2"
 ]

 MOVS   R0, R0, LSR #2
 [ Debug6
 BEQ    %FT90
 Push   "R0,LR"
 MOV    R0, #"E"
 BL     TubeChar
 LDR    R0, [SP]
 Tword  R0
 LDR    R0, HDCstatus
 Tword  R0
 Pull   "R0,LR"
90
 ]
 [ Debug2
 wrhex  R0
 mess   ,"result",NL
 ]
 MOV    PC, LR


; =========
; StartSeek
; =========

; dest. cylinder in R0, drive in R1
; corrupts R0, R1

StartSeek2 ROUT
 MOV    R0, R6
StartSeek1
 MOV    R1, R3
StartSeek
 [ Debug2
 wrhex  R0
 wrhex  R1
 mess   ,"start seek",NL
 ]
 MOV    R0, R0, ASL #16
 ORR    R0, R0, R1, ASL #8
 STR    R0, parameters
 MOV    R0, #CSeek

;fall through to CommandHDC

; ==========
; CommandHDC
; ==========

; CommandHDC
; Stuff command R0 and parameters up it so it does the biz - uses R0, R1
;
CommandHDC ROUT
 [ Debug2
 mess   ,"*winnie op "
 wrhex R0
 ]
 [ Debug6
 Tword  R0
 ]
 STRB   R0, command

10
 LDR    R0, HDCstatus
 TSTS   R0, #BSY :OR: POL
 BNE    %BT10

 TSTS   R0, #CPR
 MOVNE  R0, #CRecall :SHL: 16   ;gets it ready for parameters
 STRNE  R0, HDCcommand
20
 LDRNE  R0, HDCstatus
 TSTNES R0, #BSY
 BNE    %BT20
 LDR    R0, parameters
 [ Debug6
 Tword  R0
 ]
 [ Debug2
 wrhex  R0
 ]
 MOV    R1, R0, ASL #16
 STR    R1, HDCparameter
 STR    R0, HDCparameter

 LDR    R0, parameters + 4
 [ Debug6
 Tword  R0
 ]
 [ Debug2
 wrhex  R0
 ]
 MOV    R1, R0, ASL #16
 STR    R1, HDCparameter
 STR    R0, HDCparameter
 LDR    R0, parameters + 8
 [ Debug2
 wrhex  R0
 ]
 MOV    R1, R0, ASL #16
 STR    R1, HDCparameter
 STR    R0, HDCparameter

 LDR    R0, parameters + 12
 [ Debug2
 wrhex  R0
 mess   ,NL
 ]
 MOV    R1, R0, ASL #16
 STR    R1, HDCparameter
 STR    R0, HDCparameter

 LDRB   R0, command
 MOV    R0, R0, LSL #16
 STR    R0, HDCcommand

 TEQS   R0, #CSeek :SHL: 16
 TEQNES R0, #CRestore :SHL: 16
 MOVNES PC, LR
                        ;start polling if seek or restore
30
 LDR    R0, HDCstatus
 TSTS   R0, #BSY
 BNE    %BT30
 TSTS   R0, #SED :OR: DER :OR: ABN
 MOVNES PC, LR

 MOV    R0, #CPollingOn :SHL: 16
 STR    R0, HDCcommand
40
 LDR    R0, HDCstatus
 TSTS   R0, #BSY
 BNE    %BT40
 MOVS   PC, LR


; ===================
; WaitForSeekComplete
; ===================

; corrupts R0

WaitForSeekComplete ROUT
 MOV    R9, R14
WaitForSeekCompleteRTSViaR9
 [ Debug2
 mess   ,"*start wait for seek complete",NL
 ]
10
 LDR    R0, HDCstatus
 TSTS   R0, #SED :OR: DER :OR: ABN
 BEQ    %BT10
 TSTS   R0, #BSY
 BNE    %BT10
 [ Debug2
 mess   ,"*seek complete",NL
 ]
 MOVS   PC, R9


; These are parameters for the maximum number of heads and cylinders possible
SpecifyBlock
 = &C3 ; OM1 or C1 with AMEX = 0
 = &1F ; OM0 *** was 0F
 = &00 ; CUL overwritten if drive(s) present
 = &16 ; SL, step rate code or something *** was 16

 = (MaxCyls-1) :MOD: &100       ; NCL
 = (MaxCyls-1)/&100 + &3F:SHL:2 ; TO/NCH
 = 32 - 1                       ; NS
 = 8  - 1                       ; NH

 = &0A ; GPL1 *** was 0A ***                        *** Marv sez 06
 = &A9 ; SH/RL, step hi time/Record length = 256 bytes *** was A9
 = &0C ; GPL3 or 0C if 3 is always added *** was 0F *** Marv sez 09
 = &0D ; GPL2 or 0A if 3 is always added *** was 0D *** Marv sez 0C

 = &80 ; LCCL
 = &00 ; LCCH
 = &FF ; PCCL *** was FF *** Marv sez 00 for MiniScribe
 = &03 ; PCCH *** was 03 *** Marv sez 00 for MiniScribe

 ALIGN

Specify ROUT
 [ Debug2
 mess   ,"Specify",NL
 ]
 MOV    R9, LR
 ORR    R0, LR, #I_bit
 TEQP   PC, R0                  ;disable IRQs
 ASSERT InterruptBits = InterruptPtr + 4
 ADR    R0, InterruptPtr
 LDMIA  R0, {R0,R1}

 [ PodFix

 LDR    R4, = DefaultHDC
 TEQS   R4, HDC
 LDREQB R4, [R0]
 BICEQ  R4, R4, R1
 MOVNE  R4, #0

 |

 LDRB   R4, [R0]
 BIC    R4, R4, R1

 ]

 STRB   R4, [R0]
 TEQP   PC, LR                  ;restore IRQ state
 BL     GetResult               ;->/ R0, Z

 MOV    R0, #CAbort             ;to avoid write gate assert bug after specify
 BL     CommandHDC
05
 LDR    R0, HDCstatus
 TSTS   R0, #BSY
 BNE    %BT05

 baddr  R0, SpecifyBlock
 LDMIA  R0, {R1,R4,LR}
 sbaddr R0, parameters
 STMIA  R0, {R1,R4,LR}

; now insert the parms we were called with here
 ASSERT MaxWinnies=2
 TSTS   R2, #DiscBits           ;make CUL
 MOVEQ  R0, #2_0010             ;if drive 0
 MOVHI  R0, #2_0100             ;if any other drive
 STRHSB R0, parameters+2

 LDRB   R0, WHeads
 CMPS   R0, #8
 MOVHI  R0, #8
 TEQS   R6, #NIL                ;if not mount fill in parms
 SUBNE  R0, R0, #1
 STRNEB R0, parameters+7        ;heads
 LDRNEB R0, WSecsPerTrk
 SUBNE  R0, R0, #1
 STRNEB R0, parameters+6        ;sectors
 ADDNE  R0, R6, #ParkDiscAdd
 LDMNEDB R0,{R5,R7,R8}          ;misc hardware params
 MOVNE  R5, R5, LSR #24
 STRNEB R5, parameters+3        ;SL
 BICNE  R7, R7, #&0700          ;force sector size = 256
 ORRNE  R7, R7, #&0100
 STRNE  R7, parameters+8        ;GPL1, SH, GPL3, GPL2
 STRNE  R8, parameters+12       ;LCC, PCC
 MOV    R0, #&FF
 STRB   R0, SpecifiedWinnie
 MOV    R0, #CSpecify
 BL     CommandHDC              ;do the specify command corrupts R0,R1
 MOVNE  R0, R2, LSR #(32-3)     ;Unless mount update specified winnie
 STRNEB R0, SpecifiedWinnie
10
 LDR    R0, HDCstatus
 TST    R0, #BSY
 BNE    %BT10                   ; wait for not busy
 BL     GetResult               ;->/ R0, Z
 STRB   R0, completion
 MOVS   PC, R9                  ;exit R0 completion code

 LTORG

;************************************************************************
;*                                                                      *
;*             T H E   A C T U A L   E N T R Y   P O I N T              *
;*                                                                      *
;************************************************************************
WinnieDrivers ROUT
 [ Debug5
 SetBorder &F,0,0
 ]
 MOV    R0, #NormalEntry
 Push   "R0,R7-R11,LR"
 [ Debug6
 MOV    R0, #"("
 BL     TubeChar
 ]
 [ Debug2
 wrhex  R1
 wrhex  R2
 wrhex  R3
 wrhex  R4
 wrhex  R5
 wrhex  R6
 mess   ,"parms",NL
 ]

 LDR    HDC,HDCPtr
 [ Debug2
 wrhex  HDC
 mess   ,"*HDC",NL
 ]

 LDRB   R10,[R5, #Zones]
 LDR    R8, [R5, #DiscSize]
 LDR    R5, [R5]
 ASSERT SecsPerTrk=1
 ASSERT Heads=2
 ASSERT (:INDEX: WSecsPerTrk) :MOD: 4 = 1
 ASSERT WHeads=WSecsPerTrk+1
 STR    R5, WSecsPerTrk-1
 STRB   R10,WZones
 TSTS   R1, #ScatterBit
 ADDEQ  R5, SB, #:INDEX: WScatterRam
 STMEQIA R5,{R3,R4}
 STREQ  R4, WLength
 MOVNE  R5, R3
 ADR    R0, parms
 ASSERT opCode      = parms             ;R1
 ASSERT discAddress = opCode+4          ;R2
 ASSERT WRemains    = discAddress+4     ;R4
 ASSERT WScatter    = WRemains+4        ;R5
 ASSERT WDefectList = WScatter+8        ;R6
 ASSERT WDiscSize   = WDefectList+4     ;R8
 STMIA  R0!,{R1,R2,R4,R5}
 STMIB  R0, {R6,R8}
 LDRB   LR, SpecifiedWinnie
 TEQS   LR, R2, LSR #(32-3)     ;is correct winnie specified
 MOV    R0, #-1
 STR    R0, dsI         ;flag no defect skipping (yet)
 BEQ    %FT05
 BL     Specify         ;exit R0 completion code
 TEQS   R0, #0
 BNE    TransferEnd
05

; now deal with the defect skipping.
 LDRB   R0, opCode
 AND    R0, R0, #OpMask
 CMPS   R0, #3
 LDRCS  R1, WRemains
 BCS    %FT50           ;it's >= 3, so not Verify, read or write

 RSBS   R1, R0, #ReadSecsOp
 BHI    %FT08           ;verify
                        ;C set <=> read
 ADRCSL R1, BackgroundReadResume
 ADRCCL R1, BackgroundWriteResume
 STR    R1, Resume

 LDRB   R1, WinnieRamOp
 TEQS   R0, R1                          ;preserves C
 BEQ    %FT08
 MOV    R1, #&FF
 STRB   R1, WinnieRamOp

 ADRCSL R9, LowReadCodeStart
 ADRCCL R9, LowWriteCodeStart
 ADR    R10,LowCodeLocation
 ADDCS  LR, R10,#LowReadCodeSize
 ADDCC  LR, R10,#LowWriteCodeSize
07
 LDMIA  R9!, {R1-R8}
 STMIA  R10!,{R1-R8}
 CMPS   R10,LR
 BLO    %BT07
 STRB   R0, WinnieRamOp
08
 LDRB   R1, WZones
 TEQS   R1, #0          ;IF new format
 LDREQ  R1, WDefectList
 TSTEQS R1, #PsrMask    ;OR bad address
 LDRNE  R2, discAddress
 LDRNE  R3, WDiscSize
 BNE    %FT45           ;THEN no defect skipping

 MOV    R0, #0
DefectSkipLoopBack
; R0 = dsI, R1 = defectList
 LDR    R2, discAddress
 BIC    LR, R2, #DiscBits
10
 LDR    R3, [R1,R0]
 CMPS   LR, R3
 ADDHS  R0, R0, #4
 ADDHS  LR, LR, #&100   ; one blocksize (skip unit) in bytes
 BHS    %BT10           ; examine next entry
 AND    R2, R2, #DiscBits
 ORR    R2, R2, LR
 STR    R2, discAddress
 [ Debug2
 wrhex  R2
 mess   ,"disc address adjusted for defects",NL
 ]

;[ R1, R0 ] is the address of the first entry > discAddress
 STR    R0, dsI

45
 BIC    LR, R2, #DiscBits
 SUB    LR, R3, LR

 LDR    R1, opCode
 TSTS   R1, #BackgroundOp
 LDREQ  R1, WRemains
 MOVNE  R1, #&40000000

 CMPS   R1, LR
 MOVHI  R1, LR
50
 [ Debug2
 wrhex  R1
 mess   ,"Contig",NL
 ]
 ADD    R1, R2, R1
 STR    R1, ContigEnd
 LDRB   R0, WinnieRetries
 STRB   R0, WRetry

RetryEntryPoint ; where we come to try again!
 MOV    R0, #0
 STRB   R0, completion

 ADR    R0, OpcodeTable
 LDR    R1, opCode
 AND    R1, R1, #OpMask
 CMPS   R1, #OpcodeTableSize
 LDRCC  R1, [ R0, + R1, ASL #2 ] ; take the case if in range
 ADRCCL R0, StartOfTheWholeThing
 ADDCC  PC, R0, R1

 CMPS   R1, #SpecifyOp  ; initialise case?
 BLEQ   Specify
 MOVNE  R0, #BadParmsErr
 STRNEB R0, completion
                        ;fall through to ContigEnded

ContigEnded

;Exodus
 LDRB   R0, completion
 CMPS   R0, #0
 BNE    TransferEnd     ;if there's an error status, don't carry on!
 LDR    R0, dsI
 CMPS   R0, #-1
 BEQ    TransferEnd     ;no defect skipping in progress
 LDR    R1, opCode
 TSTS   R1, #BackgroundOp
 BNE    %FT70

 LDR    R1, WRemains
 CMPS   R1, #0
 BEQ    TransferEnd
 B      %FT80

70
 MOV    R1, PC
 ORR    R9, R1, #I_bit
 TEQP   PC, R9
 LDR    R9, WScatter
 LDR    R2, [R9,#4]
 TEQS   R2, #0
 BEQ    TransferEnd     ;IRQs still disabled
 TEQP   PC, R1

80
 LDR    R1, WDefectList
; R0 = dsI, R1 -> defect list
 B DefectSkipLoopBack

TransferEnd
;DISABLE HDC IRQs
 MOV    R3, PC
 ORR    R4, R3, #I_bit
 TEQP   PC, R4                  ;disable IRQs
 ASSERT InterruptBits = InterruptPtr + 4
 ADR    R0, InterruptPtr
 LDMIA  R0, {R0,R1}

 [ PodFix

 LDR    R2, = DefaultHDC
 TEQS   R2, HDC
 LDREQB R2, [R0]
 BICEQ  R2, R2, R1
 MOVNE  R2, #0

 |

 LDRB   R2, [R0]
 BIC    R2, R2, R1

 ]

 STRB   R2, [R0]
 TEQP   PC, R3                  ;restore IRQ state
;TURN LIGHTS OFF BY SELECTING DRIVE 0 WHICH DOESN'T EXIST
 MOV    R0, #0
 STR    R0, parameters
; STR    R0, parameters+4
; STR    R0, parameters+8
; STR    R0, parameters+12
 MOV    R0, #CCheckDrive
 BL     CommandHDC
81
 LDR    R0, HDCstatus
 TSTS   R0, #BSY
 BNE    %BT81           ;wait for not busy, ignoring the resulting error status
 MOV    R8, #BackgroundOp       ;flag will be amending process block if one

BreakOffExit

 ADR    R0, parms
 ASSERT opCode      = parms             ;R1
 ASSERT discAddress = opCode+4          ;R2
 ASSERT WRemains    = discAddress+4     ;R4
 ASSERT WScatter    = WRemains+4        ;R5
 LDMIA  R0, {R1,R2,R4,R5}               ;get result parms
 LDR    R0, dsI
 CMPS   R0, #-1
;EQ no need to compensate returned disc address for defect skipping
 SUBNE  R2, R2, R0, ASL #(8-2)  ;multiples of 4 to those of 256
 MOV    R3, R5

 TSTS   R1, #ScatterBit
 BNE    %FT83

 TEQS   R4, #0
 TOGPSR Z_bit, R0
 LDRNE  R0, WLength
 TEQNES R0, #0
 LDRNE  R3, [R3, #-8]
 LDREQ  R3, [R3]
83

 LDRB   R0, completion          ;IF 0 < error <= MaxDiscErr alter error format
 SUBS   R5, R0, #0              ; also R5 is value for ProcessStatus
 MOVNE  R5, R3
 RSBHIS LR, R0, #MaxDiscErr+1
 MOVHI  R0, R0, LSL #24
 ORRHI  R0, R0, R2, LSR #8
 ORRHI  R0, R0, #DiscErrorBit
 EORHI  R0, R0, #4 :SHL: (29-8)

 TSTS   R1, R8                  ;update process block if background op and done
 BEQ    %FT86

 MOV    R7, R3                  ;loop to find start of scatter block
84
 LDR    LR, [R7, #8]!
 [ FixTBSAddrs
 CMN    LR, #ScatterListNegThresh
 BCC    %BT84
 |
 TEQS   LR, #0
 BPL    %BT84
 ]
 ADD    R7, R7, LR
 STMDB  R7, {R0,R5}     ;set ProcessError and ProcessStatus
                ;THIS ALLOWS RESTARTING SO CAN'T RELY ON WINNIE WORKSPACE
86
 TEQS   PC, PC, LSR #1          ;C=0/1 IRQ/SVC
 BCS    %FT90                   ;if in SVC mode
 [ Debug5
 SetBorder 8,8,8
 ]
 [ Debug6
 MOV    R0, #"]"
 BL     TubeChar
 ]

 TEQP   PC, #I_bit :OR: SVC_mode
 nop
 MOV    R0, LR
 MOV    R1, SB
 LDR    SB, FileCorePrivate
 MOV    LR, PC          ;set return link
 LDR    PC, [R1, #:INDEX: WinnieCallAfter]
 MOV    LR, R0          ;will return here
 TEQP   PC, #IRQ_mode :OR: I_bit
 nop
 Pull   $WinIrqRegs,,^

90
 LDRB   LR, EntryReason
 CMPS   LR, #NormalEntry
 BNE    TimerReturn
 TEQP   PC, #SVC_mode   ;reenable IRQs

 TEQS   R4, #0          ;IF position in transfer is now in background part
 ADDMI  R2, R2, R4      ;(only happens on write foreground part >0, background
 MOVMI  R4, #0          ;part = &100) then adjust to background start
                        ;impossible to adjust R3 and not useful anway
 BL     SetVOnR0
 ADD    SP, SP, #4      ;skip stacked entry reason
 [ Debug5
 SetBorder 0,0,0
 ]
 [ Debug6
 Push   "R0"
 MOV    R0, #")"
 BL     TubeChar
 Pull   "R0"
 ]
 Pull   "R7-R11,PC"     ;foreground return

OpcodeTable ROUT
 & VerifyCase     - StartOfTheWholeThing ; 0
 & ReadCase       - StartOfTheWholeThing ; 1
 & WriteCase      - StartOfTheWholeThing ; 2
 & ReadIdCase     - StartOfTheWholeThing ; 3
 & WriteTrackCase - StartOfTheWholeThing ; 4
 & SeekCase       - StartOfTheWholeThing ; 5
 & RestoreCase    - StartOfTheWholeThing ; 6
OpcodeTableEnd
OpcodeTableSize * (OpcodeTableEnd - OpcodeTable)/4
 ASSERT OpcodeTableSize = 7

;  Now various little routines for sharing among the main options

PrepareDriveBlockHeadCylinder ROUT
; exit: R0-R2,R9 corrupt
; R3: drive, R4: start block, R5: head, R6: cylinder
 MOV    R9, LR
 LDR    R2, discAddress
 MOV    R3, R2, LSR #29         ; get the drive number
 ADD    R3, R3, #1              ; so we start at 1, clients start at 0
 BIC    R2, R2, #DiscBits       ; blat the drive number
 MOV    R0, R2, LSR #8          ; block address
 LDRB   R1, WSecsPerTrk
 BL     Divide
 MOV    R4, R1                  ; remainder is start block
 LDRB   R1, WHeads
 BL     Divide
 MOV    R5, R1                  ; remainder is head number
 MOV    R6, R0                  ; result is cylinder number
 MOV    R0, #0
 STRB   R0, NextHead            ;to set pending seek
 [ Debug2
 wrhex  R3
 wrhex  R4
 wrhex  R5
 wrhex  R6
 mess   ,"PrepareDriveBlockHeadCylinder",NL
 ]
 MOVS   PC, R9


; =====================
; WritePrepareNextBlock
; =====================

WritePrepareNextBlock
 LDR    R1, WriteAdjust
 [ Debug2
 wrhex  R2
 wrhex  R1
 mess   ,"WritePrepareNextBlock",NL
 ]
 CMPS   R1, #&200
 ADDLO  R1, R1, R2
 STRLO  R1, WriteAdjust
 MOVLOS PC, LR
;fall through to PrepareForNextBlock


; ===================
; PrepareForNextBlock
; ===================

;entry R2 = transferred this block
;exit R0,R1,R3-R5 corrupt

PrepareForNextBlock ROUT
 [ Debug2
 wrhex  R2
 mess   ,"PrepareForNextBlock",NL
 ]
 ADR    R5, discAddress
 ASSERT WRemains = discAddress + 4

 LDMIA  R5, {R0,R3}
 ADD    R0, R0, R2
 SUB    R3, R3, R2
 STMIA  R5, {R0,R3}

 ORR    R5, LR, #I_bit  ;disable IRQs to prevent more pairs being added
 TEQP   PC, R5
 LDR    R5, WScatter
 LDMIA  R5, {R0,R1}
 SUBS   R4, R2, R1
 MOVLS  R3, R2
 MOVHI  R3, R1
 ADD    R0, R0, R3
 SUB    R1, R1, R3
 STMIA  R5!,{R0,R1}
 MOVLOS PC, LR

 BEQ    %FT70
 LDMIA  R5, {R0,R1}
 [ FixTBSAddrs
 CMN    R0, #ScatterListNegThresh
 ADDCS  R5, R5, R0
 LDMCSIA R5, {R0,R1}
 |
 TEQS   R0, #0
 ADDMI  R5, R5, R0
 LDMMIIA R5, {R0,R1}
 ]
 ADD    R0, R0, R4
 SUBS   R1, R1, R4
 STRNE  R5, WScatter
 STMIA  R5!,{R0,R1}
 MOVNES PC, LR

70
 LDR    R0, opCode
 ANDS   R0, R0, #BackgroundOp   ;if background op may need to loop back to
 LDRNE  R1, [R5]                ;start of scatter list
 TSTNES R1, #bit31
 ADDNE  R5, R5, R1
 STR    R5, WScatter
 TEQS   R0, #BackgroundOp       ;if background op 0 length marks end
 LDREQ  R1, [R5, #4]
 TEQEQS R1, #0
 MOVNES PC, LR
 BL     DoAbort                 ;->R0
 B      TransferEnd             ;IRQs still disabled


; =============
; TestContigEnd
; =============

;exit
; if more in this contiguous fragment returns R0 amount left, R1 corrupt
; otherwise jumps to ContigEnded

TestContigEnd ROUT
 LDR    R0, ContigEnd
 LDR    R1, discAddress
 SUBS   R0, R0, R1
 BEQ    ContigEnded
 LDR    R1, opCode
 TSTS   R1, #BackgroundOp
 MOVEQS PC, LR
                        ;IF BackgroundOp also check for 0 length pair
 ORR    R1, LR, #I_bit
 TEQP   PC, R1          ;disable IRQ to prevent more pairs being added
 LDR    R1, WScatter
 LDR    R1, [R1,#4]
 TEQS   R1, #0
 MOVNES PC, LR          ;if more return restoring IRQ state
 B      TransferEnd     ;leave IRQs disabled


; ==================
; PrepareForTransfer
; ==================

;entry
; R3 drive
; R4 block
; R5 head
; R6 cylinder

;exit R0-R2,R7,R9,R10 corrupt
;     R8 transfer length

PrepareForTransfer ROUT
 [ Debug2
 wrhex  R3
 wrhex  R4
 wrhex  R5
 wrhex  R6
 mess   ,"PrepareForTransfer",NL
 ]
 MOV    R9, LR
 BL     TestContigEnd           ;doesn't return if end ->R1 / R0
 [ Debug2
 wrhex  R0
 mess   ,"left",NL
 ]
 MOV    R2, #0
 STR    R2, WriteAdjust
 ADD    R2, R0, #255            ; bytes + 255 to round up
 MOV    R2, R2, LSR #8          ; get it into blocks
 BL     TestEscapeStatus        ;doesn't return if escape, ->R0

; R2: remaining blocks to xfer
 STR    R6, Cylinder
 LDRB   R7, NextHead
 RSBS   R7, R7, #0
 BMI    %FT10                   ;no seek needed if not back to head 0

 BL     StartSeek2              ;R3,R6->R0,R1

 LDR    R7, WRemains
 CMPS   R7, #0
 MOVLE  R0, #&FF                ;to prevent another seek
 STRLEB R0, NextHead

 STRLEB R4, WBlock
 STRLEB R5, WHead

 BLLE   BackgroundBreakOff

10
 TEQS   R5, #&FF
 LDRLEB R4, WBlock
 LDRLEB R5, WHead

 LDRB   R0, WSecsPerTrk
 LDRB   R8, WHeads
 SUB    R1, R0, R4      ;blocks left on this track (secTrk - block)
 BIC    R10,R5, #7
 ADD    R10,R10,#8
 ADD    R5, R5, #1
 SUB    R8, R8, R5
 MLA    R8, R0, R8, R1  ;blocks left on this cylinder
 SUB    LR, R10,R5
 SUB    R5, R5, #1
 MLA    LR, R0, LR, R1  ;blocks left to next 8 head boundary
 CMPS   R2, R8
 MOVHI  R2, R8          ;blocks = min (blocks left,blocks on cylinder)
 CMPS   R2, LR
 MOVHI  R2, LR          ;if cross 8 head boundary reduce transfer
 MOVLS  R10,#0          ;otherwise next head = 0
 STRB   R10,NextHead
; now set up the parameter block for either read or write data
 MOV    R0, R6, ASL #16         ;cylinder into upper halfword
 ORR    R0, R0, R3, ASL #8      ;insert US = drive number
 ORR    R0, R0, R5              ;insert PHA = head number MOD 8
 BIC    R0, R0, #&F8
 STR    R0, parameters

 MOV    R0, R2, ASL #16         ;block count into upper HW
 ORR    R0, R0, R5, ASL #8      ;LHA = head number
 ORR    R0, R0, R4              ;LSA = start block
 STR    R0, parameters + 4
 MOV    R8, R2, LSL #8          ;so it's available if needs be (in verify)!

 LDR    R0, =DefaultHDC
 ORR    R1, R9, #I_bit
 TEQP   PC, R1                  ;disable IRQs
 CMPS   R0, HDC                 ;IF EQ C=1

 AND    R0, R5, #8
 MOVEQ  R1, #HeadSelectBit3
 ASSERT HeadSelectBit3=bit7
 MOVEQ  R0, R0, LSL #4
 BLEQ   WrSharedLatch
 ASSERT InterruptBits=InterruptPtr+4
 ADRNE  R1, InterruptPtr
 LDMNEIA R1, {R1,R2}
 MOVNE  R0, R0, LSL #3
 STRNEB R0, HeadSelBit3Copy
 TEQNES PC, PC, LSR #1          ;C=0 <=> IRQ mode, preserves NE
 ORRCC  R0, R0, R2
 STRNEB R0, [R1]                ;head select 3 is bit 6 on podule
 TEQP   PC, R9                  ;reenable IRQs

 CMPS   R7, #0                  ;did we do a seek ?
 BGT    WaitForSeekCompleteRTSViaR9
 MOVS   PC, R9


; ==========
; WaitForReq
; ==========

WaitForReq ROUT
;exit R0 status, R1,R2 corrupt
 [ Debug2
 mess   ,"*start wait for request"
 ]
 ASSERT PollBits=PollPtr+4
 ADR    R1, PollPtr
 LDMIA  R1, {R1,R2}
50
 LDRB   R0, [R1]
 TSTS   R0, R2
 BEQ    %BT50
 LDR    R0, HDCstatus
 [ Debug2
 wrhex  R0
 mess   ," *done",NL
 ]
 MOVS   PC, LR


; ===================
; PrepareForNextChunk
; ===================

;exit R0 corrupt
;R3 drive
;R4 block
;R5 head
;R6 cylinder

PrepareForNextChunk ROUT
 MOV    R9, LR
 BL     GetResult       ;-> / R0,Z
 STRB   R0, completion
 BNE    WinnieError

 LDRB   R0, command
 TEQS   R0, #CSeek
 TEQNES R0, #CRestore
 LDRNEB R0, WinnieRetries
 STRNEB R0, WRetry
 LDR    R2, WriteAdjust
 TEQS   R2, #0
 BLNE   PrepareForNextBlock     ;R2 -> R0,R1,R3-R5


VerifyNextChunk         ;enter with return link in R9
 LDR    R3, discAddress
 MOV    R3, R3, LSR #29 ;drive
 ADD    R3, R3, #1
 MOV    R4, #0
 LDRB   R5, NextHead
 LDR    R6, Cylinder

 TEQS   R5, #0
 ADDEQ  R6, R6, #1      ;next cylinder if back to head 0
 [ Debug2
 wrhex  R3
 wrhex  R4
 wrhex  R5
 wrhex  R6
 mess   ,"<PrepareForNextChunk",NL
 ]
 MOVS   PC, R9


; ==================
; BackgroundBreakOff
; ==================

BackgroundBreakOff ROUT
 TEQS   PC, PC, LSR #1          ;C=0/1 IRQ/SVC
 [ Debug5
 SetBorder 8,8,8,CC
 ]
 [ Debug6
 MOVCC  R0, #"]"
 BLCC   TubeChar
 ]
 Pull   $WinIrqRegs,CC,^        ;If in IRQ mode
 [ Debug2
 mess   ,"BackgroundBreakOff",NL
 ]
 LDR    R2, opCode              ;IF background op
 TSTS   R2, #BackgroundOp
 MOVEQS PC, LR

 [ Debug6
 MOV    R0, #"b"
 BL     TubeChar
 ]
 TEQP   PC, #I_bit :OR: SVC_mode        ;disable IRQs to CPU
 ADD    R0, SB, #:INDEX: InterruptPtr   ;enable IRQs from HDC
 ASSERT InterruptBits=InterruptPtr+4
 LDMIA  R0, {R0,R1}
 LDR    R2, =DefaultHDC
 TEQS   R2, HDC

 LDREQB R2, [R0]
 LDRNEB R2, HeadSelBit3Copy
 ORR    R2, R2, R1
 [ Debug2
 wrhex  R0
 wrhex  R1
 wrhex  R2
 mess   ,"Enable HDC IRQ"
 ]
 STRB   R2, [R0]

 LDRB   R2, EntryReason
 CMPS   R2, #NormalEntry
 MOVEQ  R8, #0
 BEQ    BreakOffExit
 BNE    TimerReturn

; >>>>>>>>>
; WinnieIRQ
; >>>>>>>>>

WinnieIRQ ROUT          ;CAN CORRUPT R0-R3,R11,R12
 [ Debug5
 SetBorder 0,&F,0
 ]
 Push   "R4-R10,LR"
 [ Debug6
 MOV    R0, #"["
 BL     TubeChar
 ]
 LDR    HDC,HDCPtr
 LDR    R0, HDCstatus
 LDR    PC, Resume


WinnieError ROUT
 [ Debug5
 SetBorder &F,&F,&F
 ]
; R0 SSB>>2
 CMPS   R0, #&48 :SHR 2         ;&48 = SSB for corrected ECC
 LDR    R2, opCode
 AND    R2, R2, #OpMask         ; get the opcode
 BNE    %FT10                   ; on the compare with &48
 [ Debug2
 mess   ,"*Corrected ECC ",NL
 ]
 CMPS   R2, #ReadSecsOp         ; is it Read
 MOVEQ  R0, #0                  ; as we're about to carry on, but
 STREQB R0, completion          ; may have finished already

 [ WTEST
 LDREQ  R0, ECCTotal
 ADDEQ  R0, R0, #1
 STREQ  R0, ECCTotal
 ]
 BEQ    ReadCase        ;carry on where we left off if a corrected ECC
;if it drops through here we got error &48 while not reading!
;This should not happen!  But just in case we'll treat it like any error.
 [ Debug2
 mess   ,"*!!! while not reading !!!",NL
 ]
10
 [ WTEST
 LDR    LR, ErrorTotal
 ADD    LR, LR, #1
 STR    LR, ErrorTotal
 ]
; opcode 0-F in R2
 CMPS   R2, #ReadSecsOp         ;Read?
 CMPNES R2, #2                  ;or Write? are the only ones I'll retry.
 BNE    %FT90                   ;on the read or write comparison

 LDRB   R2, WRetry
 SUBS   R2, R2, #1
 STRB   R2, WRetry
 [ Debug6
 Tword  R2
 ]
 BMI    %FT90                   ;retrys exhausted - give up!
; here we'll do something clever to make the retrys more effective.
 LDR    R3, discAddress
 MOV    R3, R3, LSR #29 ;drive
 ADD    R3, R3, #1

 [ Debug2
 wrhex  R2
 mess   ,"*Retrying ",NL
 ]
 CMPS   R0, #&20 :SHR: 2
 CMPNES R0, #&28 :SHR: 2
 BEQ    %FT70                   ;if it's drive been not ready, always restore

 ANDS   R2, R2, #3
 BEQ    %FT70
 CMPS   R2, #3
 [ Debug6
 MOVEQ  R0, #"="
 MOVNE  R0, #"S"
 BL     TubeChar
 ]
 BEQ    RetryEntryPoint

 LDR    R6, Cylinder
 CMPS   R2, #1
 ADDNE  R0, R6, #5              ;a place to seek to
 SUBEQS R0, R6, #5
 MOVMI  R0, #0
 CMPS   R0, #MaxCyls
 MOVHS  R0, #MaxCyls
 SUBHS  R0, R0, #1
 BL     StartSeek1              ;R0,R3->R0,R1

 LDR    R1, WRemains
 CMPS   R1, #0
 BLGT   WaitForSeekComplete     ;->R0/
 BGT    RetryEntryPoint

 ADR    R2, %FT60
 STR    R2, Resume
 BL     BackgroundBreakOff      ;doesn't return

60
 LDR    R0, opCode
 ASSERT ReadSecsOp=1
 ASSERT WriteSecsOp=2
 TSTS   R0, #2
 ADREQ  R0, BackgroundReadResume
 [ Dev
 ADRNEL R0, BackgroundWriteResume
 |
 ADRNE  R0, BackgroundWriteResume
 ]
 STR    R0, Resume
 B      RetryEntryPoint

70
 MOV    R0, R3, ASL #8 ; drive number
 STR    R0, parameters
 MOV    R8, #2
 STRB   R8, RestoreCount
80
 BL     TestEscapeStatus
81
 [ Debug6
 MOV    R0, #"R"
 BL     TubeChar
 ]
 MOV    R0, #CRestore
 BL     CommandHDC
 LDR    R1, WRemains
 CMPS   R1, #0
 ADRLE  R2, %FT82
 STRLE  R2, Resume
 BLLE   BackgroundBreakOff      ;doesn't return
 BL     WaitForSeekComplete
82
 BL     GetResult               ;-> / R0,Z
 LDRB   R8, RestoreCount
 [ Debug2
 wrhex  R0
 ]

 SUBEQS R8, R8, #1
 [ Debug6
 MOV    R0, #"r"
 BL     TubeChar
 Tword  R8
 ]
 STRB   R8, RestoreCount
 BEQ    %BT60

 LDR    R0, WRemains
 CMPS   R0, #0
 BGT    %FT86

 MOV    R0, #CRecall :SHL: 16   ;clears interrupt
 BL     CommandHDC              ;(R0->R0,R1)

 MOV    R0, #25                 ;call back after 1/4s
 ADR    R1, %FT85
 MOV    R2, SB

 MOV    R3, PC                  ;go to SVC mode to do SWI
 ASSERT SVC_mode=3
 ORR    LR, R3, #SVC_mode
 TEQP   PC, LR
 nop
 Push   "LR"
 SWI    XOS_CallAfter
 Pull   "LR"
 BICVC  R3, R3, #V_bit
 ORRVS  R3, R3, #V_bit
 TEQP   PC, R3
 nop

 BVS    %FT86
 TEQS   PC, PC, LSR #1          ;C=0/1 IRQ/SVC
 [ Debug5
 SetBorder 8,8,8,CC
 ]
 [ Debug6
 MOVCC  R0, #"]"
 BLCC   TubeChar
 ]
 Pull   $WinIrqRegs,CC,^        ;If in IRQ mode

;fall through to TimerReturn

TimerReturn
 ADD    SP, SP, #4      ;skip stacked entry reason
 [ Debug6
 MOV    R0, #"}"
 BL     TubeChar
 ]
 Pull   "R0-R11,LR"
 TEQP   PC, #IRQ_mode :OR: I_bit
 nop
 [ Debug5
 SetBorder 0,0,0
 ]
 Pull   "PC",,^

85
 [ Debug5
 SetBorder 0,0,&F
 ]
 Push   "LR"
 TEQP   PC, #I_bit :OR: SVC_mode
 nop
 Push   "R0-R11,LR"
 [ Debug6
 MOV    R0, #"{"
 BL     TubeChar
 ]
 MOV    R0, #TimerEntry
 Push   "R0"
 LDR    HDC,HDCPtr
 B      %BT81

86
 MOV    R0, #&80000 ;1/2 million
88
 SUBS   R0, R0, #1  ;s + (2s+n) = 5s, * 512k = 2.5M at 8MHz = 5/16 Second delay
 BPL    %BT88
 B      %BT80

90
 [ Debug2
 mess   ,"*Error!",NL
 ]
 B      TransferEnd


;**********   R E A D   C A S E   **********
ReadCase ROUT ; 1 - read data into store
 BL     PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6
 B      %FT10

05
 BL     PrepareForNextChunk     ;->R0 / R3-R6 if not a data transfer
10
 BL     PrepareForTransfer      ;R3-R6 -> R0-R2,R7-R10 may break off
 MOV    R0, #CRead
 BL     CommandHDC
 B      %FT50                   ;skip here for speed

ReadLoopNext
 MOV    R2, #&100
45
 BL     PrepareForNextBlock     ;R2 -> R0,R1,R3-R5
; now poll the data xfer
50
 LDR    R7, WRemains
 CMPS   R7, #0
 BLLE   BackgroundBreakOff
 BL     WaitForReq              ;->R1,R2 / R0
BackgroundReadResume
 TSTS   R0, #CED :OR: SED :OR: DER :OR: ABN
 BNE    %BT05
 ASSERT WScatter=WRemains+4
 ADR    R0, WRemains
 LDMIA  R0, {R0,R1}
 [ Debug2
 wrhex  R1
 ]
 LDR    R1, [R1]
 ADR    R10,ReadLoopNext
 SUBS   R2, R0, #0
 CMPNES R0, #&100
 MOVCS  R9,     #&0000FF00
 ORRCS  R9, R9, #&00FF0000
 [ Debug2
 wrhex  R0
 wrhex  R1
 wrhex  R10,CS
 mess   CS,"WHOLE",NL
 ]
 ADRCS  PC, LowCodeLocation     ;same as BCS LowCodeLocation

 [ Debug2
 mess   ,"PARTIAL",NL
 ]
;read a fragment
 MOV    R3, #&100
60
 LDR    R4, HDCdataRead
 SUBS   R0, R0, #1
 STRPLB R4, [R1], #1
 MOV    R4, R4, LSR #8
 SUBS   R0, R0, #1
 STRPLB R4, [R1], #1
 SUBS   R3, R3, #2
 BGT    %BT60
 B      %BT45


; this lot will be relocated into RAM at LowCodeLocation
LowReadCodeStart ROUT
 MOVS   R2, R1, LSL #31         ;NE <=> bit 0, CS <=> bit 1
 BNE    Read256OddAddress
 BCS    Read256HalfWordAddress
Read256WordAddress ROUT
 MOV    R0, #256-4

 Align16 LowReadCodeStart
10                              ;DONT REORDER, ALIGNMENT MOD 16 TIME CRITICAL
 SUBS   R0, R0, #7*4
 LDR    R2, HDCdataRead
 LDR    LR, HDCdataRead
 AND    R2, R2, R9, LSR #8

 ORR    R2, R2, LR, LSL #16
 LDR    R3, HDCdataRead
 LDR    LR, HDCdataRead
 AND    R3, R3, R9, LSR #8

 ORR    R3, R3, LR, LSL #16
 LDR    R4, HDCdataRead
 LDR    LR, HDCdataRead
 AND    R4, R4, R9, LSR #8

 ORR    R4, R4, LR, LSL #16
 LDR    R5, HDCdataRead
 LDR    LR, HDCdataRead
 AND    R5, R5, R9, LSR #8

 ORR    R5, R5, LR, LSL #16
 LDR    R6, HDCdataRead
 LDR    LR, HDCdataRead
 AND    R6, R6, R9, LSR #8

 ORR    R6, R6, LR, LSL #16
 LDR    R7, HDCdataRead
 LDR    LR, HDCdataRead
 AND    R7, R7, R9, LSR #8

 ORR    R7, R7, LR, LSL #16
 LDR    R8, HDCdataRead
 LDR    LR, HDCdataRead
 AND    R8, R8, R9, LSR #8

 ORR    R8, R8, LR, LSL #16
 STMIA  R1!,{R2-R8}
 BGT    %BT10
 LDR    R8, HDCdataRead

 AND    R8, R8, R9, LSR #8
 LDREQ  LR, HDCdataRead         ;EQ <=> 4n
 ORREQ  R8, R8, LR, LSL #16
 STREQ  R8, [R1], #4
 MOVEQ  PC, R10

 STRB   R8, [R1],#1             ;here if 4n+2
 MOV    R8, R8, LSR #8
 STRB   R8, [R1],#1

 MOV    PC, R10

Read256HalfWordAddress
 LDR    R8, HDCdataRead
 STRB   R8, [R1],#1

 MOV    R8, R8, LSR #8
 STRB   R8, [R1],#1
 MOV    R0, #256-4-2
 B      %BT10


Read256OddAddress ROUT
 MOV    R0, #(256-4)/12
 MOV    R4, #&FF
 BCS    Read256at4Nplus3
; so here we know that the address is 4N + 1
 LDR    R8, HDCdataRead
 STRB   R8, [R1], #1
 MOV    R8, R8, LSR #8
 STRB   R8, [R1], #1
 BL     Read254odd
 MOV    PC, R10

Read256at4Nplus3 ROUT
; here we know the address is 4N + 3

 BL     Read254odd
 LDR    R8, HDCdataRead
 STRB   R8, [R1], #1
 MOV    R8, R8, LSR #8
 STRB   R8, [R1], #1
 MOV    PC, R10

Read254odd ROUT                 ;corrupts R0,R2,R5-R8,LR
 LDR    R8, HDCdataRead
 STRB   R8, [R1],#1
 AND    R5, R4, R8, LSR #8
 Align16 LowReadCodeStart
10                              ;DONT REORDER, ALIGNMENT MOD 16 TIME CRITICAL
 SUBS   R0, R0, #1              ;R5=next byte
 LDR    R2, HDCdataRead         ;xxxxBhBl
 LDR    R6, HDCdataRead         ;xxxxChCl
 AND    R2, R2, R9, LSR #8      ;0000BhBl

 ORR    R2, R2, R6, LSL #16     ;ChClBhBl
 LDR    R7, HDCdataRead         ;xxxxDhDl
 ORR    R6, R5, R2, LSL #8      ;ClBhBlAh
 LDR    R5, HDCdataRead         ;xxxxEhEl

 AND    R7, R9, R7, LSL #8      ;00DhDl00
 LDR    R8, HDCdataRead         ;xxxxFhFl
 ORR    R7, R7, R5, LSL #24     ;ElDhDl00
 ORR    R7, R7, R2, LSR #24     ;ElDhDlCh

 MOV    R5, R5, LSL #16         ;EhEl0000
 LDR    R2, HDCdataRead         ;xxxxGhGl
 AND    R8, R9, R8, LSL #8      ;00FhFl00
 ORR    R8, R8, R2, LSL #24     ;GlFhFl00

 ORR    R8, R8, R5, LSR #24     ;GlFhFlEh
 STMIA  R1!, {R6-R8}
 AND    R5, R4, R2, LSR #8      ;000000Gh
 BNE    %BT10

 STRB   R5, [R1],#1
 MOV    PC, LR

LowReadCodeEnd
LowReadCodeSize * LowReadCodeEnd - LowReadCodeStart

;**********   W R I T E   C A S E   **********
WriteCase ROUT ; 2 - write data to disc
 BL     PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6
 B      %FT10

05
 BL     PrepareForNextChunk     ;->R0 / R3-R6 if not a data transfer
10
 BL     PrepareForTransfer      ;R3-R6 -> R0-R2,R7,R9,R10 / R8 may break off

 LDR    LR, opCode
 TSTS   LR, #BackgroundOp
 BEQ    %FT40

 MOV    R0, PC                  ;disable IRQs to stop possible extension
 ORR    LR, R0, #I_bit
 TEQP   PC, LR

 MOV    R1, #0                  ;init total write left
 LDR    R2, WScatter
 MOV    R3, R2
 MOV    R4, #NIL                ;init start of block unknown
 B      %FT20

15
 ADD    R1, R1, LR
 CMPS   R1, R8
 BHS    %FT35
 TEQS   R3, R2
 BEQ    %FT22
20
 LDMIA  R3, {R5,LR}
 [ FixTBSAddrs
 CMN    R5, #ScatterListNegThresh
 ADDCS  R3, R3, R5
 ADDCS  R4, R3, #2*4
 BCS    %BT20
 |
 TEQS   R5, #0
 ADDMI  R3, R3, R5
 ADDMI  R4, R3, #2*4
 BMI    %BT20
 ]
 TEQS   LR, #0
 ADD    R3, R3, #2*4
 BNE    %BT15
22
 TEQS   R4, #NIL
 BNE    %FT30
25
 LDMIA  R3!,{R5,LR}
 [ FixTBSAddrs
 CMN    R5, #ScatterListNegThresh
 BCC    %BT25
 |
 TEQS   R5, #0
 BPL    %BT25
 ]
 ADD    R4, R3, R5
30
 [ Debug6
 Push   "R0"
 MOV    R0, #"W"
 BL     TubeChar
 Tword  R1
 Tword  R8
 Pull   "R0"
 ]
 MOV    LR, #bit31
 STR    LR, [R4, #-(2*4+4)]
 MOV    R1, R1, LSR #8
 STRB   R1, parameters+6
 MOV    R1, R1, LSR #8
 STRB   R1, parameters+7
35
 TEQP   PC, R0
40

 MOV    R0, #CWrite
 BL     CommandHDC
 B      %FT50

WriteLoopNext
 MOV    R2, #&100
45
 BL     WritePrepareNextBlock   ;R2 -> R0,R1,R3-R5
50
 LDR    R7, WRemains
 CMPS   R7, #0
 BLLE   BackgroundBreakOff
 BL     WaitForReq              ;->R1,R2 / R0
BackgroundWriteResume
 TSTS   R0, #CED :OR: SED :OR: DER :OR: ABN
 BNE    %BT05
 ASSERT WScatter=WRemains+4
 ASSERT WriteAdjust=WScatter+4
 ADR    R0, WRemains
 LDMIA  R0, {R2-R4}
 SUB    R2, R2, R4
55
 LDMIA  R3, {R1,R5}
 [ FixTBSAddrs
 CMN    R1, #ScatterListNegThresh
 ADDCS  R3, R3, R1
 BCS    %BT55
 |
 TEQS   R1, #0
 ADDMI  R3, R3, R1
 BMI    %BT55
 ]
 ADD    R1, R1, R4
 SUBS   R4, R4, R5
 ADDHS  R3, R3, #8
 BHS    %BT55

 ADR    R10,WriteLoopNext
 SUBS   R0, R2, #0
 CMPNES R0, #&100
 [ Debug2
 wrhex  R0
 wrhex  R1
 wrhex  R10,CS
 mess   CS,"WHOLE",NL
 ]
 ADRCS  PC, LowCodeLocation     ;same as BCS LowCodeLocation

 [ Debug2
 mess   ,"PARTIAL",NL
 ]
;else write a fragment
 MOV    R3, #&100
60
 SUBS   R0, R0, #1
 MOVMI  R4, #0
 LDRPLB R4, [R1], #1
 MOV    R4, R4, ASL #16
 SUBS   R0, R0, #1
 MOVMI  R8, #0
 LDRPLB R8, [R1], #1
 ORR    R4, R4, R8, ASL #24
 STR    R4, HDCdataWrite
 SUBS   R3, R3, #2
 BGT    %BT60
 B      %BT45


; this will all be copied down into RAM at LowCodeLocation
LowWriteCodeStart ROUT
 MOVS   R2, R1, LSL #31         ;NE <=> bit 0, CS <=> bit 1
 BNE    Write256OddAddress
 BCS    Write256HalfWordAddress

Write256WordAddress ROUT
 MOV    R0, #256-4

 Align16 LowWriteCodeStart
10                              ;DONT REORDER, ALIGNMENT MOD 16 TIME CRITICAL
 SUBS   R0, R0, #7*4

 LDMIA  R1!,{R2-R8}
 MOV    R9, R2, LSL #16
 STR    R9, HDCdataWrite

 MOV    R9, R3, LSL #16
 STR    R2, HDCdataWrite
 STR    R9, HDCdataWrite
 STR    R3, HDCdataWrite

 MOV    R9, R4, LSL #16
 STR    R9, HDCdataWrite
 STR    R4, HDCdataWrite
 MOV    R9, R5, LSL #16

 MOV    LR, R6, LSL #16
 STR    R9, HDCdataWrite
 STR    R5, HDCdataWrite
 STR    LR, HDCdataWrite

 MOV    R9, R7, LSL #16
 STR    R6, HDCdataWrite
 STR    R9, HDCdataWrite
 STR    R7, HDCdataWrite

 MOV    R9, R8, LSL #16
 STR    R9, HDCdataWrite
 STR    R8, HDCdataWrite
 BGT    %BT10

 LDR    R7, [R1], #4
 MOV    R2, R7, LSL #16
 STR    R2, HDCdataWrite
 STREQ  R7, HDCdataWrite        ;EQ <=> 4n

 MOVEQ  PC, R10
 SUB    R1, R1, #2
 MOV    PC, R10

Write256HalfWordAddress
 BIC    R1, R1, #3
 LDR    R2, [R1], #4
 STR    R2, HDCdataWrite ; store the odd halfword at the start

 MOV    R0, #256-4-2
 B      %BT10

Write256OddAddress ROUT
 BCS    Write256at4Nplus3
; so here we know the address is 4N + 1
 BIC    R1, R1, #3
 LDR    R6, [R1],#4      ;3 odd start bytes
 MOV    R2, R6, LSL #8
 STR    R2, HDCdataWrite
 MOV    R6, R6, LSR #8    ;odd byte in top half R6
 BL     Write252odd
 LDRB   R7, [R1], #1      ;get the odd byte at the end
 ORR    R2, R6, R7, LSL #24
 STR    R2, HDCdataWrite
 MOV    PC, R10

Write256at4Nplus3 ROUT
 LDRB   R6, [R1],#1     ; get the first odd byte
 MOV    R6, R6, ASL #16
 BL     Write252odd
 LDR    R7, [R1],#3
 ORR    R2, R6, R7, LSL #24
 STR    R2, HDCdataWrite
 MOV    R2, R7, LSL #8
 STR    R2, HDCdataWrite
 MOV    PC, R10

Write252odd     ROUT            ;entry/exit next byte in top half R6
 MOV    R0, #(256-4)/12

 Align16 LowWriteCodeStart
10                              ;DONT REORDER, ALIGNMENT MOD 16 TIME CRITICAL
 SUBS   R0, R0, #1
 LDMIA  R1!,{R7-R9}
 ORR    R2, R6, R7, LSL #24
 STR    R2, HDCdataWrite

 MOV    R2, R7, LSL #8
 STR    R2, HDCdataWrite
 MOV    R7, R7, LSR #8
 ORR    R2, R7, R8, LSL #24

 MOV    R6, R8, LSL #8
 STR    R2, HDCdataWrite
 STR    R6, HDCdataWrite
 MOV    R8, R8, LSR #8

 ORR    R2, R8, R9, LSL #24
 STR    R2, HDCdataWrite
 MOV    R2, R9, LSL #8
 STR    R2, HDCdataWrite

 MOV    R6, R9, LSR #8
 BNE    %BT10
 MOV    PC, LR

LowWriteCodeEnd
LowWriteCodeSize * LowWriteCodeEnd - LowWriteCodeStart

 ! 0, "Read code " :CC: :STR: LowReadCodeSize
 ! 0, "Write code " :CC: :STR: LowWriteCodeSize

 [ LowWriteCodeSize > LowReadCodeSize
LowCodeSize     * LowWriteCodeSize
 |
LowCodeSize     * LowReadCodeSize
 ]
;Claim multiple of 8 words for low code as moved 8 words at a time
 [ LowCodeSize :MOD: (8*4) = 0
WorkSize * LowCodeLocation+LowCodeSize
 |
WorkSize * LowCodeLocation+LowCodeSize+8*4-(LowCodeSize :MOD: (8*4))
 ]


SeekCase         ROUT ; 5 - seek for some reason
 BL     PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6

 BL     StartSeek2              ;R3,R6 -> R0,R1
 BL     WaitForSeekComplete
 B      TransferEnd


RestoreCase      ROUT ; 6 - restore to track zero
 BL     PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6

 MOV    R0, R3, ASL #8
 STR    R0, parameters
 MOV    R8, #2
 MOV    R7, #30*4       ;retry for 30s
10
 BL     TestEscapeStatus
 MOV    R0, #CRestore
 BL     CommandHDC
 BL     WaitForSeekComplete
 BL     GetResult       ;-> / R0,Z

 [ Debug2
 wrhex  R0
 ]

 SUBEQS R8, R8, #1
 BEQ    TransferEnd
 MOV    LR, #&80000     ; 1/2 million
20
 SUBS   LR, LR, #1      ;s+(s+n)=4s, * 512k = 2M at 8MHz = 1/4 Second delay
 BPL    %B20
 SUBS   R7, R7, #1      ;count a retry
 BNE    %BT10           ;loop if more retries
 MOV    R0, R0, LSR #2
 B      TransferEnd


VerifyCase ROUT
 BL     PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6
10
 BL     PrepareForTransfer      ;R3-R6 -> R0-R2,R7,R9,R10 / R8=blocks to verify
 MOV    R0, #CCheckData
 BL     CommandHDC

50
 BL     WaitForReq
 BL     GetResult               ;-> / R0,Z
 STRB   R0, completion
 LDR    R3, ContigEnd
 LDR    R2, discAddress
 SUB    R3, R3, R2
 MOV    R2, R8                  ;bytes to verify
 BNE    %FT90                   ;if error

 CMPS   R2, R3
 MOVHI  R2, R3
 BL     PrepareForNextBlock     ;R2 -> R0,R1,R3-R5 / LR
 SUB    R9, LR, #.-%BT10        ;set link for return to 10
 B      VerifyNextChunk         ;-> / R3-R6

90
;Set LS <=> error decrements sector count for error sector ie
;&40 Data field ECC error
;&44 Data field CRC error
;&48 Corrected ECC
;&4C Data field fatal error
;&60 No data address mark

 CMPS   R0, #&4C :SHR: 2
 RSBLSS LR, R0, #&40 :SHR: 2
 TEQHIS R0, #&60 :SHR: 2

 LDR    R1, HDCresult
 LDR    R1, HDCresult
 LDR    R1, HDCresult
 LDR    R1, HDCresult           ;result sector count
 BIC    R1, R1, #&00FF0000
 BIC    R1, R1, #&FF000000

 ADDLS  R1, R1, #1              ;adjust if error sector counted
 SUB    R2, R2, R1, LSL #8      ;bytes verified
 CMPS   R2, R3
 MOVHI  R2, R3
 BL     PrepareForNextBlock     ;R2 -> R0,R1,R3-R5
 LDRB   R0, completion
 B      WinnieError


WriteTrackCase   ROUT ; 4 - format a track
 BL     PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6
 BL     PrepareForTransfer              ;R3-R6 -> R0-R2,R7-R10
 LDRB   R0, WSecsPerTrk                 ;number of blocks to format
 AND    R5, R5, #2_111
 ORR    R0, R5, R0, ASL #16
 ORR    R0, R0, R3, ASL #8
 STR    R0, parameters

 MOV    R0, #CFormat
 BL     CommandHDC

; now poll the data xfer - hopefully only two "blocks"
50
 BL     WaitForReq
 TSTS   R0, #CED
 BLNE   PrepareForNextChunk     ;->R0 / R3-R6 if not a data transfer
 BNE    TransferEnd             ; as there's never a next cylinder

 ASSERT WriteAdjust=WScatter+4
 ADR    R0, WScatter
 LDMIA  R0, {R3,R4}
55
 LDMIA  R3, {R1,R5}
 ADD    R1, R1, R4
 SUBS   R4, R4, R5
 BHS    %BT55

 [ Debug2
 wrhex  R1
 mess   ,"RAM",NL
 ]

 MOV    R0, #256
 MOV    R2, R0
90
 LDRB   R8, [R1], #1
 LDRB   R9, [R1], #1
 ORR    R8, R8, R9, ASL #8
 MOV    R8, R8, ASL #16
 STR    R8, HDCdataWrite
 SUBS   R0, R0, #2
 BGT    %BT90

 BL     WritePrepareNextBlock     ;R2 -> R0,R1,R3-R5
 B      %BT50

ReadIdCase ROUT
 BL     PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6
 BL     PrepareForTransfer              ;R3-R6 -> R0-R2,R7-R10
 LDRB   R0, WSecsPerTrk                 ; number of blocks to read
 STR    R0, parameters + 4
 AND    R5, R5, #2_111
 ORR    R0, R5, R3, ASL #8
 STR    R0, parameters ; US/PHA

 MOV    R0, #CReadId
 BL     CommandHDC

; now poll the data xfer - hopefully only two "blocks" if that.
50
 BL     WaitForReq
 TSTS   R0, #CED
 BLNE   PrepareForNextChunk     ;->R0 / R3-R6 if not a data transfer
 BNE    TransferEnd             ; as there's never a next cylinder

 LDR    R1, WScatter
 LDR    R1, [R1]
 MOV    R0, #256
 MOV    R2, R0
90
 LDR    R9, HDCdataRead
 STRB   R9, [R1], #1
 MOV    R9, R9, LSR #8
 STRB   R9, [R1], #1
 SUBS   R0, R0, #2
 BGT    %BT90

 BL     PrepareForNextBlock     ;R2 -> R0,R1,R3-R5
 B      %BT50

 LTORG

; ===============
; ClaimWinnieIRQs
; ===============

ClaimWinnieIRQs ROUT
 Push   "R0-R4,LR"
 LDRB   R0, Winnies
 TEQS   R0, #0
 BEQ    %FT90
 LDR    R0, HDCPtr
 LDR    LR, =DefaultHDC
 TEQS   R0, LR
 TEQNEP PC, #I_bit :OR: SVC_mode        ;preserves NE
 MOVNE  R0, #IOC
 LDRNEB LR, [R0, #IOCIRQMSKB]
 ORRNE  LR, LR, #podule_IRQ_bit
 STRNEB LR, [R0, #IOCIRQMSKB]
 MOVEQ  R0, #WinnieIRQ_DevNo
 MOVNE  R0, #Podule_DevNo
 baddr  R1, WinnieIRQ
 MOV    R2, SB
 [ fix_1
 LDRNE  R3, PollPtr
 MOVNE  R4, #WinPodIRQrequest
 |
 ADDNE  R3, SB, #:INDEX: PollPtr
 ASSERT PollBits = PollPtr + 4
 LDMNEIA R3, {R3,R4}
 ]
 [ Debug2
 wrhex  R0
 wrhex  R1
 wrhex  R2
 wrhex  R3, NE
 wrhex  R4, NE
 ]
 SWI    XOS_ClaimDeviceVector
 [ Debug2
 wrhex  R0,VS
 mess   ,"Claim IRQ",NL
 ]
 MOVVS  R0, #0
90
 STRB   R0, WinIRQ
 Pull   "R0-R4,PC",,^


; =================
; ReleaseWinnieIRQs
; =================

ReleaseWinnieIRQs ROUT
 Push   "R0-R4,LR"
 LDRB   R0, WinIRQ
 ASSERT Podule_DevNo > WinnieIRQ_DevNo
 CMPS   R0, #WinnieIRQ_DevNo
 baddr  R1, WinnieIRQ
 MOV    R2, SB
 [ fix_1
 LDRHI  R3, PollPtr
 MOVHI  R4, #WinPodIRQrequest
 |
 ADDHI  R3, SB, #:INDEX: PollPtr
 ASSERT PollBits = PollPtr + 4
 LDMHIIA R3, {R3,R4}
 ]
 [ Debug2
 wrhex  R0, HS
 wrhex  R1, HS
 wrhex  R2, HS
 wrhex  R3, HI
 wrhex  R4, HI
 mess   HS, "release IRQ",NL
 ]
 SWIHS  XOS_ReleaseDeviceVector
 MOV    R0, #0
 STRB   R0, WinIRQ
 Pull   "R0-R4,PC",,^

 END
