; Copyright 2000 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetCPU
        $GetIO
        $GetMEMC
        $GetMEMM
        $GetVIDC

                GBLL    CheckProtectionLink     ; if true, disallow CMOS RAM changes if link in protected position
CheckProtectionLink SETL (IO_Type = "IOMD") :LAND: {TRUE}       ; NB affects Delete/Copy/R/T and 0-9/.

        GET     Hdr:Proc
        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS



                GBLL    VCOstartfix
VCOstartfix     SETL    {TRUE}

        GBLL    A7000
A7000   SETL    {TRUE} ; Should be replaced with auto-detect ASAP

                GBLL    RO371Timings
RO371Timings    SETL    :LNOT: STB

                GBLL    IgnoreVRAM
IgnoreVRAM      SETL    {FALSE}

VideoPhysRam *  &02000000               ; Amazing - it's in the same place!
DRAM0PhysRam *  &10000000               ; 4 DRAM banks
DRAM1PhysRam *  &14000000
DRAM2PhysRam *  &18000000
DRAM3PhysRam *  &1C000000
DRAMBaseAddressMask * &1C000000         ; used to mask off bits after stealing video RAM
SAMLength *     512*4                   ; SAM length in bytes for 1 bank of VRAM

; This version assumes a RISC OS image starting 64K after us.

        AREA    |!!!ROMStart|, CODE, READONLY, PIC

        ENTRY

HAL_Base

vectors
;	B	start
        LDR     pc, ResetInd            ; Reset
        LDR     pc, HaltInd             ; Undefined instruction
        LDR     pc, HaltInd             ; SWI
        LDR     pc, HaltInd             ; Prefetch abort
        LDR     pc, HaltInd             ; Data abort
        LDR     pc, HaltInd             ; (Address exception)
        LDR     pc, HaltInd             ; IRQ
        LDR     pc, HaltInd             ; FIQ

; The above 8 instructions will operate as expected in 32-bit ROM mode,
; or in 16-bit ROM mode with a 16-bit ROM used.  In 16-bit ROM mode, and
; with 32-bit wide ROMs in use, they will instead be intepreted as 4
; NV-condition instructions (exact meaning not determined and should be
; irrelevant) which should do nothing and so allow control to drop
; through to this point, still in 16-bit mode.  Force IOMD into 32-bit
; ROM mode for bank 0.  The following instruction sequence has been
; produced in 16-in-32 form by extracting hex values from a listing...

        DCD     &0000B632, &0000E3A0    ; 20: MOV R11, #IO+IOMDREGS - point at IOMD
        DCD     &00000000, &0000E3A0    ; 28: MOV R0, #&0 - ROMCR:32b,slow,218.75us,no burst
        DCD     &00000080, &0000E5CB    ; 30: STRB R0,[R11,#ROMCR0] - switch mode
        DCD     &0000F000, &0000E3A0    ; 38: MOV PC, #0 - jump to 0 (this instr pre-fetched)

ResetInd
        DCD     start - HAL_Base
HaltInd
        DCD     halt - HAL_Base

halt    B       halt

        ASSERT  . - HAL_Base < 0x60
        %       0x60 - (. - HAL_Base)
ROMsize
        DCD     0                       ; patched in by build system

HALdescriptor   DATA
        DCD     0
        DCD     HAL_Base - HALdescriptor
        DCD     64*1024
        DCD     HAL_EntryTable - HALdescriptor
        DCD     HAL_Entries
        DCD     HAL_WsSize

        MACRO
        HALEntry $name
        ASSERT  (. - HAL_EntryTable) / 4 = EntryNo_$name
        DCD     $name - HAL_EntryTable
        MEND

        MACRO
        NullEntry
        DCD     HAL_Null - HAL_EntryTable
        MEND

        IMPORT   Video_init

        IMPORT   HAL_IRQEnable
        IMPORT   HAL_IRQDisable
        IMPORT   HAL_IRQClear
        IMPORT   HAL_IRQSource
        IMPORT   HAL_IRQStatus
        IMPORT   HAL_FIQEnable
        IMPORT   HAL_FIQDisable
        IMPORT   HAL_FIQDisableAll
        IMPORT   HAL_FIQClear
        IMPORT   HAL_FIQSource
        IMPORT   HAL_FIQStatus

        IMPORT   HAL_Timers
        IMPORT   HAL_TimerDevice
        IMPORT   HAL_TimerGranularity
        IMPORT   HAL_TimerMaxPeriod
        IMPORT   HAL_TimerSetPeriod
        IMPORT   HAL_TimerPeriod
        IMPORT   HAL_TimerReadCountdown

        IMPORT   HAL_CounterRate
        IMPORT   HAL_CounterPeriod
        IMPORT   HAL_CounterRead
        IMPORT   HAL_CounterDelay

        IMPORT   HAL_IICBuses
        IMPORT   HAL_IICType
        IMPORT   HAL_IICSetLines
        IMPORT   HAL_IICReadLines

        IMPORT   HAL_NVMemoryType
        IMPORT   HAL_NVMemorySize
        IMPORT   HAL_NVMemoryPageSize
        IMPORT   HAL_NVMemoryProtectedSize
        IMPORT   HAL_NVMemoryProtection
        IMPORT   HAL_NVMemoryIICAddress
        IMPORT   HAL_NVMemoryRead
        IMPORT   HAL_NVMemoryWrite

        IMPORT   HAL_VideoFlybackDevice
        IMPORT   HAL_Video_SetMode
        IMPORT   HAL_Video_WritePaletteEntry
        IMPORT   HAL_Video_WritePaletteEntries
        IMPORT   HAL_Video_ReadPaletteEntry
        IMPORT   HAL_Video_SetInterlace
        IMPORT   HAL_Video_SetBlank
        IMPORT   HAL_Video_SetPowerSave
        IMPORT   HAL_Video_UpdatePointer
        IMPORT   HAL_Video_SetDAG
        IMPORT   HAL_Video_VetMode
        IMPORT   HAL_Video_PixelFormats
        IMPORT   HAL_Video_Features
        IMPORT   HAL_Video_BufferAlignment
        IMPORT   HAL_Video_OutputFormat

	IMPORT   HAL_ATAControllerInfo
	IMPORT   HAL_ATASetModes
	IMPORT   HAL_ATACableID
        ;IMPORT   HAL_MatrixColumns
        ;IMPORT   HAL_MatrixScan

        IMPORT   HAL_MachineID

HAL_EntryTable  DATA
        HALEntry HAL_Init

        HALEntry HAL_IRQEnable
        HALEntry HAL_IRQDisable
        HALEntry HAL_IRQClear
        HALEntry HAL_IRQSource
        HALEntry HAL_IRQStatus
        HALEntry HAL_FIQEnable
        HALEntry HAL_FIQDisable
        HALEntry HAL_FIQDisableAll
        HALEntry HAL_FIQClear
        HALEntry HAL_FIQSource
        HALEntry HAL_FIQStatus

        HALEntry HAL_Timers
        HALEntry HAL_TimerDevice
        HALEntry HAL_TimerGranularity
        HALEntry HAL_TimerMaxPeriod
        HALEntry HAL_TimerSetPeriod
        HALEntry HAL_TimerPeriod
        HALEntry HAL_TimerReadCountdown

        HALEntry HAL_CounterRate
        HALEntry HAL_CounterPeriod
        HALEntry HAL_CounterRead
        HALEntry HAL_CounterDelay

        HALEntry HAL_NVMemoryType
        HALEntry HAL_NVMemorySize
        HALEntry HAL_NVMemoryPageSize
        HALEntry HAL_NVMemoryProtectedSize
        HALEntry HAL_NVMemoryProtection
        HALEntry HAL_NVMemoryIICAddress
        HALEntry HAL_NVMemoryRead
        HALEntry HAL_NVMemoryWrite

        HALEntry HAL_IICBuses
        HALEntry HAL_IICType
        HALEntry HAL_IICSetLines
        HALEntry HAL_IICReadLines
        NullEntry ;HAL_IICDevice
        NullEntry ;HAL_IICTransfer
        NullEntry ;HAL_IICMonitorTransfer

        HALEntry HAL_VideoFlybackDevice
        HALEntry HAL_Video_SetMode
        HALEntry HAL_Video_WritePaletteEntry
        HALEntry HAL_Video_WritePaletteEntries
        HALEntry HAL_Video_ReadPaletteEntry
        HALEntry HAL_Video_SetInterlace
        HALEntry HAL_Video_SetBlank
        HALEntry HAL_Video_SetPowerSave
        HALEntry HAL_Video_UpdatePointer
        HALEntry HAL_Video_SetDAG
        HALEntry HAL_Video_VetMode
        HALEntry HAL_Video_PixelFormats
        HALEntry HAL_Video_Features
        HALEntry HAL_Video_BufferAlignment
        HALEntry HAL_Video_OutputFormat

        NullEntry ;HAL_MatrixColumns
        NullEntry ;HAL_MatrixScan

        NullEntry ;HAL_TouchscreenType
        NullEntry ;HAL_Touchscreenread
        NullEntry ;HAL_Touchscreenread
        NullEntry ;HAL_Touchscreenread

        HALEntry HAL_MachineID

        HALEntry HAL_ControllerAddress
        HALEntry HAL_HardwareInfo
        HALEntry HAL_SuperIOInfo
        HALEntry HAL_PlatformInfo
        HALEntry HAL_CleanerSpace

        NullEntry ;HAL_UARTPorts
        NullEntry ;HAL_UARTStartUp
        NullEntry ;HAL_UARTShutdown
        NullEntry ;HAL_UARTFeatures
        NullEntry ;HAL_UARTReceiveByte
        NullEntry ;HAL_UARTTransmitByte
        NullEntry ;HAL_UARTLineStatus
        NullEntry ;HAL_UARTInterruptEnable
        NullEntry ;HAL_UARTRate
        NullEntry ;HAL_UARTFormat
        NullEntry ;HAL_UARTFIFOSize
        NullEntry ;HAL_UARTFIFOClear
        NullEntry ;HAL_UARTFIFOEnable
        NullEntry ;HAL_UARTFIFOThreshold
        NullEntry ;HAL_UARTInterruptID
        NullEntry ;HAL_UARTBreak
        NullEntry ;HAL_UARTModemControl
        NullEntry ;HAL_UARTModemStatus
        NullEntry ;HAL_UARTDevice

        NullEntry ;HAL_Reset
        NullEntry ;HAL_DebugRX
        NullEntry ;HAL_DebugTX

        NullEntry ;HAL_PCIFeatures
        NullEntry ;HAL_PCIReadConfigByte
        NullEntry ;HAL_PCIReadConfigHalfword
        NullEntry ;HAL_PCIReadConfigWord
        NullEntry ;HAL_PCIWriteConfigByte
        NullEntry ;HAL_PCIWriteConfigHalfword
        NullEntry ;HAL_PCIWriteConfigWord
        NullEntry ;HAL_PCISpecialCycle
        NullEntry ;HAL_PCISlotTable
        NullEntry ;HAL_PCIAddresses

        HALEntry HAL_ATAControllerInfo
        HALEntry HAL_ATASetModes
        HALEntry HAL_ATACableID

        NullEntry ;HAL_InitDevices

        HALEntry HAL_KbdScanSetup
        HALEntry HAL_KbdScan
        HALEntry HAL_KbdScanFinish
        HALEntry HAL_KbdScanInterrupt

HAL_Entries     * (.-HAL_EntryTable)/4

; R11 is used as pointer to RISC OS entry table throughout pre-MMU stage.
        MACRO
        CallOSM $entry, $reg
        LDR     ip, [v8, #$entry*4]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND

        MACRO
        CallOS  $entry
        ASSERT  $entry <= HighestOSEntry
        MOV     lr, pc
        LDR     pc, OSentries + 4*$entry
        MEND


start
        ADRL    R5, HAL_Base + 64*1024          ; R5 -> RISC OS image

        LDR     R11, [R5, #OSHdr_Entries]
        ADD     R11, R11, R5                    ; R11 -> RISC OS entry table

        MOV     R0, #0
        CallOSM OS_InitARM

  ;      LDR     R13, =&10001000

        MOV     r12, #IOMD_Base

; Perform a dummy write to IOMD (some harmless register) to get it out of ROM force mode.
; Reads from IOMD will return garbage before this has happened. If we're actually running out
; of 32-bit wide ROMs on MORRIS, a write will already have happened, to get ROMCR0 from
; 16 to 32-bit wide mode, but we can't yet determine for sure (by reading it back), so do it
; anyway.

        STRB    r12, [r12, #IOMD_DMAREQ]              ; writes to DMAREQ are ignored

        LDRB    r2,[r12,#IOMD_ID1]      ; load r2 with IOMD ID high byte
        LDRB    r0,[r12,#IOMD_ID0]      ; load r0 with IOMD ID low byte
        ORR     r0,r0,r2, LSL #8        ; Or r0 and r2 - shifted left 8, put in r0
        LDR     r2,=IOMD_7500           ; get Ref IOMD ID code for IOMD in a 7500
        CMPS    r0,r2                   ; check for IOMD ID Code for IOMD in a 7500
        BEQ     init7500cpu             ; If equal, got to init7500cpu

        LDRNE   r2,=IOMD_7500FE         ; If not, get ID code for IOMD in a 7500FE
        CMPNES  r0,r2                   ; If not, check for IOMD ID Code for IOMD in a 7500FE
        BNE     MedusaInit              ; NOT MORRIS assume Medusa hardware


init7500FEcpu
; Here bceause its an ARM7500 'FE' variant
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-

;       CPUCLK divide by 1
;       MEMCLK divide by 2
;       IOCLK  divide by 2
;
        MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkHalf + IOMD_CLKCTL_IOclkHalf
        STRB    r0, [r12, #IOMD_CLKCTL] ; initialise all the prescalers.
;
; Set ROM speed, take care to preserve 16-bit mode bit, or all hell breaks loose...
;
        LDRB    r0, [r12, #IOMD_ROMCR0]         ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_3
        STRB    r0, [r12, #IOMD_ROMCR0]         ; Prog. the reg.s

; Program the 2nd ROM bank

        STRB    r0, [r12, #IOMD_ROMCR1]         ; 2nd bank unused: program it the same anyway


; Now program ASTCR to add wait states, since MEMCLK is fast relative to IOCLK

        MOV     r0, #IOMD_ASTCR_WaitStates
        STRB    r0, [r12, #IOMD_ASTCR]

        B       init7500cpu_common              ; branch to common init code.
;

init7500cpu
; Here because its an ARM7500 variant - NON 'FE' device.
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-
;       CPUCLK divide by 1
;       MEMCLK divide by 1
;       IOCLK  divide by 1
;
        MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkNormal + IOMD_CLKCTL_IOclkNormal
        STRB    r0, [r12, #IOMD_CLKCTL] ; initialise all prescalers to div1
;
; Set ROM speed, take care to preserve 16-bit mode bit, or all hell breaks loose...

        LDRB    r0, [r12, #IOMD_ROMCR0]          ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_3
        STRB    r0, [r12, #IOMD_ROMCR0]          ; Prog. the reg.s

; Program the 2nd ROM bank

        STRB    r0, [r12, #IOMD_ROMCR1]         ; Program the 2nd bank the same as the 1st


; Now program ASTCR to *NOT* add wait states, since MEMCLK is slow relative to IOCLK

        MOV     r0, #IOMD_ASTCR_Minimal
        STRB    r0, [r12, #IOMD_ASTCR]

;
;
init7500cpu_common
; Common setup requirments for BOTH 7500 and 7500FE.
;
; MORRIS doesn't support VRAM. Kryten has same DRAM speed as Medusa
;
        MOV     r0, #IOMD_VREFCR_REF_16                         ; select 16µs refresh
        STRB    r0, [r12, #IOMD_VREFCR]

        MOV     r0, #IOMD_IOTCR_Network_TypeA :OR: IOMD_IOTCR_Combo_TypeB :OR: IOMD_IOTCR_Sound_TypeB :OR: IOMD_IOTCR_Sound_Word
        STRB    r0, [r12, #IOMD_IOTCR]

        MOV     r0, #0                          ; Podule manager wants TypeA setting by default for all podules
        STRB    r0, [r12, #IOMD_ECTCR]

        B       CommonInit

        LTORG

MedusaInit

        ; we know we might meet StrongARM 110, enable fast core clock if so
        ; (grey area - clocking regarded as HAL rather than kernel problem)
        ;
        MRC     p15, 0, r0, c0, c0, 0   ; read id
        AND     r0, r0, #&F000
        TEQ     r0, #&A000              ; is that my old friend, StrongARM?
        MCREQ   p15, 0, r0, c15, c1, 2  ; enable fast core clock

        MOV     r0, #&12    ; 5-3 cycle ROM access

        STRB    r0, [r12, #IOMD_ROMCR0]
        STRB    r0, [r12, #IOMD_ROMCR1]         ; and do the same for extension ROMs (just in case)
        MOV     r0, #IOMD_VREFCR_VRAM_256Kx64 :OR: IOMD_VREFCR_REF_16   ; select 16µs refresh, assume 2 banks of VRAM
        STRB    r0, [r12, #IOMD_VREFCR]

        MOV     r0, #IOMD_IOTCR_Network_TypeA :OR: IOMD_IOTCR_Combo_TypeB :OR: IOMD_IOTCR_Sound_TypeB :OR: IOMD_IOTCR_Sound_Word
        STRB    r0, [r12, #IOMD_IOTCR]

        MOV     r0, #0                          ; Podule manager wants TypeA setting by default for all podules
        STRB    r0, [r12, #IOMD_ECTCR]

CommonInit

 [ {FALSE}
; Turn off VIDC (set power down bit in control register)

        MOV     R1, #VIDCPhys   ; Must ALWAYS initialise VIDC on reset or else
        MOV     R0, #1:SHL:14   ; we may get vsync interrupts that stiff us
        ORR     R0, R0, #&E0000000
        STR     R0, [R1]
 |
; VInit etc set on ze mode change: no DMA going yet so don't set owt.

        MOV     R1, #VIDCPhys   ; Must ALWAYS initialise VIDC on reset or else
        ADRL    R2, VIDCTAB     ; we may get vsync interrupts that stiff us
10      LDR     R0, [R2], #4    ; permanently as VIDC is in an undefined state
        CMP     R0, #-1         ; so have mode 0 with all black palette
        STRNE   R0, [R1]
        BNE     %BT10

 ]

; Now bang IOC (disable all but keyboard interrupts)

        MOV     R1, #IOC
        MOV     R0, #&FF                ; all inputs
        STRB    R0, [R1, #IOCControl]   ; in case called by Tim

        MOV     R0, #0
        STRB    R0, [R1, #IOCIRQMSKA]   ; kein interrupts
	STRB	R0, [R1, #IOCIRQMSKB]
        STRB    R0, [R1, #IOCFIQMSK]    ; knob off, FIQ
        STRB    R0, [R1, #IOMD_DMAMSK]  ; disable DMA interrupts, too
        STRB    R0, [R1, #IOMD_IRQMSKC] ; and the rest...
        STRB    R0, [R1, #IOMD_IRQMSKD]

  [ Keyboard_Type = "PC"
        MOV     R0, #serial_Rx_bit      ; used for Archi keyboard or IOMD PC keyboard
  ]
        ;STRB    R0, [R1, #IOCIRQMSKB]   ; allow communication with kbd, when I_bit gets cleared

; now bits to allow CMOS read/write : need timer

        LDR     R0, =20000-1    ; R0 = Timer delay (units of 0.5 microsecond)
                                ; 20000*0.5E-6 = 0.01 Seconds (100Hz ticker)
                                ; TMD 21-May-93: "-1" correction applied

        STRB    R0, [R1, #Timer0LL]     ; Set up the delay
        MOV     R0, R0, LSR #8
        STRB    R0, [R1, #Timer0LH]
        STRB    R0, [R1, #Timer0GO]     ; and start the ticks

        MOV     R0, #timer0_bit
        STRB    R0, [R1, #IOCIRQCLRA]   ; Clear pending t0 interrupt j.i.c.

  [ VCOstartfix
        ;2nd part of fix for VCO failing to start on A7000 (esp. 7500FE) - forcing PCOMP high for about 3 ms
        LDRB    R0, [R1,#IOMD_ID0]
        CMP     R0, #&E7
        LDREQB  R0, [R1,#IOMD_ID1]
        CMPEQ   R0, #&D4
        BEQ     vcofix_notMorris      ; risky to force PCOMP on Risc PC
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000A46        ; VIDC20 FSYNREG, as in VIDCTAB but with force PCOMP high
        STR     R2, [R0]
        MOV     R0, #3072*2           ; time delay of about 3 ms (0.5 us units)
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R2, [R1, #Timer0CL]   ; R2 := low output latch
vcofix_waitloop
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R3, [R1, #Timer0CL]   ; R3 := low output latch
        TEQ     R3, R2                ; unchanged ?
        BEQ     vcofix_waitloop       ; then loop
        MOV     R2, R3                ; copy anyway
        SUBS    R0, R0, #1            ; decrement count
        BNE     vcofix_waitloop       ; loop if not finished
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000A06        ; VIDC20 FSYNREG, as in VIDCTAB (PCOMP low again)
        STR     R2, [R0]
vcofix_notMorris
  ]

        MOV     R0, #0
        STRB    R0, [R1, #IOMD_ATODICR] ; power down the A to D convertor

; On breaks (ie software resets) we have to turn the MMU off.
; This is slightly tricky if we've been soft-loaded!

        MOV     r13, #0 ; No stack until we find the first RAM bank
        MOV     r12, #IOMD_Base

 [ MorrisSupport
;
        LDRB    r0, [r12, #IOMD_ID0]    ; load r1 with IOMD ID high byte
        LDRB    r1, [r12, #IOMD_ID1]    ; load r0 with IOMD ID low byte
        ORR     r0,r0,r1,LSL#8          ; Or r0 and r1, shifted left 8, put in r0
        LDR     r1,=IOMD_Original       ; get Ref IOMD ID code - original
        CMP     r0,r1                   ; check for IOMD ID Code - original
        BEQ     MemSizeIOMD             ; Not ID Code - original,
                                        ;    therefore jump to Medusa hardware code
                                        ;    else fall through to Morris code.
;
; MemSize for Morris
;
  [ RO371Timings
        MOV     r11, #&70     ;all 4 banks assumed 32 bit - EDO and timing bits set in case 7500FE (don't care bits otherwise)
  |
        MOV     r11, #IOMD_DRAMWID_DRAM_32bit * &0F     ;set all 4 banks to be 32bit initially
        LDR     r1, =IOMD_7500FE
        TEQ     r0, r1                                  ; are we on FE part?
        ORREQ   r11, r11, #IOMD_DRAMWID_EDO_Enable :OR: IOMD_DRAMWID_RASCAS_3 :OR: IOMD_DRAMWID_RASPre_3
                                                        ; if so, then enable EDO and slower RASCAS and RASPre times
        ! 0,"7500FE support expects EDO memory in s.ARM600"
  ]
        MOV     r14, #IOMD_Base
        STRB    r11, [r14, #IOMD_DRAMWID]
        MOV     r10, #0                                 ; R10 = reference pointer for OS_AddRAM
        MOV     r9, #IOMD_DRAMWID_DRAM_16bit            ;bit to OR into DRAMWID to set 16bit
        MOV     r0, #DRAM0PhysRam
;
; r0    DRAM address
; r9    IOMD_DRAMWID_DRAM_16bit for current DRAM bank
; r11   current IOMD_DRAMWID register contents
;
ExamineDRAMBank                                         ;examine first/next DRAM bank
;
        LDMIA   r0, {r1, r2}                            ;Preserve the two locations that we widdle on

        ADR     r3, funnypatterns                       ;We write different values to two locations
        LDMIA   r3, {r3, r4}                            ; incase bus capacitance holds our value
        STMIA   r0, {r3, r4}
        LDMIA   r0, {r5, r6}                            ;Reread test locations
        EORS    r5, r5, r3                              ;Both locations should read correctly
        EOR     r6, r6, r4                              ; if memory is 32bits wide
       ;TEQ     r5, #0
        TEQEQ   r6, #0
        BEQ     %FT05                                   ;32bit wide memory

        TST     r5, #&00FF                              ;If the bottom 16bits of each location
        TSTEQ   r5, #&FF00                              ; are correct, the memory is 16bits wide
        TSTEQ   r6, #&00FF
        TSTEQ   r6, #&FF00
        ADDNE   r0, r0, #DRAM1PhysRam-DRAM0PhysRam      ; move onto next bank
        BNE     NoRamInBank                             ;No memory in this bank

        ORR     r11, r11, r9                            ;Bank is 16bits wide
05
        STMIA   r0, {r1, r2}                            ;Restore the two locations we widdled on
                                                        ;Must do BEFORE poking the DRAMWID register
        MOV     r14, #IOMD_Base                         ;
        STRB    r11, [r14, #IOMD_DRAMWID]               ;

        BL      Add_DRAM_bank

NoRamInBank
        MOV     r9, r9, LSL #1                          ; shunt up position in DRAMWID
        CMP     r9, #&0010                              ; if more banks to do
        BLT     ExamineDRAMBank                         ; then loop

        MOV     r6, #0                                  ; No VRAM
        MOV     r0, #0
        MOV     r14, #IOMD_Base

        LDRB    r4, [r14, #IOMD_ID0]
        LDRB    r7, [r14, #IOMD_ID1]
        ORR     r4, r4, r7, LSL #8
        LDR     r7, =IOMD_7500FE                        ; if FE part, then assume EDO DRAM
        TEQ     r4, r7
        LDREQ   r2, =80000000                           ; so allow 80E6 bytes/s
 [ STB
        LDRNE   r2, =44000000                           ; else only allow 44E6 bytes/s
 |
        LDRNE   r2, =46500000                           ; if no VRAM, then 46.5E6 bytes/sec bandwidth
 ]
        MOV     r1, #IOMD_VIDCR_DRAMMode :OR: &10       ; if no VRAM, then turn on DRAM mode, and set increment to &10

        B       Allocate_DRAM

MemSizeIOMD
 ]

; Right, let's find out where our memory is


MemSizeIOMD_notSA

        MOV     r11, #IOMD_DRAMCR_DRAM_Large * &55      ; set all banks to be large initially
        MOV     r14, #IOMD_Base
        STRB    r11, [r14, #IOMD_DRAMCR]

        MOV     r10, #0                                 ; R10 = Reference pointer for OS_AddRAM
        MOV     r9, #IOMD_DRAMCR_DRAM_Small             ; bit to OR into DRAMCR
        MOV     r0, #DRAM0PhysRam
10
        ADD     r1, r0, #A10                            ; this should be OK for both configurations
        BL      DistinctAddresses
        ADDNE   r0, r0, #DRAM1PhysRam-DRAM0PhysRam      ; move onto next bank
        BNE     %FT15                                   ; [no RAM in this bank at all]

        ADD     r1, r0, #A11                            ; test for 256K DRAM
        BL      DistinctAddresses
        ORRNE   r11, r11, r9                            ; it is, so select small multiplexing
        MOVNE   r14, #IOMD_Base
        STRNEB  r11, [r14, #IOMD_DRAMCR]                ; store new value of DRAMCR, so we can use memory immediately

        BL      Add_DRAM_bank

; Now, we have to find a bank of DRAM, so we've got somewhere to store our results!
15
        MOV     r9, r9, LSL #2                          ; shunt up position in DRAMCR
        CMP     r9, #&100                               ; if more banks to do
        BCC     %BT10                                   ; then loop

; Now, we check out the VRAM.
; Don't bother checking for more than 2M of VRAM, because we don't know what the 1/2 SAM length is for larger sizes

        MOV     r2, #IOMD_VREFCR_VRAM_256Kx64 :OR: IOMD_VREFCR_REF_16 ; assume 2 banks of VRAM by default
        STRB    r2, [r12, #IOMD_VREFCR]

; Check for 8mb VRAM - for RPCemu
	MOV	r0, #VideoPhysRam
	ADD	r1, r0, #A22
	BL	DistinctAddresses
	MOVEQ	r6, #8
	BEQ	%FT20

        MOV     r0, #VideoPhysRam                       ; point at VRAM
        ADD     r1, r0, #A2                             ; test A2
        BL      DistinctAddresses
        MOVEQ   r6, #2                                  ; we've got 2M of VRAM
        BEQ     %FT20

        MOV     r2, #IOMD_VREFCR_VRAM_256Kx32 :OR: IOMD_VREFCR_REF_16
        STRB    r2, [r12, #IOMD_VREFCR]
        ADD     r1, r0, #A2                             ; check for any VRAM at all
        BL      DistinctAddresses
        MOVEQ   r6, #1                                  ; we've got 1M of VRAM
        MOVNE   r6, #0                                  ; no VRAM
20
 [ IgnoreVRAM
        MOV     r6, #0                                  ; pretend there's no VRAM
 ]
        CMP     r6, #1
        MOVCC   r1, #IOMD_VIDCR_DRAMMode :OR: &10       ; if no VRAM, then turn on DRAM mode, and set increment to &10
        MOVEQ   r1, #SAMLength/2/256                    ; if 1M VRAM, then use VRAM mode, and set increment for 1/2 SAM
        MOVHI   r1, #SAMLength/2/256*2                  ; if 2M VRAM, then use VRAM mode, and set increment for 2*1/2 SAM
        LDRCC   r2, =46500000                           ; if no VRAM, then 46.5E6 bytes/sec bandwidth
        LDREQ   r2, =80000000                           ; if 1M VRAM, then 80E6   ---------""--------
        LDRHI   r2, =160000000                          ; if 2M VRAM, then 160E6  ---------""--------
        MOVCC   r0, #0                                  ; Clear VRAM base if there is no VRAM

; Allocate_DRAM
;   r0  = Video base if r6!=0
;   r1  = Value for IOMD VIDCR
;   r2  = Bandwidth limit
;   r6  = VRAM size in Mb
;   r10 = OS_AddRAM ref ptr
Allocate_DRAM
        ; Tell IOMD about VRAM.
        ; We don't need to worry about r1/r2/etc. - Video_init can reverse-engineer the values from IOMD_VIDCR and from the machine type
        MOV     r14, #IOMD_Base
        STRB    r1, [r14, #IOMD_VIDCR]

        ADRL    R5, HAL_Base + 64*1024          ; R5 -> RISC OS image
        LDR     R11, [R5, #OSHdr_Entries]
        ADD     R11, R11, R5                    ; R11 -> RISC OS entry table

        ; Tell OS about VRAM
        CMP     R6,#0
        MOVEQ   R3,R10                 ; parameter for OS_Start
        BEQ     NoVRAM
        MOV     R1,R0
        ADD     R2,R1,R6,LSL #20
        LDR     R3,=&FFFFFFFF
        Push    "R10"
        LDR     R0,=4:SHL:8+1
        CallOSM OS_AddRAM
        ADD     R13,R13,#4
        MOV     R3, R0                 ; parameter for OS_Start
NoVRAM

; Check the various reset flags

        MOV     R0, #0
        MOV     R12, #IOC
        LDRB    R1, [R12, #IOCIRQSTAA]
        ANDS    R1, R1, #por_bit
        STRNEB  R1, [R12, #IOCIRQCLRA]  ; clear POR if set
        ORRNE   R0, R0, #OSStartFlag_POR

 [ CheckProtectionLink
        LDR     R2, =IOMD_MonitorType

; on Issue A's the protection bit is only weakly pulled up,
; so force it high, then read it back

        LDRB    R1, [R2]
        ORR     R1, R1, #IOMD_ProtectionLinkBit
        STRB    R1, [R2]
        LDRB    R1, [R2]
        TST     R1, #IOMD_ProtectionLinkBit
        ORRNE   R0, R0, #OSStartFlag_NoCMOSReset
 ]

 [ STB :LAND: IOMD_C_FrontPanelButton <> 0
  [ FrontPanelButtClearsCMOS
        LDRB    R1, [R12, #IOMD_CLINES] ; if front panel button pressed then CMOS reset
        TST     R1, #IOMD_C_FrontPanelButton
        ORRNE   R0, R0, #OSStartFlag_CMOSReset
  ]
 ]

        MOV     R1, R5
        ADRL    R2, HALdescriptor
        CallOSM OS_Start

funnypatterns
        &       &66CC9933   ; 0110 1100 1001 0011
        &       &CC993366   ; 1100 1001 0011 0110

        LTORG

; add_dram_bank
;   Entry: r10 -> workspace (initially 0)
;          r0  =  bank address
;   Exit:  r10 -> workspace (allocated if 0 on entry)
;          r0  =  next bank address
;          r9, r11, r13 preserved
;   Probe a DRAM bank, and add any DRAM found to the workspace
Add_DRAM_bank
        ROUT
        MOV     r12, lr                 ; r12 = return address
        EOR     r1, r0, #A16            ; Check there is some RAM in the bank
        BL      DistinctAddresses
        ADDNE   r0, r0, #DRAM1PhysRam-DRAM0PhysRam
        MOVNE   pc, r12                 ; Return if no RAM in the bank

        ; Only some address lines are decoded by the SIMM.  For example, a 4M SIMM may be split
        ; into 2 banks, with A2-A20 decoded on each, or A2-A19,A21 decoded.  First we need to
        ; find out which address lines are decoded, and which are ignored.
        MOV     r6, #DRAM1PhysRam-DRAM0PhysRam
        MOV     r7, #A17
        SUB     r6, r6, #1              ; Get address lines which select address within bank.

        ; Loop through the address lines, finding out which are decoded.  We clear the bits in r6
        ; which correspond to non-decoded address lines.
        ; r6 = address line mask
        ; r7 = current address line
10      EOR     r1, r0, r7              ; Toggle the address line
        BL      DistinctAddresses       ; Check if address line has any effect.
        BICNE   r6, r6, r7              ; Clear the bit if the address line fails.
        MOV     r7, r7, LSL #1          ; Move onto the next address line.
        TST     r6, r7                  ; Have we reached the limit?
        BNE     %BT10                   ; Repeat if not.

        ; r6 = decoded address lines in bank. (ie in A0-A25)
        ; r7 = The size of the DRAM bank
        ; Since the DRAM bank may not be contiguous, we now split the bank up into contiguous
        ; blocks.  We make these as large as possible to save work.  Here we set r8 to the
        ; size of the smallest contiguous block(s) of RAM.  (There will also be some contiguous
        ; blocks which are twice this size in some cases.)
        ADD     r8, r6, #A17
        BIC     r8, r8, r6              ; r8 = First clear bit in r6 from A17 up.

        RSB     r4, r8, #0              ; r4 = All bits at or above r8 set since r8 is a power of 2.

        RSB     r7, r7, #0              ; r7 = address bits which select the bank since r7 was a
                                        ;      power of 2.
        ORR     r3, r7, r6              ; r3 = All decoded address lines.
        AND     r7, r4, r3              ; r7 = All decoded bits at or above r8.

; Make sure that the dram bank may not be contained within the image.  The code below fails
; to work correctly if a dram bank is contained within an OS image.  Currently this would
; require an image larger than 64M.
                ASSERT  OSROM_ImageSize*1024 <= DRAM1PhysRam-DRAM0PhysRam

15      MOV     r1, r0                  ; r1 = Address of start of block (inclusive).
        ADD     r2, r1, r8              ; r2 = End of the block (exclusive).

        ; Move the end of the block if the OS image begins in this block.
        ADRL    r4, HAL_Base            ; r4 = Start of the OS image (which may be in RAM).
        EOR     r5, r4, r1              ; r5 = Difference between image and memory block.
        TST     r5, r7                  ; Check if the image begins in this block of RAM.
        ANDEQ   r2, r4, r3              ; Set end of block to start of image.

        ; Move the start of the block if the OS image ends in this block.
        ADD     r4, r4, #OSROM_ImageSize*1024
        SUB     r4, r4, #1              ; r4 = Last byte of the OS image.
        EOR     r5, r4, r1              ; r5 = Difference between end of image and block.
        TST     r5, r7                  ; Check if the image ends in this block of RAM.
        ANDEQ   r5, r4, r3              ; r5 = Address of last byte of the image within this block.
        ADDEQ   r1, r5, #1              ; Set start of block to the byte after the image.

        ; If the image is contained in the block, we will have swapped the start and end
        ; addresses.  This means that the block is split into two parts.  The bit below
        ; the image and the bit above the image.
        CMP     r1, r2
        BLS     %FT20                   ; If start <= end, then block is not fragmented.
        CMP     r2, r0                  ; Check the size of the fragment before the image.
        MOV     r0, r1                  ; Store old start address
        AND     r1, r1, r7              ; Get the start of the block
        BLNE    Allocate_DRAM_fragment  ; Allocate it if it's non-zero.
        MOV     r1, r0                  ; Restore the old start of fragment
        AND     r0, r0, r7              ; Get the start of the block again.
        ADD     r2, r0, r8              ; End of next fragment is the end of the block.

        CMP     r1, r2                  ; Compare start and (modified) end.
20      BLNE    Allocate_DRAM_fragment

        ; Now move onto the next block.  We add the non-decoded address lines to cause the
        ; carry to be propagated across them.  Then we mask them out.
        MVN     r4, r7                  ; Add the non-connected address lines to ...
        ADD     r4, r4, r0              ; ... the block address ...
        ADD     r4, r4, r8              ; ... and the block size.
;       EOR     r5, r0, r4              ; Compare with old address
        AND     r0, r4, r7              ; Leave only the decoded lines set.
;       BIC     r5, r5, r6              ; Clear decoded lines within the bank.
;       TST     r5, r7                  ; Check only the bank lines.
;       BEQ     %BT15                   ; Repeat for next block.

        TST     r0, r6
        BNE     %BT15

        MOV     pc, r12                 ; Done for this bank.

; Allocate_DRAM_block
;   Entry:
;     r1 = block start (inclusive)
;     r2 = block end (exclusive)
;     r3 = All decoded address lines
;     r7 = All decoded bits at or above r8
;     r8 = Size of largest contiguous block
;     block length is assumed to be at least the size of the static data - ie. 160k
;     The maximum block list size is then 4k, which fits easily into the cursor chunk
;   Exit:
;     r10 updated
;     r0, r3, r6-r9, r11-r13 preserved
;     r10 points to a word containing the number of blocks stored.
;     The pairs of words before
Allocate_DRAM_fragment
        ; Set up stack (if required) and call OS_AddRAM
        CMP     r13, #0
        ADDEQ   r13, r1, #4096 ; Top of first page is 'best'
        Push    "r0-r9,r11-r12,lr" ; Hello stack!
        MOV     r0, #4:SHL:8 ; TODO - set flags
        ; r1, r2 are correct
        LDR     R3, =&FFFFFFFF
        ; r3 should be correct?
        Push    "r10" ; Push reference ptr
        ADRL    R5, HAL_Base + 64*1024          ; R5 -> RISC OS image
        LDR     R11, [R5, #OSHdr_Entries]
        ADD     R11, R11, R5                    ; R11 -> RISC OS entry table
        CallOSM OS_AddRAM
        ADD     R13,R13,#4
        MOV     r10, r0 ; Keep reference
        Pull    "r0-r9,r11-r12,pc"

; DistinctAddresses routine...
; r0,r1 are the addresses to check
; uses r2-5
; writes interleaved patterns (to prevent dynamic storage...)
; checks writing every bit low and high...
; return Z-flag set if distinct

; This routine must work in 32-bit mode

DistinctAddresses ROUT
        LDR     r2, [r0] ; preserve
        LDR     r3, [r1]
        LDR     r4, Pattern
        STR     r4, [r0] ; mark first
        MOV     r5, r4, ROR #16
        STR     r5, [r1] ; mark second
        LDR     r5, [r0]
        CMP     r5, r4 ; check first
        BNE     %10    ; exit with Z clear
        LDR     r5, [r1] ; check second
        CMP     r5, r4, ROR #16 ; clear Z if not same
        BNE     %10
; now check inverse bit writes
        STR     r4, [r1] ; mark second
        MOV     r5, r4, ROR #16
        STR     r5, [r0] ; mark first
        LDR     r5, [r1]
        CMP     r5, r4 ; check second
        BNE     %10   ; exit with Z clear
        LDR     r5, [r0] ; check first
        CMP     r5, r4, ROR #16 ; clear Z if not same
10      STR     r3, [r1] ; restore
        STR     r2, [r0]
        MOV     pc, lr                  ; Z flag is already set up, and other flags don't matter

Pattern
        &       &AAFF5500 ; shiftable bit check pattern

; Constants
;
A0      *       1 :SHL: 00
A1      *       1 :SHL: 01
A2      *       1 :SHL: 02
A3      *       1 :SHL: 03
A4      *       1 :SHL: 04
A5      *       1 :SHL: 05
A6      *       1 :SHL: 06
A7      *       1 :SHL: 07
A8      *       1 :SHL: 08
A9      *       1 :SHL: 09
A10     *       1 :SHL: 10
A11     *       1 :SHL: 11
A12     *       1 :SHL: 12
A13     *       1 :SHL: 13
A14     *       1 :SHL: 14
A15     *       1 :SHL: 15
A16     *       1 :SHL: 16
A17     *       1 :SHL: 17
A18     *       1 :SHL: 18
A19     *       1 :SHL: 19
A20     *       1 :SHL: 20
A21     *       1 :SHL: 21
A22     *       1 :SHL: 22
A23     *       1 :SHL: 23
A24     *       1 :SHL: 24
A25     *       1 :SHL: 25
A26     *       1 :SHL: 26
A27     *       1 :SHL: 27
A28     *       1 :SHL: 28
A29     *       1 :SHL: 29
A30     *       1 :SHL: 30
A31     *       1 :SHL: 31

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data tables: VIDC := mode 0, all palette black

VIDCTAB DATA
; Program Control Register first, to clear power-down bit
; Now depending upon the VIDCClockSource flag, re-program the clock source.
   [ VIDCClockSource = "VCO"
     [ VCOstartfix
        & &E0000404     ; CR: FIFO load 16 words, 1 bpp, ck/2, vclk (allow for doubled VCO freq)
     |
        & &E0000400     ; CR: FIFO load 16 words, 1 bpp, ck/1, vclk
     ]
   ]
   [ VIDCClockSource = "HCLK"
        & &E0000401     ; CR: FIFO load 16 words, 1 bpp, ck/1, hclk
   ]
   [ VIDCClockSource = "RCLK"
        & &E0000406     ; CR: FIFO load 16 words, 1 bpp, ck/2, rclk
   ]

; Don't bother programming all 256 palette entries, we'll be here all night
; Since we're setting up a 1 bit-per-pixel mode, just do colours 0 and 1

        & &10000000     ; Palette address register = 0
        & &00000000     ; Colour 0 = black
        & &00000000     ; Colour 1 = black
        & &40000000     ; Border colour = black
        & &50000000     ; Pointer colour 1 = black
        & &60000000     ; Pointer colour 2 = black
        & &70000000     ; Pointer colour 3 = black

; Get a stable display up so we get stable signals

        & &80000318     ; HCR + 8 = 94 + 22 + 22 + 640 + 22 + 0
        & &81000056     ; HSWR+ 8 = 94
        & &82000068     ; HBSR+12 = 94 + 22
        & &83000078     ; HDSR+18 = 94 + 22 + 22
        & &840002F8     ; HDER+18 = 94 + 22 + 22 + 640
        & &85000314     ; HBER+12 = 94 + 22 + 22 + 640 + 22
        & &86000079     ; HCSR+17 = HDSR+18

        & &9000020B     ; VCR +2 = 2 + 32 + 0 + 480 + 0 + 11
        & &91000000     ; VSWR+2 = 2
        & &92000021     ; VBSR+1 = 2 + 32
        & &93000021     ; VDSR+1 = 2 + 32 + 0
 [ MEMC_Type = "IOMD"
        & &94000201     ; VDER+1 = 2 + 32 + 0 + 480
 | ;MEMC_Type <> "IOMD"
        & &94000201     ; VDER+1 = 2 + 32 + 0 + 480
 ] ;MEMC_Tupe = "IOMD"
        & &95000201     ; VBER+1 = 2 + 32 + 0 + 480 + 0
        & &96000021     ; VCSR+1 = VDSR+1
        & &97000021     ; VCER+1 = VDSR+1

        & &B1000001     ; SCR: sound disabled (+use 24MHz clock)

        & &C00F1003     ; EREG = comp sync, DACs on, ereg output ext lut
   [ VCOstartfix
        & &D0000A06     ; FSYNREG, clk = (10+1)/(6+1) * 32MHz = 50.286MHz  (higher frequency as part of fix)
   |
        & &D0000A0D     ; FSYNREG, clk = (10+1)/(13+1) * 32MHz = 25.143MHz
   ]
        & &F0013000     ; DCR: bus D[31:0], Hdisc       ;RCM 29/9/94: changed from &F0012000 at PSwindells request
        & &FFFFFFFF     ; That's the lot

IOPhys          *       &03000000
IOSize          *       &00800000

EASIPhys        *       &08000000
EASISlotSize    *       &01000000
EASISlotSizeShift *     24
EASISlots       *       8
EASISize        *       EASISlotSize * EASISlots

IOMDPhys        *       &03200000
VIDCPhys        *       &03400000       ; used to address VIDC when MMU is off

;--------------------------------------------------------------------------------------


HAL_Init
        Entry

        BL      SetUpOSEntries
        MOV     a1, #0
        MOV     a2, #IOPhys
        MOV     a3, #IOSize
        CallOS  OS_MapInIO
        STR     a1, IO_Address
        ADD     a2, a1, #IOMDPhys - IOPhys
        STR     a2, IOMD_Address
        ADD     a3, a1, #VIDCPhys - IOPhys
        STR     a3, VIDC_Address

        LDRB    a1, [a2, #IOMD_ID0]
        LDRB    a4, [a2, #IOMD_ID1]
        ORR     a1, a1, a4, LSL #8
        LDR     a4, =IOMD_Original
        TEQ     a1, a4
        MOVEQ   ip, #0                    ; assume Medusa
        MOVNE   ip, #IOST_7500            ; else assume Morris
        STRB    ip, IOSystemType

        MOV     a1, #0
        MOV     a2, #EASIPhys
        MOV     a3, #EASISize
        CallOS  OS_MapInIO
        STR     a1, EASI_Address

        BL      Video_init

	LDR 	a1, IOMD_Address  	; SuperIO at IOMD-0x1f0000
	SUB	a1, a1, #0x1f0000

	MOV	a2, #0x55               ; Enter config mode
	STRB	a2, [a1, #0xfc0]
	STRB	a2, [a1, #0xfc0]
	MOV	a2, #0x0d
	STRB	a2, [a1, #0xfc0]

	ADR	a2, SuperIOTab
SPL	LDRB 	a3, [a2], #1
	CMP	a3, #0xff
	LDRNEB  a4, [a2], #1
	STRNEB	a3, [a1, #0xfc0]
	STRNEB  a4, [a1, #0xfc4]
	BNE 	SPL

	MOV 	a2, #0xaa       	; Leave config mode
	STRB	a2, [a1, #0xfc0]

        EXIT

; Initialise and relocate the entry table.
SetUpOSEntries  ROUT
        STR     a1, OSheader
        LDR     a2, [a1, #OSHdr_NumEntries]
        CMP     a2, #HighestOSEntry+1
        MOVHI   a2, #HighestOSEntry+1

        ADR     a3, OSentries
        LDR     a4, [a1, #OSHdr_Entries]
        ADD     a4, a4, a1

05      SUBS    a2, a2, #1
        LDR     ip, [a4, a2, LSL #2]
        ADD     ip, ip, a4
        STR     ip, [a3, a2, LSL #2]
        BNE     %BT05

        MOV     pc, lr


HAL_Null
        MOV     pc, lr

HAL_ControllerAddress
        MOV     a1, #0                  ; Default to "not fitted"
        AND     a3, a2, #&FF            ; Get sequence number.
        MOV     a2, a2, LSR #8          ; Get controller type.
        CMP     a2, #4
        ADDLS   pc, pc, a2, LSL #2
        MOV     pc, lr
        B       ca_EASIspeed
        B       ca_EASIspace
        MOV     pc, lr
        B       ca_VIDC20
        B       ca_IOMD

ca_EASIspeed
        LDR     ip, IOMD_Address
        CMP     a3, #EASISlots
        ADDLO   a1, ip, #IOMD_ECTCR
        MOV     pc, lr

ca_EASIspace
        LDR     ip, EASI_Address
        CMP     a3, #EASISlots
        ADDLO   a1, ip, a3, LSL #EASISlotSizeShift
        MOV     pc, lr

ca_VIDC20
        TEQ     a3, #0
        LDREQ   a1, VIDC_Address
        MOV     pc, lr

ca_IOMD
        TEQ     a3, #0
        LDREQ   a1, IOMD_Address
        MOV     pc, lr

HAL_HardwareInfo
        LDR     ip, =&01010101
        STR     ip, [a1]
        MOV     ip, #1
        STR     ip, [a2]
        MOV     ip, #0
        STR     ip, [a3]
        MOV     pc, lr

HAL_SuperIOInfo
        LDR     ip, =&00311111
        STR     ip, [a1]
        LDR     ip, =&00011100
        STR     ip, [a2]
        MOV     pc, lr

HAL_PlatformInfo
        ADR     a4, %86
        LDR     ip, IOMD_Address
        LDRB    ip, [ip, #IOMD_ID0]
82
        LDR     a1, [a4], #4
        TEQ     a1, #&80000000     ;terminator
        TEQNE   a1, ip
        LDMEQIA a4, {a4,ip}
        STREQ   a4, [a2]
        STREQ   ip, [a3]
        MOVEQ   pc, lr
        ADD     a4, a4, #2*4
        B       %BT82
86
        DCD     IOMD_Original :AND: &FF, &00000005, &0000000F
        DCD     IOMD_7500     :AND: &FF, &00000001, &0000000F
        DCD     IOMD_7500FE   :AND: &FF, &00000001, &0000000F
        DCD     IOMD_IOMD2    :AND: &FF, &0000000F, &0000000F
        DCD     &80000000,                       0,         0  ;terminator

;must return address of at least 64k of physical space suitable for
;cache cleaning (at least 4k aligned, preferably 64k aligned)
;or, return -1 if HAL knows not needed (eg. knows core in system)
;
HAL_CleanerSpace
        [ {FALSE}
          ???don't know what do yet, in generic memory size case
        |
          MOV   a1, #&10000000  ; return start of physical RAM
        ]
        MOV     pc, lr

        LTORG


        ! 0, "TODO - Sort out keyboard scan for IOMD HAL"
HAL_KbdScan
        MOV     a1, #&C0000000 ; scan complete, keyboard present
HAL_KbdScanSetup
HAL_KbdScanInterrupt
HAL_KbdScanFinish
        MOV     pc, lr

SuperIOTab
	= 0x01,0x87,0x02,0x1c,0x03,0x78,0x04,0x03,0x05,0x00,0x06,0xff
	= 0x07,0x00,0x08,0x00,0x09,0x00,0x0a,0x00,0x00,0xbb,0xff

        END
