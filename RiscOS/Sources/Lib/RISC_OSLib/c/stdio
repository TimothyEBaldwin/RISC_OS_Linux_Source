/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* stdio.c: ANSI draft (X3J11 Oct 86) library code, section 4.9 */
/* Copyright (C) Codemist Ltd, 1988         */
/* Copyright (C) Acorn Computers Ltd., 1988 */
/* version 0.17e */

/* Incorporate _sys_tmpnam_ idea from WGD */

/* N.B. I am trying to factor out machine dependence via calls to           */
/* routines like _sys_read_ which can be implemented as _osgbpb or          */
/* NIOP as required.  This file SHOULD therefore be machine independent     */

/* the #include <stdio.h> imports macros getc/putc etc.  Note that we
   must keep the two files in step (more details in ctype.c).
   NOTE (sb, 09/02/01): This includes the _write function
*/

#define __system_io 1      /* makes stdio.h declare more */
#define _LARGEFILE64_SOURCE /* define 64-bit file pointer stuff in stdio.h */

#include "hostsys.h"   /* _sys_alloc() etc */
#include <stdio.h>     /* macros for putc, getc, putchar, getchar */
#include <string.h>    /* for memcpy etc */
#include <stddef.h>    /* for size_t etc */
#include <stdlib.h>    /* for free() */
#include <time.h>      /* for time() for tmpfil() */
#include <errno.h>

#include "kernel.h"    /* debug */
#include "hostsys.h"
#include "swis.h"
extern char *_kernel_getmessage(char *msg, char *tag);
extern int _fprintf_lf(FILE *fp, const char *fmt, ...);
extern int _sprintf_lf(char *buff, const char *fmt, ...);

/* HIDDEN EXPORTS */
int __dup(int new, int old);
int _fisatty(FILE *stream);
int __backspace(FILE *stream);  /* strict right inverse of getc() */

#ifndef _SYS_OPEN
/* Temp feature to cope with upgrade path of compiler */
#define _SYS_OPEN SYS_OPEN
#endif

#ifndef EDOM
#define EDOM 1
#endif

#define NO_DEBUG

/* Maximum allowable file pointers for the 32 and 64-bit APIs. */
#define OFF32_MAX (0x7fffffffL)
#if 1 /* change this once FileSwitch has a 64-bit API */
#define OFF64_MAX (0x00000000ffffffffLL)
#else
#define OFF64_MAX (0x7fffffffffffffffLL)
#endif

/* The maximum buffer size to permit via setvbuf().
 * Previous limit of 16MB-1 was maybe a bit stingy, given the amount of
 * RAM in machines these days.
 */
#define MAX_BUF_SIZE (1u<<30)

/* This macro is part of the fwrite performance improvement.  It selects
 * which strategy is being used for large block writes.  If this macro
 * is defined, then _writebuf is asked to write n*buffersize bytes in one
 * go; if it is undefined, it writes buffersize bytes n times (which
 * allows callbacks to go off during large writes ... but that's the only
 * real benefit).  Best performance is achieved by defining this macro.
 */
#define WRITE_ONCE

/* in the shared library world, __iob and _errno are generated by s.clib, */
/* in order to make it easier to keep their position fixed               */

/*FILE __iob[_SYS_OPEN];*/
/* Note that the real name for errno is _errno, and the macro errno is   */
/* defined in errno.h                                                    */
/*volatile int errno;*/

typedef struct __extradata {
  /*
   * BODGE BODGE BODGE BODGE
   * sscanf needs to know the size of this structure, so if you change
   * it, alter sscanf's view of it.
   */
  unsigned char __lilbuf[2]; /* single byte buffer for them that want it  */
                             /* plus an unget char is put in __lilbuf[1]  */
  off64_t __pos;             /* position in file corresponding to start of buffer */
  off64_t _lspos;            /* what __pos should be (set after lazy seek)*/
  unsigned char *__extent;   /* extent of writes into the current buffer  */
  int __buflim;              /* used size of buffer                       */
  int __savedicnt;           /* after unget contains old icnt             */
  int __savedocnt;           /* after unget contains old ocnt             */
#ifdef SUPPORT_WIDE
  int __orientation;
  mbstate_t __mbstate;       /* must be stored in fpos_t */
#endif
} _extradata, *_extradatap;

static _extradatap _extra;

/* 14-Mar-2005 - upgraded to handle more files beyond _SYS_OPEN; extra    */
/* handles stored  in a linked list. For simplicity, these structures are */
/* never freed until terminateio is called. Need to take care that all    */
/* code directly referencing __iob also considers this list.              */
typedef struct _FILElist {
  struct _FILElist *next;
  FILE file;
  _extradata extra;
} _FILElist, *_FILElistp;

static _FILElistp _flist;

static FILE *_getFILE(void)
{   _FILElistp fp;
    int i;
    /* First try __iob array */
    for (i=3; i<_SYS_OPEN; i++)
    {   FILE *stream = &__iob[i];
        if (!(stream->__flag & _IOREAD+_IOWRITE))
            return stream;
    }
    /* Then try linked list */
    for (fp = _flist; fp; fp = fp->next)
        if (!(fp->file.__flag & _IOREAD+_IOWRITE))
            return &fp->file;
    /* Then try to allocate a new one */
    fp = calloc(1, sizeof(_FILElist));
    if (fp)
    {   fp->file.__extrap = &fp->extra;
        fp->next = _flist;
        _flist = fp;
        return &fp->file;
    }
    return 0;
}

#ifdef SUPPORT_WIDE
#define O_NONE 0
#define O_BYTE (-1)
#define O_WIDE (+1)
#define ORIENTATION(stream) ((stream)->__extrap->__orientation)
#define BYTEORIENT(stream) (ORIENTATION(stream) == 0 ? \
                            ORIENTATION(stream) = O_BYTE : \
                            ORIENTATION(stream))
#define ENSUREBYTE(stream,e) do { if (BYTEORIENT(stream) != O_BYTE) return e; } while (0)
#define WIDEORIENT(stream) (ORIENTATION(stream) == 0 ? \
                            ORIENTATION(stream) = O_WIDE : \
                            ORIENTATION(stream))
#define ENSUREWIDE(stream,e) do { if (WIDEORIENT(stream) != O_WIDE) return e; } while (0)
#else
#define BYTEORIENT(stream)
#define ENSUREBYTE(stream,e)
#endif

#define EXTENT(stream) ((stream)->__extrap->__extent > (stream)->__ptr \
                       ? (stream)->__extrap->__extent : (stream)->__ptr)

/* Explanation of the _IOxxx bits:                                       */
/* IONOWRITES says that the file is positioned at the end of the current */
/* buffer (as when performing sequential reads), while IODIRTIED         */
/* indicates that its position is at the start of the current buffer (as */
/* in the usual case when writing a file). When the relevant bit is not  */
/* set and a transfer is needed _sys_seek() is used to reposition the    */
/* file. Now extra bit _IOSEEK indicating that repositioning of the file */
/* is required before performing I/O                                     */
/* Extra bit _IOLAZY added to indicate that a seek has been requested    */
/* but has been deferred until the next fill or flush buffer             */
/* I use IONOWRITES and IONOREADS to check the restriction               */
/* that read and write operations must be separated by fseek/fflush.     */

/* N.B. bits up to (and including 0xfff) in <stdio.h>, as below:         */
#ifdef never
#define _IOREAD     0x00000001     /* open for input */
#define _IOWRITE    0x00000002     /* open for output */
#define _IOBIN      0x00000004     /* binary stream */
#define _IOSTRG     0x00000008     /* string stream */
#define _IOSEEK     0x00000010     /* physical seek required before IO */
#define _IOLAZY     0x00000020     /* possible seek pending */
#define _IOEOF      0x00000040     /* end-of-file reached */
#define _IOERR      0x00000080     /* error occurred on stream */
#define _IOFBF      0x00000100     /* fully buffered IO */
#define _IOLBF      0x00000200     /* line buffered IO */
#define _IONBF      0x00000400     /* unbuffered IO */
#define _IOSBF      0x00000800     /* system allocated buffer */
#define _IOAPPEND   0x00008000     /* must seek to eof before write */
#endif
#define _IONOWRITES 0x00001000     /* last op was a read                 */
#define _IONOREADS  0x00002000     /* last op was a write                */
#define _IOPEOF     0x00004000     /* 'pending' EOF                      */
#define _IODIRTIED  0x00010000     /* buffer has been written to         */
#define _IOBUFREAD  0x00020000     /* indicates that the buffer being    */
                                   /* written was read from file, so a   */
                                   /* seek to start of buffer is required*/
#define _IOADFSBUG  0x00040000     /* indicates that the underlying      */
                                   /* system buffer was last written to  */
                                   /* and an ensure should be done if    */
                                   /* a seek is about to happen before   */
                                   /* the next read is performed         */
#define _IOUNGET    0x00080000     /* last op was an unget               */
#define _IOSHARED   0x00100000     /* 2 streams share the same file      */
#define _IOUSERFILE 0x00200000     /* set if should be closed by user    */
                                   /* terminateio in a module            */
#define _IOACTIVE   0x00400000     /* some IO operation already performed*/
#define _IO64       0x00800000     /* stream ok for 64-bit file pointers */
#define _IODEL      0xad000000     /* for safety check 8 bits            */
#define _IODELMSK   0xff000000

/* first functions for macros in <stdio.h>  */
int (fgetc)(FILE *stream) { return getc(stream); }
int (fputc)(int ch, FILE *stream) { return putc(ch, stream); }
int (getc)(FILE *stream) { return getc(stream); }
int (getchar)(void) { return getchar(); }
int (putc)(int ch, FILE *stream) { return putc(ch, stream); }
int (putchar)(int ch) { return putchar(ch); }
int (feof)(FILE *stream) { return feof(stream); }
int (ferror)(FILE *stream) { return ferror(stream); }
#define STDOUT stderr
#ifdef DEBUG
#define dbmsg(m, ...) if (stream > STDOUT || stream == stdin) {int last=0 ;int iw; char v[128]; \
        sprintf(v, m, __VA_ARGS__); \
        for(iw=0;v[iw];_kernel_oswrch(last=v[iw++])); \
        if (last == 10)_kernel_oswrch(13);}
#define dbmsg_noNL(m, m2) if (stream > STDOUT || stream == stdin) {int last=0 ;int iw; char v[128]; \
        sprintf(v, m, m2); \
        for(iw=0;v[iw];_kernel_oswrch(last=v[iw++]));}
#else
#define dbmsg(m, ...)
#define dbmsg_noNL(m, m2)
#endif
/* put this here too */
void clearerr(FILE *stream)
{   /* we should do more in 'clearerr' resetting __pos __ptr and _cnt      */
    if (!stream) return;
    stream->__flag &= ~(_IOEOF+_IOERR+_IOPEOF);
}

#define seterr(stream) ((stream)->__flag |= _IOERR, \
                        (stream)->__icnt = (stream)->__ocnt = 0)

int setvbuf(FILE *stream, char *buf, int type, size_t size)
{   int flags = stream -> __flag;
    unsigned char *ubuf = (unsigned char *) buf;   /* costs nothing */
    if ((!(flags & _IOREAD+_IOWRITE)) || (flags & _IOACTIVE))
        return 1;             /* failure - not open || already active */
    switch (type)
    {   default: return 1;    /* failure */
        case _IONBF:
            ubuf = stream->__extrap->__lilbuf;
            size = 1;
            break;
        case _IOLBF:
        case _IOFBF:
            if (size-1 >= MAX_BUF_SIZE) return 1;  /* unsigned! */
            break;
    }
    stream->__ptr = stream->__base = ubuf;
    stream->__bufsiz = size;
    stream->__flag = (stream->__flag & ~(_IOSBF+_IOFBF+_IOLBF+_IONBF)) | type;
    return 0;                 /* success */
}

void setbuf(FILE *stream, char *buf)
{
   (void) setvbuf(stream, buf, (buf!=0 ? _IOFBF : _IONBF), BUFSIZ);
}

int __backspace(FILE *stream)
{
    if (!(stream->__flag & _IOEOF) &&
         (stream->__ptr > stream->__base))
    {   ++(stream->__icnt);
        --(stream->__ptr);
        return 0;
    }
    return EOF;
}

int ungetc(int c,FILE *stream)
{   /* made into a fn to evaluate each arg once. */
    ENSUREBYTE(stream, EOF);
    if (c==EOF || (stream->__flag & (_IOUNGET+_IONOREADS))) return EOF;
    /* put char into unget buffer */
    stream->__extrap->__lilbuf[1] = c;
    stream->__flag = (stream->__flag | _IOUNGET | _IONOWRITES | _IOACTIVE) & ~(_IOEOF);
    stream->__extrap->__savedocnt = stream->__ocnt;
    stream->__extrap->__savedicnt = stream->__icnt;
    stream->__icnt = stream->__ocnt = 0;
    return c;
}

static int _writebuf(unsigned char *buf, unsigned int len, FILE *stream)
{   int w;
    FILEHANDLE fh = stream->__file;
    off64_t over_limit;
    int flag = stream->__flag;
    if (flag & _IOSHARED) /* this is really gross */
    {   flag |= _IOSEEK;
        stream->__extrap->__pos = _sys_flen(fh);
dbmsg("_IOSHARED so zoom to end %lld\n", stream->__extrap->__pos);
    }
    if (flag & _IOSEEK+_IOBUFREAD)
    {
dbmsg("_writebuf seeking to %lld\n", stream->__extrap->__pos);
        if (_sys_seek(fh, stream->__extrap->__pos) < 0)
        {   seterr(stream);
            return EOF;
        }
        stream->__flag = (flag &= ~(_IOSEEK+_IOBUFREAD));
    }
dbmsg_noNL("_writebuf pop goes the stoat %i, ", fh);
dbmsg_noNL("%X, ", (int)buf);
dbmsg_noNL("%d, ", len);
dbmsg("%X\n", flag);
    over_limit = stream->__extrap->__pos + len - ((stream->__flag & _IO64) ? OFF64_MAX : OFF32_MAX);
    if (over_limit < 0) over_limit = 0;
dbmsg("over_limit %lld\n", over_limit);
    len -= (unsigned int) over_limit;
    if (len == 0)
        w = 0;
    else
    {
        w = _sys_write(fh, buf, len, flag);
        stream->__flag |= _IOADFSBUG;
dbmsg("_sys_write_ returned %d\n", w);
    }
    if (w < (unsigned int) _kernel_ERROR)
        stream->__extrap->__pos += (off64_t) len - (w & 0x7fffffffLL);
    if (w!=0)    /* AM: was (w<0) but trap unwritten chars as error too */
    {   seterr(stream);
        return(EOF);
    }
    if (over_limit)
    {
        seterr(stream);
        errno = EFBIG;
        return(EOF);
    }
dbmsg("filelen = %lld\n",_sys_flen(fh));           /* length of this file      */
    return 0;
}

static int _fflush(FILE *stream)
{
    unsigned char *buff = stream->__base;
    unsigned char *extent = EXTENT(stream);
dbmsg("%s\n", "_fflush");
    stream->__flag &= ~_IOUNGET;
    if ((stream->__flag & _IOREAD+_IOWRITE) == _IOREAD) return 0;
    if ((stream->__flag & _IOERR+_IOWRITE) != _IOWRITE) return EOF;
    /* N.B. really more to do here for ANSI input stream */
    if (stream->__flag & _IODIRTIED)
    {   /* only write if dirty buffer - this avoids problems with
           writing to a file opened in append (or read+write) mode
           when only input has been done since the last fflush/fseek.
        */
dbmsg("%s\n", "dirty buffer");
        if (extent != buff)       /* something to do */
        {
dbmsg("%s\n", "call _writebuf");
          if (_writebuf(buff, extent - buff, stream)) return EOF;
        }
        stream->__ptr = stream->__extrap->__extent = extent = buff;
/* the next line forces a call to __filbuf/__flsbuf on next putc/getc -  */
/* this is necessary since change of direction may happen.               */
        stream->__ocnt = 0;
        stream->__flag &= ~_IODIRTIED;
dbmsg("%s\n", "clear IODIRTIED");
    }
else dbmsg("%s\n", "not a dirty buffer");

/* now do quick frig to fix I/O streams: essentially fseek(s, 0, SEEK_CUR).
    if ((stream->__flag & (_IOREAD+_IOWRITE)) == (_IOREAD+_IOWRITE))
    {
      stream->__flag = stream->__flag & ~(_IOEOF|_IONOWRITES|_IOREADS|_IOPEOF)
                                                                   |_IOSEEK;
      stream->__icnt = stream->__ocnt = 0;
      stream->__extrap->__pos += (extent - buff);
      stream->__ptr = buff;
    }
*/

    return 0;
}

static void _deferredlazyseek(FILE *stream)
{
dbmsg("deferredlazyseek to %lld\n", stream->__extrap->_lspos);
    /* only here because of a seek */
    stream->__flag &= ~_IOLAZY;
    if (stream->__extrap->__pos != stream->__extrap->_lspos) {
      _fflush(stream);
      /* clear EOF condition */
dbmsg("%s\n", "clear IODIRTIED");
      stream->__flag = stream->__flag & ~(_IONOWRITES | _IONOREADS) | _IOSEEK;
      stream->__extrap->__pos = stream->__extrap->_lspos;
      stream->__ptr = stream->__extrap->__extent = stream->__base;
    }
else dbmsg("%s\n", ".....already there");
    stream->__flag &= ~(_IOEOF | _IOPEOF);
}

extern int __flsbuf(int ch, FILE *stream)
{   int flag;
dbmsg_noNL("%s ", "__flsbuf");
dbmsg_noNL("%c ",ch<32?' ':ch);
dbmsg_noNL("(%d/", ch);
dbmsg("&%02x)\n", ch);
    stream->__flag = (stream->__flag & ~_IOUNGET) | _IOACTIVE;

    if (stream->__flag & _IOLAZY) _deferredlazyseek(stream);

    if ((stream->__ocnt < -1) && !(stream->__flag & _IOLBF)) {
      /* buffer ~empty, sequence of events that lead to here are :          */
      /* put seek get seek put                                              */
dbmsg("flushbuf negative ocnt = %d\n", stream->__ocnt);
      stream->__ocnt = (-stream->__ocnt) - 2;
      stream->__flag |= (_IODIRTIED+_IONOREADS);           /* we are writing */
      return *(stream->__ptr)++ = (ch);
    }

    flag = stream->__flag;
    if ((flag & _IOERR+_IOSTRG+_IOWRITE+_IONOWRITES) != _IOWRITE)
    {   seterr(stream);
dbmsg("%s\n", "!= _IOWRITE");
        return EOF;
    }
/* the next conditional code is ACN's view of that APPEND means seek to     */
/* EOF after EVERY fflush, not just initially.  Hmm, ANSI really should     */
/* clarify - the problem is perhaps that we wish to seek to EOF after       */
/* fflush after read, but not after fflush after write?                     */
/* The line "if ((flag & (_IOSEEK+_IOAPPEND)) == (_IOSEEK+_IOAPPEND))"      */
/* which PH10 suggested does not work, try the sequence:                    */
/* create file with something in it; close file; open the file (append mode)*/
/* seek to start; write a char; THE CHAR WRITTEN IS NOT WRITTEN TO EOF      */
/* The following line has been reinstated cos it works.                     */
    if ((flag & (_IONOREADS+_IOSEEK+_IOAPPEND)) == _IOAPPEND)
/* Will somebody please help ACN remember/understand what was going on here!*/
    {   /* first write to APPEND file after FFLUSH, but not FSEEK nor       */
        /* fopen (does its own FSEEK)                                       */
        fseeko64(stream, 0LL, SEEK_END);
        if (stream->__flag & _IOLAZY) _deferredlazyseek(stream);
        flag = stream->__flag;
    }
dbmsg("%s\n", "set IODIRTIED");
    stream->__flag = (flag |= (_IODIRTIED+_IONOREADS));    /* we are writing */
    if (stream->__base == NULL)
    {   if (_sys_istty(stream)) {         /* terminal - unbuffered  */
            stream->__ptr = stream->__base = stream->__extrap->__lilbuf;
            stream->__bufsiz = 1;
            stream->__flag = (flag |= _IONBF);
        } else {
            /* allocate default system buffer */
            stream->__ptr = stream->__base = _sys_alloc(stream->__bufsiz);
            stream->__flag |= (flag |= _IOSBF);
            if ((flag & _IOLBF+_IOFBF) == 0) stream->__flag |= (flag |= _IOFBF);
        }
    }
    if (flag & _IOFBF)               /* system or user buffer */
    {   unsigned char *buff = stream->__base;
        unsigned int count = EXTENT(stream) - buff;
        if (count != 0) {
            if (_writebuf(buff, count, stream)) return EOF;
        }
        stream->__ptr = stream->__extrap->__extent = buff+1;
        stream->__ocnt = stream->__bufsiz - 1;
        stream->__extrap->__buflim = stream->__bufsiz;
        return (*buff = ch);
    }
    else     /* no buffer (i.e. 1 char private one) or line buffer */
    {   unsigned char *buff = stream->__base;
        unsigned int count;
        *stream->__ptr++ = ch;   /* always room */
        count = EXTENT(stream) - buff;
        stream->__extrap->__buflim = stream->__bufsiz;
        if ((flag & _IONBF) ||
               (unsigned char)ch == '\n' || count >= stream->__bufsiz)
        {   stream->__ptr = stream->__extrap->__extent = buff;
            stream->__ocnt = 0;                 /* 2^31 is big but finite */
            return _writebuf(buff, count, stream) ? EOF : (unsigned char)ch;
        }
        return (unsigned char)ch;
    }
}

extern int __filbuf(FILE *stream)
{   int w;
    unsigned char *buff;
    FILEHANDLE fh;
    off64_t over_limit;
    unsigned int request;
dbmsg("%s\n", "__filbuf");
    stream->__flag |= _IOACTIVE;
    if (stream->__flag & _IOUNGET) {
      stream->__icnt = stream->__extrap->__savedicnt;
      stream->__ocnt = stream->__extrap->__savedocnt;
      stream->__flag &= ~_IOUNGET;
      return stream->__extrap->__lilbuf[1];
    }

    if (stream->__flag & _IOLAZY) _deferredlazyseek(stream);

    /* note that sscanf (q.v.) requires this next line to yield EOF */
    if ((stream->__flag & (_IOEOF+_IOERR+_IOSTRG+_IOREAD+_IOPEOF+_IONOREADS))
                                                                    != _IOREAD)
    {   stream->__icnt = 0;                      /* 2^31 is big but finite */
        if (stream->__flag & _IOEOF+_IOPEOF+_IOSTRG)
            /* writing ok after EOF read according to ansi */
            stream->__flag = stream->__flag & ~(_IONOWRITES+_IOPEOF) | _IOEOF;
        else seterr(stream);
        return(EOF);
    }

    if ((stream->__flag & _IOSBF+_IONBF+_IODIRTIED) == 0)
    if ((stream->__base == NULL) && ((stream->__flag & _IODIRTIED) == 0))
    {
            /* allocate default system buffer */
            stream->__ptr = stream->__base = _sys_alloc(stream->__bufsiz);
            stream->__flag |= _IOSBF;
            if ((stream->__flag & _IOLBF+_IOFBF) == 0) stream->__flag |= _IOFBF;
    }

    if (stream->__icnt < -1) {
      /* buffer ~empty, came here cos seek wanted to to tidy up flags etc */
dbmsg("fillbuf negative icnt = %d\n", stream->__icnt);
      stream->__icnt = (-stream->__icnt) - 2;
      stream->__flag |= _IONOWRITES;           /* we are reading */
      return *(stream->__ptr)++;
    }

    fh = stream->__file;
    if (stream->__flag & _IOSEEK) {
      if (stream->__flag & _IODIRTIED) _fflush(stream);
      else {
dbmsg("fillbuf seeking to %lld\n", stream->__extrap->__pos);
        if (stream->__flag & _IOADFSBUG) {
          _sys_ensure(fh);
          stream->__flag &= ~_IOADFSBUG;
        }
        if (_sys_seek(fh, stream->__extrap->__pos) < 0)
        {   seterr(stream);
            return EOF;
        }
      }
    }

    stream->__flag |= _IONOWRITES;           /* we are reading */

    if (stream->__flag & _IODIRTIED) {
      unsigned int extent = (int) (EXTENT(stream) - stream->__base);
      request = stream->__bufsiz - extent;
      if (request == 0) {
        _fflush(stream);
        request = stream->__bufsiz;
      } else {
dbmsg("fillbuf flag %X\n", stream->__flag);
        if ((stream->__flag & (_IOBUFREAD+_IOSEEK)) == 0) {
dbmsg("fillbuf dirty buffer, read into end,seeking to %lld\n", stream->__extrap->__pos+extent);
          if (stream->__flag & _IOADFSBUG) {
            _sys_ensure(fh);
            stream->__flag &= ~_IOADFSBUG;
          }
          if (_sys_seek(fh, stream->__extrap->__pos + extent) < 0)
          {   seterr(stream);
              return EOF;
          } else stream->__flag |= _IOBUFREAD;
        }
      }
      buff = stream->__base + (stream->__bufsiz - request);
dbmsg_noNL("fillbuf not splatting out writ part of file request %d ", request);
dbmsg("at buff %X\n", (int)buff);
    } else {
      request = stream->__bufsiz;
      buff = stream->__base;
      stream->__extrap->__pos += stream->__ptr - buff;     /* add buf size for ftell() */
    }
    stream->__flag &= ~_IOSEEK;

    /* At this point, we are attempting to fill the buffer with data read from the
     * file, with no knowledge of where EOF might be. If the file pointer
     * corresponding to the start of the read is already at the maximum file pointer,
     * it's time to report EOVERFLOW. Since RISC OS is treated as a 'late' eof OS,
     * we can't detect EOF coinciding with the maximum file pointer - at least, not
     * without extending the armsys.c API, since polling the EOF flag requires a
     * separate OS_Args call which it would not be desirable to do on every call to
     * _sys_read(). If the file pointer corresponding to the end of the read lies
     * beyond the maximum file pointer, we need to truncate the read so as not to
     * cause FileSwitch to exceed the limit. If the C library client uses up this
     * truncated buffer, __filbuf will be called again, and we can report EOVERFLOW
     * at that time.
     */
    over_limit = stream->__extrap->__pos + stream->__bufsiz - request - ((stream->__flag & _IO64) ? OFF64_MAX : OFF32_MAX);
    if (over_limit >= 0) /* shouldn't actually ever be > 0, but just in case */
    {
        seterr(stream);
        errno = EOVERFLOW;
        return EOF;
    }
    else if (request > -over_limit)
        request = (unsigned int) -over_limit;

dbmsg("READING FROM FILE REQUEST = %d\n", request);
dbmsg("filelen = %lld\n",_sys_flen(fh));             /* length of this file */
    stream->__icnt = 0;
    w = _sys_read(fh, buff, request, stream->__flag);
    stream->__flag &= ~_IOADFSBUG;
dbmsg("_sys_read_ returned %d\n", w);
    if (w<0) {
      if (w >= (unsigned int) _kernel_ERROR) { seterr(stream); return EOF; }
      /* this deals with operating systems with 'early' eof */
      stream->__flag |= _IOPEOF;
      w = w & 0x7fffffff;
    }
    w = request - w;
dbmsg("read %d bytes\n", w);
    stream->__extrap->__extent = buff + w;
    stream->__extrap->__buflim = stream->__bufsiz;
    if (w==0)    /* this deals with operating systems with 'late' eof  */
    {   stream->__flag |= _IOEOF;                /* is this case independent? */
        stream->__flag &= ~_IONOWRITES;          /* writing OK after EOF read */
        stream->__icnt = 0;
        stream->__ptr = buff;  /* just for fun - NB affects ftell() - check */
        return(EOF);
    }
    else
    {   stream->__icnt = w-1;
        stream->__ptr = buff+1;
        stream->__flag |= _IOBUFREAD;
        return(buff[0]);
    }
}

static int _fillb2(FILE *stream)
{   if (__filbuf(stream) == EOF) return EOF;
    stream->__icnt++;
    stream->__ptr--;
    return 0;
}

int fclose(FILE *stream)
{   /* MUST be callable on a closed file - if stream clr then no-op. */
    FILEHANDLE fh;
    unsigned char *buff;
    int flag;
    _extradatap extrap;
    int res = 0;

    /* Deal with programs calling fclose(0), ECN 21-09-93 */
    if (!stream) return EOF;
    fh = stream->__file;
    buff = stream->__base;
    flag = stream->__flag;
    extrap = stream->__extrap;
    if (!(flag & _IOREAD+_IOWRITE)) return EOF;   /* already closed    */
    if (!(flag & _IOSTRG))                    /* from _fopen_string    */
    {   int fd = _SYS_OPEN;
        res = fflush(stream);
        if (flag & _IOSHARED)
        {   /* No need to check FILElist, as only FILEs in __iob can be */
            /* shared by __dup().                                       */
            for (fd =  0;  fd < _SYS_OPEN;  ++fd)
            {   FILE *f = &__iob[fd];
                if ((f != stream) &&
                    (f->__flag & _IOREAD+_IOWRITE) &&     /* f is open */
                    (f->__file == fh) && (f->__flag & _IOSHARED))
                {   f->__flag &= ~_IOSHARED;       /* no longer shared */
                    stream->__flag &= ~_IOSHARED;
                    break;
                }
            }
        }
        /* Assert: fd != SYS_OPEN => fh is shared and mustn't be closed */
        if (fd == _SYS_OPEN &&
            _sys_close(fh) < 0) res = EOF;          /* close real file */
        if (flag & _IOSBF) free(buff);         /* free buffer if system */
        if ((flag & _IODELMSK) == _IODEL)
        {   char name[L_tmpnam];
            _sys_tmpnam_(name, stream->__signature);
            if (remove(name) != 0) res = EOF; /* delete the file if pos */
        }
    }
    memclr(stream->__extrap, sizeof(_extradata));
    memclr(stream, sizeof(FILE));
    stream->__extrap = extrap;
    return res;
}

static FILE *freopen_common(const char *name, const char *mode, FILE *iob, int flag64, off64_t limit)
{
/* The use of modes "r+", "w+" and "a+" is not fully thought out   */
/* yet, in that calls to __flsbuf may write back stuff that was    */
/* loaded by __filbuf and thereby corrupt the file.                */
/* This is now just about fixed given the ANSI restriction that    */
/* calls to getc/putc must be fflush/fseek separated.              */
    FILEHANDLE fh;
    int flag, openmode;        /* nasty magic numbers for openmode */
    fclose(iob);
    switch (*mode++)
    {   default:  return NULL;        /* 1st of mode must be r/w/a */
        case 'r': flag = _IOREAD;  openmode = OPEN_R; break;
        case 'w': flag = _IOWRITE; openmode = OPEN_W; break;
        case 'a': flag = _IOWRITE | _IOAPPEND;
                                   openmode = OPEN_A; break;
    }
    for (;;)
    {   switch (*mode++)
        {                                  /* 2nd can be b/+/b+/+b */
    case '+':   flag |= _IOREAD+_IOWRITE, openmode |= OPEN_PLUS;
                continue;
    case 'b':   flag |= _IOBIN, openmode |= OPEN_B;
                continue;
    case 'x':   if (*mode != '\0' ||   /* must be last and writing */
                    !(openmode & OPEN_W)) return NULL;    
                openmode |= OPEN_X; break;
        }
        break;
    }
    if ((fh = _sys_open(name, openmode)) == NONHANDLE) return NULL;
    if (_sys_flen(fh) > limit)
    {
        errno = EOVERFLOW;
        _sys_close(fh);
        return NULL;
    }
    flag |= flag64;
    if (_kernel_client_is_module()) flag |= _IOUSERFILE;
    iob->__ptr = iob->__base = NULL; iob->__bufsiz = BUFSIZ;
    iob->__flag = flag;
    iob->__file = fh;
    if (openmode & OPEN_A) fseeko64(iob, 0LL, SEEK_END);  /* a or a+             */
    return iob;
}

FILE *freopen(const char *name, const char *mode, FILE *iob)
{
    return freopen_common(name, mode, iob, 0, OFF32_MAX);
}

FILE *freopen64(const char *name, const char *mode, FILE *iob)
{
    return freopen_common(name, mode, iob, _IO64, OFF64_MAX);
}

FILE *fopen(const char *name, const char *mode)
{   FILE *stream = _getFILE();
    if (stream)
        return (freopen(name, mode, stream));
    return 0;   /* no more i/o channels allowed for */
}

FILE *fopen64(const char *name, const char *mode)
{   FILE *stream = _getFILE();
    if (stream)
        return (freopen64(name, mode, stream));
    return 0;   /* no more i/o channels allowed for */
}

FILEHANDLE __dup(int new, int old)
{   FILE *s_new, *s_old;
    (void) fclose(&__iob[new]);
    s_new = &__iob[new];
    s_old = &__iob[old];
    s_old->__flag |= _IOSHARED;
    s_new->__flag = s_old->__flag & (_IOREAD+_IOWRITE+_IOAPPEND+_IOSHARED+
                                              _IOSBF+_IOFBF+_IOLBF+_IONBF);
    s_new->__file = s_old->__file;
    return s_new->__file;
}

#if 0
FILE *_fopen_string_file(const char *data, int length)
{
/* open a file that will read data from the given string argument        */
/* The declaration of this function in #include "hostsys.h" suggests     */
/* that this function is of type (void *), so this definition will lead  */
/* to a warning message.                                                 */
    FILE *stream = _getFILE();
    if (stream)
    {   fclose(stream);
        stream->__flag = _IOSTRG+_IOREAD+_IOACTIVE;
        stream->__ptr = stream->__base = (unsigned char *)data;
        stream->__icnt = length;
        return stream;
    }
    return 0;   /* no more i/o channels allowed for */
}
#endif

int _fisatty(FILE *stream)  /* not in ANSI, but related needed for ML */
{   if ((stream->__flag & _IOREAD) && _sys_istty(stream)) return 1;
    return 0;
}

/* initialisation/termination code... */


void _initio(char *f1,char *f2,char *f3)
{
    int i;
    char v[128];
    memclr(__iob, _SYS_OPEN*sizeof(FILE));
/*  _extra = calloc(_SYS_OPEN, sizeof(_extradata)); */
    _extra = _sys_alloc(_SYS_OPEN * sizeof(_extradata));
    memclr(_extra, _SYS_OPEN * sizeof(_extradata));
    for (i=0; i<_SYS_OPEN; i++) __iob[i].__extrap = _extra+i;
    /* In the next lines DO NOT use standard I/O for error msgs (not open yet)
       Moreover, open in this order so we do not create/overwrite output if
       input does not exist. */
    if (freopen(f3, "w", stderr) == 0)
        _sprintf_lf(v,_kernel_getmessage("Couldn't write %s", "C46"), f3), _sys_msg(v), exit(1);
    if (freopen(f1, "r", stdin) == 0)
        _sprintf_lf(v,_kernel_getmessage("Couldn't read %s", "C47"), f1), _sys_msg(v), exit(1);
    if (freopen(f2, "w", stdout) == 0)
        _sprintf_lf(v,_kernel_getmessage("Couldn't write %s", "C46"), f2), _sys_msg(v), exit(1);
}

void _terminateio(void)
{   int i;
    int closeall = !_kernel_client_is_module();
    _FILElistp fp;
    for (i=3; i<_SYS_OPEN; i++) {
        FILE *f = &__iob[i];
        if (closeall || (f->__flag & _IOUSERFILE)) fclose(f);
    }
    for (fp = _flist; fp; fp = fp->next) {
        FILE *f = &fp->file;
        if (closeall || (f->__flag & _IOUSERFILE)) fclose(f);
    }
    /* for cowardice do stdin, stdout, stderr last (in that order) */
    for (i=0; i<3; i++) {
        FILE *f = &__iob[i];
        if (closeall || (f->__flag & _IOUSERFILE)) {
            fclose(f);
            if (!closeall) freopen(TTYFILENAME, (f == stdin ? "r" : "w"), f);
        }
    }
    if (closeall) {
        _FILElistp fpnext;
        for (fp = _flist; fp; fp = fpnext) {
            fpnext = fp->next;
            free(fp);
        }
        _flist = 0;
        free(_extra);
        _extra = 0;
    }
}


/* now the less machine dependent functions ... */

char *fgets(char *s, int n, FILE *stream)
{   char *a = s;
    if (n <= 1) return NULL;                  /* best of a bad deal */
    do { int ch = getc(stream);
         if (ch == EOF)                       /* error or EOF       */
         {   if (s == a) return NULL;         /* no chars -> leave  */
             if (ferror(stdin)) a = NULL;
             break; /* add NULL even if ferror(), spec says 'indeterminate' */
         }
         if ((*s++ = ch) == '\n') break;
       }
       while (--n > 1);
    *s = 0;
    return a;
}

char *gets(char *s)
{   char *a = s;
    for (;;)
    {    int ch = getc(stdin);
         if (ch == EOF)                       /* error or EOF       */
         {   if (s == a) return NULL;         /* no chars -> leave  */
             if (ferror(stdin)) a = NULL;
             break; /* add NULL even if ferror(), spec says 'indeterminate' */
         }
         if (ch == '\n') break;
         *s++ = ch;
    }
    *s = 0;
    return a;
}

int fputs(const char *s, FILE *stream)
{
    char c;
    while((c = *s++) != 0)
        if(putc(c, stream)==EOF) return(EOF);
    return(0);
}

int puts(const char *s)
{
    char c;
    while ((c = *s++) != 0)
       if (putchar(c) == EOF) return EOF;
    return putchar('\n');
}

/* _read improved to use __filbuf and block moves.  Optimisation
   to memcpy too if word move.  Still possible improvements avoiding copy
   but I don't want to do these yet because of interactions
   (e.g. __pos of a file).   N.B.  _read is not far from unix 'read' */
static int _read(char *ptr, int nbytes, FILE *stream)
{   int i = nbytes;
dbmsg("%s\n", "_read");
    if (i == 0) return 0;
    if (stream->__flag & _IOUNGET) {
      *ptr++ = __filbuf(stream); i--;
    }
    if (stream->__flag & _IOLAZY) _deferredlazyseek(stream);
    do
    {
dbmsg("in _read, icnt = %d\n", stream->__icnt);
        if (i <= stream->__icnt)
        {   memcpy(ptr, stream->__ptr, i);
            stream->__icnt -= i; stream->__ptr += i;
            return nbytes;
        }
        else if (stream->__icnt >= 0)
        {   memcpy(ptr, stream->__ptr, stream->__icnt);
            ptr += stream->__icnt, i -= stream->__icnt;
            stream->__ptr += stream->__icnt, stream->__icnt = -1; /* for __pos */
        }
        else stream->__icnt--;
    } while (_fillb2(stream) != EOF);
    return nbytes-i;
/*
    for (i=0; i<nbytes; i++)
    {   if ((ch = getc(stream)) == EOF) return i;
        *ptr++ = ch;
    }
    return nbytes;
*/
}

size_t fread(void *ptr, size_t itemsize, size_t count, FILE *stream)
{    /* ANSI spec says EOF and ERR treated the same as far as fread
      * is concerned and that the number of WHOLE items read is returned.
      */
dbmsg("fread %d\n", count);
    ENSUREBYTE(stream, 0);
    return itemsize == 0 ? 0   /* slight ansi irrationality */
                         : _read(ptr, itemsize*count, stream) / itemsize;
}

static int _write(const char *ptr, unsigned int nbytes, FILE *stream)
{   unsigned int i;
    if (_sys_istty(stream) || (stream->__flag & _IONBF)) {
      for(i=0; i<nbytes; i++)
        if (putc(*ptr++, stream) == EOF) return 0;
        /* H&S say 0 on error */
    }
    else if (nbytes > 0) {
      unsigned int so_far = 0;

      if (stream->__ocnt < 0) {
        /* Not ready for writes, so do one putc to force it into a nice state. */
        if (putc(*ptr++, stream) == EOF) return 0;
        ++so_far;
      }

      if (stream->__ocnt >= (nbytes - so_far)) {
        /* output will fit completely into our output buffer */
        memcpy(stream->__ptr, ptr, nbytes - so_far);
        stream->__ptr += nbytes - so_far;
        stream->__ocnt -= nbytes - so_far;
        ptr += nbytes - so_far;
      }
      else {
        /* Fill the existing buffer */
        if (stream->__ocnt > 0) {
          /* Space exists - write the data to the buffer en bloc */
          memcpy(stream->__ptr, ptr, stream->__ocnt);
          stream->__ptr += stream->__ocnt;
          ptr += stream->__ocnt;
          so_far += stream->__ocnt;
          stream->__ocnt = 0;
        }

        /* To get here, there are more bytes to write, and the current write buffer is full
         * OR non-existant.  We need to write (nbytes - so_far) bytes, at ptr to 'stream'.
         * Buffer does exist if __ocnt is zero.  Thus the call to __flsbuf will flush any
         * filled buffers AND/OR initialise the data structures to accept written data,
         * so we can legally check __ocnt, __flags and __bufsiz.  This call to __flsbuf is
         * basically simulating putc, so it MUST always decrement __ocnt before the call.
         */
        --stream->__ocnt;
        if (__flsbuf(*ptr++, stream) == EOF) return 0;
        so_far++;

        /* Now we have guaranteed a single character write, we can inspect the stream data
         * to see the size of the buffer and start bypassing the buffering
         */
        if (stream->__ocnt > 0 && (stream->__flag & _IOFBF) && stream->__bufsiz > 0) {
          /* Looks like it is worth attempting a direct write to the file */
          unsigned int nblocks, count, loop;
          nblocks = (nbytes == so_far) ? 0 : (nbytes - so_far - 1) / stream->__bufsiz;
          if (nblocks > 0) {
            /* There cannot be any _IOLAZY pending as __flsbuf will have taken care of it.
             * We want _writebuf to simply pass this data directly to _sys_write (and under
             * RISC OS to OS_GBPB)
             */
            /* Wind back one character so we can attempt block writes */
            --ptr;
            --so_far;
            ++stream->__ocnt;
            --stream->__ptr;
            --stream->__extrap->__extent;
#ifdef WRITE_ONCE
            count = nblocks * stream->__bufsiz;
            (void) loop;
#else
            count = stream->__bufsiz;
            for (loop = 0; loop < nblocks; ++loop) {
#endif
              if (_writebuf((unsigned char *)ptr, count, stream)) {
                return 0;
              }
              so_far += count;
              ptr += count;
#ifndef WRITE_ONCE
            }
#endif
          }

          i = nbytes - so_far; /* Number of bytes remaining for partial buffer */
          if (i > 0 && stream->__ocnt >= i) {
            /* Second condition above *should* be always true */
            memcpy(stream->__ptr, ptr, i);
            stream->__ptr += i;
            ptr += i;
            so_far += i;
            stream->__ocnt -= i;
          }
        }

        /* Finally, the last few bytes are written in the naive loop */
        for (i=so_far; i<nbytes; ++i) {
          if (putc(*ptr++, stream) == EOF) return 0;
        }
      }
    }
    return nbytes;
}

size_t fwrite(const void *ptr, size_t itemsize, size_t count, FILE *stream)
{
/* The comments made about fread apply here too */
dbmsg_noNL("fwrite %d ", count);
dbmsg("itemsize %d (decimal)\n", itemsize);
    ENSUREBYTE(fwrite, 0);
    return itemsize == 0 ? count
                         : _write(ptr, itemsize*count, stream) / itemsize;
}

/* back to machine dependent functions */

#define _ftell(stream) (  (stream)->__flag & _IOLAZY \
                        ? (stream)->__extrap->_lspos \
                        : (stream)->__extrap->__pos + (stream)->__ptr - (stream)->__base)

static off64_t ftell_common(FILE * stream, off64_t limit)
{  off64_t pos;
   if (!(stream->__flag & _IOREAD+_IOWRITE))     /* already closed        */
   { errno = EDOM;
     return -1LL;
   }
   pos = _ftell(stream);
   if (stream->__flag & _IOUNGET && pos > 0) --pos;
   if ((unsigned long long) pos > limit)
   {
       errno = EOVERFLOW;
       return -1LL;
   }
   return pos;
}

long int ftell(FILE *stream)
{
    return (long int) ftell_common(stream, OFF32_MAX);
}

off64_t ftello64(FILE * stream)
{
    return ftell_common(stream, OFF64_MAX);
}

/* The treatment of files that can be written to seems complicated in fseek */

static int fseek_common(FILE *stream, off64_t offset, int whence, off64_t limit)
{
    FILEHANDLE fh = stream->__file;
    int flag = stream->__flag;
dbmsg_noNL("%s ", "SEEK ENTRY");

    if (!(flag & _IOREAD+_IOWRITE+_IOSHARED) || _sys_istty(stream))
        return(2);                              /* fseek impossible  */

    switch(whence)
    {
case SEEK_SET:
        break;                                  /* relative to file start */
case SEEK_CUR:
        offset += ftello64(stream);             /* relative seek */
        break;
case SEEK_END:
        {   off64_t filelen, filepos;
            filelen = _sys_flen(fh);           /* length of this file      */
dbmsg("filelen in seek = %lld\n", filelen);
            if (filelen<0)                      /* failed to read length    */
            {   seterr(stream);
                return 1;
            }
            filepos = stream->__extrap->__pos + EXTENT(stream) - stream->__base;
            if (stream->__flag & _IOLAZY && filepos < stream->__extrap->_lspos)
              filepos = stream->__extrap->_lspos;
            if (filepos>filelen)                /* only possible on write   */
                filelen = filepos;              /* allow for stuff buffered */
            offset += filelen;                  /* relative to end of file  */
        }
        break;
default:
        seterr(stream);
        return(2);                              /* illegal operation code   */
    }

    if (offset < 0) { seterr(stream); return 2; } /* fseek impossible  */

    if (offset > limit)
    {
        seterr(stream);
        errno = EOVERFLOW;
        return 2;
    }

    if ((flag & _IONOREADS) && stream->__extrap->__extent < stream->__ptr)
      stream->__extrap->__extent = stream->__ptr;

dbmsg_noNL("%s ", "SEEK");
dbmsg_noNL("__pos %lld", stream->__extrap->__pos);
dbmsg_noNL(" offset %d", (int)offset);
dbmsg_noNL(" buflim %d", stream->__extrap->__buflim);
dbmsg_noNL(" __ptr %X", (int)stream->__ptr);
dbmsg_noNL(" __icnt %d", stream->__icnt);
dbmsg_noNL(" __ocnt %d", stream->__ocnt);
dbmsg_noNL(" __base %X", (int)stream->__base);

    if (offset < stream->__extrap->__pos ||
      offset > stream->__extrap->__pos + EXTENT(stream) - stream->__base ||
      offset >= stream->__extrap->__pos + stream->__extrap->__buflim)

      { /* outside buffer */
dbmsg("%s\n", " outside buffer");
      flag |= _IOLAZY;
      stream->__icnt = stream->__ocnt = 0;
      stream->__extrap->_lspos = offset;
    } else { /* inside buffer */
dbmsg("%s\n", " inside buffer");
      offset -= stream->__extrap->__pos;
      if (flag & _IOWRITE)
        stream->__ocnt = -(stream->__extrap->__buflim - (int)offset);
      if (flag & _IOREAD)
        stream->__icnt = -((int)(EXTENT(stream) - stream->__base) - (int)offset);
      stream->__ptr = stream->__base + offset;
      flag &= ~_IOLAZY;
    }
dbmsg_noNL("AFTER SEEK __ptr %X", (int)stream->__ptr);
dbmsg_noNL(" __icnt %d", stream->__icnt);
dbmsg(" __ocnt %d\n", stream->__ocnt);
    stream->__flag = flag & ~(_IOEOF+_IONOWRITES+_IONOREADS+_IOUNGET);

    return 0;
}

int fseek(FILE *stream, long int offset, int whence)
{
    return fseek_common(stream, offset, whence, OFF32_MAX);
}

int fseeko64(FILE *stream, off64_t offset, int whence)
{
    return fseek_common(stream, offset, whence, OFF64_MAX);
}

static int _do_fflush(FILE *stream)
{ /* ignore the effect of a previous unget on the file position indicator by
     using _ftell rather than ftell */
  if (stream->__flag & _IOREAD+_IOWRITE)   /* not open */
  { off64_t offset = _ftell(stream);
    int res;
dbmsg("%s\n", "fflush");
    if (stream->__flag & _IOLAZY) _deferredlazyseek(stream);
    stream->__flag &= ~(_IONOREADS+_IONOWRITES);
    res =_fflush(stream);
    fseeko64(stream, offset, SEEK_SET);
    return res;
  } else return 0;
}

int fflush(FILE *stream)
{ /* new definition (ANSI May 88) says that if stream == NULL, apply fflush to
     all applicable streams */
   int res = 0;
   if (stream != NULL)
     res =_do_fflush(stream);
   else
   { int i;
     _FILElistp fp;
     for (i=0; i<_SYS_OPEN; i++)
       if (_do_fflush(&__iob[i]) != 0) res = EOF;
     for (fp=_flist; fp; fp=fp->next)
       if (_do_fflush(&fp->file) != 0) res = EOF;
   }
   return res;
}

void rewind(FILE *stream)
{
   fseeko64(stream, 0LL, SEEK_SET);
   clearerr(stream);
}

/* the following routines need to become the main entry I suppose          */
int fgetpos(FILE *stream, fpos_t *pos)
{  *pos = ftell(stream);
   return 0;
}

int fgetpos64(FILE *stream, fpos64_t *pos)
{  *pos = ftello64(stream);
   return 0;
}

int fsetpos(FILE *stream, const fpos_t *pos)
{  int res = fseek(stream, *pos, SEEK_SET);
   if (res) errno = EDOM;
   return res;
}

int fsetpos64(FILE *stream, const fpos64_t *pos)
{  int res = fseeko64(stream, *pos, SEEK_SET);
   if (res) errno = EDOM;
   return res;
}

static char _tmp_file_name[L_tmpnam] = "";
static int _tmp_file_sig;

char *tmpnam(char *a)
{
/* Obtaining an unique name is tolerably nasty - what I do here is       */
/* derive the name (via _sys_tmpnam_())                                  */
/* from an integer that is constructed out of a serial number combined   */
/* with the current clock setting. An effect of this is that the file    */
/* name can be reconstructed from a 32-bit integer for when I want to    */
/* delete the file. The serial number is held in zero page and is        */
/* returned and incremented by __counter(). This ensures uniqueness      */
/* if tmpnam is called from two applications within the same second.     */
    _kernel_osfile_block fb;

    if (a==NULL) a = _tmp_file_name;
    do {
      _tmp_file_sig = ((int)time(NULL) << 8) | __counter();
      _sys_tmpnam_(a, _tmp_file_sig);
    } while (_kernel_osfile(17, a, &fb) != 0);

    return a;
}

extern char *__old_tmpnam(char *a);
char *__old_tmpnam(char *a)
{
    return tmpnam(a);
}

FILE *tmpfile(void)
{
    char name[L_tmpnam];
    FILE *f;
    f = fopen(tmpnam(name), "w+b");
    if (f)
    {   f->__flag |= _IODEL;
        f->__signature = _tmp_file_sig;
    }
    return f;
}

FILE *tmpfile64(void)
{
    char name[L_tmpnam];
    FILE *f;
    f = fopen64(tmpnam(name), "w+b");
    if (f)
    {   f->__flag |= _IODEL;
        f->__signature = _tmp_file_sig;
    }
    return f;
}

void perror(const char *s)
{   char b[256];
    if (s != 0 && *s != 0) fprintf(stderr, "%s: ", s);
    fprintf(stderr, "%s\n", _strerror(errno, b));
}

/* end of stdio.c */
