/* Copyright 2022 RISC OS Open Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef NOATOMIC_H
#define NOATOMIC_H

#include <stdbool.h>
#include <stdint.h>

/* Inlined non-atomic versions of the atomic functions that are benchmarked, to provide a reference point for the comparisons */

typedef volatile uint8_t  noatomic_uchar;
typedef volatile uint16_t noatomic_ushort;
typedef volatile uint32_t noatomic_uint;
typedef volatile uint64_t noatomic_ullong;
typedef volatile bool     noatomic_flag;

#define noatomic_store_explicit(obj,desired,order) *(obj) = desired
#define noatomic_load_explicit(obj,order) (*(obj))

static inline uint8_t  noatomic_exchange_1(noatomic_uchar * obj, uint8_t  desired) { uint8_t  old = *obj; *obj = desired; return old; }
static inline uint16_t noatomic_exchange_2(noatomic_ushort* obj, uint16_t desired) { uint16_t old = *obj; *obj = desired; return old; }
static inline uint32_t noatomic_exchange_4(noatomic_uint  * obj, uint32_t desired) { uint32_t old = *obj; *obj = desired; return old; }
static inline uint64_t noatomic_exchange_8(noatomic_ullong* obj, uint64_t desired) { uint64_t old = *obj; *obj = desired; return old; }
#define noatomic_exchange_explicit(obj,desired,order) (_Generic(*(obj) \
, uint8_t          : noatomic_exchange_1((noatomic_uchar  *) obj, desired) \
, uint16_t         : noatomic_exchange_2((noatomic_ushort *) obj, desired) \
, uint32_t         : noatomic_exchange_4((noatomic_uint   *) obj, desired) \
, uint64_t         : noatomic_exchange_8((noatomic_ullong *) obj, desired) \
))

static inline _Bool noatomic_compare_exchange_1(noatomic_uchar * obj, volatile uint8_t * expected, uint8_t  desired) { uint8_t  val = *obj; if (val == *expected) { *obj = desired; return true; } else { *expected = val; return false; } }
static inline _Bool noatomic_compare_exchange_2(noatomic_ushort* obj, volatile uint16_t* expected, uint16_t desired) { uint16_t val = *obj; if (val == *expected) { *obj = desired; return true; } else { *expected = val; return false; } }
static inline _Bool noatomic_compare_exchange_4(noatomic_uint  * obj, volatile uint32_t* expected, uint32_t desired) { uint32_t val = *obj; if (val == *expected) { *obj = desired; return true; } else { *expected = val; return false; } }
static inline _Bool noatomic_compare_exchange_8(noatomic_ullong* obj, volatile uint64_t* expected, uint64_t desired) { uint64_t val = *obj; if (val == *expected) { *obj = desired; return true; } else { *expected = val; return false; } }
#define noatomic_compare_exchange_weak_explicit(obj,expected,desired,succ,fail) (_Generic(*(obj) \
, uint8_t        : noatomic_compare_exchange_1((noatomic_uchar  *) obj, (volatile uint8_t *) expected, desired) \
, uint16_t       : noatomic_compare_exchange_2((noatomic_ushort *) obj, (volatile uint16_t*) expected, desired) \
, uint32_t       : noatomic_compare_exchange_4((noatomic_uint   *) obj, (volatile uint32_t*) expected, desired) \
, uint64_t       : noatomic_compare_exchange_8((noatomic_ullong *) obj, (volatile uint64_t*) expected, desired) \
))
#define noatomic_compare_exchange_strong_explicit noatomic_compare_exchange_weak_explicit

static inline uint8_t  noatomic_add_1(noatomic_uchar * obj, uint8_t  arg) { uint8_t  old = *obj; *obj = old+arg; return old; }
static inline uint16_t noatomic_add_2(noatomic_ushort* obj, uint16_t arg) { uint16_t old = *obj; *obj = old+arg; return old; }
static inline uint32_t noatomic_add_4(noatomic_uint  * obj, uint32_t arg) { uint32_t old = *obj; *obj = old+arg; return old; }
static inline uint64_t noatomic_add_8(noatomic_ullong* obj, uint64_t arg) { uint64_t old = *obj; *obj = old+arg; return old; }
#define noatomic_fetch_add_explicit(obj,arg,order) (_Generic(*(obj) \
, uint8_t          : noatomic_add_1((noatomic_uchar  *) obj, arg) \
, uint16_t         : noatomic_add_2((noatomic_ushort *) obj, arg) \
, uint32_t         : noatomic_add_4((noatomic_uint   *) obj, arg) \
, uint64_t         : noatomic_add_8((noatomic_ullong *) obj, arg) \
))

static inline uint8_t  noatomic_xor_1(noatomic_uchar * obj, uint8_t  arg) { uint8_t  old = *obj; *obj = old^arg; return old; }
static inline uint16_t noatomic_xor_2(noatomic_ushort* obj, uint16_t arg) { uint16_t old = *obj; *obj = old^arg; return old; }
static inline uint32_t noatomic_xor_4(noatomic_uint  * obj, uint32_t arg) { uint32_t old = *obj; *obj = old^arg; return old; }
static inline uint64_t noatomic_xor_8(noatomic_ullong* obj, uint64_t arg) { uint64_t old = *obj; *obj = old^arg; return old; }
#define noatomic_fetch_xor_explicit(obj,arg,order) (_Generic(*(obj) \
, uint8_t          : noatomic_xor_1((noatomic_uchar  *) obj, arg) \
, uint16_t         : noatomic_xor_2((noatomic_ushort *) obj, arg) \
, uint32_t         : noatomic_xor_4((noatomic_uint   *) obj, arg) \
, uint64_t         : noatomic_xor_8((noatomic_ullong *) obj, arg) \
))

#define NOATOMIC_FLAG_INIT ((noatomic_flag) false)

static inline _Bool noatomic_flag_test_and_set_explicit(volatile noatomic_flag *obj, memory_order order) { bool old = *obj; *obj = true; return old; }

#define noatomic_flag_clear_explicit(obj,order) *(obj) = false

#endif
