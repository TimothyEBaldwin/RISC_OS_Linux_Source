/* Copyright 2022 RISC OS Open Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifdef USE_ROATOMIC
#include "roatomic.h"
#else
#include <stdatomic.h>
#endif

#include <stdbool.h> // bool
#include <stddef.h> // ptrdiff_t, size_t, wchar_t
#include <stdint.h> // assorted integer types
#include <uchar.h> // char16_t, char32_t

#define assert(X) if (!(X)) { printf("Test failure: %s @ %s %d\n",#X,__FILE__,__LINE__); return; }
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CONCAT(X,Y) CONCAT2(Y,X)
#define CONCAT2(Y,X) X##Y

#define ATOMIC char
#define BASE char
#include "atomic1i.c"
#define ATOMIC schar
#define BASE signed char
#include "atomic1i.c"
#define ATOMIC uchar
#define BASE unsigned char
#include "atomic1i.c"
#define ATOMIC short
#define BASE short
#include "atomic1i.c"
#define ATOMIC ushort
#define BASE unsigned short
#include "atomic1i.c"
#define ATOMIC int
#define BASE int
#include "atomic1i.c"
#define ATOMIC uint
#define BASE unsigned int
#include "atomic1i.c"
#define ATOMIC long
#define BASE long
#include "atomic1i.c"
#define ATOMIC ulong
#define BASE unsigned long
#include "atomic1i.c"
#define ATOMIC llong
#define BASE long long
#include "atomic1i.c"
#define ATOMIC ullong
#define BASE unsigned long long
#include "atomic1i.c"
#define ATOMIC char16_t
#define BASE char16_t
#include "atomic1i.c"
#define ATOMIC char32_t
#define BASE char32_t
#include "atomic1i.c"
#define ATOMIC wchar_t
#define BASE wchar_t
#include "atomic1i.c"
#define ATOMIC int_least8_t
#define BASE int_least8_t
#include "atomic1i.c"
#define ATOMIC uint_least8_t
#define BASE uint_least8_t
#include "atomic1i.c"
#define ATOMIC int_least16_t
#define BASE int_least16_t
#include "atomic1i.c"
#define ATOMIC uint_least16_t
#define BASE uint_least16_t
#include "atomic1i.c"
#define ATOMIC int_least32_t
#define BASE int_least32_t
#include "atomic1i.c"
#define ATOMIC uint_least32_t
#define BASE uint_least32_t
#include "atomic1i.c"
#define ATOMIC int_least64_t
#define BASE int_least64_t
#include "atomic1i.c"
#define ATOMIC uint_least64_t
#define BASE uint_least64_t
#include "atomic1i.c"
#define ATOMIC int_fast8_t
#define BASE int_fast8_t
#include "atomic1i.c"
#define ATOMIC uint_fast8_t
#define BASE uint_fast8_t
#include "atomic1i.c"
#define ATOMIC int_fast16_t
#define BASE int_fast16_t
#include "atomic1i.c"
#define ATOMIC uint_fast16_t
#define BASE uint_fast16_t
#include "atomic1i.c"
#define ATOMIC int_fast32_t
#define BASE int_fast32_t
#include "atomic1i.c"
#define ATOMIC uint_fast32_t
#define BASE uint_fast32_t
#include "atomic1i.c"
#define ATOMIC int_fast64_t
#define BASE int_fast64_t
#include "atomic1i.c"
#define ATOMIC uint_fast64_t
#define BASE uint_fast64_t
#include "atomic1i.c"
#define ATOMIC intptr_t
#define BASE intptr_t
#include "atomic1i.c"
#define ATOMIC uintptr_t
#define BASE uintptr_t
#include "atomic1i.c"
#define ATOMIC size_t
#define BASE size_t
#include "atomic1i.c"
#define ATOMIC ptrdiff_t
#define BASE ptrdiff_t
#include "atomic1i.c"
#define ATOMIC intmax_t
#define BASE intmax_t
#include "atomic1i.c"
#define ATOMIC uintmax_t
#define BASE uintmax_t
#include "atomic1i.c"

void test_atomic_flag(void)
{
  printf("test_atomic_flag\n");
  atomic_flag a = ATOMIC_FLAG_INIT;
  bool old = atomic_flag_test_and_set(&a);
  assert(!old);
  old = atomic_flag_test_and_set(&a);
  assert(old);
  atomic_flag_clear(&a);
  old = atomic_flag_test_and_set(&a);
  assert(!old);
}

void test_bool(void)
{
  printf("test_bool\n");

  atomic_bool A;
  bool t,x;
  const bool a = true, b = false;
  atomic_bool *Aptr = &A;

  atomic_init(Aptr, a);
  t = atomic_load(Aptr);
  assert(t == a);

  atomic_store(Aptr, b);
  t = atomic_load(Aptr);
  assert(t == b);

  t = atomic_exchange(Aptr, a);
  assert(t == b);
  t = atomic_load(Aptr);
  assert(t == a);

  /* Successful compare-exchange */
  t = a;
  x = atomic_compare_exchange_strong(Aptr, &t, b);
  assert(x);
  assert(t == a);
  t = atomic_load(Aptr);
  assert(t == b);

  /* Failing compare-exchange */
  t = a;
  x = atomic_compare_exchange_strong(Aptr, &t, b);
  assert(!x);
  assert(t == b);
  t = atomic_load(Aptr);
  assert(t == b);
}

void runtests(void)
{
  /* ~8 bit types */
  test_char          (0x7b,0x44,0x14);
  test_schar         (0x7b,0x44,0x14);
  test_uchar         (0x7b,0x44,0x14);
  test_int_least8_t  (0x7b,0x44,0x14);
  test_uint_least8_t (0x7b,0x44,0x14);
  test_int_fast8_t   (0x7b,0x44,0x14);
  test_uint_fast8_t  (0x7b,0x44,0x14);

  /* ~16 bit types */
  test_short         (0x387b,0x1844,0x2014);
  test_ushort        (0x387b,0x1844,0x2014);
  test_char16_t      (0x387b,0x1844,0x2014);
  test_int_least16_t (0x387b,0x1844,0x2014);
  test_uint_least16_t(0x387b,0x1844,0x2014);
  test_int_fast16_t  (0x387b,0x1844,0x2014);
  test_uint_fast16_t (0x387b,0x1844,0x2014);

  /* ~32bit types */
  test_int           (0x3842107b,0x18633544,0x20fbca14);
  test_uint          (0x3842107b,0x18633544,0x20fbca14);
  test_long          (0x3842107b,0x18633544,0x20fbca14);
  test_ulong         (0x3842107b,0x18633544,0x20fbca14);
  test_char32_t      (0x3842107b,0x18633544,0x20fbca14);
  test_wchar_t       (0x3842107b,0x18633544,0x20fbca14);
  test_int_least32_t (0x3842107b,0x18633544,0x20fbca14);
  test_uint_least32_t(0x3842107b,0x18633544,0x20fbca14);
  test_int_fast32_t  (0x3842107b,0x18633544,0x20fbca14);
  test_uint_fast32_t (0x3842107b,0x18633544,0x20fbca14);
  test_intptr_t      (0x3842107b,0x18633544,0x20fbca14);
  test_uintptr_t     (0x3842107b,0x18633544,0x20fbca14);
  test_size_t        (0x3842107b,0x18633544,0x20fbca14);
  test_ptrdiff_t     (0x3842107b,0x18633544,0x20fbca14);
  test_intmax_t      (0x3842107b,0x18633544,0x20fbca14);
  test_uintmax_t     (0x3842107b,0x18633544,0x20fbca14);

  /* ~64bit types */
  test_llong         (0x3842107b9a5cdef6,0x18633544c02d9ea2,0x20fbca143975ed68);
  test_ullong        (0x3842107b9a5cdef6,0x18633544c02d9ea2,0x20fbca143975ed68);
  test_int_least64_t (0x3842107b9a5cdef6,0x18633544c02d9ea2,0x20fbca143975ed68);
  test_uint_least64_t(0x3842107b9a5cdef6,0x18633544c02d9ea2,0x20fbca143975ed68);
  test_int_fast64_t  (0x3842107b9a5cdef6,0x18633544c02d9ea2,0x20fbca143975ed68);
  test_uint_fast64_t (0x3842107b9a5cdef6,0x18633544c02d9ea2,0x20fbca143975ed68);

  test_atomic_flag();

  test_bool();
}

#ifndef NOMAIN
int main(int argc,char **argv)
{
#ifdef USE_ROATOMIC
  roatomic_init((argc > 1) && strchr(argv[1],"n"));
#endif
  runtests();
}
#endif
