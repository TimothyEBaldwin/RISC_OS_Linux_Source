/*
 * Copyright (c) 2022, RISC OS Open Ltd
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdint.h>
#include <ctype.h>
#include "xo.h"
#include "DebugLib/DebugLib.h"

#define UNUSED(k) ((k)=(k))
extern char *__progname; /* Program name */

int xo_parse_args(int argc, char **argv)
{
    debug_initialise("xolib", "", NULL);
    debug_set_device(PRINTF_OUTPUT);
    UNUSED(argv);
    return argc; /* Text consumes no args */
}

void xo_set_version(const char *version)
{
    UNUSED(version); /* Text has no version */
}

xo_ssize_t xo_open_container(const char *name)
{
    UNUSED(name); /* Text isn't containerised */
    return 0;
}

xo_ssize_t xo_open_list(const char *name)
{
    UNUSED(name); /* No lists */
    return 0;
}

xo_ssize_t xo_open_instance(const char *name)
{
    UNUSED(name); /* No instances */
    return 0;
}

xo_ssize_t xo_close_instance(const char *name)
{
    UNUSED(name); /* No instances */
    return 0;
}

xo_ssize_t xo_close_list(const char *name)
{
    UNUSED(name); /* No lists */
    return 0;
}

xo_ssize_t xo_close_container(const char *name)
{
    UNUSED(name); /* Text isn't containerised */
    return 0;
}

void xo_error(const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);
}

void xo_message(const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    vfprintf(stdout, fmt, args);
    va_end(args);
}

xo_ssize_t xo_flush(void)
{
    fflush(stdout);
    return 0;
}

xo_ssize_t xo_finish(void)
{
    fflush(stdout);
    return 0;
}

#define CONSUME_CHAR(ch,ptr)   (ch) = *(ptr); (ptr)++
#define PEEP_CHAR(ch,ptr)      (ch) = *(ptr)
#define CHECK_ZERO_END(ch)     if ((ch) == '\0') \
                               { dprintf(("", "Unexpected end of formatter at line %d\n", __LINE__)); \
                                 goto zeroend; \
                               }
#define SKIP_XO_FORMAT(ptr)    { char temp; \
                                 do { CONSUME_CHAR(temp,ptr); } while (temp != '\0' && temp != '}'); \
                                 if (temp == '\0') fmt--; /* Rewind to terminator */ \
                               }

typedef enum
{
    FIELD_NOT_FOUND,
    FIELD_P, /* Any pointer */
    FIELD_32I,
    FIELD_64I,
    FIELD_C
} field_type_t;

typedef union
{
    uint32_t all;
    struct
    {
        uint32_t add_space:1;
        uint32_t add_colon:1;
        uint32_t add_quote:1;
        uint32_t encoding:1;
    } flags;
} field_qual_t;

static const char *xo_extract_field(const char **fmt, field_type_t *basefmt, size_t *stars)
{
#define MAX_FMT_LENGTH 16 /* Arbitrary */
    static char field[MAX_FMT_LENGTH] = { '%' };
    const char *scan = *fmt;
    int ch, out = 1, nl = 0, nh = 0;

    /* From an xo field, extract the next printf compatible formatter.
     * The formatter pointer on entry is at the first character after the % and
     * the formatter is known not to be the escaped %% form.
     * It only needs to be parsed to the level of detail of knowing whether the
     * width/field are done with *'s and what the base type is (so the va_list can
     * be stepped appropriately).
     * No floating point thanks.
     */
    *basefmt = FIELD_NOT_FOUND;
    *stars = 0;

    do
    {
        ch = *scan; scan++;
        *fmt = *fmt + 1;
        switch (ch)
        {
            case 'l':
                nl++; if (nl > 2) return ""; /* Too many */
                field[out] = 'l'; out++;
                break;

            case 'h':
                nh++; if (nh > 2) return ""; /* Too many */
                field[out] = 'h'; out++;
                break;

            case 0:
            default:
                break;

            case '*':
                *stars = *stars + 1;
                /* Fall through */
            case '+':
            case '-':
            case ' ':
            case '.':
            case '0': case '1': case '2' : case '3': case '4':
            case '5': case '6': case '7' : case '8': case '9':
                field[out] = ch; out++;
                break;

            case 'o':
            case 'u':
            case 'd':
            case 'i':
            case 'x':
            case 'X':
                *basefmt = (nl < 2) ? FIELD_32I : FIELD_64I;
                field[out] = ch; out++;
                field[out] = '\0';
                return field;

            case 'p':
                *basefmt = FIELD_P;
                return "%p";

            case 's':
                *basefmt = FIELD_P;
                field[out] = ch; out++;
                field[out] = '\0';
                return field;

            case 'c':
                *basefmt = FIELD_C;
                return "%c";
        }
        if (out >= MAX_FMT_LENGTH)
        {
            dprintf(("", "Overran formatter buffer of %d\n", MAX_FMT_LENGTH));
            return "";
        }
    } while (ch != 0);

    return "";
}

xo_ssize_t xo_emit(const char *fmt, ...)
{
    xo_ssize_t count = 0;
    va_list args;
    field_qual_t quals;
    char role, c;
    const char *fieldfmt;

    /* Check for no-op */
    if (fmt == NULL) return 0;

    va_start(args, fmt);
    while (*fmt)
    {
        CONSUME_CHAR(c, fmt);
        if (c == '{')
        {
            CONSUME_CHAR(role, fmt);
            CHECK_ZERO_END(role);
            switch (role)
            {
                case 'E': /* Error */
                case 'W': /* Warning */
                case '[': /* Start anchor */
                case ']': /* Stop anchor */
                case 'G': /* Use gettext() */
                case 'L': /* Label prefix */
                case 'N': /* Note suffix */
                    dprintf(("", "Unsupported field '%c' by this xolib\n", role));
                    SKIP_XO_FORMAT(fmt);
                    break;

                case 'C': /* Colour */
                case 'U': /* Units */
                    dprintf(("", "Ignoring field '%c' for text-only output\n", role));
                    SKIP_XO_FORMAT(fmt);
                    break;

                default:
                    if (strchr("acdeghklnpqtw", role) == NULL)
                    {
                        dprintf(("", "Unrecognised modifier after missing role\n"));
                        SKIP_XO_FORMAT(fmt);
                        break;
                    }
                    /* Started with a modifier, so set the default role */
                    role = 'V';
                    fmt--;
                    /* Fall through */

                case 'T': /* Title */
                case 'P': /* Padding */
                case 'D': /* Decoration */
                case 'V': /* Value */
                case ':':
                    c = role;
                    quals.all = 0;
                    while (c != ':')
                    {
                        CONSUME_CHAR(c, fmt);
                        CHECK_ZERO_END(c);
                        switch (c)
                        {
                            case 'd': quals.flags.encoding = 0; break;
                            case 'e': quals.flags.encoding = 1; break;
                            default:  dprintf(("", "Unsupported modifier '%c' by this xolib\n", c));
                                      break;
                        }
                    }

                    /* Deal with any field name */
                    do
                    {
                        CONSUME_CHAR(c, fmt);
                        CHECK_ZERO_END(c);
                        if ((role == 'P' && c == ' ') ||
                            (role == 'T' && (c != '/' && c != '}')))
                        {
                            /* Literal padding (or) title text */
                            putchar(c);
                            count++;
                        }
                    } while (c != '/' && c != '}');
                    if ((role == 'P' || role == 'T') && c == '}') break; /* No default fields for these roles */
                    fieldfmt = (c == '/') ? fmt : "%s}"; /* Default to a string if no field given */
                    fmt--;

                    /* Now process the field format one character at a time */
                    while (!quals.flags.encoding)
                    {
                        CONSUME_CHAR(c, fieldfmt);
                        CHECK_ZERO_END(c);
                        if (c == '/' || c == '}') break;
                        if (c == '%')
                        {
                            PEEP_CHAR(c, fieldfmt);
                            if (c == '%')
                            {
                                /* An escaped percent */
                                fieldfmt++;
                                putchar('%');
                                count++;
                            }
                            else
                            {
                                field_type_t base;
                                size_t stars;
                                const char *printfmt = xo_extract_field(&fieldfmt, &base, &stars);

                                /* Variadic print it, then pop the appropriate number of arg(s) */
                                count += vprintf(printfmt, args);
                            }
                            continue;
                        }
                        putchar(c);
                        count++;
                    }

                    /* Dispose of the encoding format, if any */
                    do
                    {
                        CONSUME_CHAR(c, fmt);
                        CHECK_ZERO_END(c);
                    } while (c != '}');
                    break;
            }
        }
        else
        {
            putchar(c);
            count++;
        }
    }

zeroend:
    va_end(args);

    return count;
}

static void do_va_msgx(const char *fmt, va_list args)
{
#ifndef __riscos
    int report = errno;
#endif

    /* Common tail for warnx and errx */
    fprintf(stderr, "%s: ", __progname);
    if (fmt)
    {
        vfprintf(stderr, fmt, args);
        fprintf(stderr, ": ");
    }
#ifdef __riscos
    fprintf(stderr, "%s\n", _inet_err());
#else
    fprintf(stderr, "%s\n", strerror(report));
#endif
}

void xo_errx(int eval, const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    do_va_msgx(fmt, args);
    va_end(args);
    exit(eval);
}

void xo_warnx(const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    do_va_msgx(fmt, args);
    va_end(args);
}

static void do_va_msg(const char *fmt, va_list args)
{
    /* Common tail for warnx and errx */
    fprintf(stderr, "%s: ", __progname);
    if (fmt)
    {
        vfprintf(stderr, fmt, args);
    }
    fprintf(stderr, "\n");
}

void xo_err(int eval, const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    do_va_msg(fmt, args);
    va_end(args);
    exit(eval);
}

void xo_warn(const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    do_va_msg(fmt, args);
    va_end(args);
}
