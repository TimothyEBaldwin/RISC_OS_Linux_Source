/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

//#define SVC_SWIS

static char buffer[256];
static void build_asm(const char *filename, const char *function, const char *swi,
                      int args, int result, int module);

int main(int argc, char *argv[])
{
    FILE *f;
    char function[64];
    char swi[64];
    char filename[64];
    int args, result, fields, line=0;

    if (argc != 2)
    {
        fprintf(stderr, "usage: mkveneers protofile\n");
        return 1;
    }

    f=fopen(argv[1], "r");
    if (!f)
    {
        fprintf(stderr, "Can't open %s for input\n", argv[1]);
        return 1;
    }

    while (!feof(f))
    {
        fgets(buffer, sizeof buffer, f);
        line++;
        fields=sscanf(buffer, "%s%s%d%d%s", function, swi, &args, &result, filename);
        if (function[0]=='#')
            continue;
        if (fields<4)
        {
            fprintf(stderr, "Syntax error at line %d\n", line);
            return 1;
        }
        sprintf(buffer, "sn.%s", fields<5 ? function : filename);
        build_asm(buffer, function, swi, args, result, 0);

        sprintf(buffer, "sz.%s", fields<5 ? function : filename);
        build_asm(buffer, function, swi, args, result, 1);
    }

    fclose(f);

    return 0;
}

static void build_asm(const char *filename, const char *function, const char *swi,
                      int args, int result, int module)
{
    FILE *f;
    int bigframe=0;
    time_t t;
    char extraregs[8];

    time(&t);

    if (args <= 4)
        extraregs[0]='\0';
    else if (args == 5)
        strcpy(extraregs, "v1,");
    else
        sprintf(extraregs, "v1-v%d,", args-4);

    f=fopen(filename, "w");

    if (f==0)
    {
        fprintf(stderr, "Unable to open %s for output\n", filename);
        exit(1);
    }

    /* A few opening comments */
    fprintf(f, ";\n");
    fprintf(f, "; %s\n", filename);
    fprintf(f, ";\n");
    fprintf(f, "; Generated by mkveneers on %s", ctime(&t));
    fprintf(f, ";\n\n");

    /* Get the definitions for OS_EnterOS and the other SWIs */
    fprintf(f, "\tGET\thdr.InetSWIs\n\n");

    fprintf(f, "\tAREA\tSockLib,CODE,READONLY\n\n");
    #if 0
    if (!module)
        fprintf(f, "\tIMPORT\t__rt_stkovf_split_small\n");
    #endif
    fprintf(f, "\tIMPORT\t_copyerror\n");
    fprintf(f, "\tEXPORT\t%s\n", function);

    /* Put in the function name a la CC's -fn option */
    if (!module)
    {
        fprintf(f, "\n\t= \"%s\", 0\n", function);
        fprintf(f, "\tALIGN\n");
        fprintf(f, "\t& &FF0000%02X\n", (strlen(function)+1+3)&~3);
    }

    fprintf(f, "%s\n", function);

    /* The APCS entry (yum!) */
    fprintf(f, "\tMOV\tip,sp\n");
    if (!module && args>0)
    {
        if (args > 4)
        {
            fprintf(f, "\tSTMDB\tsp!,{a1-a4}\n");
            fprintf(f, "\tSTMDB\tsp!,{%sfp,ip,lr,pc}\n", extraregs);
            bigframe=1;
        }
        else if (args >=2 && args <=4)
            fprintf(f, "\tSTMDB\tsp!,{a1-a%d,fp,ip,lr,pc}\n", args);
        else if (args == 1)
            fprintf(f, "\tSTMDB\tsp!,{a1,fp,ip,lr,pc}\n");
    }
    else
        fprintf(f, "\tSTMDB\tsp!,{%sfp,ip,lr,pc}\n", extraregs);

    fprintf(f, "\tSUB\tfp,ip,#%d\n", bigframe ? 20 : 4);

    if (!module)
    {
        /* Stack limit checking */
        /* (Don't bother because _copyerror doesn't really use much stack - we
            know we had 256 bytes on entry) */
        #if 0
        fprintf(f, "\tCMPS\tsp,sl\n");
        fprintf(f, "\tBLLT\t__rt_stkovf_split_small\n");
        #endif
    }

    /* Load any extra registers after the first four */
    /* (This is not the customary way to do it - one normally references via fp
       but we know ip is unaltered since entry) */
    if (args == 5)
        fprintf(f, "\tLDR\tv1,[ip]\n");
    else if (args >= 6)
        fprintf(f, "\tLDMIA\tip,{v1-v%d}\n", args-4);

    #ifdef SVC_SWIS
    if (!module)
    {
        /* Enter SVC mode, to prevent any callbacks going off as the SWI
           returns (which could call the Internet module, corrupting the
           error block before we read it!) */
        fprintf(f, "\tSWI\tOS_EnterOS\n");
    }
    #endif

    /* Call the SWI */
    fprintf(f, "\tSWI\tX%s\n", swi);

    /* If an error, call _copyerror (which returns -1) */
    fprintf(f, "\tBLVS\t_copyerror\n");

    #ifdef SVC_SWIS
    if (!module)
    {
        /* Return to USR mode */
        fprintf(f, "\tTEQP\tpc,#0\n");
        /* A NOP - we can't access sp or lr on the next instruction */
        fprintf(f, "\tNOP\n");
    }
    #endif

    /* And return (returning either R0 from the SWI, or -1 if an error */
    fprintf(f, "\t[ {CONFIG}=26\n");
    fprintf(f, "\tLDMDB\tfp,{%sfp,sp,pc}^\n", extraregs);
    fprintf(f, "\t|\n");
    fprintf(f, "\tLDMDB\tfp,{%sfp,sp,pc}\n", extraregs);
    fprintf(f, "\t]\n\n");

    fprintf(f, "\tEND\n");

    fclose(f);
}
