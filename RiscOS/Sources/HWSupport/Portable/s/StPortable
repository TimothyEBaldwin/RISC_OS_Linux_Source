; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     Source.StPortable

;
; Module header and misc. functions
;
        AREA    |Portable$$Code|, CODE, READONLY, PIC

;******************************************************************************
;
; Module header
;
Module_BaseAddr
        DCD     0
        DCD     Init     - Module_BaseAddr
        DCD     Die      - Module_BaseAddr
        DCD     Service  - Module_BaseAddr
        DCD     Title    - Module_BaseAddr
        DCD     Help     - Module_BaseAddr
        DCD     Command  - Module_BaseAddr
        DCD     Module_SWISystemBase + PortableSWI * Module_SWIChunkSize
        DCD     SWIEntry - Module_BaseAddr
        DCD     SWINameTable - Module_BaseAddr
        DCD     0
 [ International_Help <> 0
        DCD     messagefilename - Module_BaseAddr
 |
        DCD     0
 ]

;******************************************************************************

Title   DCB     "Portable",0
Help    DCB     "Portable",9,"$Module_HelpVersion", 0
        ALIGN


Command
        DCB     "FreezeTime", 0
        ALIGN
        DCD     SleepTimeCmd - Module_BaseAddr
        DCD     &0001FF00:OR:International_Help
        DCD     SleepTimeSyn - Module_BaseAddr
        DCD     SleepTimeHlp - Module_BaseAddr
        DCD     0                  ; No more cmd's

 [ International_Help=0
SleepTimeHlp    DCB     "*FreezeTime (seconds) sets the delay before an idle machine enters freeze mode.", 13
                DCB     "If used with no parameters, it displays the current status.", 13
                DCB     "To turn off use *FreezeTime 0", 13
SleepTimeSyn    DCB     "Syntax: *FreezeTime [Time]", 0
 |
SleepTimeHlp
        DCB     "HSCSLP", 0
SleepTimeSyn
        DCB     "SSCSLP", 0
 ]
        ALIGN


SleepTimeCmd    Entry
        LDR     R12, [R12]                      ;get workspace pointer

        TEQ     R1, #0
        BEQ     SleepTimeNoParams

SleepTimeLoop
        LDRB    R1, [R0]                        ;check for end
        CMP     R1, #32                         ;and chop off leading spaces.
        ADDEQ   R0, R0, #1
        BEQ     SleepTimeLoop
        EXITS   LT                              ;exit if control-char.
        BL      DecodeParam
        BVC     SleepTimeLoop
        EXIT                                    ;return V set

SleepTimeNoParams
;;;;        BL      openmsgfile
;;;;        EXIT    VS

        LDR     R0, SleepTimerDelay
        TEQ     R0, #0
        ADREQ   R1,SleepOff
        ADRNE   R1,StrBuff
        MOVNE   R2,#StrBuffLen
        SWINE   XOS_BinaryToDecimal
        SUBNE   R2, R2, #2              ; convert to seconds (sort of)
        MOVNE   R4,R1
        MOVNE   r0, #0
        STRNEB  r0, [r4, r2]
        MOVNE   R1,R2
        ADRNE   R1,SleepTim

        SUB     sp, sp, #80

        wsaddr  R0, MsgTransBlk

        MOVVC   r2, sp
        MOVVC   r3, #80
        SWIVC   XMessageTrans_Lookup
        MOVVC   r0, r2
        SWIVC   XOS_Write0
        ADD     sp, sp, #80

        SWIVC   XOS_NewLine

        EXIT

SleepOff DCB    "SleepOff", 0
SleepTim DCB    "SleepTm", 0
                ALIGN


DecodeParam Entry "R6"
        MOV     R1, R0                          ;move strpointer to R1
        MOV     R0, #(1<<29)                    ;check  0<=R2<=2^18 (ca. 3 days)
        MOV     R2, #(1<<18)                    ;restrict to moderate positive int
        SWI     XOS_ReadUnsigned
        BVS     DecodeErr                       ;print error and exit.
        MOV     R6, R1                          ; save the updated strpointer
        MOV     R3, #100
        MUL     R0,R2,R3                        ;R0 is SleepTime in centiseconds
        BL      SWISleepTime                    ; Corrupts some registers
        MOV     R0,R6
        EXITS

DecodeErr
        Pull    "R6,LR"
        ORRS    PC, LR, #V_bit


;******************************************************************************
;
; Errors
;
        ^               ErrorBase_Portable
        AddError        BadBMUVariable,"BadBMUVar"
        AddError        BadBMUCommand,"BadBMUCmd"
        AddError        BMUBusy,"BMUBusy"
        AddError        BadBMUVersion,"BadBMUVer"
        AddError        BMUFault,"BMUFault"
        AddError        BMUVecClaim,"BMUVecClaim"
        AddError        CantFreeze,"CantFreeze"
        AddError        FreezeFailed,"FreezeFailed"

        ASSERT          @ <= (ErrorBase_Portable + ?ErrorBase_Portable)


;******************************************************************************
;
; Resources
;
;Path            DCB     "Portable$Path",0
;DefPath         DCB     "Resources:$.Resources.Portable.",0

MessageFile
messagefilename
        DCB     "Resources:$.Resources.Portable.Messages", 0
        ALIGN


;******************************************************************************
;
; Init - Module initialisation code
;
; Exit
;   R7-R11, R13 preserved
;
Init    Entry   "R7"
;
; Check machine type
;
        MOV     r0, #2                          ;Check main hardware details
        SWI     XOS_ReadSysInfo
        EXIT    VS
                                                ;R0 bits 8..15 give I/O control chip type
        AND     r0, r0, #&0000FF00              ;  0=IOC, 1=IOMD
        TEQ     r0,     #&00000100              ;  must have IOMD
                                                ;R1 bits 0..8 give I/O combo chip type
        ANDEQ   r1, r1, #&000000FF              ;  0=absent, 1=82C710/711 or SMC'665 or similar
        TEQEQ   r1,     #&00000001              ;  must have a combo chip (exact type checked below)
 [ {TRUE}
                                                ;R2 bits 0..7 give LCD controller type
        ANDEQ   r2, r2, #&000000FF              ;  0=absent, 1=A4, 2=Stork
        TEQEQ   r2,     #&00000002              ;  must be Stork
 ]
        BNE     %FT99

        MOV     r0, #3                          ;Now check I/O combo chip details
        SWI     XOS_ReadSysInfo
        EXIT    VS
                                                ;R0 bits 20..23 give configuration type
        AND     r0, r0, #&00F00000              ;  1=82C710, 2=82C711, 3=37C665
        TEQ     r0,     #&00300000              ;  must be type 3 (for 37C665)
        BNE     %FT99
;
; Hardware OK
;
        LDR     R2, [R12]
        TEQS    R2, #0                          ;already got work space if entered
        BNE     %FT10                           ;as part of RMTidy

;private word is zero, so claim some workspace
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #MemNeeded
        SWI     XOS_Module
        EXIT    VS                              ;quit if error

        STR     R2, [R12]                       ;got workspace ok, so store in private word
10
        MOV     R12, R2

 [ Debug
        InsertTMLInitialisation 0               ;my EasiStork uses podule slot 0
       ;DLINE   "Portable module initialisation"
 ]

 [ SwitchPower
        BL      InitLatchSoftCopies             ;Initialise variables and ensure hardware consistency
 ]
        BL      InitSWIPortableControl          ;Initialise variables and ensure hardware consistency

        MOV     R0, #0

        STRB    r0, PaletteVFlag                ;not yet on PaletteV
        STRB    R0, EventVFlag                  ;not yet on event vector (for hot-key detection)
        STRB    R0, KeyVFlag
        STRB    R0, SleepTimerFlag
        BL      InitMicroController             ;also clears BMUDevFlag
 [ HWPolling
        STRB    R0, CallEveryFlag
 ]

        STRB    R0, KeyRepeatFlag
        STR     R0, KeyRepeatAction
        STR     R0, KeyRepeatDelay
        STR     R0, KeyRepeatRate

;>>>do I need Path variable stuff?

; open messages file

        wsaddr  R0,MsgTransBlk
        addr    R1,MessageFile
        MOV     R2,#0                           ; no buffer supplied
        SWI     XMessageTrans_OpenFile
        EXIT    VS

        BL      CheckForCMOSReset               ;may need to reconfigure a few things
        BL      ClaimEventV                     ;capture 'hot-keys' events
        BL      ClaimPaletteV           ;>>>a kludge A4 code does this on mode change iff LCD mode
        BL      ClaimKeyV
        BL      ClaimMicroControllerEvent       ;Claims event, but DOES NOT enable interrupts
                                                ; from device. This is done by PS2Driver calling
                                                ; us via a KeyV upcall with reason code
                                                ; KeyV_PseudoIntMask. See DoKeyV_PseudoIntMask.
;
; Kernel starts in CRT mode but we switch to LCD in !Boot
;
        MOV     R0, #0
        STRB    R0, PaletteMode
        MOV     R0, #&FF
        STRB    R0, DisplayMode

;
; Read LCD contrast & brightness settings from CMOS RAM
;
        ASSERT  ContrastTableMaxIndex = 63      ;we allocate 6bits in CMOS
        MOV     R0, #ReadCMOS
        MOV     R1, #ContrastCMOS
        SWI     XOS_Byte                        ;result in R2.b
        MOVVS   R1, #default_LCDContrast
        AND     R1, R2, #2_00111111
        STRB    R1, ContrastIndex

        MOV     R0, #0                          ;Brightness and contrast written simultaneously
        STRB    R0, BrightnessValue             ; to digipot, fudge zero for brightness whilst
        BL      SendContrast                    ; setting contrast

        ASSERT  BrightnessTableMaxIndex = 7     ;we allocate 3bits in CMOS for each
        MOV     R0, #ReadCMOS
        MOV     R1, #BrightnessCMOS
        SWI     XOS_Byte                        ;result in R2.b
        MOVVS   R2, #(default_LCDBrightness1 :OR: (default_LCDBrightness2 :SHL: 3)) ;b7 and b6 clear

        AND     R1, R2, #2_11000000             ;b7 lid closure, b6 idle mode inhibit
        STRB    R1, ModeBits

        AND     R1, R2, #7                      ;extract bits 0..2 as one brightness value
        MOV     R2, R2, LSR #3                  ;
        AND     R2, R2, #7                      ;extract bits 3..5 as another brightness value

        CMP     R1, R2                          ;sort values, use highest ie start in undimmed state
        EORLT   R1, R1, R2                      ; R1:=a EOR b
        EORLT   R2, R1, R2                      ; R2:=a EOR b EOR b ie R2:=a
        EORLT   R1, R1, R2                      ; R1:=a EOR b EOR a ie R1:=b
        STRB    R2, BrightnessIndex2            ;store lowest value as 'other' value
        BL      SetBrightness_WithLock          ;In R1=value to set (highest value)

;
; Read Freeze time from CMOS RAM
;
        ASSERT  FreezeTimesMaxIndex = 7
        MOV     R0, #ReadCMOS
        MOV     R1, #TimeCMOS
        SWI     XOS_Byte                        ;result in R2.b
        MOVVC   R2, R2, LSR #3                  ;
        ANDVC   R2, R2, #7                      ;extract bits 3..5 freeze time
        MOVVS   R2, #default_FreezeTime

        ADRL    R1, FreezeTimes
        LDR     R2, [R1, R2,LSL #2]             ;multiply index by 4 - table of words
        STR     R2, SleepTimerDelay

 [ HWPolling
        BL      ClaimCallEvery
 ]
;
; We currently have no software support for 'machine wake-up by alarm', other than to allow
; external software to program it. We take steps to silence any already triggered alarm to
; ensure that the machine can shutdown/freeze.
;
        BL      KillRTCAlarm                    ;We may have been switched on by the alarm
        EXITS
;
;Wrong hardware for Portable module
;
99
        ADR     r0, ErrorBlock_BadHard
        MOV     r1, #0                          ;only use global message file
        MOV     r2, #0                          ;use MessageTrans buffer
        MOV     r3, #0                          ;buffer size (irrelevant)
        MOV     r4, #0                          ;don't substitute anything
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

        MakeErrorBlock  BadHard
        MakeErrorBlock  ModuleBadSWI
        MakeErrorBlock  CantFreeze
        MakeErrorBlock  FreezeFailed

        LTORG

;******************************************************************************
;
; Finalisation code - Called before killing the module
;
; Entry
;   R10 = fatality indication: 0 is non-fatal, 1 is fatal
;   R11 = instantiation number
;   R12 = pointer to private word
;
; Exit
;   R7-R11, R13 preserved
;
Die     Entry
        LDR     R12, [R12]                      ;get workspace pointer

        BL      CancelSleepTimer

;
; Ensure all hardware is powered up, ie leave machine in usable state.
;
        LDR     R0, = InitialPowerState         ;Put the machine back as we found it
        MOV     R1, #0                          ; ie with everything powered up
        BL      SWIControl                      ; (sends Power-Up message around)

        BL      ReleaseEventV
        BL      ReleasePaletteV
        BL      ReleaseKeyV

;>>>DO we need to inhibit MicroController key/battery reports
;>>>DO we need to mask of its IRQ's???
        BL      ReleaseMicroControllerEvent
 [ HWPolling
        BL      ReleaseCallEvery
 ]

; close message file

        wsaddr  R0,MsgTransBlk
        SWI     XMessageTrans_CloseFile

        CLRV
;
; Brightness and Contrast is left 'as is'.
;
        EXIT


;******************************************************************************
;
; Service call handler
;
; Entry
;   R1  = service number
;   R12 = pointer to private word
;
; Exit
;    R1 = 0 => service claimed
;    All other registers preserved unless returning values
;
Service ROUT
        TEQ     r1, #Service_Reset
    ;    TEQNE   r1, #Service_PostInit
    ;>>>TEQNE   r1, #Service_PreReset
    ;>>>TEQNE   r1, #Service_ModeChanging
    ;>>>TEQNE   r1, #Service_ModeExtension
    ;>>>TEQNE   r1, #Service_ModeTranslation
    ;>>>TEQNE   r1, #Service_ModeChange
    ;>>>TEQNE   r1, #Service_MonitorLeadTranslation
; no need to handle Service_MessageFileClosed
    ;>>>[       standalonemessages
    ;>>>TEQNE   R1,#Service_ResourceFSStarting
    ;>>>]
        MOVNES  PC, LR

        LDR     wp, [r12]

    ;>>>TEQ     r1, #Service_PreReset
    ;>>>BEQ     Svc_PreReset

    ;    TEQ     r1, #Service_PostInit
    ;    BEQ     Svc_PostInit


;drop into...

Svc_Reset Entry "R0-R2"
        MOV     r0, #&FD                ; read last reset type
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
        TEQ     r1, #0                  ; if not a soft reset, ignore
        EXITS   NE

        BL      CancelSleepTimer

        MOV     R0, #0
        STRB    R0, PaletteVFlag
        STRB    R0, EventVFlag          ; indicate not on EventV (r1 = 0)
        STRB    R0, KeyVFlag
        STRB    R0, SleepTimerFlag
 [ HWPolling
        STRB    R0, CallEveryFlag
 ]

        STRB    R0, KeyRepeatFlag
        STR     R0, KeyRepeatAction
        STR     R0, KeyRepeatDelay
        STR     R0, KeyRepeatRate

        BL      ClaimEventV
        BL      ClaimPaletteV           ;>>>a kludge A4 code does this on mode change iff LCD mode
        BL      ClaimKeyV
        BL      InitMicroController             ;also clears BMUDevFlag
        BL      ClaimMicroControllerEvent

        MOV     r0, #0                          ;Now try turning as much off as possible,
        LDR     r1, =:NOT: PowerSaveBits        ; serial, parallel and FDC etc
        BL      SWIControl                      ; NB this call does send power-down messages.
 [ HWPolling
        BL      ClaimCallEvery
 ]
        EXITS

Svc_PreReset Entry "r0-r2"
;>>>wait for VSync before disabling LCD panel???
        EXITS

 [ {FALSE}
;
; Svc_PostInit - Issued on a reset after all ROM resident modules have been initialised.
;
; Setup a callback routine to start the LCDisplay.
;
Svc_PostInit
        Entry   "R0,R1"
        ADRL    R0, CB_SwitchToLCD
        MOV     R1, R12
        SWI     XOS_AddCallBack
        EXITS
 ]

;******************************************************************************

SWIEntry        ROUT
        LDR     R12,[R12]
        CMPS    R11,#(EndSWIJmpTable - SWIJmpTable) /4
        ADDCC   PC,PC,R11,LSL #2
        B       SWIUnknown

SWIJmpTable
        B       SWISpeed
        B       SWIControl
        B       SWI_ReadBMUVariable
        B       SWI_WriteBMUVariable
        B       SWI_CommandBMU
        B       SWIReadFeatures
        B       SWIIdle
        B       SWIStop
        B       SWIStatus
 [ SwindellCode
   ;     B       SWIPortable_Contrast
        B       SWIRefresh
        B       SWIHalt
       ;B       SWISleepTime
 ]
EndSWIJmpTable


;******************************************************************************

ModuleTitle ; Share the string
SWINameTable
        =       "Portable",0
        =       "Speed",0
        =       "Control",0
        =       "ReadBMUVariable",0
        =       "WriteBMUVariable",0
        =       "CommandBMU",0
        =       "ReadFeatures",0
        =       "Idle",0
        =       "Stop",0
        =       "Status",0
   ;     =       "Contrast",0
 [ SwindellCode
        =       "Refresh",0
        =       "Halt",0
 ]
        =       0
        ALIGN

;******************************************************************************

 [ SwindellCode
; enter with
; R0 Num refresh cycles
; R1 &03200000
; R2 STOP  data bus pattern
; R3 #&F0  Cas Lo, Ras Hi
; R4 #&FF  Cas Lo, Ras Lo
; R11 return address
;
SWIRefresh
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi
        STRB R4, [R1,#&D4]      ; Cas Lo, Ras Lo   CBR self refresh
SWIHalt
stop
        STR  R2, [R1,#&2C]      ; STOP data bus driven by Wr data
; stop until wake up event
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi   End self refresh
        MOV  R5, R0             ; get loop length into loop counter
refresh
        STRB R4, [R1,#&D4]      ; Cas Lo, Ras Lo   CBR Refresh
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi
        SUBS R5, R5, #1
        BNE  refresh
        STRB R5, [R1,#&D4]      ; Cas Hi, Ras Hi (R5=0)

        LDR R6, [R1,#&70]       ; irqD status, check if woken by event 2 if so go back to stop
        TST R6, #&08            ; was it event1, if not then must be event2 so stop again
        BEQ stop                ; stop again if event1=0
        BICS    PC,LR,#V_bit    ; jump back to application code
 ]
;******************************************************************************


SWIUnknown
SWISpeed
        Push    "r4,lr"
        ADR     r0, ErrorBlock_ModuleBadSWI
        ADR     r4, ModuleTitle
        BL      ErrorLookup1Parm
        Pull    "r4,pc"


;******************************************************************************
;
; SWI Portable_ReadFeatures
;
; Exit
;   R1  = bit 4 set to indicate SWI Portable_Idle is impletemted
;         bit 5 set to indicate SWI Portable_Stop is impletemted
;
; All other bits in R1 zeroed, all other registers preserved.
;
SWIReadFeatures ROUT
        MOV     R1,#(PortableFeature_Idle :OR: PortableFeature_Stop)
        BICS    PC,LR,#V_bit


;******************************************************************************
;
; SWI Portable_Idle - Places the system into idle mode.
;
; The CPU clock is stopped, but all other clocks run normally. This means the
; Video display and all the IO channels are active, the DRAM is refreshed, but
; the system consumes less power as the CPU is inactive. The CPU remains in
; this state until it receives a FIQ or IRQ interrupt (eg from the keyboard,
; floppy, centi-second timer etc).
;
SWIIdle Entry   "R0, R1"
       ;DLINE   "SWIIdle"

        MOV     R0, #0                          ;0 will stop Fclk, Clk2, Clk8, Ref8 and Clk16
        IOMDBase R1                             ;1 will stop Fclk (the CPU core clock) only
        STRB    R0, [R1, #IOMD_IDLEMODE]        ;INicholas 6/10/94 recommended stopping them all

        EXITS


;******************************************************************************
;
; SWI Portable_Stop - Stop (or freeze) the System.
;
; Sets the DRAM to self-refresh, then places the system into stop mode (all
; clocks are stopped). Execution continues only on receipt of an external
; wakeup event from the keyboard or real-time-clock. Normal FIQ or IRQ or
; centi-second timer events cannot happen because the IO system is not clocked.
;
; Exit
;   R0  = restart code, 1-keyboard interrupt
;                       2-RTC interrupt         (NYA)
;
SWIStop Entry   "R0-R9"
       ;DLINE   "SWIStop entry"

        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_FreezeRequest      ;that we would like to freeze
        SWI     XOS_ServiceCall
        CMP     R1, #0                          ;If service call is claimed, someone objects
        BEQ     TooHotToFreeze                  ; eg BatMgr wants to stay alive whilst cycling the battery

        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_Freeze     ; that we are entering freeze mode
        SWI     XOS_ServiceCall                 ;

        MOV     R7, #0                          ;Failure indication, set to OK

       ;TEQP    PC, #SVC_mode + I_bit + F_bit
;
; call ADFS_PowerControl to 'spindown' the winnies
;
       ;DLINE   "SWIStop - trying to shutdown the winnies"
        MOV     R0, #2                          ; manual control of drive spin
                                                ; without affecting autospindown
        MOV     r2, #0                          ; spin down immediately
        BL      ADFSPowerOp                     ; apply to all IDE drives
        MOVVS   R7, #1                          ;VS, failure to spin-down winnies
        BVS     fail_1
;
; turn IRQ's and FIQ's off to prevent things turning back on
;
        TEQP    PC, #SVC_mode + I_bit + F_bit
;
; shutdown the sound system
;
       ;DLINE   "SWIStop - trying to shutdown the sound system"
        MOV     R0, #1
        SWI     XSound_Enable                   ;turn sound system off
        MOV     R5, R0                          ;preserve old state for later
        MOVVS   R7, #2                          ;VS, failure to kill sound system
        BVS     fail_2
;
; blank the screen
;
       ;DLINE   "SWIStop - blanking the screen (probably was already)"
        MOV     R0, #ScreenBlankerReason_Blank
        SWI     XScreenBlanker_Control          ;blank screen
        MOVVS   R7, #3                          ;VS, failure to blank screen
        BVS     fail_3
;
; call Portable_Control to powerdown floppies/econet/serial etc
;
        MOV     R0, #0                          ;Now try turning off as much off as possible,
        LDR     r1, =:NOT: Shutdown1Bits        ; serial, parallel and FDC etc
        BL      SWIControl                      ; NB this call does send power-down messages.
        MOVVS   R7, #4
        BVS     fail_4

        LDR     R0, =Shutdown1Bits              ;Consider the items we tried to turn off.
        AND     R1, R1, R0
;
; Ignore any failure of the parallel or serial ports to shutdown.
; We call SetPwrState directly later on to force them off.
;
        LDR     R0, =(PortableControl_SerialEnable :OR: PortableControl_ParallelEnable)
        BICS    R1, R1, R0
        MOVNE   R7, #5                          ;NE, something refused to shutdown
        BNE     fail_5

;>>>if serial or parallel failed to shutdown, call SetPwrState directly to shut them down
;
;>>>on wake up call SetPwrState or Portable_Control to power them back up. Which should we
;>>>use? ie do we want a power up message to go round for them.
;
;>>>Use of a second call allows us to put mouse & lcd asleep once we know we are actually
;>>>going to succeed.

;
; Send 'Suspend' command to microcontroller
;
        LDRB    R1, CommandState
        TEQ     R1, #0
        MOVNE   R7, #6                          ;NE, battery manager busy (interupted SendPowerCommand)
        BNE     fail_6
        LDR     R0, =uC_StatusReg               ;Get Tx buffer status bit
        LDRB    R1, [R0]                        ;
        TST     R1, #uC_Status_OBF              ;
        MOVNE   R7, #6                          ;NE, battery manager busy (processing an earlier Power or Keyboard command)
        BNE     fail_6

        MOV     R2, #PwrCmd_Suspend
        LDR     R0, =uC_PwrDataTxReg
        STRB    R2, [R0]                        ;Write byte to Power manager

;
; Force remaining units to shutdown ie serial, parallel, trackerball, mouse etc
;
        LDR     R0, ConfigExtraBitsCopy         ;R0  = current state
        LDR     R1, =Shutdown2Bits
        BIC     R1, R0, R1                      ;R1  = required state
        BL      SetPwrState                     ;Force required state, NB ConfigExtraBitsCopy
                                                ; unaltered for later restoration
;
; Write &FF to HWLatchMC to save power, SCLatchMC untouched, for later restoration.
;
        MOV     R0, #&FF
        LDR     R1, =HWLatchMC
        STRB    R0, [R1]
;
; Set IIC clock and data lines low.
;
        MOV     R0, #0
        BL      SetIIC

 [ {TRUE}
        MOV     R4, #paletteV_VIDCDisable
        MOV     R9, #PaletteV
        SWI     XOS_CallAVector
 ]

        ADR     R14, StopTab
05
        LDMIA   R14!, {R0, R1}                  ;address, data
        TEQ     R0, #0
        STRNE   R1, [R0]
        BNE     %BT05

        IOMDBase R8
        LDRB    R6, [R8, #IOMD_VREFCR]
        AND     R1, R6, #&E0                    ;preserve VRAM(Sz2..0) bits, but turn refresh off
        STRB    R1, [R8, #IOMD_VREFCR]          ;old value kept in R6 for later restoration

        MOV     R1, #0                          ;Useful value

        LDRB    R0, [R8, #IOMD_VIDCR]
        STRB    R0, holdVIDCR
        STRB    R1, [R8, #IOMD_VIDCR]

        LDRB    R0, [R8, #IOMD_SD0CR]
        STRB    R0, holdSD0CR
        STRB    R1, [R8, #IOMD_SD0CR]

        LDRB    R0, [R8, #IOMD_ATODICR]
        STRB    R0, holdATODICR
        STRB    R1, [R8, #IOMD_ATODICR]

       ;DLINE   "SWIStop - setting DRAM to self refresh, stopping the processor"


        ASSERT  HWLatchMC = (IOMD_Base + IOMD_CLINES)
        LDRB    R1, [R8, #IOMD_CLINES]          ;iop3 pulled low for slow-refresh
        TST     R1, #08
        BEQ     StopWithSlowRefresh

StopWithSelfRefresh
        BL      BurstRefresh
;
; Put DRAM into self-refresh mode by lowering the CAS lines then the RAS lines
;
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS lines low
        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS and RAS lines low
;
; Stop the processor
;
        MOV     R1, #&FFFFFFFF
        STR     R1, [R8, #IOMD_STOPMODE]
;
; *** The system is now asleep, pending a wake-up interrupt ***
;
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;raise RAS (CAS lines still low)
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;return CAS and RAS lines to normal use

        BL      BurstRefresh

        B       RestoreRegs
;
;
;
StopWithSlowRefresh
        BL      BurstRefresh                    ;Refresh the DRAM before entering/reentering STOP mode
;
; Stop the processor
;
        MOV     R1, #&FFFFFFFF
        STR     R1, [R8, #IOMD_STOPMODE]
;
; *** The system is now asleep, pending a wake-up interrupt ***
;
        LDRB    R1, [R8, #IOMD_IRQSTD]  ; irqD status, check if woken by event 2 if so go back to stop
        TST     R1, #IOMD_Nevent1_bit   ; was it event1, if not then must be event2 so stop again
        BEQ     StopWithSlowRefresh     ; stop again if event1=0

        BL      BurstRefresh                    ;Refresh the DRAM before reawakening the machine

;
; Bring the machine back to life
;
RestoreRegs
        IOMDBase R8
        STRB    R6, [R8, #IOMD_VREFCR]          ;Restore VRAM size and refresh rate

        LDRB    R1, holdVIDCR
        STRB    R1, [R8, #IOMD_VIDCR]

        LDRB    R1, holdSD0CR
        STRB    R1, [R8, #IOMD_SD0CR]

        LDRB    R1, holdATODICR
        STRB    R1, [R8, #IOMD_ATODICR]

       ;DLINE   "SWIStop - restarting"

 [ {TRUE}
        ADR     R14, StartTab
55
        LDMIA   R14!, {R0, R1}                  ;address, data
        TEQ     R0, #0
        STRNE   R1, [R0]
        BNE     %BT55
 ]

        MOV     R4, #paletteV_VIDCRestore
        MOV     R9, #PaletteV
        SWI     XOS_CallAVector

;
; Restore IIC clock and data lines to high.
;
        MOV     R0, #(i2c_clock_bit :OR: i2c_data_bit)
        BL      SetIIC
;
; Restore HWLatchMC - we set it to &FF to save power
;
        LDRB    R0, SCLatchMC                   ;Load soft copy
        LDR     R1, =HWLatchMC                  ;
        STRB    R0, [R1]                        ; and write to the port
;
; Restore state of serial, parallel etc
;
        LDR     R1, ConfigExtraBitsCopy
        BL      SetPwrState

        MOV     R0, #0                          ;Update RTC soft copy
        SWI     XOS_ResyncTime
;
;>>>determine cause of wakeup
;
;;;        MOV     R2, #PwrCmd_Send_input_signals
;;;        BL      SendPowerCommand
;;;        TST  R2, #

        MOV     R0, #1                          ;The only restart mechanism currently supported!
        STR     R0, [SP]                        ;overwrite stack R0

        BL      ClearRTCAlarm                   ;We may have been switched on by the alarm

        MOV     R7, #0                          ;Failure indication, set to OK
;
;
fail_6  ;Problem talking to microcontroller

fail_5
fail_4  ;Problem powering down floppy or winnie

        MOV     R0, #ScreenBlankerReason_Unblank
        SWI     XScreenBlanker_Control          ; un-blank screen

fail_3  ;Problem with screen blanking
        MOV     R0, R5                          ;restore state of sound system
        SWI     XSound_Enable

fail_2  ;Problem with sound system

fail_1  ;Problem with winnies
       ;SWI     XOS_WriteI + 7
;
; If R7 <> 0 it indicates an error occurred
;

;
;>>>send unfreeze service call here???
;
; could copy R7 into R3 to indicate success
        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_Unfreeze   ; that we are exiting Portable_Stop
        MOV     R3, R7
        SWI     XOS_ServiceCall

        CMP     R7, #0
        ADRNE   R0,ErrorBlock_FreezeFailed
        BLNE    ErrorLookupNoParms              ;If called, will set V
        STRVS   R0, [SP]                         ; overwrite stack R0
        PullEnv
        BICVCS  PC,LR,#V_bit
        ORRVSS  PC,LR,#V_bit                    ;Exit
;
;>>>what about R0 - restart reason code???
;


TooHotToFreeze
        addr    R0,ErrorBlock_CantFreeze        ; error, R0 -> tokenised error block
        BL      ErrorLookupNoParms
        STR     R0,[SP]                         ; overwrite stack R0
        PullEnv
        ORRS    PC,LR,#V_bit



;HWLatchPA  2_00000000
;HWLatchPB  2_00001000
;HWLatchMC  2_11111111
;HWLatchMA  2_00000000

StopTab
   ;     DCD     &83400000, &C0000003    ;dac off, ereg set to external LUT
   ;     DCD     &83400000, &D0004000    ;Vclk off, Pcomp=0
   ;     DCD     &83400000, &E0004049    ;PoDown, Hclk
        DCD     &83400000, &B1000001    ;sound Dac off, serial (16bit) sound off
        DCD     &88000000, &FFFFFFFF    ;buffered data bus
        DCD     0

StartTab
        DCD     &83400000, &B1000003    ;sound Dac off, serial (16bit) sound on, 24Mhz ref. clock
        DCD     0


;
; NB Must NOT read/write from/to DRAM (which includes the stack)
;
BurstRefresh
        MOV     R0, #1024
77
;
; One CAS before RAS refresh cycle
;
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;CAS and RAS high
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS lines low
        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS and RAS lines low

        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;CAS and RAS lines (still) low

        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;raise RAS (CAS lines still low)
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;return CAS and RAS lines to normal use

        SUBS    R0, R0, #1
        BGT     %BT77

        MOVS    PC, LR


;
; SetIIC Based on SetC1C0 from IIC.s.IICMod
;
; Set the state of the IIC clock and data lines
;
; Entry
;   R0 bits i2c_clock_bit and i2c_data_bit set to required levels
;
SetIIC
        Entry   "R0-R2"
        ORR     R14, R14, #I_bit                ; disable interrupts round access to IOCControlSoftCopy
        TEQP    R14, #0

        AND     R0, R0, #(i2c_clock_bit :OR: i2c_data_bit)

        MOV     R2, #0                          ; prepare to index soft copy
        LDRB    R1, [R2, #IOCControlSoftCopy]   ; read soft copy

        BIC     R1, R1, #(i2c_clock_bit :OR: i2c_data_bit)      ; clear clock and data
        ORR     R1, R1, R0                      ; put in new clock and data
        ORR     R1, R1, #&C0                    ; make sure two test bits are
                                                ; always set to 1 !
        STRB    R1, [R2, #IOCControlSoftCopy]   ; store back to soft copy

        MOV     R2, #IOC
        STRB    R1, [R2, #IOCControl]

        EXITS


;******************************************************************************
;
; SWI Portable_Status - Return status of connected devices.
;
; Exit
;   R0  = bit 0 set to indicate docking station connected
;         bit 1 set to indicate floppy connected
;     NYA bit 2 set to indicate internal tracker ball connected
;         bit 3 set to indicate internal (LCD) display in use
;
SWIStatus
        Entry   "R1"
        MOV     R0, #0

        LDR     R1, =HWLatchPB + 4              ;Read PCMCIA portB (+4 cos split register)
        LDRB    R1, [R1]                        ;
        TST     R1, #1                          ; examine docins* bit (negative logic)
        ORRNE   R0, R0, #PortableStatus_DocStationConnected ;1

        LDR     R1, =HWLatchPA + 4              ;Read PCMCIA portA (+4 cos split register)
        LDRB    R1, [R1]                        ;
        TST     R1, #2_00100000                 ; examine PrinterNotFloppy bit
        ORRNE   R0, R0, #PortableStatus_PrinterFloppy   ;2

        LDRB    R1, DisplayMode
        TEQ     R1, #0
        ORRNE   R0, R0, #8

        EXITS


;******************************************************************************

SWISleepTime    Entry
        STR     R0, SleepTimerDelay     ;>>>should we restart any existing
        EXITS                           ;>>>screen blank/sleep timer???


;******************************************************************************
;
; ClaimEventV - Claim EventV so we can notice hot keys
;
; Always preserves flags
;
ClaimEventV Entry "r0-r3"
        LDRB    r3, EventVFlag
        TEQ     r3, #0                  ; if already on vector
        EXITS   NE                      ; then exit

        MOV     r0, #EventV
        ADRL    r1, EventVHandler
        MOV     r2, wp
        SWI     XOS_Claim
        EXITS   VS

        MOV     r0, #14                 ; enable event
        MOV     r1, #Event_Keyboard
        SWI     XOS_Byte

        MOV     r3, #1                  ; indicate we're on vector
        STRB    r3, EventVFlag
        EXITS


;******************************************************************************
;
; ReleaseEventV - Release EventV
;
; Always preserves flags
;
ReleaseEventV Entry "r0-r3"
        LDRB    r3, EventVFlag
        TEQ     r3, #0                  ; if not on vector
        EXITS   EQ                      ; then don't bother releasing

        MOV     r0, #13                 ; disable event
        MOV     r1, #Event_Keyboard
        SWI     XOS_Byte

        MOV     r0, #EventV
        ADRL    r1, EventVHandler
        MOV     r2, wp
        SWI     XOS_Release

        MOV     r3, #0                  ; indicate not on vector
        STRB    r3, EventVFlag
        EXITS


;******************************************************************************
;
;       ClaimKeyV - Claim KeyV
;       Always preserves flags
;

ClaimKeyV Entry "r0-r3"
        MOV     r0, #KEYV               ; always claim KeyV (MOS ensures we're only on once) -
        ADRL    r1, KeyVHandler
        MOV     r2, wp
        SWI     XOS_Claim
        EXITS   VS

        MOV     r3, #1                  ; indicate we're on vector
        STRB    r3, KeyVFlag
        EXITS


;******************************************************************************
;
;       ReleaseKeyV - Release KeyV
;       Always preserves flags
;

ReleaseKeyV Entry "r0-r3"
        LDRB    r3, KeyVFlag
        TEQ     r3, #0                  ; if not on vector
        EXITS   EQ                      ; then don't bother releasing

        MOV     r0, #KEYV
        ADRL    r1, KeyVHandler
        MOV     r2, wp
        SWI     XOS_Release

        MOV     r3, #0                  ; indicate not on vector
        STRB    r3, KeyVFlag
        EXITS


;******************************************************************************
;
;       ClaimPaletteV - Claim PaletteV
;       Always preserves flags
;

ClaimPaletteV Entry "r0-r3"
        MOV     r0, #PaletteV           ; always claim PaletteV (MOS ensures we're only on once) -
        ADR     r1, PaletteVHandler     ; PaletteVFlag may be wrong immediately after a soft reset.
        MOV     r2, wp
        SWI     XOS_Claim
        EXITS   VS

        MOV     r3, #1                  ; indicate we're on vector, but colours not inited
        STRB    r3, PaletteVFlag
        EXITS

;******************************************************************************
;
;       ReleasePaletteV - Release PaletteV
;       Always preserves flags
;

ReleasePaletteV Entry "r0-r3"
        LDRB    r3, PaletteVFlag
        TEQ     r3, #0                  ; if not on vector
        EXITS   EQ                      ; then don't bother releasing

        MOV     r0, #PaletteV
        ADR     r1, PaletteVHandler
        MOV     r2, wp
        SWI     XOS_Release

        MOV     r3, #0                  ; indicate not on vector
        STRB    r3, PaletteVFlag
        EXITS


;******************************************************************************
;
;       PaletteVHandler
;
; in:   r4 = reason code
;
; out:  depends on r4
;

        ASSERT  paletteV_Complete = 0
        ASSERT  paletteV_Read = 1
        ASSERT  paletteV_Set = 2
        ASSERT  paletteV_1stFlashState = 3
        ASSERT  paletteV_2ndFlashState = 4
        ASSERT  paletteV_SetDefaultPalette = 5
        ASSERT  paletteV_BlankScreen = 6
        ASSERT  paletteV_DimScreen = 11
 [ {TRUE}
PaletteVHandler Entry "r0-r3"
        CMP     r4, #paletteV_BlankScreen
        BEQ     PV_BlankUnblank
        CMP     r4, #paletteV_DimScreen
        BEQ     PV_DimUndim
        EXITS

ClaimExit
        MOV     r4, #0
        PullEnv
        Pull    pc
 |
PaletteVHandler Entry "r0-r3"
        CMP     r4, #1
        EXITS   CC
        BEQ     PV_ReadPalette
        CMP     r4, #3
        BCC     PV_SetPalette
        BEQ     PV_1stFlashState
        CMP     r4, #5
        BCC     PV_2ndFlashState
        BEQ     PV_SetDefaultPalette
        CMP     r4, #7
        BCC     PV_BlankUnblank
        EXITS

ClaimExit
        MOV     r4, #0
        PullEnv
        Pull    pc

PV_1stFlashState
PV_SetFlashState
PV_2ndFlashState
PV_ReadPalette
PV_SetPalette
PV_SetDefaultPalette
        EXITS
 ]

;******************************************************************************
;
;       PV_BlankUnblank - Blank/unblank screen
;
; in:   r0 = -1 (read blank state)
;          or 0 (unblank screen)
;          or 1 (blank screen)
;       r0-r3, lr already pushed
;
; out:  r0 = old state (0=unblanked, 1=blanked)
;       r4 = 0 => operation complete
;

PV_BlankUnblank ROUT
       ;DREG    R0, "PV_BlankUnblank, R0 is ",,Integer
        TEQ     R0, #0
        BLEQ    CancelSleepTimer
        TEQ     R0, #1
        BLEQ    StartSleepTimer

        EXITS   ;NB registers pushed by PaletteVHandler

 [ {TRUE}
;******************************************************************************
;
;       PV_DimUndim - Dim/undim screen
;
; in:   r0 = -1 (read dim state)
;          or 0 (undim screen)
;          or 1 (dim screen)
;       r0-r3, lr already pushed
;
; out:  r0 = old state (0=undimmed, 1=dimmed)
;       r4 = 0 => operation complete
;

PV_DimUndim ROUT
        LDRB    R2, BrightnessIndex1            ;NB load order swapped! (reduces code later)
        LDRB    R1, BrightnessIndex2
        CMP     R2, R1
        MOVLT   R3, #1                          ;dim
        MOVGE   R3, #0                          ;bright
        STR     R3, [sp]                        ; return old state in R0 (on stack)

        CMP     R0, #1
        BHI     ClaimExit                       ;HI, reading only

        CMP     R3, R0
        BEQ     ClaimExit                       ;EQ already in requested state

        LDRB    R3, BrightnessHold              ;NE not in requested state
        TEQ     R3, #1                          ;
        BEQ     ClaimExit                       ;EQ leave screen dim, cos user set it so
;^^^merge above
       ;LDRB    R2, BrightnessIndex1            ;NB Swap values
       ;LDRB    R1, BrightnessIndex2            ; (final store of R1 into BrightnessIndex1
        STRB    R2, BrightnessIndex2            ;  performed by subroutine)
        BL      SetBrightness                   ;In R1=brightness value
        B       ClaimExit                       ;finish
 ]

;******************************************************************************
;
;       ADFSPowerOp - Issue an ADFS_PowerControl SWI to all IDE drives
;
; in:   r0, r2 are the parameters we wish to pass to the SWI
;
; out:  -
;

ADFSPowerOp Entry "r0-r4"
        MOV     r4, r0                          ; save r0 value
        MOV     r1, #4                          ; for drive = 4 to 7
10
        MOV     r0, r1                          ; read type of drive
        SWI     XADFS_ControllerType
        BVS     %FT20                           ; if error then skip
        TEQ     r0, #4                          ; if IDE drive
        MOVEQ   r0, r4                          ; then perform operation
        SWIEQ   XADFS_PowerControl
 [ {FALSE}
        BVC     %FT20
        ADD     R0, R0, #4      ;skip error number
       ;DLINE   R0, "XADFS_PowerControl reported: ",,String
 ]
20
        ADD     r1, r1, #1
        TEQ     r1, #8
        BNE     %BT10
        EXITS


;******************************************************************************
;
; CheckForCMOSReset - Check CMOS reset bit in CMOS RAM, and reconfigure
;                     certain values if so
;
; Entry:
;
; Exit:
;   R0-R7 may be corrupted
;
CheckForCMOSReset Entry
        MOV     r0, #ReadCMOS
        MOV     r1, #SystemSpeedCMOS            ;CMOS reset indicator location
        SWI     XOS_Byte
        EXITS   VS                              ;if couldn't read it then finish

        TST     r2, #CMOSResetBit               ;or if bit clear then finish
        EXITS   EQ

; Set configured Delay to 25 and Repeat to 6 and reflect in current states

        ADR     r0, ConfigureDelayCommand
        SWI     XOS_CLI
        ADRL    r0, ConfigureRepeatCommand
        SWI     XOS_CLI
        MOV     r0, #12
        MOV     r1, #0
        SWI     XOS_Byte                        ;set current delay and repeat to configured

; Set configured screen-blanking time to 5 minutes and reflect in current state

        MOV     r0, #ReadCMOS
        MOV     r1, #Misc1CMOS
        SWI     XOS_Byte
        BICVC   r2, r2, #7 :SHL: 3
        ORRVC   r2, r2, #4 :SHL: 3              ; 0=>none, 1=>30s, 2=>1min, 3=>2min,
        MOVVC   r0, #WriteCMOS                  ; 4=>5min, 5=>10min, 6=>15min, 7=>30min
        SWIVC   XOS_Byte
        ADRL    r0, BlankTimeCommand
        SWI     XOS_CLI

; Set configured SoundDefault to 1 6 2 and reflect in current states

        MOV     r0, #WriteCMOS
        MOV     r1, #SoundCMOS
        MOV     r2, #(1 :SHL: 7) :OR: (6 :SHL: 4) :OR: ((2-1) :SHL: 0)
        SWI     XOS_Byte

        MOV     r0, #6*18+1                     ; set volume to 6
        SWI     XSound_Volume                   ; (speaker should already be set to 1)

        MOV     r0, #1                          ; set channel 1
        MOV     r1, #2                          ; to use voice generator 2 (StringLib-Soft)
        SWI     XSound_AttachVoice

; Set configured beep to Loud and reflect in current state

        MOV     r0, #ReadCMOS
        MOV     r1, #DBTBCMOS
        SWI     XOS_Byte
        ORRVC   r2, r2, #2                      ; set beep to LOUD
        MOVVC   r0, #WriteCMOS
        SWIVC   XOS_Byte

        MOV     r0, #212                        ; OS_Byte number to set bell volume/envelope
        MOV     r1, #&90
        MOV     r2, #0
        SWI     XOS_Byte

; Set configured IDE disc spin to 2 mins and reflect in current state

        MOV     r0, #WriteCMOS
        MOV     r1, #ADFSSpinDownCMOS           ; set configured autospindown
        MOV     r2, #120/5                      ; to 2 minutes = 120 seconds
        SWI     XOS_Byte
        MOV     r0, #1                          ; set drive autospindown
        MOV     r2, #120/5                      ; to same
        BL      ADFSPowerOp

; Make !BatMgr appear on icon bar by default

        MOV     r0, #ReadCMOS
        MOV     r1, #Deskboot2CMOS
        SWI     XOS_Byte
        ORRVC   r2, r2, #1                      ; bit 0 set => appear on icon bar, clear => don't
        MOVVC   r0, #WriteCMOS
        SWIVC   XOS_Byte
;
; Set 'bright' and 'dim' brightness levels, 'idle mode inhibit' and 'lid closure'
; Pack 'current' into bits 0..2 and 'other' into bits 3..5
;
        MOV     R2, #(default_LCDBrightness1 :OR: (default_LCDBrightness2 :SHL: 3))

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #BrightnessCMOS
        SWIVC   XOS_Byte
;
; Set contrast level
;
        MOV     R0, #ReadCMOS
        MOV     R1, #ContrastCMOS
        SWI     XOS_Byte                        ;result in R2.b

        BICVC   R2, R2, #2_00111111
        ORRVC   R2, R2, #default_LCDContrast

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #ContrastCMOS
        SWIVC   XOS_Byte
;
; Set 'screen dim time' and 'freeze time' values
; Pack 'screen dim time' into bits 0..2 and 'freeze time' into bits 3..5
;
        MOV     R0, #ReadCMOS
        MOV     R1, #TimeCMOS
        SWI     XOS_Byte                        ;result in R2.b

        BICVC   R2, R2, #2_00111111             ;clear both time values
        ORRVC   R2, R2, #(default_DimTime :OR: (default_FreezeTime :SHL: 3))

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #TimeCMOS
        SWIVC   XOS_Byte

;>>>set MonitorType of 7 (or should it be 8???) for LCD

        EXITS

ConfigureDelayCommand
        =       "Configure Delay 25", 0
ConfigureRepeatCommand
        =       "Configure Repeat 6", 0
BlankTimeCommand
        =       "BlankTime 300", 0              ; 300 seconds = 5 minutes
        ALIGN

;******************************************************************************

ErrorLookupNoParms      Entry   "R1-R7"
;
; Entry:
;    R0 -> error block with tokenised message
;
; Exit:
;    R0 -> error block with real message
;    V set

        MOV     R4,#0                           ; no parameter 0
        B       ErrorLookupContinue

ErrorLookup1Parm        ALTENTRY
;
; Entry:
;    R0 -> error block with tokenised message
;    R4 -> parameter to substitute into error
;
; Exit:
;    R0 -> error block with real message
;    V set

ErrorLookupContinue

        wsaddr  R1,MsgTransBlk
        MOV     R2,#0                           ; use internal buffer
        MOV     R5,#0                           ; no parameter 0
        MOV     R6,#0                           ; no parameter 0
        MOV     R7,#0                           ; no parameter 0
        SWI     XMessageTrans_ErrorLookup
        EXIT

;******************************************************************************
;
; StartSleepTimer - called when screen blanks (ie paletteV_BlankScreen)
;
; We define BlankTime and FreezeTime as starting when the user last pressed a key or moved
; the mouse. Since this routine is called at the expiry of the screen blank timer, we must
; subtract the BlankTime from FreezeTime to give the time remaining before freezing.
;
; No params, all registers preserved
;
StartSleepTimer Entry "R0-R2"
        LDRB    R0, SleepTimerFlag
        TEQ     R0, #0
        EXITS   NE                              ;NE, reentry, no action required
;DLINE "StartSleepTimer"
        LDR     R0, SleepTimerDelay             ;sleep time delay
        TEQ     R0, #0
        EXITS   EQ                              ;EQ, freeze timer switched off

 [ {TRUE}
        MOV     R0, #ScreenBlankerReason_ReadTimeout2
        SWI     XScreenBlanker_Control          ;Returns: R0 corrupted, R1=blanking delay (centi-seconds)
        MOVVS   R1, #0
 |
        MOV     R0, #ScreenBlankerReason_ReadTimeout
        SWI     XScreenBlanker_Control          ;Returns: R0 corrupted, R1=blanking delay (seconds)
        MOVVS   R1, #0                          ;despite what the documentation says, R1 is in seconds
        MLA     R1, R1, #100                    ;convert to centi-seconds
 ]
        LDR     R0, SleepTimerDelay             ;sleep time delay
        SUB     R0, R0, R1                      ;calculate time remaining
        CMP     R0, #50                         ;If FreezeTime <= BlankTime
        MOVLT   R0, #50                         ; then switch off now (almost)

RestartSleepTimer
        ADR     R1, SleepTimerCallAfter         ;routine to call after timer expires
        MOV     R2, R12                         ;R12 value to call it with
        SWI     XOS_CallAfter                   ;if this fails, the 'go to sleep' event never happens...
        MOVVC   R0, #1                          ;eventually we receive a battery low interrupt
        STRVCB  R0, SleepTimerFlag
        EXITS

;******************************************************************************
;
; CancelSleepTimer
;
; No params, all registers preserved
;
CancelSleepTimer Entry "R0-R2"
        LDRB    R0, SleepTimerFlag
        TEQ     R0, #0
        EXITS   EQ
        ADR     R0, SleepTimerCallAfter         ;address and workspace originally
        MOV     R1, R12                         ;passed to OS_CallAfter
        SWI     XOS_RemoveTickerEvent

        MOV     R0, #0
        STRB    R0, SleepTimerFlag
        EXITS

;******************************************************************************

SleepTimerCallAfter Entry "R0-R2"
        ADR     R0, SleepTimerCallBack
        MOV     R1, R12
        SWI     XOS_AddCallBack
        EXITS

SleepTimerCallBack Entry "R0-R2"
        MOV     R0, #0                          ;timer cleared once it fires
        STRB    R0, SleepTimerFlag

        SWI     XPortable_Stop                  ;try putting the machine to sleep
        EXITS   VC                              ;VC machine stopped then restarted
                                                ;VS something objected
        MOV     R0, #RetryDelay
        B       RestartSleepTimer

; Aside: XPortable_Stop calls Screen blanker to blank the screen (it happens to be blanked).
;        This causes us to be entered via PaletteV and another sleep timer is set up.
;        The machine then sleeps.
;        As soon as the machine restarts, the Screen blanker is called to unblank the screen,
;        it calls us via PaletteV which cancels the sleep timer.

FreezeTimes
        DCD     0               ;Off
        DCD     60*100          ; 1 minute
        DCD     2*60*100        ; 2 minutes
        DCD     5*60*100        ; 5 minutes
        DCD     10*60*100       ;10 minutes
        DCD     15*60*100       ;15 minutes
        DCD     30*60*100       ;30 minutes
        DCD     60*60*100       ;60 minutes
FreezeTimesMaxIndex * ((. - FreezeTimes)/4 - 1)
        ASSERT  FreezeTimesMaxIndex = 7

        ASSERT  default_FreezeTime <= FreezeTimesMaxIndex

;******************************************************************************

; KillRTCAlarm  - Cancel alarm completely on module startup.
;
; ClearRTCAlarm - Clear any previously flagged alarm prior to freeze/shutdown.
;
KillRTCAlarm
        Push    "R0-R2,LR"
        MOV     R0, #IICAddress_AcornRTC
        ADR     R1, IICBlk_2
        MOV     R2, #2
        SWI     XIIC_Control
        Pull    "R0-R2,LR"                      ;drop into...

ClearRTCAlarm
        Push    "R0-R2,LR"
        MOV     R0, #IICAddress_AcornRTC
        ADR     R1, IICBlk_1
        MOV     R2, #2
        SWI     XIIC_Control
        Pull    "R0-R2,PC",,^                   ;drop into...

IICBlk_1
        DCB     0       ;Control/status register
        DCB     &04     ; Alarm enable bit=1 (alarm active), stops RTC interrupt line pulsing
                        ; at 1Hz, also clears alarm flag (bit1)

IICBlk_2
        DCB     8       ;Alarm control register
        DCB     &00     ; all alarms and timers off

        ALIGN


;******************************************************************************

 [ Debug
        InsertDebugRoutines
 ]

;******************************************************************************

        END
