; Copyright 2021 RISC OS Open Limited
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

; Maths functions from <math.h> in the SharedCLibrary - translated by hand
; to stand alone in VFPSupport

INT_MAX         * &7FFFFFFF
INT_MIN         * &80000000
FP_ILOGB0       * -INT_MAX
FP_ILOGBNAN     * INT_MIN

        EXPORT  NextAfter
        EXPORT  FRExp
        EXPORT  LDExp
        EXPORT  ILogB

        GBLL    BehaveLikeVFP
BehaveLikeVFP SETL {TRUE}
        GBLL    UseSharedCLib
UseSharedCLib SETL {FALSE}

        ; double nextafter(double a, double b)
        ; Return the next machine value after a in the direction of b
NextAfter ROUT
      [ UseSharedCLib
        IMPORT  nextafter
        Push    "a1-a2, lr"
        VMOV    a2, a1, d0              ; Note FPA ordering
        VMOV    a4, a3, d1              ; Note FPA ordering
        BL      nextafter
        STFD    f0, [sp]
        Pull    "a1-a2, lr"
        VMOV    d0, a2, a1              ; Note FPA ordering
        BX      lr
      ]
        Push    "v1, lr"
        LDR     v1, =&7FF
        VMOV    a1, a2, d0
        ExpBits64 ip, a2
        TEQ     ip, v1
        BNE     %FT10
        ORRS    ip, a1, a2, LSL #1+11
        BNE     %FT20
10
        VMOV    a3, a4, d1
        ExpBits64 ip, a4
        TEQ     ip, v1
        BNE     %FT30
        ORRS    ip, a3, a4, LSL #1+11
        BEQ     %FT30
20
        VADD.F64 d0, d0, d1             ; a or b were NaN
        Pull    "v1, pc"
30
        VCMP.F64 d0, d1
        VMRS    APSR_nzcv, FPSCR
        VMOVEQ.F64 d0, d1               ; a == b
        Pull    "v1, pc",EQ

        ORRS    ip, a1, a2, LSL #1
        BNE     %FT40
        AND     a4, a4, #1:SHL:31       ; a == 0
        MOV     a3, #1
        VMOV    d0, a3, a4              ; ulp with sign of b
        MOV     a1, #FPSCR_UFC
        BL      RaiseException
        Pull    "v1, pc"
40
        TST     a2, #1:SHL:31
        BNE     %FT50
        VMRS    APSR_nzcv, FPSCR        ; a > 0
        BGT     ulpm                    ;       a > b
        B       ulpp                    ;       a < b
50
        VMRS    APSR_nzcv, FPSCR        ; a < 0
        BGT     ulpp                    ;       a > b
ulpm                                    ;       a < b
        SUBS    a1, a1, #1
        SBC     a2, a2, #0              ; -1 ulp
        B       %FT60
ulpp
        ADDS    a1, a1, #1
        ADC     a2, a2, #0              ; +1 ulp
60
        VMOV    d0, a1, a2
        ExpBits64 ip, a2
        CMP     ip, v1                  ; overflowed?
        MOVCS   a1, #FPSCR_OFC
        BCS     %FT90
        CMP     ip, #1:SHL:20           ; underflowed?
        Pull    "v1, pc",CS             ; normal
        MOV     a1, #FPSCR_UFC
90
        BL      RaiseException
        Pull    "v1, pc"

        ; double frexp(double a, int *e)
        ; Split a double into exponent and mantissa
FRExp ROUT
      [ UseSharedCLib
        IMPORT  frexp
        Push    "a1-a2, lr"
        MOV     a3, a1
        VMOV    a2, a1, d0              ; Note FPA ordering
        BL      frexp
        STFD    f0, [sp]
        Pull    "a1-a2, lr"
        VMOV    d0, a2, a1              ; Note FPA ordering
        BX      lr
      ]
        Push    "v1, lr"
        MOV     v1, a1
        VMOV    a1, a2, d0
        ExpBits64 ip, a2
        LDR     a3, =&7FF
        ; ip = exponent, a3 = &7FF
        TEQ     ip, a3                  ; NaN or ±INF
        BEQ     %FT30
        LDR     a3, =DBL_EXP_BIAS - 1
        TEQ     ip, #0                  ; 0.0 or subnormal
        BEQ     %FT10
        SUB     a4, ip, a3              ; Normal
        B       %FT40
10
        ; exponent == 0
        ORRS    a4, a1, a2, LSL #1
        MOVEQ   a4, #0
        STREQ   a4, [v1]                ; 0.0
        Pull    "v1, pc",EQ
        SUB     ip, ip, a3
        ADD     ip, ip, #1
        AND     lr, a2, #1:SHL:31       ; Keep the sign
20
        TST     a2, #1:SHL:19           ; Top bit of fractional part
        MOV     a4, a1, LSR #31
        ORR     a2, a4, a2, LSL #1
        MOV     a1, a1, LSL #1
        SUB     ip, ip, #1
        BEQ     %BT20
        BIC     a2, a2, #1:SHL:31
        ORR     a2, a2, lr              ; Put sign back
        MOV     a4, ip
        B       %FT40
30
        ; exponent == &7FF
        ORRS    a4, a1, a2, LSL #1+11
        LDRNE   a4, =FP_ILOGBNAN
        LDREQ   a4, =INT_MAX
        STR     a4, [v1]
        Pull    "v1, pc"
40
        STR     a4, [v1]
      [ NoARMT2
        BIC     a2, a2, #&70000000
        BIC     a2, a2, #&0FF00000
        ORR     a2, a2, a3, LSL #20
      |
        BFI     a2, a3, #20, #11
      ]
        VMOV    d0, a1, a2
        Pull    "v1, pc"

        ; double ldexp(double a, int e)
        ; Load the exponent to a double
LDExp ROUT
    [ UseSharedCLib
        IMPORT  ldexp
        Push    "a1-a2, lr"
        MOV     a3, a1
        VMOV    a2, a1, d0              ; Note FPA ordering
        BL      ldexp
        STFD    f0, [sp]
        Pull    "a1-a2, lr"

      [ BehaveLikeVFP
        LDRD    a3, a4, hugeval
        BIC     ip, a1, #1:SHL:31       ; Note FPA ordering
        TEQ     a4, ip
        TEQEQ   a3, a2
        VMOVNE.F64 d0, a2, a1           ; Note FPA ordering
        BXNE    lr
        VLDR    d0, dblinf              ; Map ±HUGE_VAL to ±INF for compatibility
        TST     a1, #1:SHL:31
        VNEGNE.F64 d0, d0
        BX      lr
      ]
    ]
        Push    "v1, lr"
        MOVS    v1, a1
        Pull    "v1, pc",EQ             ; n = 0
        VMOV    a1, a2, d0
        ExpBits64 ip, a2
        LDR     a3, =&7FF
        ; ip = exponent, a3 = &7FF
        TEQ     ip, a3                  ; NaN or ±INF
        Pull    "v1, pc",EQ
        TEQ     ip, #0                  ; 0.0 or subnormal
        BNE     %FT20

        ; Starting subnormal or zero
        ORRS    a4, a1, a2, LSL #1
        Pull    "v1, pc",EQ             ; return a
        ADD     ip, ip, #1
        AND     lr, a2, #1:SHL:31       ; Keep the sign
10
        TST     a2, #1:SHL:19           ; Top bit of fractional part
        MOV     a4, a1, LSR #31
        ORR     a2, a4, a2, LSL #1
        MOV     a1, a1, LSL #1
        SUB     ip, ip, #1
        BEQ     %BT10
        BIC     a2, a2, #1:SHL:31
        ORR     a2, a2, lr              ; Put sign back
20
        ADD     a4, ip, v1
        CMP     v1, #&1000
        BGT     %FT30
        CMP     a4, a3
        BLT     %FT40
30
        ; Overflowed
        MOV     v1, a2
        MOV     a1, #FPSCR_OFC :OR: FPSCR_IXC
        BL      RaiseException
        TST     v1, #1:SHL:31
      [ BehaveLikeVFP
        VLDR    d0, dblinf              ; Return ±INF on overflow
      |
        VLDR    d0, hugeval             ; Return ±HUGE_VAL on overflow
      ]
        VNEGNE.F64 d0, d0
        Pull    "v1, pc"

        LTORG

dblinf  DCD     &00000000, &7FF00000
hugeval DCD     &FFFFFFFF, &7FEFFFFF
twom53  DCD     &00000000, &3CA00000

40
        CMP     v1, #-&1000
        BLT     %FT50
        CMP     a4, #-DBL_MANT_DIG
        BGT     %FT60
50
        ; Total underflow
        MOV     v1, a2
        MOV     a1, #FPSCR_UFC :OR: FPSCR_IXC
        BL      RaiseException
        AND     a2, v1, #1:SHL:31
        MOV     a1, #0
        VMOV    d0, a1, a2              ; Return ±0 on underflow
        Pull    "v1, pc"
60
        CMP     a4, #0
        ADDLE   a4, a4, #DBL_MANT_DIG
      [ NoARMT2
        BIC     a2, a2, #&70000000
        BIC     a2, a2, #&0FF00000
        ORR     a2, a2, a4, LSL #20
      |
        BFI     a2, a4, #20, #11
      ]
        VMOV    d0, a1, a2
        Pull    "v1, pc",GT
70
        ; Subnormal result
        VLDR    d1, twom53
        VMUL.F64 d0, d0, d1             ; Scaled up and rounded to nearest
        VCMP.F64 d0,#0.0
        VMRS    APSR_nzcv, FPSCR
        MOVEQ   a1, #FPSCR_UFC :OR: FPSCR_IXC
        BLEQ    RaiseException
        Pull    "v1, pc"

        ; int ilogb(double a)
        ; Return the unbiased exponent of a double
ILogB ROUT
      [ UseSharedCLib
        IMPORT  ilogb
        Push    "lr"
        VMOV    a2, a1, d0              ; Note FPA ordering
        BL      ilogb
        Pull    "pc"
      ]
        VMOV    a1, a2, d0
        ExpBits64 ip, a2
        LDR     a3, =&7FF
        ; ip = exponent, a3 = &7FF
        TEQ     ip, a3                  ; NaN or ±INF
        BEQ     %FT30
        TEQ     ip, #0                  ; 0.0 or subnormal
        BEQ     %FT10
        SUB     a1, ip, a3, LSR #1      ; Normal
        BX      lr
10
        ; exponent == 0
        ORRS    a4, a1, a2, LSL #1+11
        LDREQ   a1, =FP_ILOGB0          ; 0.0
        BEQ     %FT40
        MOV     ip, #1
20
        TST     a2, #1:SHL:19           ; Top bit of fractional part
        MOV     a4, a1, LSR #31
        ORR     a2, a4, a2, LSL #1
        MOV     a1, a1, LSL #1
        SUB     ip, ip, #1
        BEQ     %BT20
        SUB     a1, ip, a3, LSR #1
        BX      lr
30
        ; exponent == &7FF
        MOV     a2, a2, LSL #1+11
        ORRS    a4, a2, a1
        LDRNE   a1, =FP_ILOGBNAN
        LDREQ   a1, =INT_MAX
40
        Push    "a1, lr"
        MOV     a1, #FPSCR_IOC
        BL      RaiseException
        Pull    "a1, pc"

        END
