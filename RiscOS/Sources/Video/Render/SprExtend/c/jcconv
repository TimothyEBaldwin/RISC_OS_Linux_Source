/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* c.jcconv - various cases of colour conversion which are not
important enough to be coded in assembler. */

void mono_convert_block(JBLOCK jblock, int *outptr, int outoffset)
/* Convert greyscale image into 32bit RBG values. */
{
  int i, j;

  for (j = 0; j < 8; j++)
  {
    for (i = 0; i < 8; i++)
    {
      int y;

      y = jblock[j + i*8];          /* extract, NB in row order */
      y = (y + (1<<18)) >> 19;      /* descale */
      y += 128;                     /* normalise */
      if (y < 0) y = 0;             /* clip */
      if (y > 255) y = 255;
      y = y | (y << 8) | (y << 16); /* construct RGB value */
      outptr[i] = y;
    }
    outptr += outoffset;
  }
}

static int mono_convert_pixel(decompress_info_ptr cinfo, int pix)
/* Just do a single pixel - eg. for DC-only display. The pixel does not have to
be shifted down, as it has not gone through the DCT. */
{
  int y = pix;

  y += 128;                      /* normalise */
  if (y < 0) y = 0;              /* range check */
  if (y > 255) y = 255;
  return y | (y << 8) | (y << 16); /* replicate Y value */
}


#ifdef FIX
  #undef FIX
#endif
#define SCALEBITS       8 /*16*/      /* speedier right-shift on some machines */
#define ONE_HALF        ((INT32) 1 << (SCALEBITS-1))
#define FIX(x)          ((INT32) ((x) * (1L<<SCALEBITS) + 0.5))

#if 0
extern int gun_oflow = 0; /* pixels that did in some way overflow, +ve or -ve */
extern int gun_noflow = 0; /* didn't overflow */
/* Result of this experiment - about 6K/135K (<5%) of pixels in the dragon picture overflow. */
#endif

void colour_convert_block(JCOEF *yuv, int *outptr, int outoffset)
/* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block */
{
  int i, j;
  JCOEF *by0 = yuv;
  JCOEF *by1 = by0 + DCTSIZE2;
  JCOEF *by2 = by1 + DCTSIZE2;
  JCOEF *by3 = by2 + DCTSIZE2;
  JCOEF *bu = by3 + DCTSIZE2;
  JCOEF *bv = bu + DCTSIZE2;

  for (j = 0; j < 16; j++)
  {
    for (i = 0; i < 16; i++)
    {
      int y;
      int u;
      int v;

      y = (j < 8 ? (i < 8 ? by0 : by1) : (i < 8 ? by2 : by3))[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>1) + (i>>1)*8];
      v = bv[(j>>1) + (i>>1)*8];

      y = (y + (1<<18)) >> 19;      /* descale */
      y += 128;                     /* normalise */
      u = (u + (1<<18)) >> 19;
      v = (v + (1<<18)) >> 19;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += ONE_HALF; r >>= SCALEBITS; r += y; if (r < 0) r = 0; if (r > 255) r = 255;
        g += ONE_HALF; g >>= SCALEBITS; g += y; if (g < 0) g = 0; if (g > 255) g = 255;
        b += ONE_HALF; b >>= SCALEBITS; b += y; if (b < 0) b = 0; if (b > 255) b = 255;
        outptr[i] = r | (g << 8) | (b << 16);
      }
    }
    outptr += outoffset;
  }
}

static void colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset, int wide, int high)
/* yuv[0..1] are Y, yuv[4] is U, yuv[5] is V. wide/high are 1 or 2. Both being 2 is the
most common case, for which we use hand-coded assembler instead. */
{
  unsigned int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *bu = yuv + 4*DCTSIZE2;
  JCOEF *bv = yuv + 5*DCTSIZE2;

  for (j = 0; j < 8*high; j++)
  {
    for (i = 0; i < 8*wide; i++)
    {
      int y;
      int u;
      int v;

      /* Simplification because we don't use this code in the 2x2 case, so
       * we only need to worry about accessing a second block. */

      y = ((i < 8 && j < 8) ? by0 : by1)[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>(high-1)) + (i>>(wide-1))*8];
      v = bv[(j>>(high-1)) + (i>>(wide-1))*8];

      y = (y + (1<<18)) >> 19;      /* descale */
      y += 128;                     /* normalise */
      u = (u + (1<<18)) >> 19;
      v = (v + (1<<18)) >> 19;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += ONE_HALF; r >>= SCALEBITS; r += y; if (r < 0) r = 0; if (r > 255) r = 255;
        g += ONE_HALF; g >>= SCALEBITS; g += y; if (g < 0) g = 0; if (g > 255) g = 255;
        b += ONE_HALF; b >>= SCALEBITS; b += y; if (b < 0) b = 0; if (b > 255) b = 255;
        outptr[i] = r | (g << 8) | (b << 16);
      }
    }
    outptr += outoffset;
  }
}

static void colour_convert_pixels(int *y, int u, int v)
/* Convert four pixels. Input y values are in y[0..3], put output there too.
Used for DC-only colour output. The input pixels do not have to be shifted
down by 19, as they have not been through the DCT. */
{
  u = (u + 4) >> 3; /* descale */
  v = (v + 4) >> 3;

  {
    int r =                        v * FIX(1.40200);
    int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
    int b =     u * FIX(1.77200);
    int i;
    int rr, gg, bb, yy;

    r += ONE_HALF; r >>= SCALEBITS;
    g += ONE_HALF; g >>= SCALEBITS;
    b += ONE_HALF; b >>= SCALEBITS;
    for (i = 0; i < 4; i++)
    {
      yy = ((y[i] + 4) >> 3) + 128;
      rr = r + yy; if (rr < 0) rr = 0; if (rr > 255) rr = 255;
      gg = g + yy; if (gg < 0) gg = 0; if (gg > 255) gg = 255;
      bb = b + yy; if (bb < 0) bb = 0; if (bb > 255) bb = 255;
      y[i] = rr | (gg << 8) | (bb << 16);
    }
  }
}

static void mono_convert_pixels(int *y)
/* Convert four pixels. Input y values are in y[0..3], put output there too.
Used for DC-only mono output. The input pixels do not have to be shifted
down by 19, as they have not been through the DCT. */
{
  int i;
  int yy;

  for (i = 0; i < 4; i++)
  {
    yy = ((y[i] + 4) >> 3) + 128;
    if (yy < 0) yy = 0; if (yy > 255) yy = 255;
    y[i] = yy | (yy << 8) | (yy << 16);
  }
}

#if 0
/* This isn't called by anyone at the moment, I can't get the relationship
with the scaling code precisely right. */

static void interpolate_x(decompress_info_ptr cinfo)
/* The band buffer contains 8 or 16 lines of decompressed data. Double the
size of each line, by interpolating the pixels. There is enough room. We
actually do a teeny approximation by ignoring the bottom bit of each colour
gun when doing the interpolation, but this is almost certainly OK given the
inaccuracies that have already happened in the JPEG process. */
{
  int l2_band_height = 2 + cinfo->comp_info[0].v_samp_factor; /* log2 of band height - 3 for mono, usually 4 for colour */
  /* int band_height = 1 << l2_band_height; */
  int line_offset = cinfo->band_buffer_size >> l2_band_height; /* offset in words between lines of output */
  int *line_ptr;
  int *line_lim;
  int pix_mask = 0x00fefefe; /* mask to knock out bot pixel of each gun */

  for (line_ptr = cinfo->band_buffer, line_lim = cinfo->band_buffer + cinfo->band_buffer_size; line_ptr < line_lim; line_ptr += line_offset)
  {
    int prev_pixel = line_ptr[cinfo->image_width - 1] & pix_mask;
    int *pix_ptr;
    int *out_ptr = line_ptr + 2*cinfo->image_width;

    for (pix_ptr = line_ptr + cinfo->image_width; pix_ptr != line_ptr;)
    {
      int this_pixel = *--pix_ptr;
      int trunc_this_pixel = this_pixel & pix_mask;

      *--out_ptr = (trunc_this_pixel + prev_pixel) >> 1;
      *--out_ptr = this_pixel;
      prev_pixel = trunc_this_pixel;
    }
  }
}
#endif
