; Copyright 2013 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; YUV to RGB conversion code, for 16bpp output

; This is too big to be used as a macro, so it's in its own seperate file which
; can be GET'd multiple times instead

; Input variables:
;   red_bits = number of bits of red bits in output pixel
;   green_bits = number of bits of blue bits
;   blue_bits = number of bits of green bits
;   red_shift = position of lowest red bit in output pixel
;   green_shift = position of lowest green bit
;   blue_shift = position of lowest blue bit
;   alpha_value = alpha value to set in output pixel
;   function_name = function name to export


        ; Almost identical to the 32bpp case in Sources.jdcolor, except that 16bit pixels are generated.
        ; An ordered dither is added to this using Bayer's ordered dither matrix of
        ; of D2 = [ 3   1 ]
        ;         [ 0   2 ]
        ; Really only good for 1:1 plotting in 16bpp, thus a block copy can move it to the
        ; screen, and the whole thing is a great deal faster.

        ; extern void $function_name(JCOEF *yuv, short *outptr, int outoffset)
        ; /* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 16bit pixels */
        ;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
        ;   r1 -> output buffer
        ;   r2 = offset in words between rows of output
        ; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  $function_name
$function_name
        STMDB   sp!,{r0-r1,r4-r11,lr}       ; save state
        ADD     r3,r1,#(2*DCTSIZE)*2        ; column limit pointer (inner loop) - outptr+16 halfwords
        ADD     r4,r1,r2,LSL #3+2           ; row limit pointer (outer loop) - outptr+8*outoffset words
        ADD     r5,r0,#4*DCTSIZE2*4         ; pointer into U block. V values DCTSIZE2 words on from this
        ADD     r6,r4,r2,LSL #3+2           ; real row limit pointer - outptr+16*outoffset words

        STMIA   sp,{r4,r6}                  ; r4 and r6 used as temp workspace during the colour conversion:
                                            ; we never need to reload r0/r1, so use these stack locations.

        ; The main loop goes round once for each 2*2 square of four output pixels, using
        ; four Y values, one U value, one V value.
$function_name._loop                        ; each two rows and each two columns of output

        ; do four output pixels, using:
        ; [r5] is U value
        ; [r5,#DCTSIZE2*4] is V value
        ; [r0] and [r0,#DCTSIZE*4] are Y values for output word [r1]
        ; [r0,#4] and [r0,#DCTSIZE*4+4] are Y values for output word [r1,r2,LSL #2]

        ; first we compute the values derived from U and V, which are
        ; true for all four pixels.
        LDR     r7,[r5]                     ; U value
        MOV     r7,r7,ASR #8                ; the multiplies will get us back to SCALEBITS again
        LDR     r8,[r5,#DCTSIZE2*4]         ; V value
        MOV     r8,r8,ASR #8                ; the multiplies will get us back to SCALEBITS again
        ; Should add 1:SHL:7 before ASR #8, but not regarded as significant enough
        ; considering how much bigger SCALEBITS is.

        ; Multiply sequences generated by cc 4.50, for 8 bits of accuracy.
        ; these sequences lead to a result shifted left by 8 bits.
        ;MulCon r9,r7,FIX(1.77200)          ; B, without the Y yet
        ADD     r9,r7,r7,LSL #5
        RSB     r9,r9,r7,LSL #8
        SUB     r9,r9,r7,LSL #3             ; still needs a LSL #1
        
        ;MulCon r10,r8,FIX(1.40200)         ; R, without the Y yet
        ADD     r10,r8,r8,LSL #5
        RSB     r10,r10,r10,LSL #3
        ADD     r10,r10,r8,LSL #7

        ;MulCon r12,r8,-FIX(0.71414)
        RSB     r12,r8,r8,LSL #6
        ADD     r12,r12,r8,LSL #7
        SUB     r12,r12,r8,LSL #3

        ;MulCon r11,r7,-FIX(0.34414)
        ADD     r11,r7,r7,LSL #1
        ADD     r11,r11,r7,LSL #3           ; LSL #3 still needed - see below
        ADD     r11,r12,r11,LSL #3          ; -G, without the Y yet

        ; After those multiplies, the values are shifted up by SCALEBITS again.
        ; We're going to add each of r9/r10/r11 to the Y values.
        ; The Y values need 128 added to them - add it at this point.
        ; need to add a half for the truncation of NormaliseGun16 - do that at the same time.
        MOV     r7,#(ONE_HALF:SHL:(8-red_bits)) + (128:SHL:SCALEBITS)
        ASSERT  red_bits = blue_bits
        ADD     r9,r7,r9,LSL #1             ; LSL #1 still owed to R9 - see above.
        ADD     r10,r7,r10
      [ red_bits <> green_bits
        MOV     r7,#(ONE_HALF:SHL:(8-green_bits)) + (128:SHL:SCALEBITS)
      ]
        RSB     r11,r7,r11                  ; r11 is to be subtracted from Y, not added.
        
        ; now process the four pixels one at a time.
        LDMIA   r0,{r7,r8}                    ; first two Y values, shifted up by SCALEBITS
        ;ADD    r7,r7,#0:SHL:SCALEBITS        ; ordered dither
        ADD     r8,r8,#4:SHL:SCALEBITS        ; ordered dither
        NormaliseGun ADD,r12,r7,r9,blue_bits  ; B
        NormaliseGun ADD,lr,r7,r10,red_bits   ; R
        NormaliseGun SUB,r7,r7,r11,green_bits ; G
        ; compute output pixel
        CombineRGB r4,lr,r7,r12,alpha_value,red_shift,green_shift,blue_shift

        NormaliseGun ADD,r12,r8,r9,blue_bits  ; B
        NormaliseGun ADD,lr,r8,r10,red_bits   ; R
        NormaliseGun SUB,r8,r8,r11,green_bits ; G
        ; compute output pixel
        CombineRGB r6,lr,r8,r12,alpha_value,red_shift,green_shift,blue_shift

        ADD     r7,r0,#DCTSIZE*4              ; prepare to load next two pixels
        
        LDMIA   r7,{r7,r8}                    ; other two pixels
        ADD     r7,r7,#6:SHL:SCALEBITS        ; ordered dither
        ADD     r8,r8,#2:SHL:SCALEBITS        ; ordered dither
        NormaliseGun ADD,r12,r7,r9,blue_bits  ; B
        NormaliseGun ADD,lr,r7,r10,red_bits   ; R
        NormaliseGun SUB,r7,r7,r11,green_bits ; G
        ; compute output pixel
        CombineRGB r7,lr,r7,r12,alpha_value,red_shift,green_shift,blue_shift

        ORR     r7,r4,r7,LSL #16              ; combine two pixels
        STR     r7,[r1]                       ; output two pixels

        NormaliseGun ADD,r12,r8,r9,blue_bits  ; B
        NormaliseGun ADD,lr,r8,r10,red_bits   ; R
        NormaliseGun SUB,r8,r8,r11,green_bits ; G
        ; compute output pixel
        CombineRGB r8,lr,r8,r12,alpha_value,red_shift,green_shift,blue_shift

        ORR     r8,r6,r8,LSL #16            ; combine the two pixels
        STR     r8,[r1,r2,LSL #2]           ; output pixel
        ADD     r1,r1,#4

        ; increment pointers to go two pixels along an output row
        ; r1 (output pointer) already updated
        ADD     r5,r5,#DCTSIZE*4            ; pointer into row-organised U,V values
        ADD     r0,r0,#2*DCTSIZE*4          ; ditto for Y values

        ; check for end of row
        CMP     r1,r3                       ; output pointer reached end of output row?
        BNE     $function_name._loop        ; go round for next column

        ; Amazingly there is no special action to take half-way along each output row,
        ; when we switch from one Y block to the next - because of the ordering and
        ; arrangement of the Y blocks, it just acts as a single 8*16 block.

        ; It's the end of the row. Update all input and output pointers to
        ; advance to next one.
        ADD     r1,r1,r2,LSL #2+1           ; advance output ptr by two output rows
        SUB     r1,r1,#2*DCTSIZE*2          ;      ... and then to beginning of next output row.
        SUB     r5,r5,#(DCTSIZE2*4-4)*1     ; advance UV pointer to start of next row
        SUB     r0,r0,#(DCTSIZE2*4-4)*2     ; ditto Y pointer, but back two blocks
        ADD     r3,r1,#2*DCTSIZE*2          ; reset column limit pointer (inner loop) - outptr+16 halfwords

        ; Check for having to change to the second pair of Y blocks, or terminate
        LDMIA   sp,{r4,r6}                  ; reload loop end test registers
        CMP     r1,r4
        BNE     $function_name._loop        ; normal case - we set off on another two rows of output

        ; It's either the half-way point, in which case we need to change to the second pair
        ; of input Y blocks, or it's the end. Test r4 against the 'real' limit pointer.

        CMP     r4,r6                       ; is this the end?
        LDMEQIA sp!,{r0-r1,r4-r11,pc}       ; if so, return - nothing more to do

        ; We've reached the half-way point.
        MOV     r4,r6                       ; next time we test r4 and r6, exit.
        STR     r4,[sp]                     ; remember for final termination
        ADD     r0,r0,#((2*DCTSIZE2)-DCTSIZE)*4  ; advance r0 from end of row 0 of block 0,
                                            ; to start of row 0 of block 2.
        B       $function_name._loop        ; and continue.

        END
