; Copyright 2011 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.jdcolor

; Colour conversion facilities, see also the contents of c.jdcolor.
; 24-Sep-93 - started

        ; All values in DCT blocks are scaled up by SCALEBITS bits.
SCALEBITS * 19
ONE_HALF  * 1:SHL:(SCALEBITS - 1)

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Monochrome colour conversion
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ; If negative, clamp at zero. If >= 2^bits, clamp at (2^bits)-1.
        MACRO
        Clamp   $r,$bits
      [ NoARMv6
        MOVLT   $r,#0                    ; must be preceded by a flags setting op
        CMP     $r,#1:SHL:$bits
      [ $bits > 8
        MOVCS   $r,#(1:SHL:$bits)
        SUBCS   $r,$r,#1                 ; pesky 8 bit immediates
      |
        MOVCS   $r,#(1:SHL:$bits) - 1
      ]
      |                                  ; take a look at my funky USAT
        USAT    $r, #$bits, $r
      ]
        MEND
        
        ; Do descaling etc. for a mono pixel
        MACRO
        MonoConv $r
        ADD     $r,$r,#ONE_HALF          ; rounding prior to truncation
        ADDS    $r,r12,$r,ASR #SCALEBITS ; normalise, truncate
        Clamp   $r,8
        ORR     $r,$r,$r,LSL #8          ; replicate grey value in each of R, G, B
        ORR     $r,$r,$r,LSL #8
        MEND

        ; Do a DC mono pixel no descaling
        MACRO
        MonoDC  $r
        ADD     $r,$r,#4
        MOV     $r,$r,ASR #3             ; descale Y
        ADDS    $r,$r,#128               ; normalise
        Clamp   $r,8
        ORR     $r,$r,$r,LSL #8          ; replicate grey value in each of R, G, B
        ORR     $r,$r,$r,LSL #8
        MEND

        ; Do descaling etc. for a mono pixel
        MACRO
        MonoConv8 $r
        ADD     $r,$r,#ONE_HALF          ; rounding prior to truncation
        ADDS    $r,r12,$r,ASR #SCALEBITS ; normalise, truncate
        Clamp   $r,8
        MEND

        ; Combine three seperate RGB values into a final colour, with an
        ; optional constant alpha value
        MACRO
        CombineRGB $out,$r,$g,$b,$alpha,$red_shift,$green_shift,$blue_shift
      [ $red_shift = 0
        ORR     $out,$r,$g,LSL #$green_shift   ; G and R
        ORR     $out,$out,$b,LSL #$blue_shift  ; complete output pixel
      |
        ASSERT $blue_shift = 0
        ORR     $out,$b,$g,LSL #$green_shift   ; G and B
        ORR     $out,$out,$r,LSL #$red_shift   ; complete output pixel
      ]
      [ $alpha <> 0
        ORR     $out,$out,#$alpha              ; with alpha
      ]
        MEND
       

        ; extern int asm_mono_convert_pixel(int pix)
        ; /* Convert greyscale pixel into 32bit RGB values. */
        ;   r0 = luma, no shifting needed as it's not been through the DCT.
        EXPORT  asm_mono_convert_pixel
asm_mono_convert_pixel
        MonoDC  r0
        MOV     pc,lr

        ; extern int asm_mono_convert_pixels(int *y)
        ; /* Convert 4 greyscale pixels into 32bit RGB values. */
        ;   r0 -> array of luma, no shifting needed as it's not been through the DCT.
        EXPORT  asm_mono_convert_pixels
asm_mono_convert_pixels
        MOV     r1,#4
10
        SUBS    r1,r1,#1
        MOVMI   pc,lr
        LDR     r2,[r0,r1,LSL#2]
        MonoDC  r2
        STR     r2,[r0,r1,LSL#2]
        B       %BT10

        ; extern void asm_mono_convert_block(JBLOCK jblock, int *outptr, int outoffset)
        ; /* Convert greyscale image into 32bit RGB values. */
        ;   r0 = jblock - in row order, values that need descaling
        ;   r1 = outptr - in column order, put RGB values here
        ;   r2 = outoffset - distance (in words) between output rows.
        ;   r11 = col counter.
        ; We LDR from the block and STM to the output rather than visa versa,
        ; because a long sequence of STRs clogs up the write buffer and is slow.
        EXPORT  asm_mono_convert_block
asm_mono_convert_block
        STMDB   sp!,{r4-r11,lr}             ; save state
        MOV     r11,#DCTSIZE                ; col counter
        MOV     r12,#128                    ; required constant

jc_mono_loop
        LDR     r3,[r0,#DCTSIZE*4*0]        ; get a whole row
        LDR     r4,[r0,#DCTSIZE*4*1]        ; interleave order hopes to help ARM8!
        MonoConv r3
        LDR     r5,[r0,#DCTSIZE*4*2]
        MonoConv r4
        LDR     r6,[r0,#DCTSIZE*4*3]
        MonoConv r5
        LDR     r7,[r0,#DCTSIZE*4*4]
        MonoConv r6
        LDR     r8,[r0,#DCTSIZE*4*5]
        MonoConv r7
        LDR     r9,[r0,#DCTSIZE*4*6]
        MonoConv r8
        LDR     r10,[r0,#DCTSIZE*4*7]
        MonoConv r9
        MonoConv r10

        STMIA   r1,{r3-r10}                 ; store a row
        ADD     r1,r1,r2,LSL #2             ; add row offset to output pointer
        ADD     r0,r0,#4                    ; advance input pointer
        SUBS    r11,r11,#1                  ; outer loop
        BNE     jc_mono_loop

        LDMIA   sp!,{r4-r11,pc}

        ; extern void asm_mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset)
        ; /* Convert greyscale image into 8bit Grey values. */
        ;   r0 = jblock - in row order, values that need descaling
        ;   r1 = outptr - in column order, put grey values here
        ;   r2 = outoffset - distance (in words) between output rows.
        ;   r11 = col counter.
        ; We LDR from the block and STM to the output rather than visa versa,
        ; because a long sequence of STRs clogs up the write buffer and is slow.
        EXPORT  asm_mono_convert_block_8
asm_mono_convert_block_8
        STMDB   sp!,{r4-r11,lr}             ; save state
        MOV     r11,#DCTSIZE                ; col counter
        MOV     r12,#128                    ; required constant

jc_mono_loop8
        LDR     r3,[r0,#DCTSIZE*4*0]        ; get a whole row
        LDR     r4,[r0,#DCTSIZE*4*1]        ; interleave order hopes to help ARM8!
        MonoConv8 r3
        LDR     r5,[r0,#DCTSIZE*4*2]
        MonoConv8 r4
        ORR     r3,r3,r4,LSL #8
        LDR     r6,[r0,#DCTSIZE*4*3]
        MonoConv8 r5
        ORR     r3,r3,r5,LSL #16
        LDR     r7,[r0,#DCTSIZE*4*4]
        MonoConv8 r6
        ORR     r3,r3,r6,LSL #24
        LDR     r8,[r0,#DCTSIZE*4*5]
        MonoConv8 r7
        LDR     r9,[r0,#DCTSIZE*4*6]
        MonoConv8 r8
        ORR     r7,r7,r8,LSL #8
        LDR     r10,[r0,#DCTSIZE*4*7]
        MonoConv8 r9
        ORR     r7,r7,r9,LSL #16
        MonoConv8 r10
        ORR     r7,r7,r10,LSL #24

        STMIA   r1,{r3,r7}                  ; store a row
        ADD     r1,r1,r2,LSL #2             ; add row offset to output pointer
        ADD     r0,r0,#4                    ; advance input pointer
        SUBS    r11,r11,#1                  ; outer loop
        BNE     jc_mono_loop8

        LDMIA   sp!,{r4-r11,pc}

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; YUV->RGB colour conversion 32bpp
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ; combine the y value of r/g/b with the value derived from u and v.
        ; then normalise the result to be $gunbits number of bits
        ; $y holds the y value, $gunsrc the value from u and v, result in $gun.
        MACRO
        NormaliseGun $op,$gun,$y,$gunsrc,$gunbits
        $op     $gun,$y,$gunsrc             ; R/G/B, at SCALEBITS bits
        MOVS    $gun,$gun,ASR #SCALEBITS+8-$gunbits ; truncate
        Clamp   $gun,$gunbits
        MEND

k140200 RN 3
k034414 RN 4
k071414 RN 5
k177200 RN 6

jc_fix_table
        ;       FIX(1.40200), FIX(0.34414), FIX(0.71414), FIX(1.77200)
        ASSERT  SCALEBITS=19
        DCD     735052,       180428,       374415,       929038 

        ; extern void asm_colour_convert_pixels(int *y, int u, int v)
        ; /* Convert four pixels. Input y values are in y[0..3]. */
        ;   r0 -> the four blocks, YYYY, no shifting needed as it's not been through the DCT.
        ;   r1 = corresponding u
        ;   r2 = corresponding v
        ; the output goes back in y[0..3]
        EXPORT  asm_colour_convert_pixels
asm_colour_convert_pixels
      [ cfsi_jpeg
        MOV     pc,lr                       ; referenced from C code, but never used.
      |
        STMDB   sp!,{r4-r8,lr}

        ADD     r1,r1,#4
        MOV     r1,r1,ASR #3
        ADD     r2,r2,#4
        MOV     r2,r2,ASR #3                ; descale

        ADR     r14,jc_fix_table
        LDMIA   r14,{r3-r6}                 ; get magic scalers

        MUL     r3,r2,k140200               ; r = v * 1.40200
        ADD     r3,r3,#ONE_HALF

        MUL     r4,r1,k034414
        MLA     r5,r2,k071414,r4            ; g = 0 -  u * 0.34414 - v * 0.71414
        RSB     r4,r5,#0                    ;   = 0 - (u * 0.34414 + v * 0.71414)
        ADD     r4,r4,#ONE_HALF

        MUL     r5,r1,k177200               ; b = u * 1.77200
        ADD     r5,r5,#ONE_HALF

        MOV     r1,#4
        MOV     r14,#128
10
        SUBS    r1,r1,#1
        LDMMIIA sp!,{r4-r8,pc}              ; loop 3 to 0

        LDR     r2,[r0,r1,LSL#2]

        ADD     r2,r2,#4
        ADD     r2,r14,r2,ASR #3            ; normalise and descale Y

        ADDS    r6,r2,r3,ASR #SCALEBITS     ; rr = r + yy unFIX'd
        Clamp   r6,8
        ADDS    r7,r2,r4,ASR #SCALEBITS     ; gg = g + yy unFIX'd
        Clamp   r7,8
        ADDS    r8,r2,r5,ASR #SCALEBITS     ; bb = b + yy unFIX'd
        Clamp   r8,8

        ORR     r6,r6,r8,LSL #16            ; collect up &0BGR and store
        ORR     r6,r6,r7,LSL #8 
        STR     r6,[r0,r1,LSL#2]
        B       %BT10
      ]

        ; extern void asm_colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset, int wide, int high)
        ; /* yuv[0..1] are Y, yuv[4] is U, yuv[5] is V. wide/high are 1 or 2. */
        ;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
        ;   r1 -> output buffer
        ;   r2 = offset in words between rows of output
        ;   r3 = hsamp
        ;   sp+0 = vsamp
        ; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  asm_colour_convert_unusual_block
asm_colour_convert_unusual_block
        STMDB   sp!,{r2,r4-r11,lr}
        LDR     r2,[sp,#10*4]               ; recover vsamp
        SUB     r2,r2,#1                    ; vsamp zeros based
        SUB     r10,r3,#1                   ; hsamp zeros based
        MOV     r11,#0                      ; ycoord counter (j)
        MOV     r12,#0                      ; xcoord counter (i)
        MOV     r14,#128                    ; useful constant
10
        AND     r4,r11,#7
        AND     r6,r12,#7
        ADD     r4,r4,r6,LSL #3
        ADD     r4,r0,r4,LSL #2
        CMP     r11,#DCTSIZE
        CMPCC   r12,#DCTSIZE
        LDRCC   r7,[r4,#0*4*DCTSIZE2]
        LDRCS   r7,[r4,#1*4*DCTSIZE2]       ; extract y from right block, NB row order

        MOV     r4,r11,ASR r2
        MOV     r6,r12,ASR r10
        ADD     r4,r4,r6,LSL #3             ; (j >> (vsamp-1)) + ((i >> (hsamp-1)) * 8)
        ADD     r4,r0,r4,LSL #2

        LDR     r8,[r4,#4*4*DCTSIZE2]       ; u
        LDR     r9,[r4,#5*4*DCTSIZE2]       ; v

        ADD     r7,r7,#ONE_HALF
        ADD     r8,r8,#ONE_HALF
        ADD     r9,r9,#ONE_HALF
        ADD     r7,r14,r7,ASR #SCALEBITS    ; normalise & descale
        MOV     r8,r8,ASR #SCALEBITS        ; descale
        MOV     r9,r9,ASR #SCALEBITS        ; descale

        ADR     r3,jc_fix_table
        LDMIA   r3,{r3-r6}                  ; get magic scalers

        MUL     r3,r9,k140200               ; r = v * 1.40200
        ADD     r3,r3,#ONE_HALF

        MUL     r4,r8,k034414
        MLA     r5,r9,k071414,r4            ; g = 0 -  u * 0.34414 - v * 0.71414
        RSB     r4,r5,#0                    ;   = 0 - (u * 0.34414 + v * 0.71414)
        ADD     r4,r4,#ONE_HALF

        MUL     r5,r8,k177200               ; b = u * 1.77200
        ADD     r5,r5,#ONE_HALF

        ADDS    r6,r7,r3,ASR #SCALEBITS     ; r = r unFIX'd + y
        Clamp   r6,8
        ADDS    r3,r7,r4,ASR #SCALEBITS     ; g = g unFIX'd + y
        Clamp   r3,8
        ADDS    r4,r7,r5,ASR #SCALEBITS     ; b = b unFIX'd + y
        Clamp   r4,8

        ORR     r6,r6,r4,LSL #16            ; collect up &0BGR and store
        ORR     r6,r6,r3,LSL #8
        STR     r6,[r1,r12,LSL#2]

        ADD     r12,r12,#1                  ; next i
        CMP     r10,r12,LSR #3              ; 8->1 16->2 comparing with 0 or 1
        BHS     %BT10

        MOV     r12,#0                      ; restart i=0
        LDR     r3,[sp]                     ; outoffset on entry
        ADD     r1,r1,r3,LSL #2             ; outptr += outoffset

        ADD     r11,r11,#1                  ; next j
        CMP     r2,r11,LSR #3               ; 8->1 16->2 comparing with 0 or 1
        BHS     %BT10

        LDMIA   sp!,{r2,r4-r11,pc}

        ; extern void asm_colour_convert_block_32(JCOEF *yuv, int *outptr, int outoffset)
        ; /* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block */
        ;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
        ;   r1 -> output buffer
        ;   r2 = offset in words between rows of output
        ; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  asm_colour_convert_block_32
asm_colour_convert_block_32
        STMDB   sp!,{r4-r11,lr}             ; save state
        ADD     r3,r1,#(2*DCTSIZE)*4        ; column limit pointer (inner loop) - outptr+16 words
        ADD     r4,r1,r2,LSL #3+2           ; row limit pointer (outer loop) - outptr+8*outoffset words
        ADD     r5,r0,#4*DCTSIZE2*4         ; pointer into U block. V values DCTSIZE2 words on from this
        ADD     r6,r4,r2,LSL #3+2           ; real row limit pointer - outptr+16*outoffset words

        ; The main loop goes round once for each 2*2 square of four output pixels, using
        ; four Y values, one U value, one V value.
jc_colour_loop                              ; each two rows and each two columns of output

        ; do four output pixels, using:
        ; [r5] is U value
        ; [r5,#DCTSIZE*4] is V value
        ; [r0] is Y value for output word [r1]
        ; [r0,#4] is Y value for output word [r1,r2,LSL #2]
        ; [r0,#DCTSIZE*4] is Y value for output word [r1,#4]
        ; [r0,#DCTSIZE*4+4] is Y value for output word [r1,#4 + r2,LSL #2] (so to speak!)

        ; first we compute the values derived from U and V, which are
        ; true for all four pixels.
        LDR     r7,[r5]                     ; U value
        MOV     r7,r7,ASR #8                ; the multiplies will get us back to SCALEBITS again
        LDR     r8,[r5, #DCTSIZE2*4]        ; V value
        MOV     r8,r8,ASR #8                ; the multiplies will get us back to SCALEBITS again
        ; Should add 1:SHL:7 before ASR #8, but not regarded as significant enough
        ; considering how much bigger SCALEBITS is.

        ; Multiply sequences generated by cc 4.50, for 8 bits of accuracy.
        ; these sequences lead to a result shifted left by 8 bits.
        ;MulCon  r9,r7,FIX(1.77200)         ; B, without the Y yet
        ADD     r9,r7,r7,LSL #5
        RSB     r9,r9,r7,LSL #8
        SUB     r9,r9,r7,LSL #3             ; still needs a LSL #1

        ;MulCon  r10,r8,FIX(1.40200)        ; R, without the Y yet
        ADD     r10,r8,r8,LSL #5
        RSB     r10,r10,r10,LSL #3
        ADD     r10,r10,r8,LSL #7

        ;MulCon  r12,r8,-FIX(0.71414)
        RSB     r12,r8,r8,LSL #6
        ADD     r12,r12,r8,LSL #7
        SUB     r12,r12,r8,LSL #3

        ;MulCon  r11,r7,-FIX(0.34414)
        ADD     r11,r7,r7,LSL #1
        ADD     r11,r11,r7,LSL #3           ; LSL #3 still needed - see below
        ADD     r11,r12,r11,LSL #3          ; -G, without the Y yet - did the LSL #3, see above.

        ; After those multiplies, the values are shifted up by SCALEBITS again.
        ; We're going to add each of r9/r10/r11 to the Y values.
        ; The Y values need 128 added to them - add it at this point.
        ; need to add a half for the truncation of NormaliseGun - do that at the same time.
        MOV     r7,#ONE_HALF
        ADD     r7,r7,#128:SHL:SCALEBITS
        ADD     r9,r7,r9,LSL #1             ; LSL #1 still owed to R9 - see above.
        ADD     r10,r7,r10
        RSB     r11,r7,r11                  ; r11 is to be subtracted from Y, not added.

        ; now process the four pixels one at a time.
        LDMIA   r0,{r7,r8}                  ; first two Y values, shifted up by SCALEBITS
        NormaliseGun ADD,r12,r7,r9,8        ; B
        NormaliseGun ADD,lr,r7,r10,8        ; R
        NormaliseGun SUB,r7,r7,r11,8        ; G
        ORR     r7,lr,r7,LSL #8             ; G and R
        ORR     r7,r7,r12,LSL #16           ; complete output pixel
        STR     r7,[r1]                     ; output pixel

        NormaliseGun ADD,r12,r8,r9,8        ; B
        NormaliseGun ADD,lr,r8,r10,8        ; R
        NormaliseGun SUB,r8,r8,r11,8        ; G
        ORR     r8,lr,r8,LSL #8             ; G and R
        ORR     r8,r8,r12,LSL #16           ; complete output pixel
        STR     r8,[r1,r2,LSL #2]           ; output pixel
        ADD     r1,r1,#4

        ADD     r7,r0,#DCTSIZE*4            ; prepare to load next two pixels
        
        LDMIA   r7,{r7,r8}                  ; other two pixels
        NormaliseGun ADD,r12,r7,r9,8        ; B
        NormaliseGun ADD,lr,r7,r10,8        ; R
        NormaliseGun SUB,r7,r7,r11,8        ; G
        ORR     r7,lr,r7,LSL #8             ; G and R
        ORR     r7,r7,r12,LSL #16           ; complete output pixel
        STR     r7,[r1]                     ; output pixel

        NormaliseGun ADD,r12,r8,r9,8        ; B
        NormaliseGun ADD,lr,r8,r10,8        ; R
        NormaliseGun SUB,r8,r8,r11,8        ; G
        ORR     r8,lr,r8,LSL #8             ; G and R
        ORR     r8,r8,r12,LSL #16           ; complete output pixel
        STR     r8,[r1,r2,LSL #2]           ; output pixel
        ADD     r1,r1,#4

        ; increment pointers to go two pixels along an output row
        ; r1 (output pointer) already updated
        ADD     r5,r5,#DCTSIZE*4            ; pointer into row-organised U,V values
        ADD     r0,r0,#2*DCTSIZE*4          ; ditto for Y values

        ; check for end of row
        CMP     r1,r3                       ; output pointer reached end of output row?
        BNE     jc_colour_loop              ; go round for next column

        ; Amazingly there is no special action to take half-way along each output row,
        ; when we switch from one Y block to the next - because of the ordering and
        ; arrangement of the Y blocks, it just acts as a single 8*16 block.

        ; It's the end of the row. Update all input and output pointers to
        ; advance to next one.
        ADD     r1,r1,r2,LSL #2+1           ; advance output ptr by two output rows
        SUB     r1,r1,#2*DCTSIZE*4          ;      ... and then to beginning of next output row.
        SUB     r5,r5,#(DCTSIZE2*4-4)*1     ; advance UV pointer to start of next row
        SUB     r0,r0,#(DCTSIZE2*4-4)*2     ; ditto Y pointer, but back two blocks
        ADD     r3,r1,#2*DCTSIZE*4          ; reset column limit pointer (inner loop) - outptr+16 words

        ; Check for having to change to the second pair of Y blocks, or terminate
        CMP     r1,r4
        BNE     jc_colour_loop              ; normal case - we set off on another two rows of output

        ; It's either the half-way point, in which case we need to change to the second pair
        ; of input Y blocks, or it's the end. Test r4 against the 'real' limit pointer.

        CMP     r4,r6                       ; is this the end?
        LDMEQIA sp!,{r4-r11,pc}             ; if so, return - nothing more to do

        ; We've reached the half-way point.
        MOV     r4,r6                       ; next time we test r4 and r6, exit.
        ADD     r0,r0,#((2*DCTSIZE2)-DCTSIZE)*4  ; advance r0 from end of row 0 of block 0,
                                            ; to start of row 0 of block 2.
        B       jc_colour_loop              ; and continue.

        ; Performance notes for colour conversion.
        ; approx number of ticks for 4 pixels:
        ;    7        loop etc.
        ;   23        common work on the UV values
        ;   40        loading/storing,combining gun values
        ;   52        normalising gun values
        ;   --
        ;  122/4 = 30.5 per pixel.

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; YUV->RGB colour conversion 16bpp
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        GBLA    red_bits
        GBLA    green_bits
        GBLA    blue_bits
        GBLA    red_shift
        GBLA    green_shift
        GBLA    blue_shift
        GBLA    alpha_value
        GBLS    function_name

        ; extern convert_block_16_func asm_get_convert_block_16_func(int ncolour,int modeflags);
        ;
        ; Return a pointer to the right colour conversion function
        ; Handled in assembler because I don't trust Norcroft!
        EXPORT  asm_get_convert_block_16_func
asm_get_convert_block_16_func
        ADD     r0,r0,#1
        CMP     r0,#4096
        MOVEQ   r2,#0
        MOVNE   r2,#4
        TSTNE   r1,#ModeFlag_64k
        MOVNE   r2,#8
        BICNE   r1,r1,#ModeFlag_DataFormatSub_Alpha
        TST     r1,#ModeFlag_DataFormatSub_RGB
        ADDNE   r2,r2,#1
        TST     r1,#ModeFlag_DataFormatSub_Alpha
        ADDNE   r2,r2,#2
        ADR     r0,convert_16_table
        LDR     r1,[r0,r2,LSL #2]
        ADD     r0,r0,r1
        MOV     pc,lr

convert_16_table
        DCD   asm_colour_convert_block_4444_TBGR - convert_16_table
        DCD   asm_colour_convert_block_4444_TRGB - convert_16_table
        DCD   asm_colour_convert_block_4444_ABGR - convert_16_table
        DCD   asm_colour_convert_block_4444_ARGB - convert_16_table
        DCD   asm_colour_convert_block_1555_TBGR - convert_16_table
        DCD   asm_colour_convert_block_1555_TRGB - convert_16_table
        DCD   asm_colour_convert_block_1555_ABGR - convert_16_table
        DCD   asm_colour_convert_block_1555_ARGB - convert_16_table
        DCD   asm_colour_convert_block_565_BGR - convert_16_table
        DCD   asm_colour_convert_block_565_RGB - convert_16_table

        ; 4444 formats
        
red_bits      SETA 4
green_bits    SETA 4
blue_bits     SETA 4
red_shift     SETA 0
green_shift   SETA 4
blue_shift    SETA 8
alpha_value   SETA 0
function_name SETS "asm_colour_convert_block_4444_TBGR"
        GET     jdcolor16
alpha_value   SETA &F000
function_name SETS "asm_colour_convert_block_4444_ABGR"
        GET     jdcolor16
red_shift     SETA 8
blue_shift    SETA 0
function_name SETS "asm_colour_convert_block_4444_ARGB"
        GET     jdcolor16
alpha_value   SETA 0
function_name SETS "asm_colour_convert_block_4444_TRGB"
        GET     jdcolor16

        ; 1555 formats
        
red_bits      SETA 5
green_bits    SETA 5
blue_bits     SETA 5
red_shift     SETA 0
green_shift   SETA 5
blue_shift    SETA 10
alpha_value   SETA 0
function_name SETS "asm_colour_convert_block_1555_TBGR"
        GET     jdcolor16
alpha_value   SETA &8000
function_name SETS "asm_colour_convert_block_1555_ABGR"
        GET     jdcolor16
red_shift     SETA 10
blue_shift    SETA 0
function_name SETS "asm_colour_convert_block_1555_ARGB"
        GET     jdcolor16
alpha_value   SETA 0
function_name SETS "asm_colour_convert_block_1555_TRGB"
        GET     jdcolor16

        ; 565 formats
        
red_bits      SETA 5
green_bits    SETA 6
blue_bits     SETA 5
red_shift     SETA 0
green_shift   SETA 5
blue_shift    SETA 11
function_name SETS "asm_colour_convert_block_565_BGR"
        GET     jdcolor16
red_shift     SETA 11
blue_shift    SETA 0
function_name SETS "asm_colour_convert_block_565_RGB"
        GET     jdcolor16


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; YUV->RGB colour conversion 8bpp
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ; Similar in structure to 32bpp and 16bpp output, except that 8bpp (VIDC1) pixels
        ; are generated.

        ; A macro to generate an 8bpp pixel from YUV values, and subtract the actual value
        ; of that pixel from the YUV values.
        ; r12 holds the lookup table (yuv->pixel, approximate)
        ; r11 holds the palette (pixel->yuv)
        MACRO
        Generate8bitFromYUV   $y,$u,$v,$pixel,$temp,$dest
        MOVS    $temp,$v,ASR #8-yuvtab_vbits                  ; get relevant bits of v
        MOVS    $pixel,$u,ASR #8-yuvtab_ubits                 ; get relevant bits of u
        ORR     $pixel,$temp,$pixel,LSL #yuvtab_vbits         ; combine u and v
        MOVS    $temp,$y,ASR #8-yuvtab_ybits                  ; get relevant bits of v
        ORR     $pixel,$pixel,$temp,LSL #yuvtab_ubits+yuvtab_vbits ; combine y, u, v
        LDRB    $pixel,[r12,$pixel]                           ; get the pixel value
        STRB    $pixel,$dest                                  ; store the pixel
        LDR     $pixel,[r11,$pixel,LSL #2]                    ; get real yuv value, as word &0YUV
        AND     $temp,$pixel,#&ff                             ; get real v value
        SUB     $v,$v,$temp                                   ; subtract it from v
        AND     $temp,$pixel,#&ff00                           ; get real u value
        SUB     $u,$u,$temp,LSR #8                            ; subtract it from u
        SUB     $y,$y,$pixel,LSR #16                          ; subtract it from y
        MEND

        ; The yuv values are SCALEBITS up in their respective words, in the approximate range
        ; (0..255):SHL:SCALEBITS.
        ; Get a Y, U or V value from the given location, subtract 128 from it,
        ; add it to the cumulative error so far in that gun.
        MACRO
        GetColourValue $reg,$loc,$temp
        LDR     $temp,$loc                                    ; get the value into temp register - shifted up SCALEBITS
        ADD     $temp,$temp,#128:SHL:SCALEBITS                ; make it in approx range 0..256
        ADDS    $reg,$reg,$temp,ASR #SCALEBITS                ; add it to error so far
        Clamp   $reg,8
        MEND

      [ :LNOT: cfsi_jpeg
        GET     yuvtabs.s

        ; extern char *pixel_to_yuv_table_base(void)
        ; Returns the relocated address of the pixel to YUV table
        EXPORT  pixel_to_yuv_table_base
pixel_to_yuv_table_base
        ADRL    r0, pixel_to_yuv_table
        MOV     pc, lr

        ; extern int *yuv_to_pixel_table_base(void)
        ; Returns the relocated address of the YUV to pixel table
        EXPORT  yuv_to_pixel_table_base
yuv_to_pixel_table_base
        ADRL    r0, yuv_to_pixel_table
        MOV     pc, lr
      ]
      
        ; extern void asm_colour_convert_block_8(JCOEF *yuv, char *outptr, int outoffset)
        ; /* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 8bit pixels */
        ;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
        ;   r1 -> output buffer
        ;   r2 = offset in words between rows of output
        ; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  asm_colour_convert_block_8
asm_colour_convert_block_8
      [ cfsi_jpeg
        MOV     pc,lr                       ; referenced from C code, but never used.
      |
        STMDB   sp!,{r0-r1,r4-r11,lr}       ; save state
        ADD     r3,r1,#(2*DCTSIZE)*1        ; column limit pointer (inner loop) - outptr+16 bytes
        ADD     r4,r1,r2,LSL #3+2           ; row limit pointer (outer loop) - outptr+8*outoffset words
        ADD     r5,r0,#4*DCTSIZE2*4         ; pointer into U block. V values DCTSIZE2 words on from this
        ADD     r6,r4,r2,LSL #3+2           ; real row limit pointer - outptr+16*outoffset words

        STMIA   sp,{r4,r6}                  ; r4 and r6 used as temp workspace during the colour conversion:
                                            ; we never need to reload r0/r1, so use these stack locations.

        ADRL    r12,yuv_to_pixel_table
        ADRL    r11,pixel_to_yuv_table
        MOV     r7,#0                       ; cumulative error in U so far
        MOV     r8,#0                       ; cumulative error in V so far
        MOV     r9,#0                       ; cumulative error in Y so far

        ; The main loop goes round once for each 2*2 square of four output pixels, using
        ; four Y values, one U value, one V value.
jc_colour_loop8                             ; each two rows and each two columns of output

        ; do four output pixels, using:
        ; [r5] is U value
        ; [r5,#DCTSIZE2*4] is V value
        ; [r0] and [r0,#DCTSIZE*4] are Y values for output word [r1]
        ; [r0,#4] and [r0,#DCTSIZE*4+4] are Y values for output word [r1,r2,LSL #2]

        GetColourValue r7,"[r5]",r4              ; U value
        GetColourValue r8,"[r5,#DCTSIZE2*4]",r4  ; V value
        GetColourValue r9,"[r0,#4]",r4           ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,"[r1,r2,LSL #2]"

        GetColourValue r7,"[r5]",r4              ; U value
        GetColourValue r8,"[r5,#DCTSIZE2*4]",r4  ; V value
        GetColourValue r9,"[r0]",r4              ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,"[r1]"
        ADD     r1,r1,#1

        ; Next two pixels done in a swapped order, so we do a little U around the square of four
        ; pixels - this seems to reduce the amount of horizontal-line effect that you get.

        GetColourValue r7,"[r5]",r4              ; U value
        GetColourValue r8,"[r5,#DCTSIZE2*4]",r4  ; V value
        GetColourValue r9,"[r0,#DCTSIZE*4]",r4   ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,"[r1]"

        GetColourValue r7,"[r5]",r4              ; U value
        GetColourValue r8,"[r5,#DCTSIZE2*4]",r4  ; V value
        GetColourValue r9,"[r0,#DCTSIZE*4+4]",r4 ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,"[r1,r2,LSL #2]"
        ADD     r1,r1,#1

        ; increment pointers to go two pixels along an output row
        ; r1 (output pointer) already updated
        ADD     r5,r5,#DCTSIZE*4            ; pointer into row-organised U,V values
        ADD     r0,r0,#2*DCTSIZE*4          ; ditto for Y values

        ; check for end of row
        CMP     r1,r3                       ; output pointer reached end of output row?
        BNE     jc_colour_loop8             ; go round for next column

        ; Amazingly there is no special action to take half-way along each output row,
        ; when we switch from one Y block to the next - because of the ordering and
        ; arrangement of the Y blocks, it just acts as a single 8*16 block.

        ; It's the end of the row. Update all input and output pointers to
        ; advance to next one.
        ADD     r1,r1,r2,LSL #2+1           ; advance output ptr by two output rows
        SUB     r1,r1,#2*DCTSIZE*1          ;      ... and then to beginning of next output row.
        SUB     r5,r5,#(DCTSIZE2*4-4)*1     ; advance UV pointer to start of next row
        SUB     r0,r0,#(DCTSIZE2*4-4)*2     ; ditto Y pointer, but back two blocks
        ADD     r3,r1,#2*DCTSIZE*1          ; reset column limit pointer (inner loop) - outptr+16 bytes

        ; zero cumulative error on Y U V registers
        MOV     r7,#0
        MOV     r8,#0
        MOV     r9,#0

        ; Check for having to change to the second pair of Y blocks, or terminate
        LDMIA   sp,{r4,r6}                  ; reload loop end test registers
        CMP     r1,r4
        BNE     jc_colour_loop8             ; normal case - we set off on another two rows of output

        ; It's either the half-way point, in which case we need to change to the second pair
        ; of input Y blocks, or it's the end. Test r4 against the 'real' limit pointer.

        CMP     r4,r6                       ; is this the end?
        LDMEQIA sp!,{r0-r1,r4-r11,pc}       ; if so, return - nothing more to do

        ; We've reached the half-way point.
        MOV     r4,r6                       ; next time we test r4 and r6, exit.
        STR     r4,[sp]                     ; remember for final termination
        ADD     r0,r0,#((2*DCTSIZE2)-DCTSIZE)*4  ; advance r0 from end of row 0 of block 0,
                                            ; to start of row 0 of block 2.
        B       jc_colour_loop8             ; and continue.
      ]

        END
