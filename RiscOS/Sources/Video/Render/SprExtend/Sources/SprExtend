; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.SprExtend

;;----------------------------------------------------------------------------
;; Sprite Extension Module
;;
;; *********************
;; ***  CHANGE LIST  ***
;; *********************
;;
;;  2-Jul-87    0.01    Implement enlarged sprites
;; 16-Sep-87    0.02    Implement scaled (up & down) sprites
;; 17-Sep-87            Optimise for large y-scaling
;; 24-Sep-87            Implement PostScript VDU 5 text
;; 29-Sep-87            Implement scaled mask plotting

;; 29-Sep-87            Implement scaled char painting
;;  7-Oct-87    0.03    Changed so that SpriteV is intercepted
;;  7-Oct-87            Grey-scale sprite scaling & pixel translation
;;  8-Oct-87            Change SpriteOp reason codes & parameters
;; 12-Oct-87            Generalise PutSpriteScaled (use colour translation)
;; 21-Oct-87    0.04    Make it work on Arthur 0.3
;; 29-Oct-87            Change name to 'SpriteExtension'
;; 29-Oct-87            Ensure that R3=0 on entry to SwitchOutputToSprite/Mask
;; 29-Oct-87            Implement mask plotting for unmasked sprites
;;  6-Nov-87            Implement SpriteReason_MergeSprites
;; 12-Nov-87            Changed name to SpriteReason_AppendSprite
;; 25-Jan-88            Put in 'division by zero' check on scale factors
;; 25-Jan-88            Fix bug in ttr code (bpp used instead of inbpp)
;; 28-Jan-88            PlotMaskScaled with different bpp does block instead (used to give an error - Bad Translation Table)
;;  1-Feb-88            Implement SpriteReason_SetPointerShape
;;  8-Mar-88    0.05    Remove OS version number bodgeing
;;  8-Mar-88            Fix bug: PaintCharScaled in 1-bpp modes
;;  8-Mar-88            Remove SwitchOutputToSprite/Mask (leave up to MOS)
;; 16-Mar-88            Allow scale factors and pixtrans in SetPointerShape
;; 24-Mar-88    0.06    Claim vectors on Service_Reset
;; 29-Mar-88    0.10    Change plot code so it is compiled into RAM
;;  3-Apr-88            Fix bug: double-pixel input sprite wasn't coped with
;;  7-Apr-88            Change Arthur 1.20 version so it doesn't use SWI table
;; 10-Apr-88    0.11    Fix bug: big reason codes are now passed on unchanged
;; 14-Apr-88            Change default scaling so 1st pixel is included
;; 15-Apr-88            Change it back again!
;; 24-Jun-88    0.12    Implement OS_ChangedBox stuff
;; 25-Jul-88    0.13    Fix bug: changedbox used x,ycount instead of x,ysize
;; 29-Jul-88    0.14    Change SetPointerShape to use 3 more bits in R3
;; 29-Jul-88    0.15    Fix bug: allow 12-character sprite names
;;  2-Aug-88    0.16    Fix bug: ChangedBox stuff got it wrong when clipping
;;  9-Aug-88    0.17    Fix bug: SetPointerShape should move sprite to right
;; 15-Aug-88    0.18    Fix bug: SetPointerShape corrupts [spritecode]
;; 19-Aug-88            SetPointerShape defaults ttr to 0,1,3,3 in hi-res mono
;; 19-Aug-88    0.19    SetPointerShape uses 1/2 ptr width in hi-res mono
;;  2-Sep-88    0.20    Change code to save 8 words in jump table
;; 20-Oct-88            Change to use new Make procedure
;; 31-Mar-89    0.21    Only call *FX &87 when mode number is needed
;; 23-May-89    0.22    Deal with system sprites by calling OS_ReadDynamicArea
;; 19-Sep-89    0.23    Fix bug: GCOL 2/6 in scaled sprites plotted too much
;; 29-Sep-89            Released new version to net - PutSpriteTransformed and PlotMaskTransformed working
;; 29-Sep-89    0.24    Rewrite PaintCharScaled to define a mode 0 sprite and then transform that
;; 28-Nov-89    0.25    Add SpriteReason_InsertDeleteRows and SpriteReason_InsertDeleteColumns
;; 18-Dec-89    0.26    Fixed inserting zero words in InsertDelete stuff. Used to set it all to zero
;; 05-Jan-90    0.27    Fixed two bugs in InsertDelete columns, due to LH and RH wastage
;; 12-Jan-90    0.28    And another...
;; 30-Jan-91    0.29    Add SpriteReason_CreateRemovePalette
;; 05-Feb-91    0.30    Extended above call to return palette pointer + mode
;; 13-Mar-91    0.31    Internationalisation; NB: "Sprite doesn't exist" is cached
;; 10-May-91    0.34    Fixed Service_Reset code
;; 14-Aug-91    0.35    Fix bug: Transforming transparent sprites work again
;; 14-Aug-91            Optimised for 1:1 mapping in BPP for transformed sprite masks
;; 14-Aug-91    0.36    Fix bug: Insert/delete columns works when rapping off a word boundary
;; 02-Sep-91    0.37    Fix bug: Insert columns doesn't barf when there's exactly enough room
;; 13-Sep-91            Fix bug: revist insert columns and apply crow bar where appropriate (used to scramble sprite quite often)
;; 10-Dec-91    0.38    Removed comments from Messages file and shortened tokens
;; 06-Feb-92    0.39    Fixed calculation of amount of memory to move in CreateRemovePalette
;; 17-Feb-92    0.39    ECN: Bug fix: Rotate sprite incorrectly calculated the amount to move the sprite pool to make room for the larger sprite
;; 20-Feb-92    0.40    ECN: Bug fix: Fixed out of memory error inserting 0 rows/columns
;; 18-Mar-92    0.41    ECN: Bug fix: Fixed insert columns
;; 18-Mar-92    0.42    ECN: Removed debugging OS_Confirm call
;; 30-Mar-92    0.43    ECN: Fixed insert column bug (another one)
;;                           Fixed garbage fill when inserting rows
;; 02-Apr-92    0.44    ECN: RP-2050: Deleting 1 column in a single column mode 0 sprite lead to a 32 bit wide sprite
;;                           "Sprite not found" error now cached on Service_ResourceFSStarted instead of Service_MessageFileClosed
;; 23-Apr-92    0.45    ECN: RP-2503: Fix boundary condition when inserting rows. Previously the test for space in sprite area did BGE
;;                           error, EQ is OK, changed to BGT
;; 23-Apr-92    0.46    TMD: RP-2540: Corrected start and end addresses of block to copy in CreateRemovePalette
;;
;; ---------------------- RISC OS 3.10 releae module -----------------
;;
;; 24-Jul-92            Removed the conditional code - made it more readable
;; 24-Jul-92            Bodge OS code removed - can no longer build Sprite Extend for Arthur - shame
;; 24-Jul-92            Seperated off Insert/Delete Rows/Columns into seperate file
;;  3-Aug-92            Support for rendering into higher depth modes implemented
;;  3-Aug-92            Incorporated Tims wacky bit reordering function
;;  5-Aug-92            Handling of masked sprites tidied to work with greater depths
;;  5-Aug-92            Modified pixel translation code, now works for all depths upto 32 bit per pixel
;; 11-Aug-92            PutSpriteScaled now faults sprites of depth > 8 bit per pixel
;; 17-Aug-92            Generalised copying and other functions for translation tables
;; 18-Aug-92            Transformed sprites into 16 or 32 bit per pixel now working (must test 32 bit per pixel)
;; 18-Aug-92            PutSpriteTransformed now errors if input depth > 8 bit per pixel
;; 28-Aug-92            PutSpriteScaled now copes with sprite containing new header (needs new kernel)
;;  7-Sep-92            Support for VIDC 20 added (conditional between two boards)
;; 11-Sep-92            Implemented a crude bit munging function to generate 32 bit per pixel sprites
;; 03-Mar-93            AMG: Added multiple buffer code
;;    Mar-93            AMG: Make SpriteScaled cope with input from/output to 16/32bpp
;;    Apr-93            AMG: Make SpriteTransformed cope with input from/output to 16/32bpp
;;    Apr-93            AMG: Optimise the but mungeing functions from 11-Sep-92
;;    Apr-93            AMG: When plotting a 8bpp or lower sprite with a full palette to
;;                           16bpp or above, ignore the translation table and use the
;;                           palette entries directly. NB will NOT work for braindamaged
;;                           8bpp 16 or 64 entry palettes. Flag 'ignore_ttr' controls this.
;; 04-Apr-93    0.48    AMG: New version number for return to source filer
;; 06-Apr-93                 Bug fix on sprext plotting via 32K tables
;;                           Bug fix on plotting 32bpp sprites to 8bpp
;; 11-May-93    0.49    AMG: Bounce mask/palette operations on 16 & 32bpp new format sprites
;; 21-May-93    0.50    AMG: Fix bug in PutSpriteTransformed (causing an extra plot of first
;;                           pixel on each row of sprite)
;; 23-Jun-93    0.51    AMG: Introduce 1bpp masks on sprites (only for putspritescaled &
;;                           transformed - NOT greyscaled)
;; 14-Jul-93    0.52    AMG: Wrap up mask work and fix bugs.
;; 03-Aug-93    0.52W   WRS: ccompiler flag - new PutSpriteScaled compiler started.
;;                           debug true, file true, hostvdu false.
;; 09-Aug-93    0.53    AMG: Fix bug in PutSprite/MaskScaled for sprites with LH obscured
;;                           (merged in by WRS - doesn't actually affect things,
;;                            cos it's in the compiler we're replacing)
;; 25-Aug-93    0.53W   WRS: ccompiler work continues - old compiler disabled,
;;                           PutSpriteGreyScaled disabled (noone uses it).
;; 14-Sep-93    0.54W   WRS: jpeg decompression started.
;; 14-Oct-93    0.55W   WRS: printer calibration stuff entered (not tried yet, no printer driver around)
;; 09-Nov-93            WRS: patch OS_ReadModeVariable to recognise type-9 new sprites as JPEG.
;; 21-Feb-94            WRS: added sprite reason codes JPEGInfo and PutJPEGScaled.
;; 20-Jun-94            GPS: Ported AMG changes between 0.53 and 0.62 to this version.
;;                           Added correct flags so compiles with + without C code added.
;; 28-Jul-94            AMG: Fix bug MED-03238. PlotTransformed went wrong plotting a 1bpp
;;                           mask if LH edge obscured or excluded using a source rectangle.
;;
;; 12-Aug-94    0.63    GPS: WRS new plotsclaed engine stabilised and new JPEG swis implemented.
;; 12-Aug-94    0.64    GPS: Chnaged c.rojpeg so CFSI-jpeg builds correctly.
;; 30-Aug-94    0.68    GPS: Removed bug in plotmaskscaled which was apparent when using dragasprite.
;;                           Bug was due to obscure use of ECF patterns. Why?
;;                           Implemented 3 more SWIs. JPEG_PDriverIntercept, and skeletons for
;;                           JPEG_PlotTransformed and JPEG_PlotFileTransformed.
;; 01-Sep-94    0.69    GPS: Implemented dithering switch on JPEG SWIs
;; 13-Sep-94    0.70    GPS: Implemented JPEG_PlotTransformed SWI
;;                           added switch to PutSpriteScaled to allow dithering of 16bpp+ sprites
;;                           fixed bug where word aligned JPEGS were not printed with the correct width.
;; 19-Sep-94    0.71    GPS: Added extra bit to JPEG_PDriverIntercept SWI so trnaslation table is always
;;                           used when printing.
;;                           Fixed bug where plotting sprites with 1bpp masks into 16bpp mode sometimes
;;                           corrupted with non-aligned data.
;; 22-Sep-94    0.72    GPS: Changed behaviour of Plotscaled when a NULL scale factors pointer passed.
;;                           Fixed bug in JPEG_PlotTransformed when co-ordinate was -ve.
;;                           Added Error handling for C plotscaled engine.
;; 26-Sep-94    0.73    GPS: Fixed bug where JPEG_PlotScaled junked r0
;;                           Implemented JPEG_PlotFileTrnasformed.
;;                           Corrected scaling in JPEG_PlotTransformed
;; 29-Sep-94    0.74    GPS: Impletmented Sprite_Reason CheckSpriteArea
;;                           Added extra return parameter to JPEG_Info SWIs. They now
;;                           return the memory required in R6.
;; 07-Oct-94    0.75    GPS: Fixed bug when plotting sprites with 1bpp masks, not word aligned.
;;                           Made SpriteExtend plot from palette when R5:b4 is set.
;; 20-Oct-94    0.76    GPS: Added speed-ups to plotscaled code, when plotting at large scales
;;                           because it went much slower than version 0.62!!
;; 25-Oct-94    0.77    GPS: Made operation of 'dither' flag consistent when error-diffusing JPEGS
;;                           Added an error when Sprite 'PutSpriteGreyScaled' is called
;; 31-Oct-94    0.78-0.79    Build changes.
;;
;; 01-Nov-94    0.80    GPS: Fixed bug in SpriteOp 35 (Append Sprite) where r0 was being junked
;;                           when returning an error.
;; 11-Nov-94    0.81    GPS: Stopped JPEG_FileInfo from grabbing a 1k buffer and not returning it...
;;                           Stopped error when trying to plot a JPEG without a translation table
;;                           which means that it works on pre RO3.5 machines.
;; 15-Nov-94    0.82    GPS: Fixed Bug where PlotMaskScaled was only allowing for 8 bits of bg colour
;;                           Fixed Bug where plotting with 'action' AND was masking out all other
;;                           pixels in a word.
;; 21-Nov-94    0.83    GPS: Fixed bug in OS_SpriteOp CheckSpriteArea where it was being slightly too
;;                           pessimistic. In c.SpriteOp
;;                           Added compiler flags to c.rojpeg so that CFSIjpeg compiles correctly.
;; 24-Nov-94    0.84    GPS: Fixed bug where JPEG_PlotTransformed didn't forbid -ve scale factors. in Sources.SWIs
;;                           Made SpriteExtend use a dynamic area to hold the JPEG workspace. in Sources.SprExtend,
;;                           Sources.SWIs, c.rojpeg and c.PutScaled
;;                           Internationalised name of Dynamic Area. In Sources.CSupport and c.PutScaled.
;; 28-Nov-94    0.85    GPS: Moved create_dynamic_area function from Sources.CSupport to Sources.PutScaled.
;;                           Fixed bug in SpriteOp PaintCharScaled, where both the colour used for the plot
;;                           and the plotting action were being junked. In Sources.SprExtend and c.PutScaled
;; 01-Dec-94    0.86    GPS: Fixed small semantic bugs in OS_SpriteOp CheckSpriteArea. In c.SpriteOp
;;                           Stopped OS_SpriteOp CheckSpriteArea junking r12. In Sources.SWIs
;; 02-Dec-94    0.87    GPS: Fixed bug MED-04026. Where plotting Old Format 1bpp Sprites with a mask was failing. In c.PutScaled
;; 07-Dec-94    0.88    GPS: Fixed bug in c.Putscaled, when using a non-zero plot action. The optimised code for scale factors >4
;;                           doesn't work, so the code now reverts to the non-optimised code in this case. This fixes
;;                           MED-03952 and MED-03968.
;; 16-Dec-94    0.89    GPS: Changed functionality of OS_SpriteOp CheckSpriteArea so that a sprite's mask has to be either 1bpp
;;                           for new sprites or the same size as the sprite image.
;;                           Fixed bug introduced into version 0.88 for plotting at 5:1+ scale without a mask. Ooops.
;; 01-Feb-95    0.90    GPS: Added extra bit to JPEG_Plot(File)Scaled SWIs to allow error-diffused dithering
;;                           Made JPEG SWIs error when invalid flag bits are set.
;; 09-Feb-95    0.91    GPS: Fixed MED-04481 where all plot actions except 'Set' were failing for scaling > 1:1 in 16M colour modes
;;                           Fixed MED-04508 where an invalid spritearea pointer was causing a crash even when it was not required
;;                           in the spriteOp.
;;                           Made JPEG_PlotFileScaled successfully return when invalid flag bits set.
;; 13-Feb-95    0.92    GPS: Fixed MED-04131 where JPEG files with pixel sizes of ratio 0:0 were causing a divide by zero error
;;                           a 0:0 ratio is now returned as 1:1
;; 15-Feb-95    0.93    GPS: Fixed MED-04158 where the PutScaled blitter was running out of registers when you plotted a new format
;;                           sprite <=8bpp, with a mask into a 16bpp mode plotting directly from the palette (phew!). SpriteExtend
;;                           now converts the palette to 16bpp and sticks it in the space resevered for the creation of a translation
;;                           table. This avoids the need for conversion on the fly which requires 2 temporary registers.
;; 24-Feb-95    0.94    GPS: Made error diffusion work with an arbitary palette held in 'newtranstable' a pointerto which is stacked
;;                           before entering the diffusion code. Investigated which palettes were unsuitable for error-diffusion
;;                           and came to the conclusion that the error-diffused result was always superior to the ordered-dither.
;;                           Fixes bug MED-04727.
;; 24-Feb-95    0.95    GPS: Checked Sources.SprAdjSize onto SrcFiler which was changed in December but overlooked (oops!).
;;                           Fixes MED-04141, MED-03966 and  MED-03967
;; 27-Feb-95    0.96    GPS: Fixed bug where optimised code for scales >4:1 failed with obscure values eg 575:115 which draw supplied!
;;                           This is fixed by trying to rationalise the scale factors near the beginning of a sprite plot.
;; 28-Feb-95    0.97    GPS: Fixed bug when outputting to 32bpp mode with large output scales.
;;                           removed warnings and error from CFSIjpeg compilation. Fixes MED-04643
;; 17-Mar-95    0.98    GPS: Fixed bug MED-05018. r_xcount was not being initialised with 16bop source and dither bit set.
;; 29-Mar-95    0.99    GPS: Fixed bug MED-05084. Redone the plotmask code to use the ECF AND & EOR mask in the kernel. This
;;                           has to be done because when doing a PaintCharScaled of a delete char. the kernel sneakily replaces
;;                           the foreground colour with the background one to make it work.
;;
;; ---------------------- RISC OS 3.60 release module -----------------
;;
;; 15-Jun-95    1.00    GPS: Made JPEG Error diffusion work with <8bpp output. When outputting to greyscale modes, only take
;;                           luminance of the JPEG.
;;
;;----------------------------------------------------------------------------

        GBLL    StrongARM
StrongARM SETL {TRUE}

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:CPU.Arch
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:VduExt
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:NDRDebug
        GET     Hdr:Sprite
        GET     Hdr:ColourTran
        GET     Hdr:PublicWS     ; only if bodgeOS is false
        GET     Hdr:Draw         ; needed for transform sprite
        GET     Hdr:ExtraLong    ; needed for transform sprite
        GET     Hdr:MsgTrans
        GET     Hdr:Proc
        GET     Hdr:HostFS
        GET     Hdr:Debug
        GET     Hdr:HostDebug
        GET     VersionASM
        GET     Hdr:PDriver

        AREA    |!!!ModuleHeader|, CODE, READONLY, PIC
Module_BaseAddr

; ---------------------------------------------------------------------------

; OSS Macro for Sprite internationalised error blocks. This is because all
; the names start with "Sprite_". This adds no useful information to the
; string, and just makes the module and the Messages file bigger

        MACRO
$label  MakeSpriteErrorBlock $name, $noalign, $tag
        ALIGN
$label
ErrorBlock_$name
        DCD     ErrorNumber_Sprite_$name
    [   "$tag" = ""
        DCB     "$name"
    |
        DCB     "$tag"
    ]
        DCB     0
    [   "$noalign" = ""
        ALIGN
    ]
        MEND

        GBLL    debugmc
        GBLL    debugpt
        GBLL    debugmg
        GBLL    debugid
        GBLL    debugin
        GBLL    debuglp
        GBLL    debugsc
        GBLL    debugsp
        GBLL    debugch
        GBLL    debugtr
        GBLL    debuger
        GBLL    debugxx
        GBLL    debugcg
        GBLL    debugcp
        GBLL    debugco
        GBLL    debugcn
        GBLL    debugcs
        GBLL    debugcw
        GBLL    debugcu
        GBLL    debugmb
        GBLL    debugms
        GBLL    debugag
        GBLL    debuggs
        GBLL    debugcc

        GBLL    hostvdu
        GBLL    file
 [ :LNOT: :DEF: localmessages
                GBLL    localmessages
localmessages SETL {FALSE}
 ]
        GBLL    AvoidScreenReads
AvoidScreenReads SETL    {TRUE}         ; When true, look out for BIC masks of FFFFFFFF and skip read

        GBLL    multibuffer
multibuffer     SETL {FALSE}            ; keep multiple copies of generated code

        GBLL    vidc20
vidc20  SETL    {TRUE}                  ; VIDC20 support, else graphics enhancer

        GBLL    ignore_ttr
ignore_ttr SETL {TRUE}                  ; if plotting <16 to >8bpp and it has a
                                        ; palette, use that instead of the ttr
        GBLL    med01867
med01867 SETL   {TRUE}                  ; if true changes ignore_ttr behaviour to
                                        ; only apply at 8bpp full palette
        GBLL    flagbit
flagbit SETL    {TRUE}                  ; if true forces the palette to be used over
                                        ; the translation table, overriding the effect
                                        ; of med01867 if b4 of R5 on entry was set

        GBLL    widetrans
widetrans SETL  {TRUE}                  ; support for wide translation tables via R5 bit 5

        [       flagbit
        GBLA    flg2_ignorettr
flg2_ignorettr  SETA 1                  ; R5 is shifted right 4 before storing
        GBLA    flg2_ditheron
flg2_ditheron   SETA 4
        ]

        [       widetrans
        GBLA    flg2_widetrans
flg2_widetrans  SETA 2
        ]

        GBLL    ccompiler               ; new PutSpriteScaled compiler, written in C
ccompiler SETL  {TRUE}
        GBLL    remoldcompiler          ; remove old compiler - set multibuffer to FALSE as well
remoldcompiler SETL {TRUE}

        GBLL    jpeg                    ; jpeg decompression
jpeg    SETL    {TRUE}

        GBLL    dynamicarea             ; for storing jpeg workspace
dynamicarea SETL {TRUE}

        GBLL    usemull
usemull SETL    :LNOT: NoARMM

debug   SETL    {FALSE} 
debugmc SETL    {FALSE}                 ; macro compilation
debugpt SETL    {TRUE}                  ; pointer
debugmg SETL    {FALSE}                 ; 'merge sprites' code
debugid SETL    {TRUE}                  ; insertdelete rows or columns
debugin SETL    {TRUE}                  ; input parameters
debuglp SETL    {FALSE}                 ; loop
debugsc SETL    {FALSE}                 ; screen parameters
debugsp SETL    {TRUE}                  ; sprite parameters
debugch SETL    {FALSE}                 ; character painting
debugtr SETL    {FALSE}                 ; transformed plotting
debuger SETL    {FALSE}                 ; error trapping
debugxx SETL    {FALSE}                 ; misc debugging
debugcg SETL    {FALSE}                 ; code generator
debugcp SETL    {FALSE}                 ; code generator - asm_putmany
debugco SETL    {FALSE}                 ; code generator - asm_tryoutput
debugcn SETL    {FALSE}                 ; code generator - asm_newpixel
debugcs SETL    {FALSE}                 ; code generator - asm_start
debugcw SETL    {FALSE}                 ; code generator - asm_newword
debugcu SETL    {FALSE}                 ; code generator - asm_putword
debugmb SETL    {FALSE}                 ; multibuffer code for code generator
debugms SETL    {FALSE}                 ; minimal multibuffer info messages
debugag SETL    {TRUE}                  ; amg transient debugging - could be anywhere :-)
debuggs SETL    {FALSE}                 ; JPEG SWI debugging.
debugcc SETL    {TRUE}                  ; PutSpriteScaled compiler in C

hostvdu SETL    {TRUE}
file    SETL    {FALSE}

        [ multibuffer
nbuffers * 8                            ; number of code buffers to use
        ]

        ; Enable use of cc -cpu 6 with an old version of objasm
        ; If your objasm understands v6 opcodes, it will ignore these macros
        ; Note the 3rd parameter is not implemented yet (not currently needed)
        MACRO
$lab    SXTH    $rd,$rm
$lab    DCI     &E6BF0070 :OR: ($rd :SHL: 12) :OR: $rm
        MEND

        MACRO
$lab    UXTH    $rd,$rm
$lab    DCI     &E6FF0070 :OR: ($rd :SHL: 12) :OR: $rm
        MEND

; ----------------------------------------------------------------------------

        ASSERT  (.=Module_BaseAddr)
        DCD     0            ; Start
        DCD     Init    - Module_BaseAddr
        DCD     Die     - Module_BaseAddr
        DCD     Service - Module_BaseAddr
        DCD     Title   - Module_BaseAddr
        DCD     Helpstr - Module_BaseAddr
        DCD     0                                           ; Helptable
        DCD     SpriteExtendJPEGSWI_Base                    ; MySWIBase
        DCD     SpriteExtend_SWIDecode   - Module_BaseAddr  ; MySWIDecode
        DCD     SpriteExtend_SWINames      - Module_BaseAddr  ; MySWINames
        DCD     0
        DCD     0
        DCD     ModFlags - Module_BaseAddr

Title   =       "SpriteExtend"
EndTitle                        ; For length calculations for caching the
        =       0               ; "Sprite doesn't exist" error

Helpstr =       "SpriteExtension",9,"$Module_HelpVersion"
      [ debug
        =       " Development version"
      ]
        =       0
        ALIGN

ModFlags
      [ :LNOT: No32bitCode
        DCD     ModuleFlag_32bit
      |
        DCD     0
      ]




; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Macros
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        MACRO
$label  ALIGNHASH  $o,$m
      [ ((@-$o):AND:($m-1))<>0
$label  #          $m-((@-$o):AND:($m-1))
      |
$label  #          0
      ]
        MEND

        MACRO
        Claim   $vector,$entry
        MOV     R0,#$vector
        ADRL    R1,$entry
        MOV     R2,R12
        SWI     XOS_Claim
        MEND

        MACRO
        Release $vector,$entry
        MOV     R0,#$vector
        ADRL    R1,$entry
        MOV     R2,R12
        SWI     XOS_Release
        MEND

        MACRO
$label  pullx     $reglist,$cc,$hat
$label  LDM$cc.FD R13,{$reglist}$hat
        MEND




; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Table of service calls we want
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        ASSERT  Service_ModeChange > Service_Reset
        ASSERT  Service_ResourceFSStarted > Service_ModeChange

ServiceTable

        DCD     0
        DCD     ServiceUrsula - Module_BaseAddr
        DCD     Service_Reset
        [ multibuffer
        DCD     Service_ModeChange
        ]
        DCD     Service_ResourceFSStarted
        DCD     0
        DCD     ServiceTable - Module_BaseAddr




; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Service call handler
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Service
        MOV     r0, r0                  ; Indicates there is a service call table

        ; Fast rejection
        TEQ     r1, #Service_ResourceFSStarted
        [ multibuffer
        TEQNE   r1, #Service_ModeChange
        ]
        TEQNE   r1, #Service_Reset
        MOVNE   pc, lr

ServiceUrsula

        [ multibuffer
        TEQ     r1, #Service_ModeChange
        BEQ     modechange
        ]
        TEQ     r1, #Service_Reset      ; Re-initialise on soft reset
        BEQ     Init

; ** Drop through for territory started **

; OSS A new Territory has started, so I need to re-cache the error block

service_territory_started Entry "r0-r11"
        LDR     r12, [r12]
        BL      cache_sprite_doesnt_exist_error
        EXIT

        [ multibuffer

; one of the problems with using a quick 'n' fast algorithm like usage counts
; for deciding which routine needs replacing is that it has weaknesses. The
; specific weakness being dealt with here is that if a long time is spent in
; one mode then high usage counts will result for that mode. When a new mode
; is selected the new routines needed for that mode will fight over the remaining
; slots with a lower usage count. In worst case this will mean that new
; routines will be built on virtually every plot!
;
; there are two options for avoiding this. The first is to hold a time stamp
; to indicate when a routine was last used. This option has been rejected
; because of the overhead of calling the SWI. The second is to junk all the
; currently built routines on a mode change. This may result in some routines
; being rebuilt which have already been built, but will avoid the scenario
; outlined above.
;
; note that I am not clearing the associated macrowords for each routine - this
; should help to avoid too many needless rebuilds of routines

modechange
        Push    "R0-R2,R12,LR"

        ; zero the workspace pointer for JPEG - allocated from RMA if needed
        MOV     R0,#0
        ADRL    R2,jpeg_info_ptr
        STR     R0,[R2]

        LDR     R0,[R12]
        MOVS    R12,R0
        BEQ     modechange_nospace

        ADRL    R0,buffer0count
        MOV     R1,#((nbuffers :SHL: 2)-4)
        MOV     R2,#0
modechange_loop
        STR     R2,[R0,R1]
        SUBS    R1,R1,#4
        BPL     modechange_loop
        Debug   mb,"Clearing all usage counts on mode change"
modechange_nospace
        Pull    "R0-R2,R12,PC"
        ]




; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Initialisation
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Init
        Push    "R0-R12,LR"
;
        LDR     R2,[R12]
        TEQ     R2,#0
        BNE     gotarea
;
        MOV     R0,#ModHandReason_Claim
        LDR     R3,=enddata-data
        SWI     XOS_Module
        BVS     initexitdie
        STR     R2,[R12]

; Set the error pointer to zero only if we are allocating the workspace.
; This is because on Service_Reset we have the workspace and we still have
; the old cached error block so zeroing the pointer would cause us to
; never free that block.

        MOV     r0, #0
        STR     r0, [r2, #:INDEX:sprite_doesnt_exist_error]
gotarea
        MOV     R12,R2
;
        MOV     R0,#-1
        STR     R0,inmode
        STR     R0,macroword

        MOV     R0,#0
        STR     R0,vduspritename

; OSS Attempt to cache the error. This may well fail, but we ignore the
; failure. We will get another go later on Service_TerritoryStarted and
; that time it should succeed.

        BL      cache_sprite_doesnt_exist_error
02
        [ multibuffer
        ; set up the buffer usage counts and current macrowords
        ADR     R4,buffer0mask
        ADR     R5,buffer0count
        MOV     R6,#0
        MOV     R7,#((nbuffers :SHL: 2)-4)
20
        STR     R6,[R4,R7]
        STR     R6,[R5,R7]
        SUBS    R7,R7,#4
        BPL     %BT20
        ]
        CLRV

;
        Claim   SpriteV,My_SpriteOp

        MOVVC   R0,#-1
        SWIVC   XOS_ChangedBox  ; R1 --> 5-word block for changed coords
        STRVC   R1,changedbox
;
        BLVC    readvduvars     ; read for later

      [ file
        Debug_Open "<Debug$File>"
      ]

      [ ccompiler
        MOV     R7,#0
        ADRL    R6,ccompiler_space
        STR     R7,[R6]                   ; mark the ccompiler workspace clearly as uninitialised
        ADRL    r0,bitblockmove           ; ensure C code has access to bitblockmove
        STR     r0,ccompiler_bitblockmove
      ]

      [ jpeg
;        MOV     R7,#-1
;        ADRL    R6,jpeg_error_code
;        STR     R7,[R6]                    ; mark the jpeg workspace clearly as uninitialised
;        ADRL    R1,jpeg_space              ; base of workspace - a decompress_info_struct
;        ADRL    R2,jpeg_end
;        SUB     R0,R2,R1                   ; amount of space.
;        ADRL    R2,jpeg_workspace_size
;        STR     R0,[R2]                    ; store workspace size

        ; set up the fetchroutine, for use by any subsequent compiled code.
        ADRL    R2,jpeg_fetchroutine
        STR     R2,fetchroutine

        ; zero the workspace pointer for JPEG - allocated from RMA if needed
        MOV     R0,#0
        ADRL    R2,jpeg_info_ptr
        STR     R0,[R2]

        ; clear priver intercept flags....
        MOV     r0, #0
        ADRL    r2, save_PdriverIntercept
        STR     r0, [r2]
      ]
        ; initialise dithering off..
        MOV     r0, #0
        ADRL    r2, dither_truecolour
        STR     r0, [r2]

        ; check ColourTrans version is up to date
        ADR     r0, init_ctrans_check
        SWI     XOS_CLI
        MOVVS   r0, #0
        MOVVC   r0, #-1
        ADRL    r2, ctrans_recent
        STR     r0, [r2]
        
initexitdie
        STRVS   R0, [sp]
        Pull    "R0-R12,PC"

init_ctrans_check
        DCB     "RMEnsure ColourTrans 1.25 Error 1",0
        ALIGN

Die
        Push    "R0-R12,LR"
        LDR     R12,[R12]       ; R12 --> workspace

; OSS Free the cached "Sprite doesn't exist" error block - never
; returns errors.

        BL      free_sprite_doesnt_exist_error

      [ file
        Debug_Close
      ]

      [ jpeg
;        ; release the patched OS_ReadModeVariable SWI.
;        LDR     R0,=SvcTable+(OS_ReadModeVariable :SHL: 2)
;        LDR     R1,[R0]                    ; load current pointer
;        ADRL    R2,newReadModeVariable
;        CMP     R1,R2                      ; check still points to me
;        LDREQ   R1,oldReadModeVariable     ; if so, restore old handler
;        STREQ   R1,[R0]                    ; if not, we're probably dead anyway.
      [ dynamicarea
        ADRL    R1, area_number              ; dynamic area number
        LDR     R1, [R1]
        CMP     R1, #0
        MOVNE   R0, #1
        SWINE   XOS_DynamicArea
      |
        ; if JPEG workspace has been allocated, free it.
        ADRL    R2,jpeg_info_ptr
        LDR     R2,[R2]
        CMP     R2,#0
        MOVNE   R0,#7                      ; reason code
        SWINE   OS_Module                  ; free block
      ]
      ]

        Release SpriteV,My_SpriteOp             ; OSS  Errors from this ARE returned
01
        B       initexitdie

;;----------------------------------------------------------------------------
;; Data areas & register allocation
;;----------------------------------------------------------------------------

log2bpc         RN      R11             ; bpc
ycount          RN      R9              ; xcount
ysize           RN      R8              ; xsize
yadd            RN      R5
ydiv            RN      R4
inoffset        RN      R1              ; inshift
outoffset       RN      R0

inshift         RN      R1              ; inoffset

im2             RN      R12             ; wsptr         ; ecfeor
im1             RN      R11             ; log2bpc       ; ecfora
masko           RN      R10             ; ttr           ; ecfptr
xcount          RN      R9              ; ycount
xsize           RN      R8              ; ysize
xadd            RN      R7
xdiv            RN      R6
outmask         RN      R5              ; yadd
outword         RN      R4              ; ydiv
outptr          RN      R3
inptr           RN      R2
in2             RN      R1              ; inoffset      ; inshift
in1             RN      R0              ; outoffset

ecfeor          RN      R12             ; wsptr         ; im2
ecfora          RN      R11             ;               ; im1
ecfptr          RN      R10             ; masko         ; ttr

inbpp           RN      R12             ; im2
ttr             RN      R10             ; masko
vcount          RN      R7              ; xadd

zs              RN      R11
zf              RN      R10
zys             RN      R9
ycounter        RN      R8
xcounter        RN      R7
inputcell       RN      R6
flags           RN      R5
; outword       RN      R4
; outptr        RN      R3
z               RN      R2              ; Rc
zyf             RN      R1              ; Rb
Rc              RN      R2              ; z
Rb              RN      R1              ; zyf
Ra              RN      R0


bignum          *       &1000000

                  ^     0,R13           ; for stackframe
stack_inshift     #     4               ; this data is copied onto the stack
stack_outword     #     4               ; so that R12 can be re-used
stack_outmask     #     4
stack_xsize       #     4
stack_xcount      #     4
stack_ecfptr      #     4
stack_ecflimit    #     4
stack_vcount      #     4
stack_xdiv        #     4
stack_xadd        #     4
stack_tempoutptr  #     4
stack_wsptr       #     4               ; for recovering R12 later!
        ASSERT  (:INDEX:@) = 12*4       ; must be exactly 12 words on stack
stack_BPP         #     4               ; copy
stack_outoffset   #     4               ; copy
stack_inbpp       #     4               ; copy
stack_colourttr   #     4               ; copy
stack_masko       #     4               ; copy
stack_calladdr    #     4               ; copy
stack_calladdr2   #     4               ; copy
stack_returnaddr  #     4
stack_maskword    #     4               ; = (2^outlog2bpp)-1 ROR outlog2bpp
stack_maskinptr   #     4               ; destroyable copy for inside loop
stack_maskinshift #     4               ; destroyable copy for inside loop
stack_temp1       #     4               ; for temp saving of registers inside loop
stack_temp2       #     4               ; for temp saving of registers inside loop
stack_end         #     0

          ^     0,R12

; If ccompiler in use then from here is of interest to compiled C
; code. IF THERE ARE ANY CHANGES BELOW THIS POINT then there must be
; matching changes in the C.

data            #       0

        ASSERT  (:INDEX:@)=0
save_outoffset  #       4       ; reloaded from R12
save_inoffset   #       4
save_inptr      #       4
save_outptr     #       4
save_ydiv       #       4
save_yadd       #       4
save_ysize      #       4
save_ycount     #       4

save_block      #       0
save_inshift    #       4       ; <---!   this data is copied onto the stack
save_outword    #       4       ;     !   so that R12 can be re-used
save_outmask    #       4       ;     !
save_xsize      #       4       ;     !
save_xcount     #       4       ;     !
save_ecfptr     #       4       ;   --!   up to here is reloaded using LDMIA
save_ecflimit   #       4       ;     !
save_vcount     #       4       ;     !
save_xdiv       #       4       ;     !
save_xadd       #       4       ; <---!

save_masko      #       4
save_xcoord     #       4
save_ycoord     #       4
save_inputxsize #       4
save_inputysize #       4
save_tempxsize  #       4
save_tempysize  #       4
save_xftimesyf  #       4
save_xmag       #       4
save_ymag       #       4

save_inflags    #       4
save_inlog2bpp  #       4
save_inlog2bpc  #       4
save_inbpp      #       4
save_mode       #       4               ; used in PaintChar
save_spr_type   #       4

save_maskinshift #      4
save_maskinptr  #       4
save_maskinoffset #     4

save_calladdr   #       4               ; points to 'l_start'
save_calladdr2  #       4               ; points to 'l_putword'

macroword       #       4
                [ multibuffer
pc_ecflimit0     #       nbuffers :SHL: 2              ; addresses inside macro code
pc_outoffset0    #       nbuffers :SHL: 2
thisslot         #       4
calladdr20       #       nbuffers :SHL: 2
calladdr0        #       nbuffers :SHL: 2
                |
pc_ecflimit     #       4                       ; addresses inside macro code
pc_outoffset    #       4
                ]


inmode          #       4
inlog2px        #       4
inlog2py        #       4
ColourTTR       #       4

nextrowdata     #       12
nextcoldata     #       12
TOTAL           #       4
XTOTAL          #       4

vduspritepars   #       4+4         ; sprite code, areaCBptr ...
vduspritename   #       12          ; ... name

changedbox      #       4

spritecode      #       4

                ; things MOVED to let ccompiler get at them.

                [ ignore_ttr
trns_palette    #       4
                [ flagbit
trns_flags2     #       4
                ]
                ]

BPC             #       4
BPP             #       4

                [ ccompiler
ccompiler_bitblockmove # 4      ; routine for C to call back into assembler.
calibration_table # 4           ; printer calibration table
                ]

              [ jpeg
is_it_jpeg      #       4       ; BOOL - is this sprite JPEG?
ctrans_recent   #       4       ; BOOL - check for ColourTrans 1.25 or later
in_x            #       4       ; initial x coord in input sprite
in_y            #       4       ; initial y coord in input sprite
fetchroutine    #       4       ; routine for compiled code to call to get line of JPEG data.
save_sprite     #       4       ; the actual source sprite
jpeg_info_ptr   #       4       ; pointer to JPEG workspace - allocated from RMA if needed
area_number     #       4       ; dynamic area number
              ]

bgcolour        #       4       ; background colour, for plotting mask.
save_PdriverIntercept # 4       ; Flags used to determine if the pdriver is
dither_truecolour   #   4       ; do we dither true colour images when reducing BPP?

newtranstable   #       256 *4  ; buffer for pixel translation table
                                ; or for palette converted to 16bpp...

; If ccompiler in use then up to here is of interest to compiled C
; code. IF THERE ARE ANY CHANGES ABOVE THIS POINT then there must be
; matching changes in the C.

                                 ; currently intercepting the JPEG plots.
ecfspace        #       72

spritename      #       12

stackframe      #       4

charblock       #       9

       ALIGNHASH        data,16

RAM_SpriteEntry #       12
Sprite_OScopy   #       4       ; copy of OS routine address
OSflag          #       4

       ALIGNHASH        data,16

areaCB          #       0
                #       4               ; saEnd
                #       4               ; saNumber
                #       4               ; saFirst
                #       4               ; saFree
spriteCB        #       0
                #       4               ; spNext
                #       12              ; spName
                #       4               ; spWidth
                #       4               ; spHeight
                #       4               ; spLbit
                #       4               ; spRbit
                #       4               ; spImage
                #       4               ; spTrans
                #       4               ; spMode
spriteEnd       #       0

spriteSize      *       spriteEnd-spriteCB
spriteAreaSize  *       spriteEnd-areaCB + 2*8*8*16/8  ; mode 10 has 16 bpp!
                #       2*8*8*16/8
        ASSERT  (@-areaCB) = spriteAreaSize

        ALIGNHASH       data,16

sp_mode         #       4               ;WT: added for 1bpp mask support
sp2_next        #       4               ;WT: added for 1bpp mask support

sp1_data        #       0
sp1_width       #       4
sp1_height      #       4
sp1_lbit        #       4
sp1_rbit        #       4
sp1_image       #       4
sp1_trans       #       4
sp1_header      #       4
sp1_imagesize   #       4

sp1_areaCBptr   #       4

sp2_data        #       0
sp2_width       #       4
sp2_height      #       4
sp2_lbit        #       4
sp2_rbit        #       4
sp2_image       #       4
sp2_trans       #       4
sp2_header      #       4
sp2_imagesize   #       4

        ALIGNHASH       data,64

vduoutputbuffer #       0
log2px          #       4
log2py          #       4
Log2bpp         #       4
Log2bpc         #       4

orgx            #       4
orgy            #       4
gwx0            #       4
gwy0            #       4
gwx1            #       4
gwy1            #       4

linelength      #       4
screenstart     #       4
ywindlimit      #       4

modeflags       #       4

                [ multibuffer
buffer0mask     #       nbuffers :SHL: 2
buffer0count    #       nbuffers :SHL: 2
sprite_doesnt_exist_error # 4   ; OSS Pointer to error block in RMA
                                ; AMG moved here to avoid an out of range error

                ]

        ALIGNHASH       data,64

                [ multibuffer
codebuffer0      #       nbuffers * &200
codebuffer       #       &200 ;still needed elsewhere
                |
codebuffer       #       &200
                ]


                [ multibuffer
                |
sprite_doesnt_exist_error # 4   ; OSS Pointer to error block in RMA
                ]

; Private space for use by compiled C.
; If the C code needs more than this then this area must be extended.
                [ ccompiler
ccompiler_sp    #       4       ; for unexpected jumps out of compiled C
ccompiler_space #       9392    ; C code checks at run-time for there being enough.
ccompiler_end   #       0
ccompiler_errptr #      0       ; os_error pointer for if an OS error lead to exit from C code.
                ]

enddata         #       0


;;----------------------------------------------------------------------------
;; OS_SpriteOp decoding entry point
;; Entry: R0 = reason code
;;        R12 --> private word
;; Exit : R0-R7 may be used to contain results
;;----------------------------------------------------------------------------

My_SpriteOp ROUT

        Debug   gs, "Sprite Extend sprite op called...",r0
        Push    "R1"
        MOV     r1, #SpriteReason_CheckSpriteArea << 24
        CMP     r1, r0, LSL #24
        Pull    "R1"
        BEQ     SpriteOp_CheckSpr
        MOV     r0, r0, ROR #8
        CMP     r0, #myminreason << 24
        MOV     r0, r0, ROR #24
        MOVCC   pc, lr

SpriteOp_CheckSpr
        Push    "R10-R11,LR"
        STR     R13,stackframe          ; for calling OS_SpriteOp
;
        STR     R0,spritecode
        MOV     R14,#VduDriverWorkSpace + BgEcfOraEor
        STR     R14,save_ecflimit       ; mask plotting uses bg ecf pattern
;
        JumpAddress LR,My_SpriteExit,forward
        AND     R10, R0, #&FF
;First check for new SpriteReason_CheckSpriteArea
        CMP     r10, #SpriteReason_CheckSpriteArea
        BEQ     Go_CheckSpriteArea
;now carry on as before...
        SUB     r10, r10, #myminreason

        CMP     R10,#mymaxreason-myminreason
        ADDCC   PC,PC,R10,LSL #2
        Pull    "R10-R11, PC"           ; I don't know about bigger ones

mymaxreason     *       SpriteReason_ReadSaveAreaSize + 1
myminreason     *       SpriteReason_AppendSprite

jptable
        B       Go_AppendSprite         ; SpriteReason_AppendSprite
        B       Go_SetPointerShape      ; SpriteReason_SetPointerShape
        B       Go_CreateRemovePalette
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
;
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
;
        B       Go_PlotMaskScaled       ; SpriteReason_PlotMaskScaled
        B       Go_PaintCharScaled      ; SpriteReason_PaintCharScaled
        B       Go_PutSpriteScaled      ; SpriteReason_PutSpriteScaled
        B       Go_PutSpriteGreyScaled  ; SpriteReason_PutSpriteGreyScaled
;        Pull    "R10-R11, PC"           ; Disable SpriteReason_PutSpriteGreyScaled
        Pull    "R10-R11, PC"           ; (allow for SpriteReason_RemoveLefthandWastage)
        B       Go_PlotMaskTransformed  ; SpriteReason_PlotMaskTransformed
        B       Go_PutSpriteTransformed ; SpriteReason_PutSpriteTransformed
        B       Go_InsertDeleteRows     ; SpriteReason_InsertDeleteRows
        B       Go_InsertDeleteColumns  ; SpriteReason_InsertDeleteColumns

        Pull    "R10-R11, PC" ; 59
        Pull    "R10-R11, PC" ; SpriteReason_SwitchOutputToSprite
        Pull    "R10-R11, PC" ; SpriteReason_SwitchOutputToMask
        Pull    "R10-R11, PC" ; SpriteReason_ReadSaveAreaSize

;        Pull    "R10-R11, PC" ; SpriteReason_PutSpriteScaledCalibrated
;        Pull    "R10-R11, PC" ; SpriteReason_PutSpriteTransformedCalibrated

        ASSERT  (.-jptable) = (mymaxreason-myminreason) * 4

My_SpriteExit
        LDRVC   R0,spritecode
01
        Pull    "R10-R11,LR,PC"


Go_SpriteOp
        Push    "R10-R12,LR"
01
        LDR     R10,stackframe
        Push    "PC"                    ; set up return address
        LDMIA   R10,{R10-R11,PC}        ; call rest of vector owners
        NOP                             ; returns here or next instruction
        Pull    "R10-R12,PC"

TestFor16or32bpp ROUT ; return vs if R2 points at a 16/32bpp sprite
        Push    "R0-R3,R11,LR"
        MOV     R11, #0
        B       %FT40

TestForMaskAnyDepth ; fault a new format sprite with mask
        Push    "R0-R3,R11,LR"
        LDR     R0,[R2,#spMode]
        MOVS    R0,R0,LSR #27
        LDMEQFD R13!,{R0-R3,R11,PC}
        B       %FT32

TestForMaskAtDepth ; fault a mask at 16/32bpp
        Push    "R0-R3,R11,LR"
        ;reject any T=5 or T=6 sprites which have a mask, and also (later) any
        ;attempts to add a palette to one
        MOV     R11,#1
40
        ;should be called after findsprite has been called

        LDR     R0,[R2,#spMode]
        CMP     R0,#256
        BCC     %FT10                   ; go if a screen mode number
        MOV     R0,R0,LSR #27           ; isolate the type alone
        CMP     R0,#4
        BCC     %FT20                   ; under 16bpp, so don't care
30
        CMP     R11,#0
        BEQ     %FT50
32
        LDR     R0,[R2,#spImage]
        LDR     R1,[R2,#spTrans]
        TEQ     R0,R1
        BEQ     %FT20                   ; no mask, so no complaints
50
        ADR     R0, ErrorBlock_BadDepth
        addr    R1, Title
        BL      copy_error_one          ; returns V set
        STR     R0,[R13]
        STR     R1,[R13,#4]
        Pull    "R0-R3,R11,PC"

        MakeSpriteErrorBlock BadDepth,,BadDepth
10
        ;it's a mode number
        Push    "R2"
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        BCS     %BT50
        CMP     R2,#4
        Pull    "R2"
        BCS     %BT30                   ; 16 or 32 bpp so check for a mask
20
        Pull    "R0-R3,R11,PC"

;;----------------------------------------------------------------------------
;; SpriteReason_CreateRemovePalette
;; --------------------------------
;;
;; in:  r0  = 37 (SpriteReason_CreateRemovePalette) (+0 / 256 / 512)
;;      r1 -> sprite control block
;;      r2 -> sprite name / sprite
;;      r3  = -1: read palette size
;;          =  0: remove palette
;;          <> 0: add palette (bit 31=1, add extended palette)
;;
;; out: V=1 => r0 -> error block
;;
;;      r3 =-1 on entry then r3  = size of palette block, =0 if none
;;                           r4 -> palette block, =0 if none
;;                           r5  = mode
;;----------------------------------------------------------------------------

Go_CreateRemovePalette
        Push    "r1-r11, lr"

        BL      findsprite              ; r2 -> sprite block
        Pull    "r1-r11, PC",VS

        CMP     r3, #-1
        BNE     addremoveit             ; skip read palette size

        ADD     r3, r2, #spImage
        LDMIA   r3, {r3, r4}            ; r3,r4 offsets to mask/image
        CMP     r3, r4
        MOVGT   r3, r4                  ; r3 -> top of palette block
        SUB     r3, r3, #spPalette      ; r3  = size of palette block
        MOVS    r3, r3, ASR #3          ; r3  = number of colours in palette block

        ADDNE   r4, r2, #spPalette      ; r4 -> palette block to return
        MOVEQ   r4, #0                  ; or  =0 if no palette
        LDR     r5, [r2, #spMode]       ; r5  = mode number

        ADD     lr, sp, #4*2            ; lr -> r3 in return frame
        STMIA   lr, {r3, r4, r5}

        CLRV
        Pull    "r1-r11, pc"

addremoveit
        TEQ     r3, #0                  ; remove the palette?
        BNE     addpalette

; remove palette, simple case, assuming r1 -> sprite control block, r2 -> sprite
; we must move the data in the sprite and then update the header followed by
; the control block.
;

removepalette
        LDR     r4, [r2, #spImage]      ; r4   = offset to image
        LDR     r5, [r2, #spTrans]      ; r5   = offset to trans mask
        CMP     r4, r5
        MOVGT   r4, r5                  ; r4   = offset to first part of sprite data

        LDR     r8, [r1, #saFree]       ; r8   = free index into sprite area

        SUBS    r0, r4, #spPalette      ; r0   = size of palette block, if none then exit!
        ADDNE   r9, r2, #spPalette
        ADDNE   r10, r1, r8             ; r10 -> free in sprite area
        BLNE    move_memory_down

        SUB     r8, r8, r0              ; adjust free space
        STR     r8, [r1, #saFree]

        LDR     r3, [r2, #spNext]       ; adjust next sprite pointer
        SUB     r3, r3, r0
        STR     r3, [r2, #spNext]

        ADD     r3, r2, #spImage        ; adjust offsets to image data
        LDMIA   r3, {r4, r5}
        SUB     r4, r4, r0
        SUB     r5, r5, r0
        STMIA   r3, {r4, r5}

        CLRV
        Pull    "r1-r11, pc"


; add sprite palettes, this involves creating a gap for the sprite
; palette and then writing the actual data for the palette into this area
; these routines will use a general purpose function 'addpalette' taking
; r1,r2 as sprite pointers and r4 as a mask to be applied to the maximum
; number of colours.  This mask is used to generate the real number of
; colours written into the sprite header.
;

addpalette

; the test for 16/32bpp only occurs here, so that read palette size, and
; remove palette won't complain

        LDR     r0, [r2, #spMode]       ; r0  = mode
        MOVS    lr, r0, LSR #27         ; EQ for old format sprite, NE otherwise
        BEQ     %FT10

        ;now allow T=1 to T=4 to have palettes
        CMP     lr, #5
        BCC     %FT10

        ADR     r0, ErrorBlock_BadDepth
        addr    R1, Title
        BL      copy_error_one          ; this call sets V
        Pull    "r1-r11, PC",VS
10
        TST     r3, #1:SHL:31           ; add extended palette?
        MOVNE   r4, #255
        MOVEQ   r4, #63                 ; max colours that can be added

        Push    "r1-r2"

        LDR     r0, [r2, #spMode]       ; r0  = mode
        MOV     r1, #9                  ; r1  = index for log2bpp
        SWI     XOS_ReadModeVariable    ; no need to check for CS here - will already
        ADR     r1, palettetables       ; have happened in TestFor16or32bpp
        LDR     r5, [r1, r2, ASL #2]    ; r5  = offset to palette tables
        ADD     r5, r5, r1              ; r5 -> absolute table
        MOV     r8, #2                  ; shift =2 as reading from table (single entries)

        MOV     r0, #1
        MOV     r1, r0, ASL r2
        RSB     r3, r0, r0, ASL r1      ; r3  = maximum number of colours
        AND     r4, r3, r4              ; r4  = maximum number of written colours

        Pull    "r1-r2"                 ; preserve sprite pointers

        ADD     r0, r4, #1
        MOV     r0, r0, ASL #3          ; r0 = size of a palette block

        ADD     r6, r2, #spImage
        LDMIA   r6, {r6, r7}            ; r6, r7 -> sprite, mask

        MOV     lr, r6
        CMP     lr, r7
        MOVGT   lr, r7                  ; lr =lowest offset

        SUBS    lr, lr, #spPalette      ; lr =size of current palette
        SUBNE   r0, r0, lr
        ADDNE   r5, r2, #spPalette      ; if adjusting size then modify from current palette
        MOVNE   r8, #3                  ; shift =3, reading from sprite palette (double entries)

        LDR     r9, [r1, #saFree]
        LDR     r10, [r1, #saEnd]
        ADD     r9, r9, r0              ; r9 => end of free area
        CMP     r9, r10                 ; is there enough room?
        BHI     add_no_room             ; no, so complain!

        STR     r9, [r1, #saFree]       ; store new offset to start of free area
        ADD     r10, r9, r1             ; r10 -> new start of free area
        SUB     r10, r10, r0            ; r10 -> old start of free area
                                        ;     =  end address+1 of block to move

        LDR     r9, [r2, #spNext]
        ADD     r9, r9, r0
        STR     r9, [r2, #spNext]       ; adjust the offset to next sprite

        ADD     r6, r6, r0
        ADD     r7, r7, r0
        ADD     r9, r2, #spImage
        STMIA   r9, {r6, r7}            ; stash updated image + mask offsets

        ADD     r9, r2, #spPalette      ; r9 -> start of current palette
        ADD     r9, r9, lr              ; r9 -> end of current palette+1
                                        ;    =  start address of block to move
        BL      move_memory_up

        ADD     r6, r2, #spPalette      ; r6 -> destination buffer
        ADD     r6, r6, r4, LSL #3
        LDR     r7, =&0F0F0F00          ; r7  = masked used when ensuring palette entries

; r1 -> sprite blk
; r2 -> sprite
; r3  = total colours (ie. 1, 3, 15, 255)
; r4  = number of colours to write ( 1, 3, 15, 63 / 255)
; r5 -> table containing base palette entries
; r6 -> block to write data into
; r7  = &0F0F0F00
; r8  = shift to use when getting palette entries

addpalette_main
        AND     r0, r4, #15
        ADD     r0, r5, r0, LSL r8
        LDR     r0, [r0]                ; r0 = BGR combination

        TEQ     r3, #255                ; is it a 8bpp palette?
        BNE     addpalette_gotvalues

        BIC     r0, r0, #&80000000      ; transfer hard blue bit
        AND     lr, r4, #&80
        ORR     r0, r0, lr, LSL #31-7
        BIC     r0, r0, #&00C00000      ; transfer hard green bit
        AND     lr, r4, #&60
        ORR     r0, r0, lr, LSL #23-6
        BIC     r0, r0, #&00008000      ; transfer hard red bit
        AND     lr, r4, #&10
        ORR     r0, r0, lr, LSL #15-4

        BIC     r0, r0, r7
        ORR     r0, r0, r0, LSR #4      ; change from &B0G0R00 -> &BBGGRR00

addpalette_gotvalues
        ORR     r0, r0, #&10
        STR     r0, [r6],#4
        STR     r0, [r6],#-12           ; write and advance index

        SUBS    r4, r4, #1
        BGE     addpalette_main         ; loop whilst colour counter >= 0

        Pull    "r1-r11, pc"

add_no_room
        ADR     r0, ErrorBlock_NotEnoughRoom
        addr    r1, Title
        BL      copy_error_one          ; Always sets the V flag
        Pull    "r1-r11, PC"

        MakeSpriteErrorBlock NotEnoughRoom,,NoMem

; tables for creating default palettes
;

palettetables
        DCD     bpp1 -palettetables
        DCD     bpp2 -palettetables
        DCD     bpp4 -palettetables
        DCD     bpp8 -palettetables

bpp1    DCD     &00000000       ;  black
        DCD     &FFFFFF00       ;  white

bpp2    DCD     &00000000       ;  black
        DCD     &0000FF00       ;  red
        DCD     &00FFFF00       ;  yellow
        DCD     &FFFFFF00       ;  white

bpp4    DCD     &00000000       ;  black
        DCD     &0000FF00       ;  red
        DCD     &00FF0000       ;  green
        DCD     &00FFFF00       ;  yellow
        DCD     &FF000000       ;  blue
        DCD     &FF00FF00       ;  magenta
        DCD     &FFFF0000       ;  cyan
        DCD     &FFFFFF00       ;  white
        DCD     &00000000       ;  black
        DCD     &0000FF00       ;  red
        DCD     &00FF0000       ;  green
        DCD     &00FFFF00       ;  yellow
        DCD     &FF000000       ;  blue
        DCD     &FF00FF00       ;  magenta
        DCD     &FFFF0000       ;  cyan
        DCD     &FFFFFF00       ;  white

bpp8    DCD     &00000000       ;  0000
        DCD     &10101000       ;  0001
        DCD     &20202000       ;  0010
        DCD     &30303000       ;  0011
        DCD     &00004000       ;  0100
        DCD     &10105000       ;  0101
        DCD     &20206000       ;  0110
        DCD     &30307000       ;  0111
        DCD     &40000000       ;  1000
        DCD     &50101000       ;  1001
        DCD     &60202000       ;  1010
        DCD     &70303000       ;  1011
        DCD     &40004000       ;  1100
        DCD     &50105000       ;  1101
        DCD     &60206000       ;  1110
        DCD     &70307000       ;  1111

        LTORG



;;----------------------------------------------------------------------------
;; SetPointerShape
;;----------------------------------------------------------------------------

; Entry:  R1 --> sprite area
;         R2 --> sprite name/address
;         R3 bits 0..3 = pointer shape number (1..4)
;         R3 bit 4 set => don't use the sprite's image
;         R3 bit 5 set => don't use the sprite's palette
;         R3 bit 6 set => don't set the current shape number afterwards
;         R4,R5 = coordinates of active point (pixels from top-left)
;         R6 --> factors (<=0 ==> use default, depending on mode)
;         R7 --> pixel translation table (==> 2 bpp)
;

spp_ptrno       *       2_00001111
spp_noimage     *       2_00010000
spp_nopalette   *       2_00100000
spp_nosetno     *       2_01000000


sillyname       DCB     "pointer",0
                ALIGN

tempareasize    *       &200

Go_SetPointerShape
        Push    "R10,R11,LR"
        Debug   gs,"Regs at start = ",R0,R1,R2,R3,R4
        Debug   gs,"                ",R5,R6,R7,R8,R9
;
        Debug   pt, "R3 = ",R3
        TST     R3,#spp_noimage
        BLEQ    go_setimage
        Pull    "R10,R11,PC",VS

        Debug   pt, "done setimage"
        TST     R3,#spp_nopalette
        BLEQ    go_setpalette
        Pull    "R10,R11,PC",VS

        Debug   pt, "done setpalette"
        TST     R3,#spp_nosetno
        BLEQ    go_setno

        Debug   pt, "done setno",R3
        LDRVC   R0, spritecode
        Debug   gs,"Regs at end   = ",R0,R1,R2,R3,R4
        Debug   gs,"                ",R5,R6,R7,R8,R9
        Pull    "R10,R11,PC"
go_setimage
        LDR     R0,spritecode
        Push    "R0-R7,LR"              ; may need to find sprite again
;
        Debug   pt,"Input sprite:",#spritecode,R1,R2
        BL      findsprite              ; R2 --> sprite definition

        BLVC    TestFor16or32bpp

        Debug   pt,"Input sprite address is:",R2
        MOV     R1,R2                   ; R1 --> sprite definition
        MOV     R11,R2                  ; R11 --> sprite definition

        Debug   gs,"gonna do a create sprite"
        LDRVC   R0,[R2,#spMode]
        BLVC    readspritevars          ; log2px/y
        BLVC    readvduvars             ; inlog2px/y, save_inlog2bpp
        BVS     %FT99
        Debug   gs,"still gonna do a create sprite"
;
        ASSERT  saEnd=0                 ; create area header for output sprite
        MOV     R14,#tempareasize       ; should be big enough
        STR     R14,[sp,-R14]!
        MOV     R14,#0
        STR     R14,[sp,#saNumber]
        MOV     R14,#saExten
        STR     R14,[sp,#saFirst]
        STR     R14,[sp,#saFree]
;
        Debug   gs,"definately still gonna do a create sprite"
        MOV     R0,#SpriteReason_CreateSprite   ; create output sprite
        ADD     R0,R0,#&100
        MOV     R1,sp
        ADRL    R2,sillyname
        MOV     R3,#0                   ; no palette
        MOV     R4,#32                  ; 32 pixels wide
        MOV     R5,#32                  ; 32 pixels high
        MOV     R6,#1                   ; mode 1 seems reasonable
        Debug   pt,"Output sprite:",R0,R1,R2,R3,R4
        SWI     XOS_SpriteOp
        Debug   gs,"returned from crezte swi"
        BVS     %FT96
        Debug   gs,"V not set"
96
        MOVVC   R0,#SpriteReason_SwitchOutputToSprite
        ADDVC   R0,R0,#&100
        MOVVC   R3,#0                   ; no save area
        SWIVC   XOS_SpriteOp            ; on exit R0-R3 = old params
        Debug   gs,"returned from swi"
        ADDVS   sp,sp,#tempareasize
        BVS     %FT99
        Debug   gs,"V not set"
;
        Push    "R0-R3"
        ADD     R14,sp,#4*4 + tempareasize + 1*4
        LDMIA   R14,{R1-R7}
        Debug   pt,"Recovered input params:",R1,R2,R3,R4,R5,R6,R7
;
        CMP     R6,#0
        LDMNEIA R6,{R2-R5}              ; user-supplied scaling
        BNE     %FT01
;
        MOV     R14,#1
        LDR     R2,inlog2px             ; if no R6, make up the values!
        MOV     R2,R14,LSL R2
        LDR     R3,inlog2py
        MOV     R3,R14,LSL R3
        LDR     R4,log2px
        MOV     R4,R14,LSL R4
        LDR     R5,log2py
        MOV     R5,R14,LSL R5
        LDR     R14,Log2bpp             ; double-pixel modes ...
        MOV     R4,R4,LSL R14           ; ... are not quite as they seem !
        LDR     R14,Log2bpc
        MOV     R4,R4,ASR R14
        LDR     R14,modeflags
        TST     R14,#Flag_HiResMono
        MOVNE   R4,R4,LSL #1            ; 1/2 width in hi-res mono
01
        Push    "R2-R5"
        MOV     R6,sp
;
        MOV     R0,#SpriteReason_PutSpriteScaled     ; plot input into output
        ADD     R0,R0,#&200
        MOV     R2,R11                  ; R2 --> sprite

        LDR     R3,[R2,#spLBit]         ; first bit number used
        RSB     R3,R3,#1                ; remember bits are inclusive
        LDR     R14,[R2,#spRBit]        ; R14 = no of bits used in r.h. word
        ADD     R3,R3,R14
        LDR     R14,[R2,#spWidth]       ; R14 = no of words in the middle + 1
        ADD     R3,R3,R14,LSL #5        ; R3 = total width (bits)
        LDR     R14,save_inlog2bpc
        MOV     R4,R3,LSR R14           ; R4 = width (pixels)
        Debug   pt,"Input sprite width =",R4
        SUB     R6,R6,#4
        BL      mulR4                   ; scale to output pixels
        ADD     R6,R6,#4
        RSBS    R3,R4,#32               ; R3 = x-coordinate to plot sprite at
        MOVLT   R3,#0                   ; keep lhs visible!

        LDR     R4,[R2,#spHeight]
        ADD     R4,R4,#1                ; R4 = input height (pixels)
        BL      mulR4
        Push    "R3,R4"                 ; R4 = height of pointer (pixels)

        MOV     R3,R3,LSL #2            ; sprite is in mode 1 (log2px = 2)
        MOV     R4,R4,LSL #2            ; sprite is in mode 1 (log2py = 2)
        RSB     R4,R4,#32*4             ; make top-left match up

        MOV     R5,#0

        LDR     R14,modeflags

        TEQ     R7,#0                   ; PRM 1-780 zero means no table supplied
        BNE     %FT05
        TST     R14,#Flag_HiResMono
        ADRNE   R7,hiresmonottr         ; use built in table iff R7=0 and in hi-res mono
05
        Debug   pt,"Input sprite address,x,y =",R2,R3,R4
        SWI     XOS_SpriteOp
        Pull    "R10,R11"               ; R10,R11 = xcoord,height
;
        ADD     R14,sp,#4*4             ; skip factor block
        LDMIA   R14,{R0-R3}             ; SwitchOutput back to old parameters
        Debug   pt,"Switching back to",R0,R1,R2,R3
        SWI     XOS_SpriteOp
;
        ADD     R2,sp,#8*4+saExten      ; R2 --> output sprite
        Debug   pt,"Output sprite address =",R2
        LDR     R5,[R2,#spImage]
        ADD     R14,R2,R5               ; R14 --> sprite image
        Debug   pt,"Output sprite image =",R14
        MOV     R5,#0                   ; stick in reason code (= 0)
        Push    "R5,R6,R14"             ; [sp + 8] = sprite ptr
        CMP     R11,#32
        MOVGT   R11,#32
        ADD     R1,sp,#2                ; need correct alignment
        STRB    R11,[R1,#3]
        MOV     R14,#16/2               ; R14 = width (bytes)
        STRB    R14,[R1,#2]
;
        ADD     R14,sp,#3*4 + 8*4 + tempareasize + 3*4
        LDMIA   R14,{R3-R5}             ; shape no, active X, active Y
        AND     R3,R3,#spp_ptrno        ; bottom 4 bits = shape no
        STRB    R3,[R1,#1]
        SUB     R6,R6,#4                ; fool it so x-values used
        BL      mulR4
        ADD     R4,R4,R10               ; allow for sprite origin
        STRB    R4,[R1,#4]
        MOV     R4,R5
        ADD     R6,R6,#4                ; fool it so y-values used
        BL      mulR4
        STRB    R4,[R1,#5]
;
      [ debugpt
        LDMIA   sp,{R3-R5}
        Debug   pt,"OS_Word block =",R3,R4,R5
      ]
        MOV     R0,#&15
        SWI     XOS_Word
        ADD     sp,sp,#3*4 + 8*4 + tempareasize   ; correct stack
99
        LDR     R14,[sp],#4
        STR     R14,spritecode          ; may be needed later
        Pull    "R1-R7,PC"

hiresmonottr    DCB     0,1,3,3         ; translate colour 2 into colour 3
                ALIGN


go_setpalette
        Push    "R1-R5,LR"
;
        Debug   pt,"Input sprite:",#spritecode,R1,R2
        BL      findsprite              ; R2 --> sprite definition
        Debug   pt,"Input sprite address:",R2
        LDRVC   R0,[R2,#spMode]
        MOV     R1, R2
        BLVC    readspritevars          ; get save_inlog2bpp
        Pull    "R1-R5,PC",VS
;
        MOV     R14,#1
        LDR     R5,save_inlog2bpp
        MOV     R5,R14,LSL R5           ; R5 = no of elements in ttr table
;
        MOV     R3,#3                   ; start with colour 3
01
        TEQ     R7,#0                   ; PRM 1-780 zero means no table supplied
        MOVEQ   R4,R3                   ; substitute 1:1 translation
        BEQ     %FT03                   ; got colour
        MOV     R4,#0
02
        LDRB    R14,[R7,R4]
        TEQ     R14,R3                  ; found it?
        BEQ     %FT03
        ADD     R4,R4,#1
        CMP     R4,R5                   ; R5 = no of entries in table
        BCC     %BT02
        B       %FT04                   ; don't bother programming palette
03
        Debug   pt,"Programming palette entry",R4
        MOV     R14,#spPalette+1        ; point at RGB of first flash state
        ADD     R4,R14,R4,LSL #3        ; 8 bytes per palette entry
        LDR     R14,[R2,#spImage]
        CMP     R14,R4                  ; is there a palette entry for this?
        BLE     %FT04
        SWI     XOS_WriteI+19           ; program palette
        MOV     R0,R3
        SWI     XOS_WriteC              ; mouse colour number
        SWI     XOS_WriteI+25           ; program mouse colour
        ADD     R0,R2,R4
        MOV     R1,#3
        SWI     XOS_WriteN              ; R,G,B
04
        SUBS    R3,R3,#1
        BNE     %BT01                   ; forget colour 0
;
        Pull    "R1-R5,PC"

go_setno
        Push    "R1-R3,LR"
;
        MOV     R0,#&6A
        AND     R1,R3,#spp_ptrno        ; pointer shape
        MOV     R2,#0                   ; pointer linked to mouse
        SWI     XOS_Byte
;
        Pull    "R1-R3,PC"


;
; Entry:  R4 = input coordinate (pixels)
;         R6 --> scale factors ([R6,#4] and [R6,#12])
; Exit:   R4 = R4 * R6!4 / R6!12
;

mulR4
        Push    "R5,R11,LR"
;
        LDR     R14,[R6,#1*4]           ; y-magnification
        MUL     R11,R14,R4
        LDR     R5,[R6,#3*4]            ; y-division
        DivRem  R4,R11,R5, R14          ; R4 = output height
;
        Pull    "R5,R11,PC"


;;----------------------------------------------------------------------------
;; PaintChar
;;----------------------------------------------------------------------------

; Entry:  R1 = character code
;         R3,R4 = x,y coordinates
;         R6 --> scale factors

areahdr
        DCD     spriteAreaSize
        DCD     1
        DCD     spriteCB - areaCB
spritehdr
        DCB     "character",0,0,0       ; Note - 12 chars long exactly
        ALIGN

Go_PaintCharScaled
        Push    "R1-R9,LR"
;
        STRB    R1,charblock
        ADRL    R1,charblock
        MOV     R0,#&0A                 ; read character definition
        SWI     XOS_Word
;
        BLVC    readvduvars
        BVS     exitchar
;
; contruct a sprite header in module workspace
;
        MOV     R10, #0
        MOV     R11, #7                 ; Mode 0 sprite starting uses bits 0-7
;
        ADR     R14,areahdr             ; 3 words for area header,
        LDMIA   R14,{R1-R3,R6-R8}       ; and 3 for sprite name
        MOV     R5,#spriteSize+4*8*2    ; R5 = 44 + 2*8 rows of 1 word
        ADD     R4,R5,#spriteCB-areaCB  ; R4 = saFree
        ADR     R14,areaCB
        Debug   ch,"areaCB = &",R14
        STMIA   R14!,{R1-R3,R4,R5,R6-R8,R10}    ; up to spWidth
        MOV     R8,#7                   ; R8 = spHeight (no of rows - 1)
        MOV     R9,#0                   ; R9 = spLbit
        STMIA   R14!,{R8,R9,R11}        ; R11 = spRbit
        MOV     R8,#spriteSize
        ADD     R9,R8,#4*8              ; R9 = R8 + 8 rows of 1 word
        MOV     R11, #0                 ; mode 0 sprite
        STMIA   R14!,{R8,R9,R11}        ; R14 --> sprite pixels
        SUB     R7,R9,R8
        ADD     R7,R14,R7               ; R7 --> sprite mask
;
; now construct a sprite mask from the character definition
;
        ADRL    R10, charblock+1
        MOV     R5, #8
01
        LDRB    R9, [R10], #1
        MOV     R8, R9, LSR #7
        TST     R9, #&40
        ORRNE   R8, R8, #&02
        TST     R9, #&20
        ORRNE   R8, R8, #&04
        TST     R9, #&10
        ORRNE   R8, R8, #&08
        TST     R9, #&08
        ORRNE   R8, R8, #&10
        TST     R9, #&04
        ORRNE   R8, R8, #&20
        TST     R9, #&02
        ORRNE   R8, R8, #&40
        TST     R9, #&01
        ORRNE   R8, R8, #&80
        STR     R8, [R7], #4
        SUBS    R5, R5, #1
        BNE     %BT01
;
; now set up the parameters for a scaled mask plot
;
        MOV     R14,#VduDriverWorkSpace + FgEcfOraEor
        STR     R14,save_ecflimit       ; char painting uses fg ecf pattern
;
        ADR     R1,areaCB
        ADD     R2,R1,#spriteCB-areaCB
        ADD     R14,R13,#2*4            ; salvage params from stack
        LDMIA   R14,{R3-R7}
;
        MOV     R0,#&200                ; indicates that R2 --> sprite defn
        ADD     R0,R0,#SpriteReason_PlotMaskScaled
;
        LDR     R14,spritecode
        Push    "R14"
        STR     R0,spritecode
        MOV     r0, #SpriteReason_PaintCharScaled
        BL      Go_PlotMaskScaled
        Pull    "R14"
        STR     R14,spritecode

exitchar
        Pull    "R1-R9,PC"

;
; Read Vdu Variables
; also process the ones that the OS doesn't always provide
;

vduinputbuffer
        DCD     VduExt_XEigFactor               ; log2 pixels per unit (x)
        DCD     VduExt_YEigFactor               ; log2 pixels per unit (y)
        DCD     VduExt_Log2BPP                  ; for no. of colours
        DCD     VduExt_Log2BPC                  ; for double-pixel modes

        DCD     VduExt_OrgX
        DCD     VduExt_OrgY
        DCD     VduExt_GWLCol                   ; graphics window
        DCD     VduExt_GWBRow
        DCD     VduExt_GWRCol
        DCD     VduExt_GWTRow

        DCD     VduExt_LineLength
        DCD     VduExt_ScreenStart
        DCD     VduExt_YWindLimit

        DCD     VduExt_ModeFlags                ; for hi-res mono checking

        DCD     -1

readvduvars
        Push    "R0-R4,LR"
 ;
; read real vdu variables (mode is only required for PaintChar)
;
        ADR     R0,vduinputbuffer
        ADR     R1,vduoutputbuffer
        SWI     XOS_ReadVduVariables
        BVS     %FT99
;
        MOV     R0,#1
        LDR     R14,Log2bpc
        MOV     R14,R0,ASL R14
        STR     R14,BPC                 ; bpc = 2^log2bpc
        LDR     R14,Log2bpp
        MOV     R14,R0,ASL R14
        STR     R14,BPP                 ; bpp = 2^log2bpp
;
        LDR     R14,ywindlimit
        TEQ     R14,#0                  ; impossible!
        MOVEQ   R14,#1024               ; bodge for old OS versions
        LDREQ   R0,log2py               ; (goes wrong in mode 22)
        MOVEQ   R14,R14,ASR R0
        SUBEQ   R14,R14,#1
        STREQ   R14,ywindlimit
;
        Debug   sc,"ScreenStart,YWindLimit,LineLength,bpc =",#screenstart,#ywindlimit,#linelength,#BPC
99
        STRVS   R0,[R13]
        Pull    "R0-R4,PC"

;
; read mode-specific info for mode (R0)
;

readspritevars

        ; NB saved registers extended to include R3 purely for jpeg.
        ; R0=the sprite's mode word
        ; R1->the sprite
        Push    "R1-R3,LR"

      [ jpeg
      [ {TRUE}

        ; look for a JPEG sprite, and if you find it lie about these dimensions.
        LDR     R2,[R1,#spImage]        ; get offset to image data
        ADD     R2,R2,R1                ; get address of image data
        ADD     R2,R2,#4                ; skip past compression ID word

;        LDRB    R3,[R2,#6]              ; get 6th byte
;        CMP     R3,#'J'                 ; give me a J?
;        BNE     rsv_not_jpeg_file
;        LDRB    R3,[R2,#7]              ; if so, get 7th byte
;        CMP     R3,#'F'                 ; give me a F?
;        LDREQB  R3,[R2,#8]              ; if so, get 8th byte
;        CMPEQ   R3,#'I'                 ; give me a I?
;        LDREQB  R3,[R2,#9]              ; if so, get 9th byte
;        CMPEQ   R3,#'F'                 ; give me a F?
;        BNE     rsv_not_jpeg_file       ; what does that spell?
; This test is watered down a bit, to allow slightly more deviant files
; (eg. the ones that Tony Sumner finds on the net). Anything really wrong will
; still get caught later on in the C code. Still, note this increases (slightly)
; the risk that an innocent normal sprite will get accused of being JPEG.
; Alternative test:
        LDRB    R3,[R2]                 ; load first byte
        CMP     R3,#&ff                 ; is it ff?
        LDREQB  R3,[R2,#1]              ; load second byte
        CMPEQ   R3,#&d8                 ; is it d8?
        LDREQB  R3,[R2,#2]              ; load third byte
        CMPEQ   R3,#&ff                 ; is it ff?
        BNE     rsv_not_jpeg_file

        ; We have found a JPEG file - pretend it's a 32bpp sprite.
        Debug   in,"It's a JPEG file"
        LDR     R3,spritecode           ; check we're doing a PutSpriteScaled
        AND     R3,R3,#255              ; mask out to get op code
        CMP     R3,#SpriteReason_PutSpriteScaled
        Pull    "R1-R3,LR",NE           ; if not, discard stuff from readspritevars
        Pull    "R0-R12,PC",NE          ; and exit doing nothing.
                                        ; >>>> should produce an error return here.

        MOV     R3,#5                   ; log2 of 32
        STR     R3,save_inlog2bpc
        STR     R3,save_inlog2bpp
        MOV     R3,#32                  ; bits per pixel
        STR     R3,save_inbpp
        MOV     R3,#1                   ; log2 of 2 OS-units
        STR     R3,inlog2px             ; pretend to be VGA-size pixels
        STR     R3,inlog2py             ; pretend to be VGA-size pixels
        STR     R3,is_it_jpeg           ; mark as a JPEG sprite
        STR     R0,inmode               ; the mode vars are correct for mode 20 (old format) or new format compressed sprites.
        STR     R1,save_sprite          ; so that later code can find the JPEG data again
        Pull    "R1-R3,PC"
      ;  Pull    "R1-R3,LR"
      ;  B       jpeg_scan               ; initialise for this JPEG file, using R2.
rsv_not_jpeg_file
        ; if the last sprite was jpeg but this one is not then we MUST reload the sprite variables.
        LDR     R3,is_it_jpeg           ; was the last one JPEG? 0 -> not JPEG
        CMP     R3,#0
        MOVNE   R3,#0                   ; if the previous one was JPEG
        STRNE   R3,is_it_jpeg           ;   mark as not a JPEG sprite this time
        MOVNE   R14,#-1                 ;   force reload of sprite mode vars
        LDREQ   R14,inmode              ; else, vars reflect this sprite's mode
      |
        MOV     R14,#0                  ; jpeg stuff outside jpeg condition? stupid? (GPS)
        STR     R14,is_it_jpeg          ; ditto
        LDR     R14,inmode              ; check for sprite vars already right
      ]
      ]
;
        TEQ     R0,R14
        Pull    "R1-R3,PC",EQ           ; already have these variables!
        STR     R0,inmode
;
        MOV     R1,#VduExt_Log2BPC
        SWI     XOS_ReadModeVariable
        SETV    CS

        STRVC   R2,save_inlog2bpc       ; input log2(bytes per char)
        MOVVC   R1,#VduExt_Log2BPP
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,save_inlog2bpp       ; input log2(bits per pixel)
        MOVVC   R1,#VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,inlog2px
        MOVVC   R1,#VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,inlog2py
        Pull    "R1-R3,PC",VS
;
        MOV     R14,#1
        LDR     R1,save_inlog2bpp
        MOV     R14,R14,ASL R1
        STR     R14,save_inbpp
;
        Debug   in,"Input log2bpc/p, bpp = ",#save_inlog2bpc,#save_inlog2bpp,#save_inbpp
;
        Pull    "R1-R3,PC"

;
; Find sprite address given areaCBptr/name
; Entry:  [spritecode] = reason code (including bits above bit 7)
;         R1 = areaCBptr
;         R2 --> sprite name
; Exit:   R2 --> sprite definition
;

findsprite
        Push    "LR"
        LDR     R0,spritecode
        BL      getspritename
        BLVC    getspriteaddr
        Pull    "PC"

; Entry:  R0 = original sprite code

getspritename
        Push    "R0-R1,R3-R4,LR"
;
        BICS    R14,R0,#&FF             ; R0 < 256 ==> system sprite (can't!)
        TEQ     R14,#&200               ; R2 --> sprite already
        STREQ   R2,spritename           ; if so, 1st word is sprite addr
        BEQ     %FT99
;
        ADRL    R3,spritename
        ADD     R4,R3,#12
01
        LDRB    R0,[R2],#1
        CMP     R0,#32+1                ; ignore <space> too!
        BCC     %FT02
        CMP     R0,#"A"
        RSBCSS  R14,R0,#"Z"
        ORRCS   R0,R0,#&20              ; force lower-case
        STRB    R0,[R3],#1
        CMP     R3,R4                   ; terminate after 12 characters
        BCC     %BT01
02
        MOV     R0,#0
03
        CMP     R3,R4                   ; pad with nulls
        STRCCB  R0,[R3],#1
        BCC     %BT03
99
        STRVS   R0,[R13]
        Pull    "R0-R1,R3-R4,PC"
        MakeSpriteErrorBlock NoWorkSpace,,NoWork

;
; scan the sprite list to find the address
;

getspriteaddr
        Push    "R1,R3-R9,LR"
;
        BICS    R14,R0,#&FF             ; R0 < 256 ==> system sprite (can't!)
        BNE     %FT00
;
        MOV     R0,#3
        SWI     XOS_ReadDynamicArea
        TEQ     R1,#0
        ADREQ   R0, ErrorBlock_NoWorkSpace   ; can't do anything with this!
        addr    r1, Title, EQ
        BLEQ    copy_error_one          ; Always sets the V bit
        BVS     %FT99
;
        MOV     R1,R0                   ; R1 -> system sprite area
        STR     R1,[sp]                 ; return for AppendSprite
00
        TEQ     R14,#&200               ; R2 --> sprite already
        BEQ     %FT99
;
        ADRL    R14,spritename
        LDMIA   R14,{R3,R4,R5}
;
        LDR     R14,[R1,#saFree]
        ADD     R9,R1,R14               ; R9 --> free area
        LDR     R14,[R1,#saFirst]
        ADD     R2,R1,R14               ; R2 --> first sprite
04
        CMP     R2,R9
      [ debuger
        BCC     %FT01
        ADR     R14,spritename
        DebugS  er,"Sprite doesn't exist ",R14
01
      ]

        BLCS    get_sprite_doesnt_exist_error  ; r0-> error block, V set
        BVS     %FT99
;
        LDMIA   R2,{R1,R6,R7,R8}       ; get link plus name
        TEQ     R6,R3
        TEQEQ   R7,R4
        TEQEQ   R8,R5
        ADDNE   R2,R2,R1
        BNE     %BT04
99
        Pull    "R1,R3-R9,PC"

; makepalette16bpp
; convert palette to 16bpp for output to 16bpp mode plotting directly from palette
; if this is not done, the spriteextend blitter will run out of registers!
makepalette16bpp
   [ debuggs
        Push    "R1-R7,LR"
        LDR     r7, sprite_doesnt_exist_error
        Debug   gs, "converting palette..."
   |
        Push    "R1-R6,LR"
   ]
        LDR     r1, save_inbpp
        MOV     r2, #1
        MOV     r1, r2, LSL r1        ; number of entries in palette
        Debug   gs, "going to do this many entries = ",R1
        LDR     r2, trns_palette      ; pointer to palette data
        ADRL    r3, newtranstable     ; where to store altered palette
        STR     r3, trns_palette      ; where to store altered palette
01
        LDR     r4, [r2], #8
        MOV     r4, r4, LSR #8                ; BBGGRR00 to 00BBGGRR
                                              ; r4 = in2, r5 = im1, r6 = ttr
                                              ;       fedcba9876543210 fedcba9876543210
                                              ; in2 = 00000000bbbbbbbb ggggggggrrrrrrrr
        AND     r5,r4,#&F80000                ; im1 = 00000000bbbbb000 0000000000000000
        MOV     r6,r5,LSL #7                  ; ttr = 0bbbbb0000000000
        AND     r5,r4,#&F800                  ; im1 = 0000000000000000 ggggg00000000000
        ORR     r6,r6,r5,LSL #10              ; ttr = 0bbbbbggggg00000
        AND     r5,r4,#&F8                    ; im1 = 0000000000000000 00000000rrrrr000
        ORR     r4,r6,r5,LSL #13              ; in2 = 0bbbbbgggggrrrrr
    ; NB result in top half of register
    ; Needs two work registers
        MOV     r4, r4, LSR #16
        Debug   gs, "gonna store thingy at thingy",R4,R3
        STR     r4, [R3],#4
        SUBS    r1, r1, #1
        Debug   gs, "R1 now ",R1
        BNE     %BT01
   [ debuggs
        ; check workspace word at end of 'newtranstable' space to confirm we haven't walked off the edge
        LDR     r6, sprite_doesnt_exist_error
        Debug   gs, "converted palette...check words are ",R6, R7
        Pull    "R1-R7,PC"
   |
        Pull    "R1-R6,PC"
   ]

;
; PutSpriteScaled
; Entry:  [spritecode] = reason code
;         R1 --> areaCBptr
;         R2 --> sprite name
;         R3,R4 = coords
;         R5 = gcol action (0 ==> no mask, 1 ==> use mask)
;         R6,R7 = x,y scaling (pixels per pixel)
;

        MakeInternatErrorBlock DivZero
diverror
        ADR     R0, ErrorBlock_DivZero
        addr    r1, Title
        BL      copy_error_one          ; Always sets the V bit

exitbiggie
        Pull    "R1-R9,PC"

; *****************************************************************************
Go_PutSpriteGreyScaled
        Push    "LR"
        SETV
        ADR     R0, ErrorBlock_NoGrScl
        BL      copy_error_one
        Pull    "PC"

        MakeSpriteErrorBlock NoGrScl

; *****************************************************************************
Go_PlotMaskScaled
        Push    "R1-R9,LR"
;        Push    "R0-R9,LR"              ; R0 pulled just below
;       MOV     r2,r0
;       Debug   gs,"Plot Mask Scaled"
;        ; Get the graphics background plot colour - temporarily uses R1,R2,R3
;        ADR     R0,getbgcolour
;        ADR     R1,bgcolour
;        SWI     XOS_ReadVduVariables
;
;; find current background plotting action
;       CMP     r2, #SpriteReason_PaintCharScaled
;        ADREQ   R0,getfgaction
;        ADRNE   R0,getbgaction
;        ADR     R1,bgcolour
;        SWI     XOS_ReadVduVariables
;       LDR     r5, bgcolour
;       ORR     r5, r5, #8                  ; avoid masko being knackered later
;;      Debug   gs, "Plot action is ",R5
;;
;       AND     r2, r2, #255
;       CMP     r2, #SpriteReason_PaintCharScaled
;       MOVEQ   r0, #&80
;       MOVNE   r0, #&90
;       ADRL    r1, ecfspace
;        SWI     XOS_SetColour
;;      Debug   gs, "setcolour returned, r0, r1=",r0,r1
;;;        LDR     r0, [r1]
;;;        Debug   gs, "ecfpattern1 =",r0
;;;        LDR     r0, [r1,#4]
;;;        Debug   gs, "ecfpattern2 =",r0
;        ANDS    r0, r0, #&20            ; is it a pattern block
;;;        CMP     r0, #0
;       STRNE   r1, save_ecflimit
;;;        STRNE   r1, save_ecfptr
;        MOVNE   r1, #-1
;;        MOV   r1, #-1
;        STR     r1, bgcolour
;
;        Pull    "R0"                    ; pull temporary workspace
;        LDMIA   sp,{R1,R2}              ; restore values of R1,R2
;        BVS     exitbiggie

        MOV     R5,#8                   ; avoid masko being knackered later
        MOV     R7,#0                   ; no pixel translation
        MOV     R8,#0                   ; no calibration table
        B       %FT01

getbgaction
        DCD     VduExt_GPLBMD
        DCD     -1

getfgaction
        DCD     VduExt_GPLFMD
        DCD     -1

getbgcolour
        DCD     VduExt_GBCOL
        DCD     -1

        MakeSpriteErrorBlock BadTranslation,,BadTran

; *****************************************************************************

Go_PutSpriteScaled
        Push    "R1-R9,LR"
        MOV     R8,#0                   ; no printer calibration table
01
        Debug   in,"Draw sprite: R0,R1,R2 =",R0,R1,R2
        Debug   in,"Coords, gcol, &scale, &ttr =",R3,R4,R5,R6,R7
        Debug   in,"Calibration table =",R8

;
        CLRPSR  I_bit, R14              ; re-enable interrupts
        [       flagbit
        MOV     R14, R5, LSR #4
        STR     R14, trns_flags2         ; store flags
        [ widetrans
        Debug   gs,"flags are ",R14
        BICS    R14, R14, #flg2_ignorettr + flg2_widetrans + flg2_ditheron
        |
        BICS    R14, R14, #flg2_ignorettr + flg2_ditheron
        ]
        Debug   gs,"flags are ",R14
        ADRNEL  R0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one          ; Always sets the V bit
        BVS     exitbiggie
        ]
        AND     R5,R5,#&0F              ; only bottom 4 bits are interesting

        [       ccompiler
        STR     R8,calibration_table
        ]

;
; Check to see if truecolour sprites should be dithered
;
        [       flagbit
        LDR     r0, trns_flags2
        TST     r0, #flg2_ditheron
        MOVEQ   r0, #0
        MOVNE   r0, #1
        STR     r0, dither_truecolour
        ]
;
; see if reason code indicated a sprite name or sprite pointer in R2
;

        BL      findsprite              ; R2 --> sprite

        MOVVC   R1,R2                   ; now R1 --> sprite

; read input/output mode variables

        BLVC    readvduvars
        LDRVC   R0,[r1,#spMode]
        BLVC    readspritevars
        BVS     exitbiggie
        Debug   cc,"read sprite vars",R1

putsprscaled_frompjs
        LDR     R0,[R1,#spMode]         ; get sprite's original mode
        STR     R0,save_spr_type
;
; read scaling factors (set up default if necessary)
;
        CMP     R6,#0
        LDMNEIA R6,{R8-R11}
        BNE     %FT01
; Old source tries to rig scale factors which is opposed to
; what the PRM says.... Therefore I have changed it. (GPS)
;        MOV     R0,#1
;        LDR     R8,inlog2px
;        MOV     R8,R0,LSL R8
;        Debug   gs,"r8:",r8
;        LDR     R9,inlog2py
;        MOV     R9,R0,LSL R9
;        Debug   gs,"r9:",r9
;        LDR     R10,log2px
;        MOV     R10,R0,LSL R10
;        Debug   gs,"r10:",r10
;        LDR     R11,log2py
;        MOV     R11,R0,LSL R11
;        Debug   gs,"r11:",r11
        MOV     R8, #1
        MOV     R9, #1
        MOV     R10, #1
        MOV     R11, #1
01

;      [ jpeg
;        ; If jpeg we lie from here on, claiming there are twice as many pixels in the x direction
;        ; as the sprite contains, in case we want to do interpolation.
;        LDR     R14,is_it_jpeg               ; 1 -> JPEG sprite
;        CMP     R14,#0
;        MOVNE   R10,R10,LSL #1               ; if JPEG, double xdiv and so halve the scale factor
;      ]
;let's try to rationalise the scale factors...
; *************************************************
; ***  DivRem - Integer division and remainder  ***
; ***  rc := ra DIV rb; ra := ra REM rb         ***
; ***  rb preserved, rtemp corrupt              ***
; ***  DivRem   rc, ra, rb, rtemp               ***
; *************************************************
        Push    "R5-R7"
        MOV     R5, R8
        DivRem  R7, R5, R10, R6
        CMP     R5, #0
        MOVEQ   R8, R7
        MOVEQ   R10, #1
        MOV     R5, R9
        DivRem  R7, R5, R11, R6
        CMP     R5, #0
        MOVEQ   R9, R7
        MOVEQ   R11, #1
        Pull    "R5-R7"

        STR     R8,save_xmag
        STR     R9,save_ymag
        STR     R10,save_xdiv
        STR     R11,save_ydiv
        Debug   in,"x mag/div, y mag/div:",r8,r9,r10,r11

        [ ignore_ttr
;
; check for a ttr. If it's present and the sprite has a full entry palette set up to
; use that instead.
;
        MOV     R14, #0
        STR     R14, trns_palette

        LDR     R14,[R1,#spImage]
        CMP     R14,#SpriteCBsize
        BEQ     has_no_palette

        LDR     R0,[R1,#spTrans]
        CMP     R0,#SpriteCBsize
        BEQ     has_no_palette

        ;validate it (to exclude 8bpp without full palettes)
        ;test is that palette size should be 8*ncolours

        ;find the lower of the sprite start and mask start
        CMP     R14,R0
        MOVCS   R14,R0
        SUB     R14,R14,#SpriteCBsize

        MOV     R14,R14,LSR #3 ;divide by 8 for number of palette entries
        MOV     R0,#1
        LDR     R9,save_inbpp
        MOV     R0,R0,ASL R9

        CMP     R0,R14
        BNE     has_no_palette

        [       flagbit
        LDR     R14, trns_flags2
        Debug   gs,"Checking ttr flag", R14
        TST     R14, #flg2_ignorettr

;        B       has_no_palette   ;19th April 1994 remove 8bpp behaviour
        BEQ       has_no_palette   ;use ttr and ignore any palette

;        BNE     %FT01
;        [       med01867
;        CMP     R9, #8
;        BNE     has_no_palette ;restrict it to 8bpp full palette only
;        ]
01
        |
;        [       med01867
;        CMP     R9, #8
;        BNE     has_no_palette ;restrict it to 8bpp full palette only
;        ]
        Debug   gs,"ttr flag is not set"
        B       has_no_palette
        ]
        Debug   gs, "We're going to plot from palette"
        LDR     R14,[R1,#spTrans]
        ADD     R14,R1,#SpriteCBsize
        STR     R14, trns_palette
        LDR     R14, BPP
        CMP     R14, #16
        MOVEQ   r7, #0                   ; junk any translation table we were given to stop checktrans overwriting 16bpp palette
        BLEQ    makepalette16bpp
has_no_palette
       ]

;
; validate supplied translation table (if any)
;
        Debug   cc,"about to check trans table",R1
        CMP     R7,#0                    ; 0 ==> no translation
        BLNE    checktrans
        BVS     exitbiggie
        Debug   cc,"trans table is OK",R1
        [ ignore_ttr
; if doing a sprite of <16bpp to >8bpp, and it has a palette, change the ttr pointer
; to point at the palette data instead of the ttr data. Note that the two are different
; formats, so there is also a different plotting routine to include too...

        LDR     R14, BPP                               ; output bpp
        CMP     R14, #16
        MOVCC   R14, #0
        STRCC   R14, trns_palette
        BCC     %FT45
        LDR     R14, save_inbpp
        CMP     R14, #16
        MOVCS   R14, #0
        STRCS   R14, trns_palette
        BCS     %FT45
        LDR     R14, trns_palette
        TEQ     R14, #0
        MOVNE   R7,R14
        MOVEQ   R14,#0
        STREQ   R14, trns_palette ;only non-zero if going to use this

; trns_palette doubles as a pointer to the palette up this far, and then becomes a
; compilation flag for the macro generation (with the value being passed in as the
; ttr address)

45
        ]
;

        STR     R7,ColourTTR
        CMP     R7,#0
        BNE     notrans
;
        LDRB    R14,spritecode          ; R14 = bottom 8 bits of reason code
        TEQ     R14,#SpriteReason_PlotMaskScaled
      [ jpeg
;        TEQNE   R14,#SpriteReason_PutJPEGScaled    ; null table OK for this call
        LDRNE   R14,is_it_jpeg
        CMPNE   R14,#1
        Debug   gs,"1. is it JPEG?",R0
      ]
        LDRNE   R14,save_inbpp
        LDRNE   R0,BPP
        TEQNE   R14,R0                  ; OK if same bpp or mask plotting

        ;however, don't error if going 16>32 or 32>16
        BEQ     notrans ;dispose of the equal case

        CMP     R0,#16
        CMPEQ   R14,#32
        BEQ     notrans

        CMP     R0,#32
        CMPEQ   R14,#16
        BEQ     notrans
errtrans
        ADRL    R0,ErrorBlock_BadTranslation   ; different bpp ==> must have table
errexitscaled
        addr    r1, Title
        BL      copy_error_one          ; Always set the V bit
        Debug   gs,"error from trans table"
        BVS     exitbiggie
notrans
        Debug   gs,"Checked out trans table palette"
;
; try to optimise by using existing sprite plot code
; can only be done if bpp equal, no trans, no scaling and output not to sprite
;
      [ debug
        TEQ     R7,#0
        LDREQ   R14,save_inbpp
        LDREQ   R0,BPP
        TEQEQ   R14,R0                  ; if same bpp, try to optimise

        LDREQ   R14,vduspritename
        TEQEQ   R14,#0
        LDR     R6,save_xmag            ; load always!
        LDR     R7,save_ymag            ; load always!
        LDREQ   R8,save_xdiv
        LDREQ   R9,save_ydiv
        TEQEQ   R6,R8
        TEQEQ   R7,R9
        BNE     %FT87
87
      |
        TEQ     R7,#0
        LDREQ   R14,save_inbpp
        ANDS    R7, R14, #48            ; If we're dealing with deep sprites then the kernel is slower!!!
        LDREQ   R0,BPP
        TEQEQ   R14,R0                  ; if same bpp, try to optimise
;
        LDREQ   R14,vduspritename
        TEQEQ   R14,#0
        LDR     R6,save_xmag            ; load always!
        LDR     R7,save_ymag            ; load always!
        LDREQ   R8,save_xdiv
        LDREQ   R9,save_ydiv
        TEQEQ   R6,R8
        TEQEQ   R7,R9
        BNE     cantdoinOS

      [ jpeg
        LDREQ   R0,is_it_jpeg
        TEQEQ   R0,#0
        Debug   gs,"is it JPEG?",R0
        BNE     cantdoinOS
      ]
;
; if all parameters are ineffective, call the OS routine!
;
        LDR     R0,spritecode
        AND     R14,R0,#&FF             ; R14 = reason code only
        BIC     R0,R0,#&FF              ; R0 = code except for reason code
        TEQ     R14,#SpriteReason_PutSpriteScaled
        ORREQ   R0,R0,#SpriteReason_PutSpriteUserCoords
        BEQ     %FT01
        TEQ     R14,#SpriteReason_PlotMaskScaled
        ORREQ   R0,R0,#SpriteReason_PlotMaskUserCoords
        LDREQ   R14,save_ecflimit       ; is this background plotting?
        TEQEQ   R14,#VduDriverWorkSpace + BgEcfOraEor
        BNE     cantdoinOS
01
        LDMIA   R13,{R1,R2}             ; get original R1,R2
        Debug   gs,"doing it in OS"
        BL      Go_SpriteOp             ; call the OS version if there is one
        Pull    "R1-R9,PC"
cantdoinOS
      ]
        Debug   gs,"we can't do it in OS"
;
; convert coords to internal pixels
; R6,R7 = x,y magnification
;
        LDR     R14,orgx
        ADD     R3,R3,R14
        LDR     R14,log2px
        MOV     R3,R3,ASR R14
        LDR     R14,orgy
        ADD     R4,R4,R14
        LDR     R14,log2py
        MOV     R4,R4,ASR R14           ; convert to internal form
;
; bodge x-coords (inc. graphics window) so we can forget double-pixels
;
        LDR     R14,Log2bpc
        LDR     R0,Log2bpp
        SUBS    R14,R14,R0
        MOVNE   R3,R3,LSL R14
        LDRNE   R0,gwx0
        MOVNE   R0,R0,LSL R14
        STRNE   R0,gwx0
        LDRNE   R0,gwx1
        ADDNE   R0,R0,#1                ; make exclusive
        MOVNE   R0,R0,LSL R14
        SUBNE   R0,R0,#1                ; make inclusive again
        STRNE   R0,gwx1
;
; bodge x multiplier and divisor
;
        MOVNE   R6,R6,LSL R14
        STRNE   R6,save_xmag
;
        LDR     R14,save_inlog2bpc
        LDR     R0,save_inlog2bpp
        SUBS    R14,R14,R0
        LDRNE   R0,save_xdiv
        MOVNE   R0,R0,LSL R14
        STRNE   R0,save_xdiv
;
; R8, [save_ysize] <-- size of sprite in pixels (NOT double-pixels)
;
        LDR     R11,save_inlog2bpp      ; R11 = log2 ( bpp )
;
        LDR     R0,[R1,#spLBit]
        Debug   gs, "spLBit is ? = ",R0
        LDR     R2,[R1,#spRBit]
        Debug   gs, "spRbit is ? = ",R2
        SUB     R2,R2,R0
        ADD     R2,R2,#1                ; make inclusive
        Debug   gs, "R2 is ? = ",R2
        LDR     R0,[R1,#spWidth]
        Debug   gs, "Spwidth = ",R0
        ADD     R8,R2,R0,ASL #5         ; 32 bits per word
        Debug   gs, "R8 = ",R8
      [ jpeg
        ; >>> old-format (ie pilot development) JPEG files are mode 20 sprites, with JPEG data.
        ; For such a sprite the 'width' is quoted as if log2bpp were 2, ie 4bpp sprites,
        ; so that Draw gets the right width for the sprite. But this means we must shift
        ; right by 2 rather than by r11, which will be 5.
        Debug   gs, "X-size 1 = ",R8
        LDR     R14,is_it_jpeg
        CMP     R14,#0
        MOVEQ   R8,R8,ASR R11
        BEQ     %FT01
        ; It's JPEG - check for mode 20 or other.
        LDR     R14,inmode
        CMP     R14,#20
        MOVEQ   R8,R8,ASR #2            ; temp format - ASR by 2
        MOVNE   R8,R8,ASR R11           ; kosher new Medusa Sprite format - ASR by 5
        Debug   gs, "X-size 2 = ",R8
        ; >>>> This option can be thrown away when we're sure that pilot-format JPEG files
        ;      don't exist any more.

;        ; Finally, JPEG files claim to have twice as many pixels as they actually do.
;        ; This is in case we want to do interpolation in the X direction on scaling up.
;        MOV     R8,R8,LSL #1            ; R8 = no of pixels
1
      |
        MOV     R8,R8,ASR R11           ; R8 = no of pixels
      ]
        STR     R8,save_inputxsize
;
        Debug   gs, "X-size 3 = ",R8
        LDR     R14,[R1,#spHeight]
        ADD     R14,R14,#1
        STR     R14,save_inputysize
;
;
; do x-clipping
; Entry:  R6 = x-magnification
;         R8 = input x-size
; Exit:   R9 = xleft
;         [save_xcoord] = start x-coord on screen
;         [save_xcount] = initial xcount
;         [save_xsize] = output x-size
;
        Debug   cc,"Do x-clipping",r6,r8

        LDR     R14,gwx0
        SUBS    R9,R14,R3
        MOVLT   R9,#0                   ; R9 = no of pixels to skip on left
        ADD     R14,R3,R9
        STR     R14,save_xcoord
;
        MUL     R2,R8,R6                ; R2 = x-size * x-mag
        LDR     R0,save_xdiv            ; R0 = x-div
        TEQ     R0,#0
        BEQ     diverror
        DivRem  R8,R2,R0, R14           ; R8 = no of output pixels
        LDR     R14,gwx1
        ADD     R14,R14,#1
        SUB     R14,R14,R3
        CMP     R8,R14                  ; clip on right
        MOVGT   R8,R14
        SUBS    R8,R8,R9                ; R8 = number of output pixels
        BLE     exitbiggie              ; none of sprite is visible
        STR     R8,save_xsize
;
        LDR     R14,save_xdiv
        MUL     R10,R9,R14              ; R10 = initial count
        TEQ     R6,#0
        BEQ     diverror
        DivRem  R9,R10,R6, R14          ; R9 = initial INPUT pixel coord
        RSB     R10,R10,R6              ; R10 = amount of 1st input pixel left
        STR     R10,save_xcount
;
        Debug   in,"xcoord,xleft,xcount,xsize =",#save_xcoord,R9,#save_xcount,#save_xsize
;
; do y-clipping
; Entry:  [save_inputysize] = input y-size
; Exit:   R10 = ybot
;         [save_ycoord] = start y-coord on screen
;         [save_ycount] = initial y-counter
;         [save_ysize] = output y-size
;
        Debug   cc,"Do y-clipping",r10
        LDR     R14,gwy0
        SUBS    R10,R14,R4
        MOVLT   R10,#0                  ; R10 = no of pixels to skip at bottom
        ADD     R14,R4,R10
        STR     R14,save_ycoord
;
        LDR     R8,save_inputysize
        MUL     R2,R8,R7                ; R2 = y-size * ymag
        LDR     R0,save_ydiv
        TEQ     R0,#0
        BEQ     diverror
        DivRem  R8,R2,R0, R14           ; R8 = no of output pixels
        LDR     R14,gwy1
        ADD     R14,R14,#1
        SUB     R14,R14,R4
        CMP     R8,R14
        MOVGT   R8,R14
        SUBS    R8,R8,R10               ; number of output pixels
        BLE     exitbiggie
        STR     R8,save_ysize
;
        LDR     R14,save_ydiv
        MUL     R8,R10,R14              ; R8 = initial count
        TEQ     R7,#0
        BEQ     diverror
        DivRem  R10,R8,R7, R14          ; R10 = initial INPUT pixel y-coord
        RSB     R8,R8,R7                ; R8 = amount of first input pixel left
        STR     R8,save_ycount
;
        Debug   in,"ycoord,ybot,ycount,ysize =",#save_ycoord,R10,#save_ycount,#save_ysize
;
; update ChangedBox coords (if enabled)
; Entry:  [save_xcoord],[save_ycoord],[save_xsize],[save_ysize] set up
;
        LDR     R14,changedbox          ; read in initialisation routine
        LDR     R0,[R14],#4
        TST     R0,#1                   ; enabled?
        BEQ     %FT01
;
        Push    "R3-R10"
        LDR     R3,save_xcoord          ; coordinate after clipping
        LDR     R4,save_ycoord          ; ditto
        LDR     R5,save_xsize           ; size in output pixels
        LDR     R6,save_ysize           ; ditto
        LDR     R7,Log2bpc
        LDR     R8,Log2bpp
        SUBS    R7,R7,R8
        MOVNE   R3,R3,ASR R7            ; unbodge double-pixel stuff
        MOVNE   R5,R5,ASR R7
        ADD     R5,R3,R5
        ADD     R6,R4,R6
        SUB     R5,R5,#1                ; make inclusive
        SUB     R6,R6,#1
        LDMIA   R14,{R7-R10}            ; original box
        CMP     R7,R3
        MOVGT   R7,R3
        CMP     R8,R4
        MOVGT   R8,R4
        CMP     R9,R5
        MOVLT   R9,R5
        CMP     R10,R6
        MOVLT   R10,R6
        STMIA   R14,{R7-R10}            ; new box
        Pull    "R3-R10"
01
;
; get input address and shift
; Entry:  R9,R10 = initial input pixel coord (within sprite)
;         R11 = input log2bpp
; Exit:   [save_inptr] --> first input word
;         [save_inshift] = initial bit position
;         [save_inoffset] = length of 1 sprite row (bytes)
;         [save_masko] = offset from image to mask (0 ==> none)
;         [save_maskinshift] = initial mask bit position
;         [save_maskinptr] => first mask word
;         [save_maskinoffset] = length of 1 mask row (bytes)
;

; for a JPEG sprite we'll need the actual coordinates, not the computed
; address, for the input data.
      [ jpeg
        Debug   cc,"input coords",R9,R10
        STR     R9,in_x
        STR     R10,in_y
      ]

; set up things for 1bpp masks too - we decide later whether to use it

        AND     R14,R9,#31              ; mask is 1bpp, and there's no lh wastage
                                        ; so this is a lot simpler!
        STR     R14,save_maskinshift    ; save the inshift value for later

        Push    "R9"                    ; save unadjusted R9 for later

        LDR     R14,[R1,#spLBit]
        ADD     R9,R14,R9,LSL R11       ; R9 = initial bit position
        AND     R14,R9,#31
        STR     R14,save_inshift
;
        LDR     R14,[R1,#spImage]
        [ debuggs
        MOV     R0, R14
        Debug   gs,"Sprite Image at", R0
        ]
        ADD     R14,R1,R14              ; R14 --> sprite image
        LDR     R0,[R1,#spTrans]
        ADD     R0,R1,R0                ; R0 --> sprite mask
        Debug   gs,"Sprite mask at", R0
        TST     R5,#8
        MOVEQ   R0,R14                  ; R0=R14 ==> no mask
        SUBS    R0,R0,R14
        BICEQ   R5,R5,#8                ; R5 bit 3 ==> is there a mask?
        STR     R0,save_masko
;
        LDR     R2,[R1,#spHeight]
        SUB     R10,R2,R10              ; R10 = no of rows from top

        LDR     R3,save_inputxsize      ; number of pixels(==number of bits)
        ANDS    R4,R3,#&1F              ; R4=number of bits
        MOVNE   R4,#1                   ; R4=1 if R3 MOD 31 is not zero
        ADD     R4,R4,R3,LSR #5         ; R4=number of words
        MOV     R4,R4,ASL #2            ; R4=number of bytes for full row
        STR     R4,save_maskinoffset

        LDR     R2,[R1,#spWidth]
        ADD     R2,R2,#1
        MOV     R2,R2,ASL #2            ; R2 = line length
        STR     R2,save_inoffset

        MOV     R9,R9,ASR #5            ; R9 = word offset

        Pull    "R3"                    ; pull unaltered R9 from earlier
        MOV     R3,R3,ASR #5

        ADD     R11,R0,R3,ASL #2        ; R11= mask addr + byte offset
        MLA     R3,R10,R4,R11           ; R3= #rows * bytes_per_row + maskaddr & byteoffset
                                        ; R3=> first mask input word
        LDR     R11,[R1,#spImage]
        ADD     R3,R3,R11
        ADD     R3,R3,R1
        STR     R3,save_maskinptr
        Debug   gs, "Maskinptr is = ",R3
;
        ADD     R14,R14,R9,ASL #2
        MLA     R14,R10,R2,R14          ; R14 --> first input word
        STR     R14,save_inptr
;

; note that this points at the start of the last row of the sprite!

        Debug   in,"inptr,inshift,inoffset,masko =",#save_inptr,#save_inshift,#save_inoffset,#save_masko
;
; get output address and shift
; Entry:  [save_x/ycoord] = output x,y coord
;         [screenstart], [ywindlimit], [linelength] set up
; Exit:   [save_outptr] --> output address
;         [save_outword] = initial marker bit position
;         [save_outoffset] = line length
;
        LDR     R3,save_xcoord
        LDR     R4,save_ycoord
        LDR     R11,Log2bpp                     ; R11 = output log2(bpp)
;
        LDR     R14,ywindlimit
        SUB     R4,R14,R4                       ; R4 = no of rows down from top
        LDR     R2,save_ecflimit
        ADD     R14,R2,R4,ASL #3                ; R14 = offset into ecf table
        ADD     R14,R14,#8                      ; R14 --> initial ecf position
        STR     R14,save_ecfptr
;
        LDR     R14,linelength
        STR     R14,save_outoffset
        LDR     R2,screenstart
        MLA     R10,R14,R4,R2                   ; R10 = R2 + (R14 * R4)
        MOV     R3,R3,ASL R11
        AND     R14,R3,#31                      ; R14 = initial bit posn in word;
        MOV     R3,R3,ASR #5
        ADD     R10,R10,R3,ASL #2               ; R10 --> output address
        STR     R10,save_outptr
;
        MOV     R0,#&80000000
        MOV     R0,R0,LSR R14                   ; R0 = initial marker bit
        STR     R0,save_outword
;
        Debug   in,"Outptr, outword =",#save_outptr,#save_outword


;;----------------------------------------------------------------------------------------------------------------
;;
;; Register summary:
;;
;;       R0      R1      R2      R3      R4      R5      R6      R7      R8      R9      R10     R11     R12
;;       ------  ------  ------  ------  ------  ------  ------  ------  ------  ------  ------  ------  ------
;;               spriteptr       xcoord  ycoord  gcol    x-mag   y-mag
;;       -x-             -x-     R3      R4              R6      R7      -x-     -x-     -x-     log2bpp
;;    outoffset  inoffset                ydiv    yadd                    ysize   ycount
;;               inshift
;;       in1     in2     inptr   outptr  outword outmask xdiv    xadd    xsize   xcount  masko   bpp     inmask
;;
;;       in1     in2     inptr   outptr  outword outmask xdiv    xadd    xsize   xcount  ttr     bpp     inbpp
;;                                                       -x-     -x-                     ecfptr  ecfora  ecfeor
;;----------------------------------------------------------------------------------------------------------------

;
; compute xadd, yadd
;
        ASSERT  yadd<>R6
        STR     R7,save_yadd            ; yadd = size of input pixels (y-mag)
        LDR     R14,save_xdiv
        ADD     xadd,R14,R6             ; xadd = save_xdiv + xmag
        STR     xadd,save_xadd
;
        MOV     R14,#-1                 ; bit set ==> don't touch!
        STR     R14,save_outmask
        MOV     R14,#0
        STR     R14,save_vcount         ; bodge for 1st row

      [ ccompiler
;        LDR     R14,spritecode
;        AND     R14,R14,#255
;        CMP     R14,#SpriteReason_PutSpriteScaled
;        BEQ     new_putscaled_compiler
        B       new_putscaled_compiler
      ]

      [ remoldcompiler
      |
;
; compile appropriate macro (if not already done)
;
        BL      compilemacro

;
; remove cursors, since we are about to stomp on the screen!
;
        SWI     XOS_RemoveCursors
        BVS     exitbiggie              ; last chance to go to exitbiggie!
;
; copy relevant variables onto the stack, so that R12 is free
;
        LDR     R0,BPP
        LDR     R1,save_outoffset
        LDR     R2,save_inbpp
        LDR     R3,ColourTTR
        LDR     R4,save_masko
        LDR     R5,save_calladdr
        LDR     R6,save_calladdr2
        LDR     R9,save_maskinptr
        LDR     R10,save_maskinshift
;
        MVN     R8,#0                     ;fixes for 32bpp, amg
        CMP     R0,#32
        RSBLT   R14,R0,#32
        MOVLT   R8,R8,ASL R14           ; setup a suitable mask
        Debug   cn,"maskword ",R8
;
        Push    "R0-R12"                 ; R7 = space for stack_returnaddr
;
        ADR     R14,save_block
        LDMIA   R14,{R0-R9}             ; R10 irrelevant, R12 set up already
        Push    "R0-R10,R12"            ; create space on stack
;
; these variables are not reloaded at the start of the loop
;
        LDR     xdiv,save_xdiv
        LDR     xadd,save_xadd
        LDR     masko,save_masko
;
        LDR     R14,spritecode
        AND     R14,R14,#&FF
        TEQ     R14,#SpriteReason_PutSpriteScaled
        BEQ     gonextrow               ; loads up inptr, outptr
        TEQ     R14,#SpriteReason_PutSpriteGreyScaled
        BEQ     gogreyscale
;
; if plotting a mask, inptr --> mask itself
;
        LDR     R14,save_inptr          ; inptr --> mask instead of pixels
        ADD     R14,R14,masko
        STR     R14,save_inptr          ; *** R12 not corrupted yet !!!

        B       gonextmaskrow

nextrow
        LDMIA   R13,{inshift,outword,outmask,xsize,xcount}  ; unchangeable!

        STR     PC,stack_returnaddr
        LDR     PC,stack_calladdr
        NOP
;
        TEQ     outword,#&80000000
        BEQ     %FT02
;
        LDR     R14,stack_BPP                   ; R14 = bpp
        RSB     R14,R14,#32
        MVN     im1,#0
        MOV     im1,im1,ASL R14
;
        LDR     R14,stack_BPP                   ; prep up another register
01
        CMP     R14,#32
        MOVEQ   outmask,im1
        BEQ     %FT03                           ; AMG special case for 32BPP

        MOVS    outword,outword,LSR R14
        ORR     outmask,im1,outmask,LSR R14     ; set all bits from here
        BCC     %BT01
;
03      STR     PC,stack_returnaddr
        LDR     PC,stack_calladdr2              ; call 'putword'
        NOP
02
;
; go on to next row (including the first time)
;
gonextrow
        LDR     R12,stack_wsptr
        LDMIA   R12,{outoffset,inoffset,inptr,outptr,ydiv,yadd,ysize,ycount}
        LDR     R14,stack_vcount                ; =0 first time round
        SUBS    ysize,ysize,R14
        BEQ     donesprite                      ; finished!
;
        TEQ     R14,#0
01
        SUBNE   outptr,outptr,outoffset         ; move up appropriate amount
        SUBNES  R14,R14,#1
        BNE     %BT01
;
02
        SUBS    ycount,ycount,ydiv              ; room for an output row?
        ADDCS   R14,R14,#1                      ; yes
        BCS     %BT02
        ADD     ycount,ycount,ydiv              ; oops!
;
        TEQ     R14,#0                          ; any to do?
        BNE     %FT11

        STR     R0,stack_temp1
        STR     R1,stack_temp2

        LDR     R0,save_maskinptr
        LDR     R1,save_maskinoffset
        SUB     R0,R0,R1
        STR     R0,stack_maskinptr
        STR     R0,save_maskinptr
        LDR     R0,save_maskinshift
        STR     R0,stack_maskinshift

        LDR     R0,stack_temp1
        LDR     R1,stack_temp2

        SUB     inptr,inptr,inoffset            ; inptr --> row above
        ADD     ycount,ycount,yadd              ; if input row is not enough,
        B       %BT02                           ; try again
11
;
        CMP     R14,ysize
        MOVGT   R14,ysize
        STR     R14,stack_vcount
;
        ADR     R12,save_inptr
        STMIA   R12,{inptr,outptr,ydiv,yadd,ysize,ycount}
        B       nextrow
;
donesprite
        LDR     R12,stack_wsptr
        ADD     R13,R13,#:INDEX:stack_end       ; restore stack frame
;
        Push    "PC"
        SWI     XOS_RestoreCursors              ; preserve error state
        Pull    "LR"
        TEQP    LR,#0
;
        B       exitbiggie

;
; equivalent code for mask plotting (using background GCOL action)
;

nextmaskrow
        LDMIA   R13,{inshift,outword,outmask,xsize,xcount,ecfptr}  ; constant!
;
        ;if doing a new format mask sprite need to change inshift
        LDR     R12,stack_wsptr               ; get back the workspace base
        LDR     R11,save_spr_type             ; fetch the sprite type
        MOVS    R11,R11,LSR #27               ; test for T=0
        LDRNE   inshift,save_maskinshift      ; if T>0 need to change the inshift
        STRNE   inshift,save_inshift          ;   that we use to suit the 1bpp data

        STR     PC,stack_returnaddr
        LDR     PC,stack_calladdr
        MOV     R0,R0
;

        TEQ     outword,#&80000000
        BEQ     %FT02
        LDR     R14,stack_BPP
01
        MOVS    outword,outword,LSR R14
        BCC     %BT01
;

        STR     PC,stack_returnaddr
        LDR     PC,stack_calladdr2              ; call 'putword'
        MOV     R0,R0
02
;
; go on to next row (including the first time)
;
gonextmaskrow
        LDR     R14,stack_vcount                      ; =0 first time round
        LDR     ecfptr,stack_ecfptr
        LDR     yadd,stack_ecflimit
        SUB     ecfptr,ecfptr,R14,ASL #3              ; 8 bytes per pixel row
        SUB     ecfptr,ecfptr,yadd
        ANDS    ecfptr,ecfptr,#4*16-1
        ADDEQ   ecfptr,ecfptr,#4*16
        ADD     ecfptr,ecfptr,yadd
        STR     ecfptr,stack_ecfptr
;
        LDR     R12,stack_wsptr
        LDMIA   R12,{outoffset,inoffset,inptr,outptr,ydiv,yadd,ysize,ycount}
        SUBS    ysize,ysize,R14
        BEQ     donesprite                      ; finished!
;
        MUL     R14,outoffset,R14
        SUB     outptr,outptr,R14               ; move up appropriate amount
;
        MOV     R14,#0
02
        SUBS    ycount,ycount,ydiv              ; room for an output row?
        ADDCS   R14,R14,#1                      ; yes
        BCS     %BT02
        ADD     ycount,ycount,ydiv              ; oops!
;
        TEQ     R14,#0                          ; any to do?
        BNE     %FT03

        LDR     R11,save_spr_type               ; needs R12 to be right
        MOVS    R11,R11,LSR #27
        BEQ     %FT04                           ; skip 1bpp mask stuff if old format

        STR     R0,stack_temp1
        STR     R1,stack_temp2

        LDR     R0,save_maskinptr
        LDR     R1,save_maskinoffset
        SUB     R0,R0,R1
        STR     R0,stack_maskinptr
        STR     R0,save_maskinptr
        LDR     R0,save_maskinshift
        STR     R0,stack_maskinshift

        LDR     R0,stack_temp1
        LDR     R1,stack_temp2
04
        SUB     inptr,inptr,inoffset            ; inptr --> row above
        ADD     ycount,ycount,yadd              ; if input row is not enough,
        B       %BT02                           ; try again
;
03
        CMP     R14,ysize
        MOVGT   R14,ysize
        STR     R14,stack_vcount
;
        ADR     R12,save_inptr
        STMIA   R12,{inptr,outptr,ydiv,yadd,ysize,ycount}
        B       nextmaskrow

      ]

;;-----------------------------------------------------------------------------
;; Function to validate the pixel translation table, remapping as required
;; to take into account depth changes etc.
;;
;; in   R7 -> pixtrans table supplied to call
;; out  R0 -> error block (V set)
;;      R7 -> pixtrans table (may have been relocated!)
;;-----------------------------------------------------------------------------

; The following rules apply:
;
;    1/2/4/8 to 1/2/4/8 bpp   : no change
;          8 to   16/32 bpp   : use mungeGCOL8toXX routine, applied here
;      16/32 to 1/2/4/8 bpp   : only valid table is a CTrans 32K table providing 5 bit mappings
;         16 to      16 bpp   : no table allowed
;         32 to      32 bpp   : no table allowed
;      16/32 to   32/16 bpp   : no table, but a munge function will be applied instead
;                               (nb, this is called during plotting, since there's no table
;                               to modify in advance)
;
;    ColourTrans uses the following structure for the return from Select/GenerateTable:
;
;    Word 0 : &33324B2E "32K."
;    Word 4 : Pointer to the 32K table
;    Word 8 : &33324B2E "32K."
;

checktrans Entry

        LDR     LR,save_inbpp
        MOV     R8,#1
        MOV     R8,R8,ASL LR            ; R8 = number of input colours
        LDR     R9,BPP                  ; R9 = output depth
        MOV     R10,#0                  ; R10 = index / counter

        CMP     LR,#16
        BCC     checktrans1             ; branch if input is 8bpp or below

        ;now check out the following:
        ; 16 -> 16 : \                  ;
        ; 32 -> 32 :  \__ A table should never be used, however if one is presented
        ; 16 -> 32 :  /   it will be discarded but not faulted here.
        ; 32 -> 16 : /
        ; 16/32 -> 8 or lower : table must be CTrans 32K type

        CMP     R9,#16
        BCS     checktrans_ignorettr

        ;this is 16/32 to 8/lower, so check for a 32K table
      [ jpeg
        ; JPEG possibility - might get 32bpp data into small target, with no table.
        LDR     LR,is_it_jpeg
        TEQ     LR,#0                     ; 0 -> not JPEG
        BNE     checktrans_exitok
      ]
        LDR     LR,word32k
        LDR     R8,[R7,#0]
        CMP     R8,LR
        BNE     checktrans_giveerror
        LDR     R8,[R7,#8]
        CMP     R8,LR
        BNE     checktrans_giveerror
        B       checktrans_exitok

checktrans_ignorettr
        MOVS    R7,#0
        B       checktrans_exitok

word32k =       "32K."

checktrans1
        CMP     R9,#16                  ; are we outputting to >= 16 bit per pixel
        BLT     checktrans_old          ; if not then ignore the remapping

; For backwards compatibility we attempt to remap the colours by taking the GCOL
; byte which is in VIDC 1 format and convert it to a word value sensible for this
; depth of display.

; The functions which decode this byte now look for a word value which is then
; combined into the scan line being rendered.

        Push    "R0-R2,R9"
        LDR     R9,Log2bpp
        SUB     R9,R9,#3                ; convert the output Log2 bpp into a sensible index for conversion
        [ widetrans
        ; don't need to do anything for 32bpp, for 15bpp entries need to be moved to
        ; be word based. Problem is that CTrans produces a half word table, but the
        ; plot code here expects them to be words

        LDR     R14,trns_flags2         ; get the flag word
        TST     R14,#flg2_widetrans     ; if set we don't need to do the expansion
        BEQ     no_widetrans            ; skip if new bit is unset
        TSTNE   R9,#2                   ; check for 32bpp (note the the SUBS #3 above)
        LDMNEFD R13!,{R0-R2,R9}         ; it is 32bit - reload registers...
        BNE     checktrans_exitok       ; ...and go straight out

        Debug   gs,"We're gonna scribble all over newtranstable 1"
        ;now do the expansion needed for 15bpp
        ADR     R2,newtranstable        ; new table space
        MOV     R8,R8,LSR #1            ; loading a word collects two entries, so
                                        ; halve the number of colours to do
expand_15bpp
        SUBS    R8,R8,#1                ; decrement count
        Pull    "R0-R2,R9",MI           ; when we go minus we've finished, reload registers...
        ADRMI   R7,newtranstable        ; ...change the translation table pointer...
        BMI     checktrans_exitok       ; ...and get out of here!

        LDR     R0,[R7,R8,LSL #2]       ; load two values from original ctrans table
        MOV     LR,R0,LSR #16           ; put the second value in the low 16 bits of LR
        EOR     R0,R0,LR,LSL #16        ; and remove the second value from R0
        MOV     R8,R8,LSL #1            ; double the output pointer cos we've two words to store
        STR     R0,[R2,R8,LSL #2]       ; store the first word
        ADD     R8,R8,#1                ; increment
        STR     LR,[R2,R8,LSL #2]       ; and store the second word
        MOV     R8,R8,LSR #1            ; and bring the output pointer back to normal
        B       expand_15bpp            ; back to the loop to check for completion

no_widetrans
        ]

        ADR     R2,newtranstable        ; -> new translation table (passed out on exit)

converttrans_new
        SUBS    R8,R8,#1
        Pull    "R0-R2,R9",MI           ; preserve important registers
        ADRMI   R7,newtranstable
        BMI     checktrans_exitok

        LDRB    R0,[R7,R8]
        MOV     LR,PC
        ADD     PC,PC,R9,LSL #2         ; call function to remap the colour byte
        STR     R0,[R2,R8,LSL #2]       ; and store the converted value
        B       converttrans_new        ; outbpp = 3 (and inbpp < 4 log2bpp)
        B       mungeGCOL8to16          ; outbpp = 4
;        B       mungeGCOL8to32          ; outbpp = 5

mungeGCOL8to32

        Push    "R2,LR"
                                        ;      fedcba98 76543210 fedcba98 76543210
                                        ; R0 =                            bbggrrtt
        MOV     R2,R0,LSL #4            ; R2 =                       bbgg rrtt
        ORR     R2,R2,R0,LSL#10         ; R2 =                bb ggrrXXgg rrtt
        ORR     R2,R2,R0,LSL#16         ; R2 =          bbggrrXX ggrrXXgg rrtt
        AND     LR,R0,#&03              ; LR =                                  tt
        BIC     R2,R2,#&3F0000          ; R2 =          bb       ggrrXXgg rrtt
        BIC     R2,R2,#&3F00            ; R2 =          bb       gg       rrtt
        ORR     R2,R2,R14,LSL #12       ; R2 =          bb       ggtt     rrtt
        ORR     R0,R2,R14,LSL #20       ; R0 =          bbtt     ggtt     rrtt
        ORR     R0,R0,R0,LSR #4         ; R0 =          bbttbbtt ggttggtt rrttrrtt

; which saves one instruction on...
;        AND     R2,R0,#4_0033           ; R2 =                              rrtt
;        MOV     R2,R2,LSL #4            ; R2 =                          rrtt
;        AND     LR,R0,#4_0003           ; LR =                                tt
;        ORR     R2,R2,LR,LSL #12        ; R2 =                    tt    rrtt
;        ORR     R2,R2,LR,LSL #16 +4     ; R2 =           tt       tt    rrtt
;        AND     LR,R0,#4_0300           ; LR =                            gg
;        ORR     R2,R2,LR,LSL #14 -4     ; R2 =           tt     ggtt    rrtt
;        AND     LR,R0,#4_3000           ; LR =                          bb
;        ORR     R0,R2,LR,LSL #(6 +16)-6 ; R0 =         bbtt     ggtt    rrtt

        Pull    "R2,PC"


mungeGCOL8to16
      [ vidc20
                                        ;      fedcba9876543210fedcba9876543210

        Push    "R2,LR"
                                        ; R0 =                         bbggrrtt

        MOV     LR,R0,LSL #30           ; LR = tt
        ORR     R2,LR,R0,LSR #6         ; R2 = tt                            bb
        ORR     LR,LR,R0,LSR #4         ; LR = tt                          bbgg
        BIC     LR,LR,#&0C              ; LR = tt                            gg
        MOV     R0,R0,LSL #1            ; R0 =                        bbggrrtt
        AND     R0,R0,#&1E              ; R0 =                            rrtt
        ORR     R0,R0,LR,ROR #24        ; R0 =                       ggtt rrtt
        ORR     R0,R0,R2,ROR #19        ; R0 =                  bbtt ggtt rrtt
        ;and now fill in the bottom bit of the colour
        MOV     LR,LR,LSR #30           ; LR =                               tt
        AND     LR,LR,#1                ; LR =                                t
        ORR     LR,LR,LR,LSL #5         ; LR =                           t    t
        ORR     LR,LR,LR,LSL #5         ; LR =                      t    t    t
        ORR     R0,R0,LR                ; R0 =                  bbtttggtttrrttt

; which saves one inst on....
;        AND     R2,R0,#4_0033           ; R2 =             rrtt
;        AND     LR,R0,#4_0003           ; LR =               tt
;        ORR     R2,R2,LR,LSL #5         ; R2 =          tt rrtt
;        ORR     R2,R2,LR,LSL #10        ; R2 =     tt   tt rrtt
;        AND     LR,R0,#4_3000           ; LR =         bb
;        ORR     R2,R2,LR,LSL #12 -6     ; R2 =   bbtt   tt rrtt
;        AND     LR,R0,#4_0300           ; LR =           gg
;        ORR     R2,R2,LR,LSL #7 -4      ; R2 =   bbtt ggtt rrtt
;        MOV     R0,R2,LSL #1            ; R0 =  bbtt ggtt rrtt

        Pull    "R2,PC"
      |

; Tim's function for remapping the packed GCOL number to a value
; suitable for display memory.

        AND     R1,R0,#4_000033
        ORR     R0,R1,R0,LSL #4
        AND     R1,R0,#4_030330
        EOR     R1,R1,R1,LSR #6
        EOR     R1,R1,R1,LSR #4
        AND     R1,R1,#4_000330
        EOR     R0,R0,R1,LSL #4
        MOV     PC,LR
      ]

checktrans_old
        SUBS    R8,R8,#1                ; loop until -ve value
        ;B       checktrans_exitok
        BMI     checktrans_exitok       ;fix bug that was making this routine inactive! AMG

        LDRB    LR,[R7,R10]             ; get a byte from the table
        MOVS    LR,LR,LSR R9            ; if any bits are non-zero that shouldn't be then complain
        BEQ     checktrans_old
checktrans_giveerror
        Debug   gs, "We think the ttable is duff (XXX)"
        ADRL    R0,ErrorBlock_BadTranslation
        addr    R1,Title
        BL      copy_error_one          ; returns error block with V set, for bad table
        EXIT

checktrans_exitok
        CLRV
        EXIT


      [ remoldcompiler
      |

;;----------------------------------------------------------------------------
;; Scale 4-bits-per-pixel greyscale sprite into another
;; parameters set up as for the other types of sprite plotting
;;----------------------------------------------------------------------------

fcolbit         *       &80000000
frowbit         *       &40000000

; z zf zyf zs zys
; xcount ycount
; inputcell outword outptr
; flags
; Ra (Rb=zyf) (Rc=z)

; nextrowdata (12)
; nextcoldata (12)
; TOTAL
; XTOTAL

        MakeSpriteErrorBlock BadGreyScale,,BadGScl

defaultpixeltable
        DCB     0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15

gogreyscale
        LDR     R14,save_inlog2bpp
        TEQ     R14,#2
        ADRNE   R0, ErrorBlock_BadGreyScale
        addr    r1, Title, NE
        BLNE    copy_error_one                  ; Always sets the V bit
        BVS     donesprite                      ; restore cursors & stack
;
        LDR     Ra,ColourTTR                    ; pointer to pixel table?
        CMP     Ra,#0
        ADRNE   Ra,defaultpixeltable
        STRNE   Ra,ColourTTR
;
        LDR     Ra,save_xdiv
        LDR     Rb,save_ydiv
        MUL     R14,Ra,Rb
        STR     R14,save_xftimesyf
;
        LDR     inputcell,save_inptr
        MOV     inputcell,inputcell,LSL #3-2
        LDR     R14,save_inshift
        ADD     inputcell,inputcell,R14,LSR #2  ; 4 bits per pixel
;
        LDR     outptr,save_outptr
;
        LDR     zys,save_ycount
        LDR     ycounter,save_inputysize
        LDR     R14,save_ysize
        STR     R14,save_tempysize
nextgsrow
        LDR     outword,save_outword
        LDR     R14,[outptr]
01
        MOV     R14,R14,LSL #4
        MOVS    outword,outword,LSR #4
        BCC     %BT01
        LDR     outword,save_outword
        ORR     outword,outword,R14             ; initial output word
;
        LDR     zyf,save_ydiv
;
        ORR     flags,flags,#fcolbit            ; firstcolumn := true
        LDR     zs,save_xcount
        LDR     xcounter,save_inputxsize
        LDR     R14,save_xsize
        STR     R14,save_tempxsize
nextgscolumn
        LDR     zf,save_xdiv
        MOV     R14,#0
        STR     R14,TOTAL
        ORR     flags,flags,#frowbit            ; firstrow := true
        Push    "ycounter,zys,zyf"
mainloop1
        MOV     R14,#0                          ; sub-pixel total
        STR     R14,XTOTAL
        Push    "inputcell,xcounter,zs,zf"
mainloop2
        CMP     zs,zf
        MOVCC   z,zs
        MOVCS   z,zf
;
; add weighted input cell to row total
;
        MOVS    R14,inputcell,LSR #1            ; get pixel address
        LDRB    R14,[R14]
        ANDCC   R14,R14,#&0F                    ; low-order pixel
        MOVCS   R14,R14,LSR #4                  ; high-order pixel
;
        LDR     Ra,XTOTAL
        MLA     Ra,z,R14,Ra
        STR     Ra,XTOTAL
;
        SUBS    zs,zs,z
        LDREQ   zs,save_xmag
        ADDEQ   inputcell,inputcell,#1          ; go right 1 column
        SUBEQ   xcounter,xcounter,#1
        SUBS    zf,zf,z

        TEQNE   xcounter,#0
        BNE     mainloop2
;
        TST     flags,#frowbit                  ; if first row,
        BICNE   flags,flags,#frowbit
        ADRNE   R14,nextcoldata
        STMNEIA R14,{inputcell,zs,xcounter}       ; save for later.
;
; add row total into cell total
;
        Pull    "inputcell,xcounter,zs,zf"
;
        CMP     zys,zyf
        MOVCC   z,zys
        MOVCS   z,zyf
;
        LDR     Ra,TOTAL
        LDR     R14,XTOTAL
        MLA     Ra,R14,z,Ra
        STR     Ra,TOTAL
;
        SUBS    zys,zys,z
        LDREQ   zys,save_ymag
        LDREQ   R14,save_inoffset
        SUBEQ   inputcell,inputcell,R14,LSL #3-2   ; go up 1 row
        SUBEQ   ycounter,ycounter,#1
        SUBS    zyf,zyf,z
        TEQNE   ycounter,#0
        BNE     mainloop1
;
; now divide total for this cell by (xf*yf)
;
        LDR     Ra,TOTAL
        LDR     Rb,save_xftimesyf               ; zyf not used
        ADD     Ra,Ra,Rb,ASR #1                         ; round to nearest
        DivRem  Rc,Ra,Rb, R14                   ; z not used
        CMP     Rc,#16
        MOVCS   Rc,#15                                  ; 4-bit answer
;
        LDR     R14,ColourTTR           ; pixel look-up
        LDRB    Rc,[R14,Rc]
        LDR     R14,BPP
        MOV     Rc,Rc,ROR R14
        ORRS    outword,Rc,outword,LSR R14
        STRCS   outword,[outptr],#4
        MOVCS   outword,#&80000000
;
; if first column, save data for nextgsrow
;
        TST     flags,#fcolbit                  ; if first column,
        BICNE   flags,flags,#fcolbit
        ADRNE   R14,nextrowdata
        STMNEIA R14,{inputcell,zys,ycounter}      ; save for later.
;
; move right one output pixel
;
        Pull    "ycounter,zys,zyf"
        ADR     R14,nextcoldata
        LDMIA   R14,{inputcell,zs,xcounter}
        LDR     R14,save_tempxsize
        SUBS    R14,R14,#1
        STR     R14,save_tempxsize
        BGT     nextgscolumn
;
        TEQ     outword,#&80000000
        BEQ     %FT02
        MOV     Ra,#&FFFFFFFF
        LDR     R14,BPP
01
        MOV     Ra,Ra,LSR R14
        MOVS    outword,outword,LSR R14
        BCC     %BT01
        LDR     Rb,[outptr]
        BIC     Rb,Rb,Ra                ; should really depend on GCOL action
        ORR     Rb,Rb,outword
        STR     Rb,[outptr]
02
        LDR     R14,save_outoffset
        LDR     outptr,save_outptr
        SUB     outptr,outptr,R14
        STR     outptr,save_outptr
;
        ADR     R14,nextrowdata
        LDMIA   R14,{inputcell,zys,ycounter}
        LDR     R14,save_tempysize
        SUBS    R14,R14,#1
        STR     R14,save_tempysize
        BGT     nextgsrow
;
        B       donesprite


;;-----------------------------------------------------------------------------
;; Compile appropriate 'macro' for doing scaled SpriteOp's
;; Entry:  [macroword] = bits indicating state of macro
;;                0..2 = gcol action
;;                   3 = mask / no mask (used for input masking)
;;                   4 = ttr / no ttr
;;                   5 = plotmask / putsprite
;;                   6 = transformed / scaled
;; ( if ignore_ttr)  7 = use palette entries and ignore ttr (<16 to >8bpp only)
;;               8..15 = inbpp
;;              16..23 = outbpp
;;                  24 = transformed sprite routine/scaled sprite routine (version 23 and above)
;;         ColourTTR
;;         spritecode
;;         save_inshift
;;         save_inbpp
;;         BPP
;;         R5          = gcol action
;; Exit:   code recompiled if necessary
;;         ecflimit, outoffset updated inside code
;;-----------------------------------------------------------------------------

      ]
      ; some of these values used in SprTrans
mc_gcol         *       2_00000111              ; bits 0..2 of R5
mc_hasmask      *       2_00001000              ; bit 3 of R5
mc_ttr          *       2_00010000              ; R7
mc_plotmask     *       2_00100000              ; R0
mc_transformed  *       2_01000000              ; 0 if scaled, 1 if transformed sprite plot

                [ ignore_ttr
mc_ttrispalette *       2_10000000              ; use palette instead of ttr (ttr points at it)
                ]

mcb_inbpp       *       8
mcb_outbpp      *       16
mcb_sprtype     *       24

                ^       0
l_newword       #       4
l_newpixel      #       4
l_tryoutput     #       4
l_fref          #       4               ; forward reference
l_putmany       #       4
l_vloop         #       4
l_putword       #       4
l_max           #       0

vv_inbpp        RN      R6
vv_inbpp1       RN      R7
vv_outbpp       RN      R8
vv_outbpptop    RN      R9

BLEQ            *       &0B000000
BNE             *       &1A000000
BCS             *       &2A000000
BCC             *       &3A000000
BMI             *       &4A000000
BPL             *       &5A000000
BVS             *       &6A000000
BVC             *       &7A000000
BHI             *       &8A000000
BLS             *       &9A000000
BGE             *       &AA000000
BLT             *       &BA000000
BGT             *       &CA000000
BLE             *       &DA000000
BAL             *       &EA000000
BNV             *       &FA000000

        GBLA    ldmreg
        GBLS    ldmreg2

xxx     *       2

        MACRO
$l      Asm     $label,$cc
$l      GetAsm  $label,$cc
        PutAsm  $label,$cc
        MEND

        MACRO
$l      GetAsm  $label,$cc
ldmreg  SETA    ($label.end-$label+4):SHR:2
ldmreg2 SETS    "$ldmreg":RIGHT:1
      [ ldmreg>1
$l      ADR$cc  R1,$label
        LDM$cc.IA R1,{R1-R$ldmreg2}
      |
$l      LDR$cc  R1,$label
      ]
        MEND

        MACRO
$l      SetImm  $reg,$value,$cc
$l      EOR$cc  $reg,$reg,#xxx
        EOR$cc  $reg,$reg,$value
        MEND

        MACRO
$l      SetLsr  $reg,$value,$cc
$l      EOR$cc  $reg,$reg,#xxx:SHL:7
        EOR$cc  $reg,$reg,$value,LSL #7
        MEND

        MACRO
$l      SetLsl  $reg,$value,$cc
$l      EOR$cc  $reg,$reg,#xxx:SHL:7
        EOR$cc  $reg,$reg,$value,LSL #7
        MEND

        MACRO
$l      PutAsm  $label,$cc
ldmreg  SETA    ($label.end-$label+4):SHR:2
ldmreg2 SETS    "$ldmreg":RIGHT:1
        [ debugcg
        STMFD R13!,{R9,R14}
        MOV R9,#$ldmreg2
        BL ag_disasm
        LDMFD R13!,{R9,R14}
        ]
$l      STM$cc.IA R10!,{R1-R$ldmreg2}
        MEND

        MACRO
$l      Label   $lab
$l      STR     R10,[sp,#$lab]
        MEND

        MACRO
$l      Branch  $op,$lab
$l      LDR     R0,[sp,#$lab]
        SUB     R0,R0,R10
        SUB     R0,R0,#8
        MOV     R0,R0,LSL #6
        MOV     R0,R0,LSR #8
        ORR     R0,R0,#$op
        STR     R0,[R10],#4
        MEND

      [ remoldcompiler
      |

compilemacro
        Push    "R11,LR"
        [ multibuffer
        Debug    mb,""
        Debug    mb,"Multibuffer code is enabled...."
        ]
;
        AND     R11,R5,#mc_gcol:OR:mc_hasmask
        LDR     R14,ColourTTR
        CMP     R14,#0
        ORRNE   R11,R11,#mc_ttr
        LDR     R14,spritecode
        AND     R14,R14,#&FF
        TEQ     R14,#SpriteReason_PlotMaskScaled
        ORREQ   R11,R11,#mc_plotmask
        BICEQ   R11,R11,#mc_ttr
        LDR     R14,BPP
        ORR     R11,R11,R14,LSL #mcb_outbpp
        LDR     R14,[R1,#spMode]
        MOV     R14,R14,LSR #27
        ORR     R11,R11,R14,LSL #mcb_sprtype   ;include sprite type
        LDR     R14,save_inbpp
        ORR     R11,R11,R14,LSL #mcb_inbpp

        ; from the addition of 1bpp mask handling the macroword generated by both
        ; macro generators adds the sprite type to the information in the macro
        ; word, at bit 24 up. this is necessary to ensure that a mask routine for
        ; a 1bpp mask can be distinguished from a mask routine for old mask format.

        [ ignore_ttr
        TST     R11,#mc_plotmask
        BNE     %FT21
        LDR     R14,trns_palette
        TEQ     R14,#0
        ORRNE   R11,R11,#mc_ttrispalette
21
        ]
;
        [ multibuffer

        STMFD   R13!,{R6-R10}
        Debug   mb,"Macroword is ",R11
        ;usage of registers....
        ;r6 - slot to overwrite
        ;r7 - least used count so far
        ;r8 - buffer number
        ;r11 - macroword
        ;r9 & r14 available

        MOV     R6,#0
        MOV     R7,#bignum
        MOV     R8,#0

        ADR     R9,buffer0mask
        ADR     R10,buffer0count

        Debug   mb,"Looking at entry ",R8
40
        LDR     R14,[R9,R8]     ;fetch the macroword used for the routine
        Debug   mb,"Current macroword in this slot ",R14
        TEQ     R11,R14
        BEQ     %FT41           ;this routine has already been built
                                ;increment its usage count and use it
        LDR     R14,[R10,R8]     ;fetch the count for the routine
        Debug   mb,"Usage count ",R14
        CMP     R14,R7          ;has this been used less than the maximum?
        MOVCC   R6,R8           ;if so, it's the one to build over
        MOVCC   R7,R14          ;and reduce the limit

        Debug   mb,"Slot to overwrite ",R6
        ADD     R8,R8,#4
        CMP     R8,#(nbuffers :SHL: 2) ;done all buffers yet ?
        BNE     %BT40           ;no, so go back and try again

        ;there isn't a matching routine. R6 is the slot number to overwrite
        Debug   mb,"About to replace routine in slot ",R6
        Debug   ms,"Building code for ",R11
        [ debugms
        LDR     R14,[R9,R6]
        Debug   ms,"Discarding ",R14
        ]
        STR     R11,[R9,R6]     ;update the macroword for the slot
        ADR     R9,buffer0count
        MOV     R14,#1
        STR     R14,[R9,R6]     ;and set its usage count
        STR     R11,macroword
        STR     R6,thisslot     ;save the slot number for 'fillins'
        LDMFD   R13!,{R6-R10}
        B       %FT42           ;and go and compile the routine

41
        Debug   mb,"The routine already exists..."
        ;Debug   ms,"Code already built for ",R11
        LDR     R14,[R10,R8]
        ADD     R14,R14,#1
        STR     R14,[R10,R8]
        Debug   mb,"New usage count for this routine ",R14
        STR     R8,thisslot
        STR     R11,macroword
        LDMFD   R13!,{R6-R10}
        B       do_fillins
42
        |
        LDR     R14,macroword
        TEQ     R11,R14        ;is code already built ?
        BEQ     do_fillins     ;EQ: it is, so just update values in it
;
        STR     R11,macroword
        ]
;
; compile appropriate code, depending on value of R11 (macroword)
;
        Push    "R1-R10"
        SUB     sp,sp,#l_max            ; create local stack frame
        [ multibuffer
        ADR     R10,codebuffer0
        Debug   mb,"Codebuffer is at ",R10
        LDR     R14,thisslot            ;presently 0,4,8 or 12
        Debug   mb,"Slot number ",R14
                                        ;need 0,&200,&400,&600
        ADD     R10,R10,R14,LSL #7      ;R10 is now the correct buffer
        Debug   mb,"Codebuffer being used: ",R10
        |
        ADR     R10,codebuffer
        ]
;
        Debug   mc,"Compilemacro: R10,R11 =",R10,R11
        Debug   cg,"Compilemacro: R10,R11 =",R10,R11
;
        MOV     R14,R11,LSR #mcb_inbpp
        AND     vv_inbpp,R14,#&FF
        MOV     R14,R11,LSR #mcb_outbpp
        AND     vv_outbpp,R14,#&FF
        MOV     R14,#1
        MOV     R14,R14,LSL vv_inbpp
        SUB     vv_inbpp1,R14,#1        ; inbpp1 = 2^inbpp-1

        MOV     R14,#1:SHL:31
        MOV     R14,R14,ASR vv_outbpp
        MOV     R0,R14,LSL #1           ; outbpptop = 2^31 >> outbpp << 1
        BL      convert_ROR
        MOV     vv_outbpptop,R0         ; convert to opcode form
;
        Debug   cg,"{{{{{{{{{{{{{{{{{{{ Recompiling code }}}}}}}}}}}}}}}}}}}}"
        Debug   cg,""
        Debug   cw,"###### asm_newword ######"
        BL      asm_newword
        Debug   cw,""
        Debug   cs,"###### asm_start ######"
        BL      asm_start
        Debug   cs,""
        Debug   cn,"###### asm_newpixel ######"
        BL      asm_newpixel
        Debug   cn,""
        Debug   co,"###### asm_tryoutput ######"
        BL      asm_tryoutput
        Debug   co,""
        Debug   cp,"###### asm_putmany ######"
        BL      asm_putmany
        Debug   cp,""
        Debug   cu,"###### asm_putword ######"
        BL      asm_putword
        Debug   cu,""
        Debug   cg,"###### code built ######"
;
        Debug   cg,"End of Compiled code:",R10
;
        LDR     R10,[sp,#l_fref]        ; complete the forward reference
        Branch  BCS,l_putword
;
        ADD     sp,sp,#l_max
        Pull    "R1-R10"

do_fillins
        [ multibuffer
        ADR     R14,pc_ecflimit0
        LDR     R11,thisslot
        Debug   mb,"Doing fillins for routine ",R11
        LDR     R11,[R14,R11]
        CMP     R11,#0
        Debug   mb,"pc_ecflimit for this routine ",R11
        LDRNE   R0,save_ecflimit
        BLNE    convert_ROR
        LDRNE   R14,m_ecflimit
        SetImm  R14,R0,NE
        STRNE   R14,[R11]

        [ debugmb
        Debug   mb,"save_ecflimit (as imm)",R0
        Debug   mb,"composite word to store",R14
        ]
;
        |
        LDR     R11,pc_ecflimit
        CMP     R11,#0
        LDRNE   R0,save_ecflimit
        BLNE    convert_ROR
        LDRNE   R14,m_ecflimit
        SetImm  R14,R0,NE
        STRNE   R14,[R11]
;
        ]
;
        [ multibuffer
        ;set up the correct calladdr and calladdr2 for now...
        LDR     R14,thisslot
        Debug   mb,"Setting up calladdrs, slot=",R14
        ADR     R0,calladdr0
        LDR     R0,[R0,R14]
        Debug   mb,"Calladdr = ",R0
        STR     R0,save_calladdr

        ADR     R0,calladdr20
        LDR     R0,[R0,R14]
        Debug   mb,"Calladdr2 = ",R0
        STR     R0,save_calladdr2
        ]

        Pull    "R11,PC"

;
; Entry:  R0 = immediate constant
; Exit:   R0 = value to ORR into instruction opcode
;

convert_ROR
        EntryS
      [ {TRUE}
        BIC     R0, R0, #3:SHL:0
      ]
        MOV     R14,#16                 ; assume R0 bits 0,1 unset on entry
01
        TST     R0,#3                   ; assume R0<>0 on entry
        MOVEQ   R0,R0,LSR #2
        SUBEQ   R14,R14,#1
        BEQ     %BT01
        ORR     R0,R0,R14,LSL #8

        EXITS                           ; preserve flags


; ############################## code fragments for newword

pm_newword_ext          LDR     im1,[inptr,masko]
                        MOVS    im1,im1,LSR #xxx        ; inbpp
                        MOVCS   im2,#0
pm_newword_extend       LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp
                        ASSERT  (pm_newword_extend -pm_newword_ext) = (pm_newwordend -pm_newword)


tm1_newword1_ext        LDR     im1,stack_maskinptr
                        LDR     im2,stack_maskinshift
                        LDR     im1,[im1]
tm1_newword1_extend     MOV     im1,im1,LSR im2          ; inbpp
tm1_newword2_ext        MOVS    im1,im1,LSR #1
                        MOVCS   im2,#0
tm1_newword2_extend     LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp


pm1_newword1_ext        LDR     im1,stack_maskinptr
                        LDR     im2,stack_maskinshift
                        LDR     im1,[im1]
pm1_newword1_extend     MOV     im1,im1,LSR im2          ; inbpp
pm1_newword2_ext        MOVS    im1,im1,LSR #1
                        MOVCS   im2,#0
pm1_newword2_extend     LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp


tm_newword_ext          LDR     im1,stack_masko
                        LDR     im1,[inptr,im1]
                        MOVS    im1,im1,LSR #xxx        ; inbpp
                        MOVCS   im2,#0
tm_newword_extend       LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp
                        ASSERT  (tm_newword_extend -tm_newword_ext) = (tm_newwordend -tm_newword)

; ### plot mask, old format mask

pm_newword              LDR     im1,[inptr,masko]
                        MOVS    im1,im1,LSR #xxx        ; inbpp
                        MOVCS   im2,#0
pm_newwordend           MOVCC   im2,#xxx                ; (2^outbpp-1) ROR outbpp


; ### plot mask, new format mask

pm1_newword1            LDR     im1,stack_maskinptr
                        LDR     im2,stack_maskinshift
                        LDR     im1,[im1]
pm1_newword1end         MOV     im1,im1,LSR im2
pm1_newword2            MOVS    im1,im1,LSR #1
                        MOVCS   im2,#0
pm1_newword2end         MOVCC   im2,#xxx                ; (2^outbpp-1) ROR outbpp


; ### plot mask, new format mask, 16/32bpp

pm1_newword132          LDR     im1,stack_maskinptr
                        LDR     im2,stack_maskinshift
                        LDR     im1,[im1]
pm1_newword132end       MOV     im1,im1,LSR im2
pm1_newword232          MOVS    im1,im1,LSR #1
                        MOVCS   im2,#0
pm1_newword232end       LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp


; ### new plot word

p_newword               LDR     in1,[inptr],#4
                        MOV     in2,in1,LSL #xxx        ; 32-inbpp
                        MOVS    in1,in1,LSR #xxx        ; inbpp
                        ORR     in1,in1,#1:SHL:31
p_newwordend            MOV     PC,LR


; ### new plot word, 32bpp

p_newword32             LDR     in2,[inptr],#4
                        MOV     in1,#1
                        MOVS    in1,in1,LSR #1
                        ORR     in1,in1,#&80000000
p_newword32end          MOV     PC,LR


; ### transform/mask new word, old mask

tm_newword              LDR     im1,stack_masko
                        LDR     im1,[inptr,im1]
                        MOVS    im1,im1,LSR #xxx        ; inbpp
                        MOVCS   im2,#0
tm_newwordend           MOVCC   im2,#xxx                ; (2^outbpp-1) ROR outbpp


; ### transform/mask new word, new mask

tm1_newword1            LDR     im1,stack_maskinptr
                        LDR     im2,stack_maskinshift
                        LDR     im1,[im1]
                        MOV     im1,im1,LSR im2
tm1_newword1end         MOVS    im1,im1,LSR #1
tm1_newword2            MOVCS   im2,#0
tm1_newword2end         MOVCC   im2,#xxx                ; (2^outbpp-1) ROR outbpp


; ### transform/mask new word, new mask, 16/32bpp

tm1_newword1ext         LDR     im1,stack_maskinptr
                        LDR     im2,stack_maskinshift
                        LDR     im1,[im1]
                        MOV     im1,im1,LSR im2
tm1_newword1extend      MOVS    im1,im1,LSR #1
tm1_newword2ext         MOVCS   im2,#0
tm1_newword2extend      LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp


; ### transform new word 32bpp

t_newword32             LDR     in2,[inptr],#4
                        MOV     in1,#1
                        MOV     in1,in1,LSR #1
                        ORR     in1,in1,#1:SHL:31
t_newword32end          MOV     PC,LR


; ### transform new word 16bpp

t_newword161            LDR     in1,[inptr],#4
                        MOV     in2,in1,LSL #16
t_newword161end         MOV     in2,in2,LSR #16
t_newword162            MOV     in1,in1,LSR #16         ; inbpp
                        ORR     in1,in1,#1:SHL:31
t_newword162end         MOV     PC,LR


; ### transform new word <16bpp

t_newword               LDR     in1,[inptr],#4
                        AND     in2,in1,#xxx            ; 2^inbpp-1
                        MOV     in1,in1,LSR #xxx        ; inbpp
                        ORR     in1,in1,#1:SHL:31
t_newwordend            MOV     PC,LR


; ### update 1bpp mask controls

;code fragment for updating maskinptr and maskinshift.

msk_increment1          STR     im1,stack_temp1
                        STR     im2,stack_temp2
                        LDR     im1,stack_maskinshift
                        LDR     im2,stack_maskinptr
msk_increment1end       ADD     im1,im1,#xxx             ;pixels per word
msk_increment2          CMP     im1,#32
                        ADDCS   im2,im2,#4
                        MOVCS   im1,#0
msk_increment2end       STR     im1,stack_maskinshift
msk_increment3          STR     im2,stack_maskinptr
                        LDR     im1,stack_temp1
msk_increment3end       LDR     im2,stack_temp2


; ### mask new word

m_newword               LDR     in1,[inptr],#4
                        MOVS    in1,in1,LSR #xxx        ; inbpp
                        ORR     in1,in1,#1:SHL:31
m_newwordend            MOV     PC,LR


; ### new mask word for 1bpp

m1_newword1             LDR     im2,stack_maskinptr
                        LDR     im1,stack_maskinshift
                        LDR     in1,[im2]
                        MOV     in1,in1,LSR im1
m1_newword1end          ADD     im1,im1,#xxx             ;pixels per word
m1_newword2             CMP     im1,#32
                        ADDCS   im2,im2,#4
                        MOVCS   im1,#0
                        STR     im1,stack_maskinshift
m1_newword2end          STR     im2,stack_maskinptr
m1_newword3             MOVS    in1,in1,LSR #1
                        ORR     in1,in1,#1:SHL:31
m1_newword3end          MOV     PC,LR


asm_newword
                        Debug   cw,"*** asm_newword"
                        Label   l_newword
;
                        TST     R11,#mc_plotmask
                        BNE     %FT02
                        TST     R11,#mc_ttr
                        BNE     %FT01
;
                        TST     R11,#mc_hasmask
                        BEQ     %FT47
;
                        MOVS    R2,R11,LSR #mcb_sprtype
                        BEQ     %FT46

                        TST     R11,#mc_plotmask
                        BNE     %FT46

                        CMP     vv_outbpp,#16
                        Asm     pm1_newword1,LT
                        GetAsm  pm1_newword2,LT
                        SetImm  R3,vv_outbpptop,LT
                        PutAsm  pm1_newword2,LT

                        Asm     pm1_newword132,GE
                        Asm     pm1_newword232,GE

                        B       %FT47
46
                        CMP     vv_outbpp,#16
                        GetAsm  pm_newword,LT                   ; pick up code for 8 bit per pixel or less
                        SetImm  R4,vv_outbpptop,LT             ; modify based on output pixels
                        GetAsm  pm_newword_ext,GE               ; pick up code for 16 bit per pixel or greater
;
                        SetLsr  R2,vv_inbpp                     ; and write input information into it
                        Debug   cw,"pm_newword"
                        PutAsm  pm_newword, LT
                        PutAsm  pm_newword_ext, GE
47
                        TST     R11,#mc_hasmask
                        BEQ     %FT61

                        ;if it has a new format mask, include the code to increment it
                        MOVS    R1,R11,LSR #mcb_sprtype
                        BEQ     %FT61

                        TST     R11,#mc_plotmask
                        BNE     %FT61

                        LDR     R1,save_inlog2bpp
                        MOV     R0,#32
                        MOV     R0,R0,LSR R1

                        GetAsm  msk_increment1
                        SetImm  R5,R0
                        PutAsm  msk_increment1

                        Asm     msk_increment2
                        Asm     msk_increment3

61
                        CMP     vv_inbpp,#32
                        BCS     %FT48

                        GetAsm  p_newword
                        RSB     R0,vv_inbpp,#32                ; R0 = 32-inbpp
                        SetLsl  R2,R0
                        SetLsr  R3,vv_inbpp
                        PutAsm  p_newword
                        B %FT49
48
                        Asm     p_newword32
49
                        Debug   cw,"p_newword"
                        MOV     PC,LR
01
                        TST     R11,#mc_hasmask
                        BEQ     %FT47
;
                        MOVS    R1,R11,LSR #mcb_sprtype
                        BEQ     %FT71

                        CMP     vv_outbpp,#16
                        Asm     tm1_newword1,LT
                        GetAsm  tm1_newword2,LT
                        SetImm  R2,vv_outbpptop,LT
                        PutAsm  tm1_newword2,LT

                        Asm     tm1_newword1ext,GE
                        Asm     tm1_newword2ext,GE
                        B       %FT47

71
                        CMP     vv_outbpp,#16
                        Debug   cw,"tm_newword"
                        GetAsm  tm_newword,LT                   ; pick up code for 8 bpp or less
                        SetImm  R5,vv_outbpptop,LT              ; and modify the mask writing instruction
                        GetAsm  tm_newword_ext,GE               ; otherwise pick up code for greater depths
                        SetLsr  R3,vv_inbpp
                        PutAsm  tm_newword,LT                   ; always modify based on input bpp and write instructions
                        PutAsm  tm_newword_ext,GE
47

                        TST      R11,#mc_hasmask
                        MOVNES   R1,R11,LSR #mcb_sprtype
                        BEQ      %FT62
                        TST      R11,#mc_plotmask
                        BNE      %FT62

                        LDR     R1,save_inlog2bpp
                        MOV     R0,#32
                        MOV     R0,R0,LSR R1
                        GetAsm  msk_increment1
                        SetImm  R5,R0
                        PutAsm  msk_increment1
                        Asm     msk_increment2
                        Asm     msk_increment3
62
                        CMP     vv_inbpp,#16

                        Asm     t_newword32,GT

                        Asm     t_newword161,EQ
                        Asm     t_newword162,EQ

                        MOVCS   PC,LR

                        Debug   cw,"t_newword"
                        GetAsm  t_newword
                        SetImm  R2,vv_inbpp1
                        SetLsr  R3,vv_inbpp
                        PutAsm  t_newword

                        MOV     PC,LR
02
                        TST     R11,#mc_hasmask                 ; nothing at all if no mask
                        [ debugcw
                        BEQ     %FT03
                        Debug   cw,"m_newword" ;debugging macro is not conditional. pah!
03
                        ]
                        MOVEQ   PC,LR

                        MOVS    R2,R11,LSR #mcb_sprtype

                        GetAsm  m_newword,EQ
                        SetLsr  R2,vv_inbpp,EQ
                        PutAsm  m_newword,EQ

                        MOVEQ   PC,LR

                        MOV     R0,#32
                        GetAsm  m1_newword1
                        SetImm  R5,R0
                        PutAsm  m1_newword1

                        Asm     m1_newword2
                        Asm     m1_newword3

                        MOV     PC,LR

; second version, for use with prevailing NE execution
; unfortunately it has to change flags itself...

msk_incrementne1        STRNE   im1,stack_temp1
                        STRNE   im2,stack_temp2
                        LDRNE   im1,stack_maskinshift
                        BICNE   im1,im1,#xxx                 ;pixels per word -1
msk_incrementne1end     LDRNE   im2,stack_maskinptr
msk_incrementne2        ADDNE   im1,im1,#xxx             ;pixels per word
                        BEQ     %FT98                    ;skip the next bit if not executing
                        CMP     im1,#32
                        ADDCS   im2,im2,#4
msk_incrementne2end     MOVCS   im1,#0
msk_incrementne3        STR     im1,stack_maskinshift
                        CMP     R13,#0                   ;reset NE
98
                        STRNE   im2,stack_maskinptr
                        LDRNE   im1,stack_temp1
msk_incrementne3end     LDRNE   im2,stack_temp2


t_start                 LDR     ttr,stack_colourttr
t_startend              *       t_start

pmt_start               TEQ     inshift,#0
pmt_startend            MOVEQ   in1,#0

p_start                 LDRNE   im1,[inptr,masko]
p_startend              MOVNE   im1,im1,LSR inshift

p1_start1               LDRNE   im1,stack_maskinptr
                        LDRNE   im1,[im1]
                        STRNE   im2,stack_temp1
p1_start1end            LDRNE   im2,stack_maskinshift
p1_start2               MOVNE   im1,im1,LSR im2
p1_start2end            LDRNE   im2,stack_temp1


t_start2                LDRNE   im1,stack_masko
                        LDRNE   im1,[inptr,im1]
t_start2end             MOVNE   im1,im1,LSR inshift


t1_start212             STRNE   im2,stack_temp1
                        LDRNE   im1,stack_maskinptr
t1_start212end          LDRNE   im2,stack_maskinshift
t1_start222             LDRNE   im1,[im1]
                        MOVNE   im1,im1,LSR im2
t1_start222end          LDRNE   im2,stack_temp1

pmt_start2              LDRNE   in1,[inptr],#4
pmt_start2end           MOVNE   in1,in1,LSR inshift

pmt1_start2             LDRNE   im1,stack_maskinptr
                        LDRNE   im2,stack_maskinshift
                        LDRNE   in1,[im1]
pmt1_start2end          MOVNE   in1,in1,LSR im2


pt_start                ANDNE  in1,in1,im1
pt_startend             *       pt_start

pmt_start3              MOVNE   R14,#1
                        ORRNE   in1,in1,R14,ROR inshift
pmt_start3end           SUB     xcount,xcount,xadd

mm_start                MOV     in2,#xxx                        ; outbpp_top
mm_startend             SUB     xcount,xcount,xadd

mm_start16              MOV     in2,#&FF000000
                        ORR     in2,in2,in2,LSR #8
mm_start16end           SUB     xcount,xcount,xadd

mm_start32              MVN     in2,#0 ; &FFFFFFFF
mm_start32end           SUB     xcount,xcount,xadd

asm_start
                        Debug   cs,"*** asm_start"

                        [ multibuffer
                        STMFD   R13!,{R1,R14}
                        ADR     R1,calladdr0
                        LDR     R14,thisslot
                        STR     R10,[R1,R14]
                        LDMFD   R13!,{R1,R14}
                        |
                        STR     R10,save_calladdr
                        ]
;
                        AND     R0,R11,#mc_plotmask:OR:mc_hasmask
                        TEQ     R0,#mc_plotmask
                        BNE     %FT19
                        [ debugcs
                        Debug   cs,"mm_start(EQ)"
                        ]
                        CMP     vv_outbpp,#16
                        Asm     mm_start16,EQ
                        Asm     mm_start32,GT
                        GetAsm  mm_start,LT            ; all we need is in2, if no mask
                        SetImm  R1,vv_outbpptop,LT
                        PutAsm  mm_start,LT

                        MOV     PC,LR
19
;
                        TST     R11,#mc_ttr

                        Asm     t_start,NE
;
                        Debug   cs,"pmt_start"
                        Asm     pmt_start
                        TST     R11,#mc_plotmask
                        BNE     %FT01
                        TST     R11,#mc_hasmask
                        BEQ     %FT01
                        TST     R11,#mc_ttr
                        [ debugcs
                        B       %FT10
11      ; code is at end of routine - breaks an ADR otherwise!
                        ]
                        BNE     %FT16
                        MOVS    R1,R11,LSR #mcb_sprtype
                        Asm     p_start,EQ
                        Asm     p1_start1,NE
                        Asm     p1_start2,NE
                        B       %FT01
16
                        MOVS    R1,R11,LSR #mcb_sprtype
                        Asm     t_start2,EQ
                        Asm     t1_start212,NE
                        Asm     t1_start222,NE
01
                        Debug   cs,"pmt_start2"

        ; if plotting a 1bpp mask we don't use pmt_start2

                        TST     R11,#mc_plotmask
                        MOVNES  R2,R11,LSR #mcb_sprtype
                        BEQ     %FT09

                        Asm     pmt1_start2

                        B       %FT08

09
                        Asm     pmt_start2
08

                        TST     R11,#mc_plotmask
                        BNE     %FT02
                        TST     R11,#mc_hasmask
                        [ debugcs
                        BNE     %FT05
                        Debug   cs,"pt_start"
05
                        ]

        ; this segment does nothing useful since mask and image data are combined
        ; again below ... when dealing with 1bpp masks it becomes quite harmful
        ; since we are directly applying 1bpp data to nbpp data!

        ; Asm     pt_start,NE

02
                        TST     R11,#mc_hasmask
                        MOVNES  R1,R11,LSR #mcb_sprtype
                        BEQ     %FT17

; AMG bug-fix from SprExtend 0.53 merged in by WRS:
; changed assembler to reflect AMG bug fix in 0.62 (GPS)
                        LDR     R1,save_inlog2bpp
                        MOV     R0,#32
                        TST     R11,#mc_plotmask
                        MOVEQ   R0,R0,LSR R1        ; derive pix per word
                        SUB     R0,R0,#1

                        GetAsm  msk_incrementne1
;                        MOV     R0,#&1F
                        SetImm  R4,R0
                        PutAsm  msk_incrementne1

                        ADD     R0,R0,#1

                        GetAsm  msk_incrementne2
;                        MOV     R0,#32
                        SetImm  R1,R0
                        PutAsm  msk_incrementne2

                        Asm     msk_incrementne3

17
                        Debug   cs,"pmt_start3"
                        Asm     pmt_start3
                        MOV     PC,LR

                        [ debugcs
10
                        BNE     %FT03
                        Debug   cs,"p_start (NE)"
                        BEQ     %FT04
03                      Debug   cs,"t_start2 (EQ)"
04                      B       %BT11
                        ]


pmt_newpixel            ADD     xcount,xcount,xadd
pmt_newpixelend         *       pmt_newpixel

pt_newpixel             MOVS    im1,im1,LSR #xxx        ; inbpp
                        MOVCS   im2,#0
pt_newpixelend          MOVCC   im2,#xxx                ; (2^outbpp-1) ROR outbpp

pt1_newpixel            MOVS    im1,im1,LSR #1        ; inbpp
                        MOVCS   im2,#0
pt1_newpixelend         MOVCC   im2,#xxx                ; (2^outbpp-1) ROR outbpp

p_newpixel              MOV     in2,in1,LSL #xxx        ; 32-inbpp
p_newpixelend           MOVS    in1,in1,LSR #xxx        ; inbpp

t_newpixel              AND     in2,in1,#xxx            ; 2^inbpp-1
t_newpixelend           MOVS    in1,in1,LSR #xxx        ; inbpp

t_newpixel16            MOV     in2,in1
t_newpixel16end         MOVS    in1,in1,LSR #16

t_newpixel32            MOV     in2,in1
                        MOV     in1,#1
t_newpixel32end         MOVS    in1,in1,LSR #1

m1_newpixel             MOVS    in1,in1,LSR #1       ; inbpp
m1_newpixelend          *       m1_newpixel

m_newpixel              MOVS    in1,in1,LSR #xxx        ; inbpp
m_newpixelend           *       m_newpixel

m_newpixel32            MOV     in1,#1
m_newpixel32end         MOVS    in1,in1,LSR #1

m_newpixel2             MOVCC   in2,#0
m_newpixel2end          MOVCS   in2,#xxx                ; (2^outbpp-1) ROR outbpp

; ##### the macro generator should not be thrown more than five instructions
; ##### at a time, otherwise vv_inbpp (R6) gets cr*pped on !!!!!

t_newpx_16to321
                                                          ;       fedcba9876543210 fedcba9876543210
                                                          ; in2 = 0bbbbbgggggrrrrr
                        STR     im1,stack_temp1
                        MOV     im1,in2,LSR #26           ; im1 =                            0bbbbb
                        MOV     ttr,im1,LSL #19           ; ttr =        0bbbbb000 0000000000000000
                        AND     im1,in2,#&03E00000        ; im1 = 000000ggggg00000
t_newpx_16to321end      ORR     ttr,ttr,im1,LSR #10       ; ttr =        0bbbbb000 ggggg00000000000
t_newpx_16to322         MOV     im1,in2,LSL #11           ; im1 = rrrrr00000000000 0000000000000000
                        ORR     ttr,ttr,im1,LSR #24       ; ttr =        0bbbbb000 ggggg000rrrrr000
        ;now copy the top three bits of each colour component into the bottom three
                        MOV     im1,#&E0                  ;avoid an LDR for speed
                        ORR     im1,im1,im1,LSL #8
t_newpx_16to322end      ORR     im1,im1,im1,LSL #8        ; im1 = 0000000011100000 1110000011100000
t_newpx_16to323         AND     im1,im1,ttr               ; im1 = 00000000bbb00000 ggg00000rrr00000
                        ORR     in2,ttr,im1,LSR #5        ; in2 = 00000000bbbbbbbb ggggggggrrrrrrrr
t_newpx_16to323end      LDR     im1,stack_temp1

                                                              ;       fedcba9876543210 fedcba9876543210
t_newpx_32to161
                                                              ; in2 = 00000000bbbbbbbb ggggggggrrrrrrrr
                        AND     xadd,in2,#&F80000             ; im1 = 00000000bbbbb000 0000000000000000
                        MOV     ttr,xadd,LSL #7               ; ttr = 0bbbbb0000000000
                        AND     xadd,in2,#&F800               ; im1 = 0000000000000000 ggggg00000000000
t_newpx_32to161end      ORR     ttr,ttr,xadd,LSL #10          ; ttr = 0bbbbbggggg00000
t_newpx_32to162         AND     xadd,in2,#&F8                 ; im1 = 0000000000000000 00000000rrrrr000
                        ORR     in2,ttr,xadd,LSL #13          ; in2 = 0bbbbbgggggrrrrr
                        LDR     xadd,stack_xadd
t_newpx_32to162end      LDR     ttr,stack_colourttr

t_newpixel2             LDRB    in2,[ttr,in2]
t_newpixel2end          MOV     in2,in2,ROR #xxx        ; outbpp

                        [ ignore_ttr
t_newpixel3             LDR    in2,[ttr,in2,LSL #3]
t_newpixel3end          MOV    in2,in2,LSR #8
                 ; if 16 need to munge down into top two bytes, if 32 no
                 ; adjustment needed
                        ]

pt_newpixel_ext         MOVS    im1,im1,LSR #xxx        ; inbpp
                        MOVCS   im2,#0
pt_newpixel_extend      LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp
                        ASSERT  (pt_newpixel_extend -pt_newpixel_ext) = (pt_newpixelend -pt_newpixel)

pt1_newpixel_ext        MOVS    im1,im1,LSR #1        ; inbpp
                        MOVCS   im2,#0
pt1_newpixel_extend     LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp
                        ASSERT  (pt_newpixel_extend -pt_newpixel_ext) = (pt_newpixelend -pt_newpixel)

t_makeindex321          ;the 32K table use bits of r,g,b as the index, so 32bpp needs to
                        ;be munged down into 5bits of each colour
                        STR      im1,stack_temp1
                        ;im1 is being used as a temporary register here
                                                     ; in2 = 0000 0000 bbbb bbbb gggg gggg rrrr rrrr
                        MOV      im1,in2,LSR #19     ; im1 = 0000 0000 0000 0000 0000 0000 000b bbbb
                        MOV      im1,im1,LSL #5      ; im1 = 0000 0000 0000 0000 0000 00bb bbb0 0000
t_makeindex321end       MOV      in2,in2,LSL #16     ; in2 = gggg gggg rrrr rrrr 0000 0000 0000 0000
t_makeindex322          ORR      im1,im1,in2,LSR #27 ; im1 = 0000 0000 0000 0000 0000 00bb bbbg gggg
                        MOV      im1,im1,LSL #5      ; im1 = 0000 0000 0000 0000 0bbb bbgg ggg0 0000
                        MOV      in2,in2,LSL #8      ; in2 = rrrr rrrr 0000 0000 0000 0000 0000 0000
                        ORR      in2,im1,in2,LSR #27 ; in2 = 0000 0000 0000 0000 0bbb bbgg gggr rrrr
t_makeindex322end       LDR      im1,stack_temp1


t_makeindex16           MOV      in2,in2,LSL #17
t_makeindex16end        MOV      in2,in2,LSR #17

t_use32Ktable           ;note, there is an additional indirection to play with here!
                        STR     im1,stack_temp1
                        LDR     im1,[ttr,#4]
                        LDRB    in2,[im1,in2]
                        LDR     im1,stack_temp1
t_use32Ktableend        MOV     in2,in2,ROR #xxx ;outbpp


t_newpixel216           LDR     in2,[ttr, in2, ASL #2]
t_newpixel216end        MOV     in2,in2,ROR #xxx     ; outbpp
                        ASSERT  (t_newpixel216end -t_newpixel216) = (t_newpixel2end -t_newpixel2)

t_newpixel232           LDR     in2,[ttr, in2, ASL #2]
t_newpixel232end        NOP
                        ASSERT  (t_newpixel232end -t_newpixel232) = (t_newpixel2end -t_newpixel2)


m_newpixel2_ext         MOVCC   in2,#0
m_newpixel2_extend      LDRCS   in2,stack_maskword      ; (2^outbpp-1) ROR outbpp
                        ASSERT  (m_newpixel2_extend -m_newpixel2_ext) = (m_newpixel2end -m_newpixel2)
asm_newpixel
                        Label   l_newpixel

                        Debug   cn,"*** asm_newpixel"
;
                        Debug   cn,"pmt_newpixel"
                        Asm     pmt_newpixel
;
                        TST     R11,#mc_plotmask
                        BEQ     %FT01
                        TST     R11,#mc_hasmask         ; if no mask, no code needed!
                        MOVEQ   PC,LR

                        MOVS    R2,R11,LSR #mcb_sprtype
                        Asm     m1_newpixel,NE
                        BNE     %FT02

                        CMP     vv_inbpp,#32

                        Debug   cn,"m_newpixel"

                        Asm     m_newpixel32,CS
                        BCS     %FT02

                        GetAsm  m_newpixel
                        SetLsr  R1,vv_inbpp
                        PutAsm  m_newpixel
                        B       %FT02
01
                        TST     R11,#mc_hasmask
                        BEQ     %FT47

                        MOVS    R1,R11,LSR #mcb_sprtype
                        BEQ     %FT46

                        CMP     vv_outbpp,#16

                        GetAsm  pt1_newpixel,LT
                        SetImm  R3,vv_outbpptop,LT
                        PutAsm  pt1_newpixel,LT

                        Asm     pt1_newpixel_ext,GE
                        B       %FT47
46
                        CMP     vv_outbpp,#16
                        Debug   cn,"newpixel"
                        GetAsm  pt_newpixel,LT        ; pick up and modify the appropriate code
                        GetAsm  pt_newpixel_ext,GE
                        SetLsr  R1,vv_inbpp
                        SetImm  R3,vv_outbpptop,LT
                        PutAsm  pt_newpixel,LT
                        PutAsm  pt_newpixel_ext,GE
47
                        Debug   cn,"adding two words for ttr"

                        ;if doing 16->32 or 32->16

                        TST     R11,#mc_ttr
                        BNE     %FT51
                        ADR     R1,p_newpixel
                        LDMIA   R1,{R1,R2}
                        RSB     R0,vv_inbpp,#32
                        SetLsl  R1,R0
                        SetLsr  R2,vv_inbpp
                        STMIA   R10!,{R1-R2}
                        B       %FT02
51
                        CMP     vv_inbpp,#16

                        ADRCC   R1,t_newpixel
                        ADREQ   R1,t_newpixel16
                        ADRHI   R1,t_newpixel32
                        LDMLSIA R1,{R1,R2}
                        LDMHIIA R1,{R1-R3}
                        SetImm  R1,vv_inbpp1,CC
                        SetLsr  R2,vv_inbpp,CC
52
                        STMLSIA   R10!,{R1,R2}
                        STMHIIA   R10!,{R1-R3}
02
                        Debug   cn,"Branch to l_newword"
                        Branch  BLEQ,l_newword

                        TST     R11,#mc_plotmask
                        BEQ     %FT47
;
                        Debug   cn,"newpixel2"
                        CMP     vv_outbpp,#16
                        GetAsm  m_newpixel2,LT
                        SetImm  R2,vv_outbpptop,LT
                        PutAsm  m_newpixel2,LT
                        Asm     m_newpixel2_ext,GE
47
;
                        TST     R11,#mc_ttr                             ; is there a translation table?
                        BNE     %FT53

        ;if we are doing 16->32 or 32->16 there is no translation table - instead
        ;a specific munger is used to bit shuffle the word.

                        CMP     vv_inbpp,vv_outbpp
                        BEQ     %FT54
                        CMP     vv_outbpp,#16
                        BCC     %FT54

                        CMP     vv_inbpp,#16
                        BCC     %FT54

        ;if EQ we are doing 16->32 otherwise it is 32->16

                        Asm     t_newpx_16to321,EQ
                        Asm     t_newpx_16to322,EQ
                        Asm     t_newpx_16to323,EQ
                        Asm     t_newpx_32to161,NE
                        Asm     t_newpx_32to162,NE
54
                        MOV   PC,LR
53
        ;if we are going from 16/32 to 8/less bpp we translate via a
        ;32K table, so check for these cases....

                        CMP     vv_outbpp,#16
                        BCS     %FT56
                        CMP     vv_inbpp,#16
                        BCC     %FT56

        ;if EQ it is input=16, else NE means 32 as input

                        Asm     t_makeindex321,NE
                        Asm     t_makeindex322,NE

                        Asm     t_makeindex16 ;always include it, to chop any high
                                              ;bits off

                        GetAsm  t_use32Ktable
                        SetLsr  R5,vv_outbpp
                        PutAsm  t_use32Ktable

                        MOV     PC,LR
56
                        [ ignore_ttr
                        ;if doing <16 to >8 then use the palette instead
                        CMP     vv_inbpp,#16
                        BCS     %FT57
                        CMP     vv_outbpp,#16
                        BCC     %FT57
                        TST     R11,#mc_ttrispalette
                        BEQ     %FT57

                        GetAsm  t_newpixel3
                        PutAsm  t_newpixel3

                        CMP     vv_outbpp,#32
                        Asm     t_newpx_32to161,NE
                        Asm     t_newpx_32to162,NE

                        B       %FT03
57
                        ]
                        CMP     vv_outbpp,#16                           ; decide which translation function

                        GetAsm t_newpixel2,LT                          ; getting the one required
                        GetAsm t_newpixel216,EQ
                        Asm    t_newpixel232,GT
                        SetLsr R2,vv_outbpp,LE
                        PutAsm t_newpixel2,LT
                        PutAsm t_newpixel216,EQ
03
                        MOV     PC,LR

                        [ debugcn
10
                        Debug  cg,"t_newpixel2"
                        B      %BT11
                        ]

pmt_tryoutput           SUBS    xcount,xcount,xdiv

ptm_tryoutput           ORR     outmask,im2,outmask,LSR #xxx    ; outbpp
pt_tryoutput            MOV     outmask,outmask,LSR #xxx        ; outbpp

ptm32_tryoutput         MOV     outmask,im2
pt32_tryoutput          MOV     outmask,#0

pmt_tryout2             ORRS    outword,in2,outword,LSR #xxx    ; outbpp
                        MOV     R14,R14         ; branch
pmt_tryout2end          SUBS    xsize,xsize,#1

pmt_tryout32            MOVS    outword,in2     ; nothing to mask through
                        MOV     R14,R14         ; branch
pmt_tryout32end         SUBS     xsize,xsize,#1

pmt_tryoutput4          LDR     PC,stack_returnaddr

asm_tryoutput
                        Label   l_tryoutput
                        Debug   co,"*** asm_tryoutput" ;
                        Debug   co,"pmt_tryoutput (1 word)"
                        LDR     R1,pmt_tryoutput
                        STR     R1,[R10],#4
                        Debug   co,"branch to l_newpixel"
                        Branch  BCC,l_newpixel
;
                        TST     R11,#mc_plotmask
                        BNE     %FT01
;
                        Debug   co,"ptm/pt_tryoutput (1 word)"

                        CMP     vv_outbpp,#32
                        BLT     %FT10
                        ;new code to make 32 bit go
                        TST     R11,#mc_hasmask
                        LDRNE   R1,ptm32_tryoutput
                        LDREQ   R1,pt32_tryoutput
                        B       %FT11
10
                        TST     R11,#mc_hasmask
                        LDRNE   R1,ptm_tryoutput
                        LDREQ   R1,pt_tryoutput
                        SetLsr  R1,vv_outbpp
11
                        STR     R1,[R10],#4
01
                        Debug   co,"Skipping a word"
                        ADD     R0,R10,#4
                        STR     R0,[sp,#l_fref]         ; forward reference filled in later
                        Debug   co,"tryout2"
                        CMP     vv_outbpp,#32
                        GetAsm  pmt_tryout2,NE
                        GetAsm  pmt_tryout32,EQ
                        SetLsr  R1,vv_outbpp,NE
                        PutAsm  pmt_tryout2,NE
                        PutAsm  pmt_tryout32,EQ
                        Debug   co,"branch l_tryoutput"
                        Branch  BGT,l_tryoutput
                        Debug   co,"pmt_tryoutput4 (1 word)"
                        LDR     R1,pmt_tryoutput4
                        STR     R1,[R10],#4
;
                        MOV     PC,LR

pmt_putmany             MOV     vcount,R14
pmt_putmanyend          MOV     xdiv,outptr

m_putmany               LDMDB   ecfptr!,{ecfora,ecfeor}
m_ecflimit              CMP     ecfptr,#xxx                     ; ecflimit
                        ADDLS   ecfptr,ecfptr,#64
                        AND     ecfora,ecfora,outword
m_putmanyend            AND     ecfeor,ecfeor,outword

pmt_putmany22           STR     R14,[outptr]                    ;   "
                        LDR     R14,stack_outoffset             ;   "
                        SUB     outptr, outptr, R14             ;   "
pmt_putmany22end        SUBS    vcount,vcount,#1                ;   "
m_putmany2              LDR     ecfptr,stack_ecfptr
m_putmany2end           *       m_putmany2

pmt_putmany3            ADD     outptr,xdiv,#4
                        LDR     xdiv,stack_xdiv
pmt_putmany3end         LDR     xadd,stack_xadd
                        ASSERT  vcount = xadd

asm_putmany
                        Label   l_putmany
                        Debug   cp,"*** asm_putmany"
                        Debug   cp,"pmt_putmany"
                        Asm     pmt_putmany
                        Debug   cp,"Label l_vloop"
                        Label   l_vloop
;
                        TST     R11,#mc_plotmask
                        MOVEQ   R0,#0
                        ADDNE   R0,R10,#4
                        [ multibuffer
                        STMFD   R13!,{R1,R14}
                        LDR     R14,thisslot
                        ADR     R1,pc_ecflimit0
                        STR     R0,[R1,R14]
                        LDMFD   R13!,{R1,R14}
                        |
                        STR     R0,pc_ecflimit                  ; remember for later
                        ]
                        Debug   cp,"m_putmany (NE)"
                        Asm     m_putmany,NE
;
                        Push    "LR"
                        Debug   cp,"asm_gcolaction"
                        BL      asm_gcolaction                  ; depends on GCOL action
                        [ multibuffer
                        STMFD   R13!,{R1,R14}
                        LDR     R14,thisslot
                        ADR     R1,pc_outoffset0
                        STR     R10,[R1,R14]
                        LDMFD   R13!,{R1,R14}
                        |
                        STR     R10,pc_outoffset                ; remember for later
                        ]

                        ; new version to get over implicit limit in old code
                        Asm     pmt_putmany22                   ; Merged from 0.62 (GPS)

                        Debug   cp,"branch on NE to l_vloop+4"
                        Branch  BNE,l_vloop+4                   ; allow for R14 on stack

;
                        TST     R11,#mc_plotmask
                        Debug   cp,"m_putmany2 (NE)"
                        Asm     m_putmany2,NE
;
                        Debug   cp,"pmt_putmany3"
                        Asm     pmt_putmany3
                        Debug   cp,"asm_nextword"
                        BL      asm_nextword
                        Pull    "PC"

pt_gcolprelude1         MVN     outword,outmask         ; Invert
pt_gcolprelude2         MVN     outword,outword         ; AND-NOT, ORR-NOT
pt_gcolprelude3         ORR     outword,outword,outmask

pt_putword              BIC     outword,outword,outmask
pt_putwordend           *       pt_putword

pmt_putword             LDR     R14,stack_vcount
pmt_putwordend          CMP     R14,#1

m_putword               LDMDB   ecfptr,{ecfora,ecfeor}
                        AND     ecfora,ecfora,outword
m_putwordend            AND     ecfeor,ecfeor,outword

pmt_putword2            STR     R14,[outptr],#4
pmt_putword2end         *       pmt_putword2

asm_putword
                        Debug   mc,"Putword is at",R10
                        Debug   cg,"Putword is at",R10
                        [ multibuffer
                        STMFD   R13!,{R1,R14}
                        ADR     R1,calladdr20
                        LDR     R14,thisslot
                        STR     R10,[R1,R14]
                        LDMFD   R13!,{R1,R14}
                        |
                        STR     R10,save_calladdr2
                        ]
                        Label   l_putword
                        TST     R11,#mc_plotmask
                        BNE     %FT01
                        AND     R0,R11,#mc_gcol
                        CMP     R0,#4
                        LDREQ   R1,pt_gcolprelude1              ; Invert
                        LDRGT   R1,pt_gcolprelude2              ; AND-NOT, ORR-NOT
                        STRGE   R1,[R10],#4
                        CMP     R0, #2
                        LDREQ   R1,pt_gcolprelude3              ; AND - bug fix
                        STREQ   R1,[R10],#4
                        CMPNE   R0, #6
                        Asm     pt_putword,NE
01
                        Asm     pmt_putword
                        Branch  BGT,l_putmany
;
                        TST     R11,#mc_plotmask
                        Asm     m_putword,NE
;
                        Push    "LR"
                        BL      asm_gcolaction                  ; depends on GCOL action
                        Asm     pmt_putword2
                        BL      asm_nextword
                        Pull    "PC"

pmt_nextword            MOV     outword,#&80000000
                        MOV     outmask,#0
pmt_nextwordend         SUBS    xsize,xsize,#1

pmt_nextword2           LDR     PC,stack_returnaddr
pmt_nextword2end        *     pmt_nextword2

asm_nextword            Asm     pmt_nextword
                        Branch  BGT,l_tryoutput+4               ; allow for R14 on stack
                        Asm     pmt_nextword2
                        MOV     PC,LR

pmt_gcol                LDR     R14,[outptr]

pt_gcolactions          AND     R14,R14,outmask         ; Store actually uses 2 instrs
                        ORR     R14,R14,outword
                        AND     R14,R14,outword
                        EOR     R14,R14,outword
                        EOR     R14,R14,outword         ; MVN outword,outmask
                        MOVNV   R14,R14
                        AND     R14,R14,outword         ; MVN outword,outword
                        ORR     R14,R14,outword         ; MVN outword,outword

m_gcolaction            ORR     R14,R14,ecfora
                        EOR     R14,R14,ecfeor

asm_gcolaction
                        LDR     R1,pmt_gcol
                        ADR     R2,pt_gcolactions
                        EOR     R0,R11,#mc_plotmask
                        TST     R0,#mc_plotmask
                        ADREQ   R2,m_gcolaction
                        ANDNES  R0,R11,#mc_gcol
                        LDMEQIA R2,{R2,R3}                      ; 2 instructions for STORE/mask
                        LDRNE   R2,[R2,R0,LSL #2]               ; 1 instruction for others
                        STMEQIA R10!,{R1-R3}
                        STMNEIA R10!,{R1-R2}
                        MOV     PC,LR

      ]

;;-----------------------------------------------------------------------------
;; Merge Sprites (horizontally or vertically)
;;
;; Entry:  R0 = reason code
;;         R1 = areaCBptr
;;         R2 = name/ptr of 1st sprite
;;         R3 = name/ptr of 2nd sprite
;;         R4 = flags (0 ==> merge horizontally, else vertically)
;; Exit:   1st sprite is result of merging both
;;         2nd sprite is deleted
;;         scratch space used (no extra memory apart from that)
;;-----------------------------------------------------------------------------


;
; Algorithm:
;       check that sprites are compatible - if not, give error/adjust sprite
;       move sprite2 to end of sprites
;       move sprite1 just before sprite2
;       eliminate sprite2 header
;       if masked, swap(mask1,data2)
;       if R4=0 (horiz. merge) interleave rows of data (& then masks if nec)
;       reclaim wastage (depends on h/v merge) of data + masks
;       correct sprite end ptrs, no of sprites etc.
;       correct size of sprite
;

Go_AppendSprite
        Push    "R1-R11,LR"
;
        CLRPSR  I_bit, R14              ; re-enable interrupts
;
        BL      findsprite
;        BLVC    TestForMaskAtDepth       Removed in merge with 0.62 (GPS)
        STRVC   R1,sp1_areaCBptr        ; R1 may be updated if system area
        MOVVC   R5,R2                   ; R5 --> first sprite
        MOVVC   R2,R3
        BLVC    findsprite              ; R2 --> second sprite
;        BLVC    TestForMaskAtDepth       Removed in merge with 0.62 (GPS)
        BVS     %FT99
;
; check that sprites are defined in the same mode
;
        TEQ     R2,R5                   ; same sprite?
        BEQ     badappend
        LDR     R14,[R2,#spMode]
        LDR     R0,[R5,#spMode]
        Debug   ag,"Modes are",R0,R14   ; Merged from 0.62 (GPS)
        TEQ     R0,R14
        BNE     badappend               ; can't merge different modes
;
; check that rows/columns are same (depends on R4)
;
        TEQ     R4,#0                   ; R4=0 ==> horiz merge (check rows)
        BNE     %FT01
;
        LDR     R14,[R2,#spHeight]
        LDR     R0,[R5,#spHeight]
        Debug   ag,"Heights are",R0,R14 ; Merged from 0.62 (GPS)
        TEQ     R0,R14
        BEQ     %FT02
badappend
        Debug   ag,"Bad append, setting up error block and exiting"
        ADR     R0, ErrorBlock_BadAppend
        addr    r1, Title
        BL      copy_error_one          ; Always sets the V bit
        B       %FT99
        MakeSpriteErrorBlock BadAppend,,AppErr

01
        Push    "R2"
        BL      getspritewidth          ; R2 --> sprite defn, R3 = width
        MOV     R2,R5
        MOV     R6,R3
        BL      getspritewidth
        Pull    "R2"
        Debug   ag,"Widths are",R3,R6   ; Merged from 0.62 (GPS)
        TEQ     R3,R6
        BNE     badappend
02
;
; if one has a mask & the other doesn't, create mask
;
        LDR     R14,[R2,#spImage]
        LDR     R0,[R2,#spTrans]
        EORS    R6,R0,R14
        MOVNE   R6,#-1                  ; R6 = (2nd sprite has mask)
        LDR     R14,[R5,#spImage]
        LDR     R0,[R5,#spTrans]
        EORS    R0,R0,R14
        MOVNE   R0,#-1
        TEQ     R0,R6                   ; if same, skip next bit
        BEQ     %FT01
;
        Debug   ag,"One of the sprites has no mask"   ; Merged from 0.62 (GPS)
        Push    "R2"
        TEQ     R6,#0
        MOVNE   R2,R5                   ; if 2nd sprite has mask, enmask 1st
        MOV     R0,#SpriteReason_CreateMask
        ADD     R0,R0,#&200             ; since R2 --> sprite definition
        BL      Go_SpriteOp             ; call MOS version
        Pull    "R2"
        BVS     %FT99                   ; error (eg. memory full)
01
;
; move sprites to end of memory (need to get addresses back again)
;
        pullx   "R1-R3"
;
        BL      findsprite
        MOVVC   R5,R2                   ; R5 --> first sprite
        MOVVC   R2,R3
        BLVC    findsprite              ; R2 --> second sprite
        BVS     %FT99

        Debug   ag,"First sprite is at",R5      ; Merged from 0.62 (GPS)
        Debug   ag,"Second sprite is at",R2     ; Merged from 0.62 (GPS)
;
        LDR     R3,[R1,#saFree]         ; R3 --> end of sprites
        Debug   ag,"End of sprite area is",R3   ; Merged from 0.62 (GPS)
        ADD     R3,R1,R3
        MOV     R1,R2                   ; R1 --> sprite2
        LDR     R2,[R1,#spNext]
        ADD     R2,R1,R2                ; R2 --> end of sprite2
        Debug   ag,"End of sprite2 is",R2       ; Merged from 0.62 (GPS)
        BL      swapblocks
        MOV     R6,R1                   ; R6 --> sprite2 (in new position)
;
        CMP     R5,R2                   ; if sprite1 was after sprite2
        DebugIf CS,ag,"Sprite1 was after sprite2"   ; Merged from 0.62 (GPS)
        SUBCS   R14,R3,R1
        SUBCS   R5,R5,R14               ; move down by (R3-R1) ie. sprite2 size
;
        MOV     R3,R1
        MOV     R1,R5                   ; R1 --> sprite1
        LDR     R2,[R1,#spNext]
        ADD     R2,R1,R2
        Debug   ag,"End of sprite1 is",R2     ; Merged from 0.62 (GPS)
        BL      swapblocks              ; R1 --> sprite1 (in new position)
;
; note the sprite mode of sprite 1 (should = sprite2)
; and the spNext parameter of sprite 2
;
        LDR     R2, [R1,#spMode]        ; Merged from 0.62 (GPS)
        STR     R2, sp_mode             ; Merged from 0.62 (GPS)
        LDR     R2, [R6,#spNext]        ; Merged from 0.62 (GPS)
        STR     R2, sp2_next            ; Merged from 0.62 (GPS)
;
; note down sprite1's header
;
        MOV     R2,R1
        ADRL    R3,sp1_data
        BL      savespriteheader        ; sets up R5,R7-R11
;
; note down sprite2's header, and delete it
;
        MOV     R2,R6
        ADRL    R3,sp2_data
        BL      savespriteheader        ; sets up R5,R7-R11
;
        MOV     R1,R6                   ; destination
        ADD     R2,R1,R10               ; source (image)
        LDR     R3,[R1]
        SUB     R3,R3,R10               ; counter
        BL      copyblock               ; R3 bytes from R2 to R1
        MOV     R2,R6                   ; R2 --> sprite2 image
;
; if there is a mask (new or old), swap (mask1, image2) & do both sets of data
;
        SUBS    R11,R11,R10             ; offset from image to mask (sprite2)
        BEQ     %FT01
;
        Debug   ag,"These sprites have masks!"        ; Merged from 0.62 (GPS)
        LDR     R1,sp1_header
        LDR     R14,[R1,#spTrans]       ; R1 --> start of sprite1 mask
        ADD     R1,R1,R14               ; R2 --> sprite2 image
        ADD     R3,R2,R11               ; R3 --> end of sprite2 image
        BL      swapblocks              ; R2, R1 --> image2, mask1
;
        Push    "R1,R3"
;
        MOV     R3,R1                   ; R3 --> end of image2
        LDR     R1,sp1_header
        SUB     R14,R3,R1
        STR     R14,sp1_trans           ; for later
        LDR     R14,sp1_image
        ADD     R1,R1,R14               ; R1 --> start of image1
        BL      mergeblocks             ; takes note of R4
;
        Pull    "R1,R2"                 ; R1 --> mask1, R2 --> mask2
        LDR     R3,sp2_trans
        LDR     R14,sp2_next            ; Merged from 0.62 (GPS)
;        LDR     R14,sp2_image
        SUB     R3,R14,R3               ; R3 = size of mask2 (poss+) - From 0.62 (GPS)
;        SUB     R3,R3,R14               ; R3 = size of image2 (=size of mask2)
        ADD     R3,R2,R3                ; R3 --> end of mask2
        LDR     R14,sp1_header
        SUB     R14,R1,R14
;        STR     R14,sp1_trans           ; transparency mask offset (???!)
;        BL      mergeblocks            merged from 0.62 (GPS)
        Push    "R14"                   ; merged from 0.62 (GPS)
        LDR     R14, sp_mode            ; merged from 0.62 (GPS)
        MOVS    R14, R14, LSR #27       ; Old or new?                 merged from 0.62 (GPS)
        Pull    "R14"                                               ; merged from 0.62 (GPS)
        DebugIf EQ,ag,"Old format mergeblocks to be executed"       ; merged from 0.62 (GPS)
        BLEQ    mergeblocks             ;   if old format             merged from 0.62 (GPS)
        DebugIf NE,ag,"New format mergeblocks to be executed"       ; merged from 0.62 (GPS)
        BLNE    maskmergeblocks         ;   if new format             merged from 0.62 (GPS)
        B       %FT02
;
; otherwise just merge the images
;
01
        Debug   ag,"These sprites don't have masks"                 ; merged from 0.62 (GPS)
        LDR     R1,sp1_header
        LDR     R14,sp1_image
        ADD     R1,R1,R14               ; R1 --> sprite1 image
        LDR     R2,sp2_header           ; R2 --> sprite2 image
        LDR     R14,sp2_imagesize
        ADD     R3,R2,R14               ; R3 --> end of sprite2 image
        BL      mergeblocks
02
;
; now rationalise the final image - shunt all bits down
;
        Debug   ag,"Now rationalising..."          ; merged from 0.62 (GPS)
        LDR     R2,sp1_header
        LDR     R3,sp1_image
        ADD     R1,R2,R3
        MOV     R3,R1
        BL      chunterblock            ; R1 --> start of block
        LDR     R0,sp1_image
        LDR     R14,sp1_trans
        TEQ     R14,R0                  ; was there a mask?
;        SUBNE   R14,R3,R2                                          ; merged from 0.62 (GPS)
;        STRNE   R14,[R2,#spTrans]       ; point to it                merged from 0.62 (GPS)
;        BLNE    chunterblock            ; and process it             merged from 0.62 (GPS)
        BEQ     %FT03                   ; if not, skip the next bit
        SUB     R14,R3,R2                                           ; merged from 0.62 (GPS)
        STR     R14,[R2,#spTrans]       ; point to mask               merged from 0.62 (GPS)
        LDR     R14, sp_mode                                        ; merged from 0.62 (GPS)
        MOVS    R14, R14, LSR #27       ; New or old format mask?     merged from 0.62 (GPS)
        DebugIf EQ,ag,"Old format chunterblock to be executed"      ; merged from 0.62 (GPS)
        BLEQ    chunterblock            ; process old format mask     merged from 0.62 (GPS)
        DebugIf EQ,ag,"New format chunterblock to be executed"      ; merged from 0.62 (GPS)
        BLNE    maskchunterblock        ; process new format mask     merged from 0.62 (GPS)
;
03
        SUB     R14,R3,R2
        STR     R14,[R2,#spNext]        ; sprite size
        LDR     R2,sp1_areaCBptr
        SUB     R14,R3,R2
        STR     R14,[R2,#saFree]        ; area size
;
        LDR     R14,[R2,#saNumber]
        SUB     R14,R14,#1              ; sprite2 deleted
        STR     R14,[R2,#saNumber]

99
;        MOV     r0, #35                 ; merged from 0.62 (GPS)
        MOVVC   r0, #35                 ; made conditional to stop error block being junked (GPS)
        Pull    "R1-R11,PC"

;-------------------------------------------------------------------
; Chunterblock
;
; Entry:  R1 --> input data
;         R3 --> output data
;         R4 = 0/1 (horizontal/vertical merge)
;         [sp1/2_data] = original state of sprites
;         [sp1/2_imagesize] = amount of data to process
; Exit:   R1 --> end of input
;         R3 --> end of output
;         [[sp1_header]] contains correct width, height, lbit, rbit
;         sprite data crunched into shape
;
chunterblock
        Push    "R5-R11,LR"
        Debug   ag,"Chunterblock entry R1,R3,R4",R1,R3,R4
;
        TEQ     R4,#0
        BNE     %FT04
;
        LDR     R11,sp1_height          ; R11 = no of rows to do (-1)
01
        MOV     R10,R3                  ; original output ptr
;
        LDR     R5,sp1_width            ; R5 = no of intermediate words
        LDR     R6,sp1_lbit             ; R6 = input bit wastage on left
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        LDR     R8,sp1_rbit             ; bit non-wastage on right
        BL      chunterrow              ; R7 = no of bits set up in last word
;
        LDR     R5,sp2_width
        LDR     R6,sp2_lbit
        LDR     R8,sp2_rbit
        BL      chunterrow
;
        TEQ     R7,#0
        MOVEQ   R7,#32
        ADDNE   R3,R3,#4                ; skip last word if anything in it
;
        SUBS    R11,R11,#1
        BPL     %BT01
;
        B       setupwidth

04
        LDR     R11,sp1_height
01
        LDR     R5,sp1_width            ; R5 = no of intermediate words
        LDR     R6,sp1_lbit             ; R6 = input bit wastage on left
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        LDR     R8,sp1_rbit             ; bit non-wastage on right
        BL      chunterrow              ; R7 = no of bits set up in last word
        TEQ     R7,#0
        ADDNE   R3,R3,#4                ; skip last word if anything in it
;
        SUBS    R11,R11,#1
        BPL     %BT01
;
        LDR     R11,sp2_height
02
        MOV     R10,R3
        LDR     R5,sp2_width            ; R5 = no of intermediate words
        LDR     R6,sp2_lbit             ; R6 = input bit wastage on left
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        LDR     R8,sp2_rbit             ; bit non-wastage on right
        BL      chunterrow              ; R7 = no of bits set up in last word
        TEQ     R7,#0
        MOVEQ   R7,#32
        ADDNE   R3,R3,#4                ; skip last word if anything in it
;
        SUBS    R11,R11,#1
        BPL     %BT02
;
        LDR     R14,sp1_height
        LDR     R0,sp2_height
        ADD     R14,R14,R0
        ADD     R14,R14,#1              ; since each is <no of rows>-1
        STR     R14,[R2,#spHeight]
;
; R2 --> sprite header, R3-R10 = width of 1 row, R7 = spRBit+1, spLBit=0
;
setupwidth
        SUB     R14,R3,R10
        MOV     R14,R14,LSR #2
        SUB     R14,R14,#1
        STR     R14,[R2,#spWidth]       ; spWidth = no of words - 1
        MOV     R14,#0
        STR     R14,[R2,#spLBit]        ; spLBit = 0
        SUB     R7,R7,#1
        STR     R7,[R2,#spRBit]         ; spRBit = R7-1
;
        Debug   ag,"Chunterblock exit R1,R3,R4",R1,R3,R4

        Pull    "R5-R11,PC"



;-------------------------------------------------------------------
; Maskchunterblock
;
; Entry:  R1 --> input data
;         R3 --> output data
;         R4 = 0/1 (horizontal/vertical merge)
;         [sp1/2_data] = original state of sprites
;         [sp1/2_imagesize] = amount of data to process
; Exit:   R1 --> end of input
;         R3 --> end of output
;         [[sp1_header]] contains correct width, height, lbit, rbit
;         sprite data crunched into shape
;
; NOTE:   Only called for new format (1bpp) sprites
;
maskchunterblock
        Push    "R5-R11,LR"
;
        Debug   ag,"Chunterblock entry R1,R3,R4",R1,R3,R4

        TEQ     R4,#0                   ; Vertical or horizontal join?
        BNE     %FT04                   ; Go elsewhere if vertical join
;
        LDR     R11,sp1_height          ; R11 = no of rows to do (-1)
01
        MOV     R10,R3                  ; original output ptr
;
        LDR     R8,sp1_rbit
        LDR     R5,sp1_width            ; R5 = no of intermediate words
        BL      FindMaskWidth           ; Alters R5 & sets up R8 to Rbit
        MOV     R6,#0                   ; Lbit wastage = 0
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        BL      chunterrow              ; R7 = no of bits set up in last word
;
        LDR     R8,sp2_rbit
        LDR     R5,sp2_width
        BL      FindMaskWidth           ; Alters R5 & sets up R8 to Rbit for mask
        MOV     R6,#0                   ; Lbit wastage always = 0
        BL      chunterrow
;
        TEQ     R7,#0
        MOVEQ   R7,#32
        ADDNE   R3,R3,#4                ; skip last word if anything in it
;
        SUBS    R11,R11,#1              ; One line less to do...
        BPL     %BT01                   ; Do the next one
;
;        B       masksetupwidth
        Debug   ag,"Maskchunterblock exit R1,R3,R4",R1,R3,R4

        Pull    "R5-R11,PC"

04
        LDR     R11,sp1_height
01
        LDR     R8,sp1_rbit
        LDR     R5,sp1_width            ; R5 = no of intermediate words
        BL      FindMaskWidth           ; Convert R5 & set up R8
        MOV     R6,#0                   ; Lbit is zero for this format sprite
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        BL      chunterrow              ; R7 = no of bits set up in last word
        TEQ     R7,#0
        ADDNE   R3,R3,#4                ; skip last word if anything in it
;
        SUBS    R11,R11,#1
        BPL     %BT01
;
        LDR     R11,sp2_height
02
        MOV     R10,R3
        LDR     R8,sp2_rbit
        LDR     R5,sp2_width            ; R5 = no of intermediate words
        BL      FindMaskWidth
        MOV     R6,#0                   ; Lbit = 0 always
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        BL      chunterrow              ; R7 = no of bits set up in last word
        TEQ     R7,#0
        MOVEQ   R7,#32
        ADDNE   R3,R3,#4                ; skip last word if anything in it
;
        SUBS    R11,R11,#1
        BPL     %BT02
;
;        LDR     R14,sp1_height
;        LDR     R0,sp2_height
;        ADD     R14,R14,R0
;        ADD     R14,R14,#1              ; since each is <no of rows>-1
;        STR     R14,[R2,#spHeight]
        Pull    "R5-R11,PC"

;
; R2 --> sprite header, R3-R10 = width of 1 row, R7 = spRBit+1, spLBit=0
;
masksetupwidth
        SUB     R14,R3,R10
        MOV     R14,R14,LSR #2
        SUB     R14,R14,#1
        STR     R14,[R2,#spWidth]       ; spWidth = no of words - 1
        MOV     R14,#0
        STR     R14,[R2,#spLBit]        ; spLBit = 0
        SUB     R7,R7,#1
        STR     R7,[R2,#spRBit]         ; spRBit = R7-1
;
        Pull    "R2,R5-R11,PC"


;------------------------------------------------------------------------
; Chunterrow
;
; Entry:  R1 --> input data
;         R3 --> output data (some of 1st word may be valid)
;         R5 = no of whole words to do (excluding the end 2)
;         R6 = bit offset of 1st valid bit in input word
;         R7 = bit offset of 1st unused bit in output word
;         R8 = bit offset of last used bit in output word
; Exit:   R1 --> end of input data
;         R3 --> end of output data
;         R7 = no of valid bits in [R3] - 0..31 (if 32, output word & go on)
;
chunterrow
        Push    "R0,R5,R6,R8-R10,LR"
        Debug   ag,"Chunterrow entered R1,R3,R5-R8",R1,R3,R5,R6,R7,R8
;
        ADD     R8,R8,#1                ; make exclusive
        LDR     R0,[R1],#4
        MOV     R0,R0,LSR R6
        LDR     R14,[R3]
        RSB     R10,R7,#32              ; for later
        MOV     R14,R14,LSL R10
        MOV     R14,R14,LSR R10
        ORR     R14,R14,R0,LSL R7
        TEQ     R5,#0
        RSBEQ   R9,R6,R8                ; R9 = no of valid bits shifted in
        RSBNE   R9,R6,#32
        ADD     R7,R7,R9
        CMP     R7,#32
        SUBCS   R7,R7,#32
        STRCS   R14,[R3],#4
        MOVCS   R14,R0,LSR R10          ; R14 = rest of input word
        RSB     R9,R7,#32               ; R9 = no of bits to be carried over
;
; R14 = output word, R7 = no of valid bits, R1 --> input (from bit 0)
;
        TEQ     R5,#0
        BEQ     %FT05                   ; 1st word = last - we've finished!
;
        MOV     R6,#0
        SUBS    R5,R5,#1
        BEQ     %FT04                   ; middle section is null
;
        TEQ     R7,#0
        BNE     %FT02
01
        LDR     R14,[R1],#4             ; do this the quick way!
        STR     R14,[R3],#4
        SUBS    R5,R5,#1
        BNE     %BT01
        MOV     R14,#0                  ; no more bits remaining!
        B       %FT04
02
        LDR     R0,[R1],#4              ; R0 = input word - from bit 0
        ORR     R14,R14,R0,LSL R7
        STR     R14,[R3],#4
        MOV     R14,R0,LSR R9           ; R14 = remaining bits of R0
        SUBS    R5,R5,#1
        BNE     %BT02
;
; R1 --> final word of input, R3 --> next output word
; R14 = output word, R7 = no of valid bits, R6 = first valid bit in [R1]
;
04
        LDR     R0,[R1],#4              ; read final word
        MOV     R0,R0,LSR R6
        SUB     R8,R8,R6                ; no of bits used in R0
        ORR     R14,R14,R0,LSL R7
        ADD     R7,R7,R8
        CMP     R7,#32
        SUBCS   R7,R7,#32
        STRCS   R14,[R3],#4
        MOVCS   R14,R0,LSR R9
05
        TEQ     R7,#0                   ; avoid splattering next word of input
        STRNE   R14,[R3]                ; for next time
;
        Debug   ag,"Chunterrow exit R1,R3,R5-R8",R1,R3,R5,R6,R7,R8

        Pull    "R0,R5,R6,R8-R10,PC"


;----------------------------------------------------------------------
; Savespriteheader
;
; Entry:  R2 --> sprite definition
;         R3 --> where to put data
; Exit:   R5,R7-R11 = width,height,Lbit,Rbit,Image,Trans
;         also copied to [R3]
;         [R3,#header] = address of header block
;         [R3,#imagesize] = size of sprite image (excl. mask)
;
savespriteheader
        Push    "R2,LR"
;
        STR     R2,[R3,#sp1_header-sp1_data]
        LDR     R14,[R2],#spWidth
        LDMIA   R2,{R5,R7-R11}          ; width,height,Lbit,Rbit,Image,Trans
        STMIA   R3,{R5,R7-R11}
        Debug   ag,"Sprite header",R5,R7,R8,R9,R10,R11
        LDR     R14,[R1,#spNext]        ; Try & work out the image size
        TEQ     R10,R11                 ; Hang on, but is there a mask?
        LDRNE   R14,[R1,#spTrans]       ; Yes, so we have to work it out different
        SUB     R14,R14,R10             ; Convert the offset to a 'size'
        STR     R14,[R3,#sp1_imagesize-sp1_data]
;
        Pull    "R2,PC"

;-----------------------------------------------------------------------
; Getspritewidth
;
; Entry:  R2 --> sprite defn
; Exit:   R3 = sprite width (bits)
;
getspritewidth
        Push    "LR"
;
        LDR     R14,[R2,#spLBit]
        LDR     R3,[R2,#spRBit]
        SUB     R3,R3,R14
        ADD     R3,R3,#1                ; make inclusive
        LDR     R14,[R2,#spWidth]
        ADD     R3,R3,R14,LSL #5        ; 32 bits per word
        Debug   ag,"Getspritewidth thinks the sprite width (bits) is",R3
;
        Pull    "PC"

;----------------------------------------------------------------------
; Swapblocks
;
; Entry:  R1 --> start of 1st block
;         R2 --> start of 2nd block (consecutive)
;         R3 --> end of 2nd block
; Exit:   blocks swapped over
;         R1 --> start of 1st block (after 2nd block)
;         R2 --> start of 2nd block
;
swapblocks
        Push    "R3,LR"
;
        Debug   mg,"Swap blocks: ",R1,R2,R3
;
        TEQ     R1,R2
        TEQNE   R2,R3                   ; Z set if either block is null
        SUB     R14,R3,R2               ; R14 = length of 2nd block
        MOV     R2,R1
        ADD     R1,R1,R14
        Pull    "R3,PC",EQ              ; ensure R1,R2 set up correctly on exit
        Push    "R1,R2"
;
        MOV     R1,R2
        MOV     R2,R3
        BL      reverseblock
;
        LDR     R2,[R13,#0*4]           ; reverse new 2nd block
        BL      reverseblock
        MOV     R1,R2
        LDR     R2,[R13,#2*4]           ; reverse new 1st block
        BL      reverseblock
;
        Pull    "R1-R3,PC"

;-------------------------------------------------------------
; Reverse block
;
; Entry:  R1 --> start of block
;         R2 --> end of block (JUST AFTER)
; Exit:   block reversed (words)
;
reverseblock
        Push    "R1-R4,LR"
01
        CMP     R1,R2
        LDRCC   R3,[R1]
        LDRCC   R4,[R2,#-4]!
        STRCC   R3,[R2]
        STRCC   R4,[R1],#4
        BLT     %BT01
;
        Pull    "R1-R4,PC"

;-------------------------------------------------------------
; Copyblock
;
; Entry:  R1 --> destination
;         R2 --> source
;         R3 = no of bytes (must be a whole number of words)
;
copyblock
        Debug   mg,"Copy block (to, from, count): ",R1,R2,R3
;
        TEQ     R1,R2           ; check for null copy
        TEQNE   R3,#0
        MOVEQ   PC,LR
;
        Push    "R1-R3,LR"
;
        CMP     R1,R2
        BCS     copyup
01
        LDR     R14,[R2],#4
        STR     R14,[R1],#4
        SUBS    R3,R3,#4
        BGT     %BT01
;
        Pull    "R1-R3,PC"
;
copyup
        ADD     R1,R1,R3
        ADD     R2,R2,R3
01
        LDR     R14,[R2,#-4]!
        STR     R14,[R1,#-4]!
        SUBS    R3,R3,#4
        BGT     %BT01
;
        Pull    "R1-R3,PC"

;----------------------------------------------------------------
; Mergeblocks
;
; Entry:  R1,R2,R3 --> delimit 2 blocks (consecutive)
;         R4 = 0/1 (merge horizontally/vertically)
;
mergeblocks
        Debug   mg,"Merge blocks: ",R1,R2,R3
;
        TEQ     R4,#0
        MOVNE   PC,LR                   ; vertical merge
;
        Push    "R1-R3,R5-R6,LR"
;
        LDR     R5,sp1_width
        ADD     R5,R5,#1
        MOV     R5,R5,LSL #2            ; R5 = size of 1 row (bytes)
        LDR     R6,sp2_width
        ADD     R6,R6,#1
        MOV     R6,R6,LSL #2            ; R6 = size of 1 row (bytes)
01
        ADD     R1,R1,R5
        CMP     R1,R2
        BCS     %FT02                   ; no more to do
        ADD     R3,R2,R6
        BL      swapblocks
        ADD     R1,R2,R6
        MOV     R2,R3
        B       %BT01
02
        Pull    "R1-R3,R5-R6,PC"



;----------------------------------------------------------------
; Maskmergeblocks
;
; Entry:  R1,R2,R3 --> delimit 2 blocks (consecutive)
;         R4 = 0/1 (merge horizontally/vertically)
;NOTE: Only called for new format sprites
;
maskmergeblocks
        Debug   mg,"Mask merge blocks: ",R1,R2,R3
;
        TEQ     R4,#0
        MOVNE   PC,LR                   ; vertical merge, so return
;
        Push    "R1-R3,R5-R6,R8,LR"
;
        LDR     R8,sp2_rbit
        LDR     R5,sp2_width
        BL      FindMaskWidth           ;Convert R5
        ADD     R6,R5,#1
        MOV     R6,R6,LSL #2            ; R6 = size of 1 row (bytes)
        Debug   ag,"Size of 1 row of sprite2 is (bytes)",R6
        LDR     R8,sp1_rbit
        LDR     R5,sp1_width
        BL      FindMaskWidth           ;Convert R5
        ADD     R5,R5,#1
        MOV     R5,R5,LSL #2            ; R5 = size of 1 row (bytes)
        Debug   ag,"Size of 1 row of sprite1 is (bytes)",R5
01
        ADD     R1,R1,R5
        CMP     R1,R2
        BCS     %FT02                   ; no more to do
        ADD     R3,R2,R6
        BL      swapblocks
        ADD     R1,R2,R6
        MOV     R2,R3
        B       %BT01
02
        Pull    "R1-R3,R5-R6,R8,PC"
;-----------------------------------------------------------------------------

; *****************************************************************************
;
;      FindMaskWidth - convert spWidth for data to spWidth for mask (1bpp masks)
;
;   NOTE: This routine should be similar to GetMaskspWidth in VduGrafH except it does
;         not return the updated PSR
;
;       Internal routine.
;
; in:   R5 = spWidth (ie width in words-1)
;       R8 = spRbit
;       (expects R2->sprite info)
;
; out:  R5 = spWidth (words -1) for mask data
;       R8 = Last bit (spRBit) used in mask data

; MUST only be called for new format sprites

FindMaskWidth ROUT
        Push    "R0, LR"
        Debug   ag,"Entered GetMaskspWidth with R5,R8",R5,R8

        LDR     LR, sp_mode             ; fetch the sprite mode
        MOVS    LR, LR, LSR #27         ; isolate the sprite type and test for =0

        Pull    "R0, PC",EQ         ; if an old format sprite, return R5 unchanged

        ; treat any T>max sprites as 32bpp
        CMP     LR, #SpriteType_MAX
        MOVCS   LR, #SpriteType_Substitute

        ; bugfix 9/8/93: get log2bpp this way
        ADRL    R0, NSM_bpptable-4
        LDR     LR, [R0, LR, LSL #2]    ; get the log2bpp to LR

        RSB     LR, LR, #5              ; and change to 5-log2bpp

        MOV     R5, R5, LSL LR          ; number of pixels for full words

        RSB     LR, LR, #5              ; now switch back to log2bpp
        ADD     R8, R8, #1
        ADD     R5, R5, R8, LSR LR

        ANDS    LR, R5, #&1F            ; fit exactly in a number of words ?
        SUB     R8, LR, #1              ; alter the last bit used for the mask data
                                        ; fix bug MED-01130....
        AND     R8, R8, #&1F            ; ....bring back into range 00-1F (may be -1 here)
        MOVNE   LR, #1                  ; if not, add an extra word
        ADD     R5, LR, R5, LSR #5      ; add the whole number of words
        SUB     R5, R5, #1              ; returns as words-1

        Debug   ag,"Left GetMaskspWidth with R5,R8",R5,R8

        Pull    "R0, PC"

;NSM_bpptable
         ; note, yes - I know this could be type-1, but at some point some new type
         ; will break the relationship so it's a table from day 1 to cope with this
;        &       0, 1, 2, 3, 4, 5
;

        GET     Sources.SWIs
        GET     Sources.SprAdjSize
        GET     Sources.SprTrans
        GET     Sources.MsgCode
        GET     Sources.PutScaled   ; needs commenting out if not using JPEG stuff.

      [ debug
        InsertNDRDebugRoutines
        InsertDebugRoutines
        InsertHostDebugRoutines
      ]

      [ debugcg
ag_disasm
      ;disassemble R1 to R[R9]
      ;base for R1=R10
      EntryS "R0-R12"
      dreg R10,"At: " ;location
      dreg R9,"#words = "
      SUB R9,R9,#1
01    STMFD R13!,{R1-R8}
      LDMFD R13!,{R0-R7} ;move everything down one reg
      STMFD R13!,{R0-R3} ;save registers the SWI will change
      MOV R1,R10         ;get the location into place

      SWI &40380
      dstring R1,"" ;disassembly
      ADD R10,R10,#4
      LDMFD R13!,{R0-R3}
      SUBS R9,R9,#1
      BPL %BT01
      EXITS              ;ensure we return flags how they started....
      ]

Go_CheckSpriteArea
        Push    "R1-R2,SL,LR"
        MOV     r2, r0                  ; save r0 in r2
        MOVS    r0, r0, LSR #8
        BEQ     CheckSprite_exit
        MOV     r0, r1                  ;set up register for C function
        MOV     SL,R12                  ; will be left alone by compiled C - for debug routines above.
        BL      check_sprite_area       ; branch into C
        MOV     R12,SL                  ; R12 is ip to a C prog, will have been trampled on - restore it.
        CMP     r0, #0                  ; check if sprite area was valid
        BEQ     CheckSprite_exit
        Debug   gs, "There's something wrong with the sprite area"
        SETV                            ; the sprite area is bad
        ADRL    R0,ErrorBlock_BadData
        BL      copy_error_one
        Pull    "R1-R2,SL,PC"

CheckSprite_exit
        MOV     r0, r2                  ;restore r0
        Pull    "R1-R2,SL,PC"


        MakeSpriteErrorBlock BadData,,BadData

        END
