/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

/* Please note:
 *
 *
 *  This source file has been modified such that it can operate independently of the
 *  host operating system - notably, it is independent of the character that is being
 *  used as the directory delimiter.  Please do not break this.  Really.
 *
 *
 */

/* ANSI Includes */
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <assert.h>

/* RISC OS Includes */
#ifdef RISCOS
#  include "kernel.h"
#  include "swis.h"
#endif

/* CLX */
#include "host.h"

/* Local includes */
#include "srcbuild.h"
#include "parse.h"
#include "riscos.h"
#include "build.h"

/* Some bits for command line options which set environment variables */
#define ENVVAR_BUF_LEN 32
#define LOCALE_STR     "Locale"
#define LOCALE_TMP     "Locale$tmp"
#define USERIF_STR     "UserIF"
#define USERIF_TMP     "UserIF$tmp"
#define MACHINE_STR    "Machine"
#define MACHINE_TMP    "Machine$tmp"
#define ASCII_LowerCase(c) if ((c >= 'A') && ('Z' >= c)) c += 'a' - 'A'
#define ASCII_UpperCase(c) if ((c >= 'a') && ('z' >= c)) c -= 'a' - 'A'
static void override_envvar(const char *, const char *, const char *);
void copy_env(const char *, const char *);

/* The base address of a ROM image */
unsigned long rom_base_address = 0x03800000ul;

/* The contents of Alias$amu_machine */
static char *amu_machine = NULL;
static void get_amu_machine(void);


static const char corporate_copyright_for_bbe[] = "#"
  "\n# Copyright © 2001, Castle Technology Ltd. All rights reserved."
  "\n#";


typedef enum {
  build_install_rom_normal,
  build_install_rom_bbe_script,
  build_install_rom_size_calculation
} build_install_rom_reason_code;

typedef enum {
  build_resources_normal,
  build_resources_bbe_script
} build_resources_reason_code;

/* Internal function invoked by build_install, build_bbe and the joiners (if install_rom phase wasn't run) */
static int build_install_rom_(build_install_rom_reason_code);

/* Some string handling functions */
unsigned int strcasecmp(const char *xs, const char *ys);
const char *strstr_ci(const char *source, const char *substr);


/*
 * perform a amu_machine call with printf style parameter passing
 */
#ifdef __CC_NORCROFT
#pragma check_printf_formats
#endif
static int
amu_machinef(char *format, ...)
{
  char buffer[BUFFER_LEN];
  va_list list;
  int ret = 0;

  /* Create the full string for the system call, by adding together the contents
     of Alias$amu_machine, and the arguments passed into the function */
  strcpy (buffer, amu_machine);
  strcat (buffer, " ");

  /* Take the format string and extract the arguments used in the format string */
  va_start (list, format);
  vsprintf(buffer + strlen(buffer), format, list);
  va_end(list);
  if (verbose) {
    sb_printf("%s\n",buffer);
  }
  if (strlen(buffer) >= sizeof(buffer)) {
    sb_printf("ABORT: Overwrite of command string buffer (%d)\n", strlen(buffer));
    exit(EXIT_FAILURE);
  }

  /* Allow command line options to override certain environment variables */
  override_envvar(buffer, LOCALE_STR,  LOCALE_TMP);
  override_envvar(buffer, USERIF_STR,  USERIF_TMP);
  override_envvar(buffer, MACHINE_STR, MACHINE_TMP);

  /* Call the command */
  ret = sb_system(buffer);

  /* Restore the environment variables to their defaults (as set in the Env file) */
  copy_env(LOCALE_STR,  LOCALE_TMP);
  copy_env(USERIF_STR,  USERIF_TMP);
  copy_env(MACHINE_STR, MACHINE_TMP);

  return ret;
}
#ifdef __CC_NORCROFT
#pragma -v0
#endif

/* Prints out that a component is about to be processed, and changes the current directory
 * to be that of the module specified.  Returns 0 on failure, 1 on success.
 */
static int build_select_module_directory(component_entry_t *component, module_entry_t *module)
{
  int result;
  char buffer[BUFFER_LEN];

  sb_printf("\n%s (%s)...\n", component->name, module->path);
  sb_buildfilename(BUFFER_LEN, buffer, build_dir, module->path, NULL);
  result = sb_chdir(buffer);
  if (result) {
    error(0, "cannot locate '%s'", buffer);
  }
  return !result;
}


/* Sets up Resource$Dir and Locale environment variables for the given locale,
 * and re-initialises the amu_machine alias to reflect the new values.
 */
static int build_select_locale(const char *locale)
{
  char *num_locale = sb_getenv(ENV_NUM_LOCALE);
  char buffer[BUFFER_LEN];

  sb_buildfilename(BUFFER_LEN, buffer, build_dir, messages_filename, RESOURCES_DIR, build_name, num_locale, locale, NULL);
  sb_setenv(ENV_RES_DIR, buffer);
  sb_setenv(ENV_LOCALE, locale);
  get_amu_machine(); /* Reset amu_machine to include the new values */
  if (verbose)
  {
    sb_printf ("Set Locale (%s) and Resource$Dir to %s\n", locale, buffer);
  }

  return 1;
}

/*
 * check for existance of a directory before creating it, prefix all dirs
 * with build_dir.
 */
static int
_check_dir(char *prefix, char *filename)
{
  char buffer[BUFFER_LEN], *p;

  strcpy(buffer, build_dir);
  p = strchr(buffer, '\0');
  if (prefix) {
    *p++ = host_dir_sep_char();
    p = strchr(strcpy(p, prefix), '\0');
  }
  if (filename) {
    *p++ = host_dir_sep_char();
    strcpy(p, filename);
  }

  if (sb_mkdir(buffer, 0755) == -1)
    error(1, "creating directory '%s'.", buffer);

  return 0;
}

/*
 * check for existance of a directory before creating it, prefix all dirs
 * with build_dir.
 */
static int
_check_dir_p(char *prefix, char *filename)
{
  char buffer[BUFFER_LEN], *p;

  strcpy(buffer, prefix);
  if (filename)
  {
    p    = strchr(buffer, '\0');
    *p++ = host_dir_sep_char();
    strcpy(p, filename);
  }

  if (sb_mkdir_p(buffer, 0755) == -1)
    error(1, "creating directory '%s'.", buffer);

  return 0;
}

/* Construct a set of directories, one level at a time. Each arg is parsed for directory
 * separators too to enable arbitrary paths to be easily created.
 */
static int
_check_dir_v(const char *prefix, ...)
{
  va_list ap;
  const char *arg;
  const char dir_sep = host_dir_sep_char();
  char dir_sep_str[2];
  char buffer[BUFFER_LEN];

  buffer[0] = '\0';
  dir_sep_str[0] = dir_sep;
  dir_sep_str[1] = '\0';

  va_start(ap, prefix);
  for (arg = prefix; arg; arg = va_arg(ap, const char *)) {
      const char *next, *p;
      for (p = arg, next = NULL; *p; p = next)
      {
        char *eobuffer = strchr(buffer, '\0');
        if (*buffer) {
          *eobuffer++ = dir_sep;
        }
        next = p + strcspn(p, dir_sep_str);
        *eobuffer = '\0';
        strncat(eobuffer, p, next - p);
        _check_dir(NULL, buffer);
        if (*next) ++next;
      }
  }
  va_end(ap);
  return 0;
}

/*
 * Call the recursive directory creation routine to create everything
 * upto the parent directory of the specified object.
 */
static int
_check_parent(char *prefix, char *directory, char *build)
{
  char buffer[BUFFER_LEN], *p;

  strcpy(buffer, build);
  p = strrchr(buffer, host_dir_sep_char());
  if (p) *p = '\0';
  _check_dir_v(prefix, directory, p?buffer:p, NULL);

  return 0;
}

/*
 * create the directories required by the build process
 */
int build_dirs(void)
{
  component_entry_t *component;
  module_entry_t *module;
  int max_resource_suffix = 0;
  char buffer[BUFFER_LEN];
  char build[BUFFER_LEN];
  char numeric[BUFFER_LEN];

  strcpy(build, CHK_STR(sb_getenv(ENV_BUILD_NAME)));
  strcpy(numeric, CHK_STR(sb_getenv(ENV_NUM_LOCALE)));

  sb_chdir(build_dir);
  _check_dir(NULL, IMAGES_DIR);
  _check_dir(NULL, EXPORT_DIR);
  _check_dir_p(INSTALL_DIR, build_name);
  _check_dir(BUILDSYS_DIR, LOGS_DIR);
  _check_parent(BUILDSYS_DIR, SHADOW_DIR, build);

  /* If APCS is not defined, we get right result as the NULL terminates the path! */
  sb_buildfilename(BUFFER_LEN, buffer, "Export", sb_getenv("APCS"), NULL);
  _check_dir_v(buffer, "Hdr", "Global", NULL);
  _check_dir_v(buffer, "Hdr", "Interface", NULL);
  _check_dir_v(buffer, "Hdr", "Interface2", NULL);
  _check_dir_v(buffer, "Lib", NULL);

  build_select_locale(supported_territories[0]);

  component = component_database;
  while (component)
  {
    module = lookup_module(component->name);
    if (module->output != NULL) /* Ensure we don't try to create oflaofla directories... ;-) */
    {
      _check_dir_v(INSTALL_DIR, build_name, module->output, NULL);
    }
    max_resource_suffix = component->resource_sfx;
    component = component->next;
  }

  if (num_of_territories > 0)
  {
    unsigned int loop, dirs;
    for (loop=0; loop < num_of_territories; loop++)
    {
      _check_dir_v(messages_filename, RESOURCES_DIR, build, numeric, supported_territories[loop], "Apps", NULL);
      _check_dir_v(messages_filename, RESOURCES_DIR, build, numeric, supported_territories[loop], RESOURCES_DIR, NULL);
      for (dirs = 2; dirs <= max_resource_suffix; ++dirs)
      {
        sprintf(buffer, RESOURCES_DIR "%d", dirs);
        _check_dir_v(messages_filename, RESOURCES_DIR, build, numeric, supported_territories[loop], buffer, NULL);
      }
    }
  }

  return 0;
}


int build_clean(void)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (!component->no_component_sources) /* We do not wish to do a clean phase of a component if we do not have any sources... */
    {
      switch (type) {
        case RES:
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case HAL:
        case EXP:
        case DATA:
        case LOADER:
        if (build_select_module_directory(component, module))
          if (amu_machinef("-k clean COMPONENT=%s %s%s %s",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"",
  		component->options ? component->options:"") != 0)
                  error(0, "running make clean on module '%s'.", component->name);
  	/*
  	 * no need for force clean now
  	 */
  	if (component->duplicate == 0) component->force_clean = FALSE;
      }
    }
    else
    {
      sb_printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running clean phase on this component.\n", component->name, component->name);
    }

    component = component->next;
  }

  sb_system_sync();

  return 0;
}



int build_clean_all(void)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (!component->no_component_sources) /* We do not wish to do a clean_all phase of a component if we do not have any sources... */
    {
      switch (type) {
        case RES:
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case HAL:
        case EXP:
        case DATA:
        case LOADER:
        if (build_select_module_directory(component, module))
        {
          if (amu_machinef("-k clean_all COMPONENT=%s %s%s %s",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"",
  		component->options ? component->options:"") != 0)
                  error(0, "running make clean_all on module '%s'.", component->name);
          if (sb_system("stripdepnd") != 0)
                  error(0, "running stripdepnd on module '%s'.", component->name);
        }
  	/*
  	 * no need for force clean now
  	 */
  	if (component->duplicate == 0) component->force_clean = FALSE;
      }
    }
    else
    {
      sb_printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running clean_all phase on this component.\n", component->name, component->name);
    }

    component = component->next;
  }

  sb_system_sync();

  return 0;
}



/* This routine handles both export_hdrs and export_libs.  It invokes the export
 * rule with PHASE set appropriately.
 */
static int build_export(const char *phase)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;

  sb_system_sync();

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    /* We do not wish to do an export phase of a component if we do not have any sources... */
    if (!component->no_component_sources)
    {
      switch (type)
      {
        case ASM:
        case LOADER:
        case C:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
        case EXP:
          if (build_select_module_directory(component, module)) {
            if (amu_machinef("-k export PHASE=%s COMPONENT=%s %s%s %s",
              phase,
              component->name,
              module->filename?"TARGET=":"",
              module->filename?module->filename:"",
              component->options ? component->options:"") != 0)
            error(0, "running make export (%s) on module '%s'.", phase, component->name);
          }
          break;
      }
    }
    else
    {
      sb_printf("\n%s...\nComponent %s: nosources flag passed in, "
        "therefore not running export_%s phase on this component.\n",
        component->name, component->name, phase);
    }
    component = component->next;
  }

  sb_system_sync();

  return 0;
}

int build_export_hdrs(void)
{
  return build_export("hdrs");
}

int build_export_libs(void)
{
  return build_export("libs");
}



/* Executes a resources phase - or not as the parameter may be.  If reason_code is build_resources_normal,
 * then it is a real resource export.  If it is build_resources_bbe_script, then it is assumed to be a
 * resource export command discovery being done by build_bbe to generate the script filenames for the
 * resource exports.
 */
static int build_resources_(build_resources_reason_code reason_code)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char bbe_dir[BUFFER_LEN];
  char scriptfilename[BUFFER_LEN];
  module_type_t type;
  char *locale = NULL;
  char *res_dir = NULL;
  const char dir_sep = host_dir_sep_char();


  if (reason_code == build_resources_normal)
  {
    /* Read the numeric locale list */
    if ((locale = sb_strdup(sb_getenv(ENV_NUM_LOCALE))) == NULL)
    {
      error(1, "Could not read the numeric locale list system variable. */");
    }

    /*
     * Force a make clean on the messages module. Note that this is independent
     * of any settings in the module database or component database, apart from %messages.
     * We are assuming quite a lot about the Messages module here...
     */
    sb_printf("\nCleaning Messages...\n");
    sb_buildfilename(BUFFER_LEN, buffer, build_dir, messages_filename, NULL);

    if (sb_chdir(buffer))
      error(0, "cannot locate '%s'", buffer);
    else
    {
      sprintf(buffer,"-k clean COMPONENT=Messages TARGET=Messages NUMLOCALE=%s", locale);
      sb_system_sync();
      if (amu_machinef(buffer) != 0)
        error(0, "running make clean on module 'Messages'.");
    }

    /* Free the numeric locale list sys var memory. */
    if (locale) /* Usual memory-tidying gubbins */
    {
      free (locale);
      locale = NULL;
    }

    /* Build all the resource directories that are required. Can only be done after they have been cleaned as above. */
    build_dirs();
  }

  sb_system_sync();

  /*
   * now get on with rest
   */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case C:
      case ASM:
      case LOADER:
      case BAS:
      case KERNEL:
      case HAL:
      case DATA:
      case RES:
        if (build_select_module_directory(component, module))
        {
          /* We have been given a list of territories - iterate down them. */
          unsigned int loop;
          const char *const target = module->filename ? module->filename : component->name;
          char component_resource_dir[sizeof(RESOURCES_DIR) + sizeof("99")];

          for (loop = 0; loop < num_of_territories; ++loop)
          {
            if (reason_code == build_resources_bbe_script)
            {
              sb_buildfilename(BUFFER_LEN, bbe_dir, INSTALL_DIR, build_name, BBE_DIR, module->path, BBE_TMP_RES, target, NULL);
              sb_buildfilename(BUFFER_LEN - 3, scriptfilename + 3, build_dir, bbe_dir, supported_territories[loop], NULL);
              remove(scriptfilename + 3);
              memcpy(scriptfilename, "-o ", 3);
              _check_dir_v(bbe_dir, NULL);
            }
            else
            {
              *scriptfilename = '\0';
            }
            /* set the Resource$Dir and Locale environment variable to the current */
            build_select_locale(supported_territories[loop]);
#ifdef RISCOS
            res_dir = "<" ENV_RES_DIR ">";
#else
            res_dir = sb_strdup(sb_getenv(ENV_RES_DIR));
#endif
            if (component->resource_sfx > 1) {
              sprintf(component_resource_dir, RESOURCES_DIR "%d", component->resource_sfx);
            }
            else {
              strcpy(component_resource_dir, RESOURCES_DIR);
            }

            if (amu_machinef("-k resources %s RESDIR=%s%c%s COMPONENT=%s %s%s %s",
                  scriptfilename,
                  res_dir,
                  dir_sep,
                  component_resource_dir,
                  component->name,
                  module->filename?"TARGET=":"",
                  module->filename?module->filename:"",
                  component->options ? component->options : "") != 0)
              error(0, "running make resources on module '%s'.", component->name);

#ifndef RISCOS
            free(res_dir);
#endif
          }
        }
        break;
    }
    component = component->next;
  }

  sb_system_sync();

  /* Finally change the locale back to the default one (the first in the list). */
  build_select_locale(supported_territories[0]);

  return 0;
}

int build_resources(void)
{
  return build_resources_(build_resources_normal);
}



/* Copy lines from 'source' to 'dest', indenting each line with a tab if 'with_tab' is non-zero */
static void line_by_line_copy(FILE *dest, FILE *source, int with_tab)
{
  char buffer[BUFFER_LEN * 2];

  while (fgets(buffer, sizeof(buffer), source) != NULL) {
    if (with_tab) fputc('\t', dest);
    if (strncmp("echo", buffer, sizeof("echo")-1) == 0)
    {
      fputc('@', dest);
    }
    fputs(buffer, dest);
  }
}

/* After the BBE phase has invoked the faked rom_link phase, parse the resultant script looking for
 * the line which does the link.  We need to know where the partially linked ROM module is, and which
 * abssym file it wants - then we throw the script away and write the rule cleanly ourselves.
 */
static void copy_rom_link_rules(FILE *dest, FILE *source, const char *aof_target, const char *targetname)
{
  char buffer[BUFFER_LEN * 2];
  char link_args[BUFFER_LEN];
  int skip_next;
  enum skip_flags {
    skip_read = 0,
    skip_ignore = 1,
    skip_copy = 2,
    skip_copy_and_ignore = (skip_ignore | skip_copy)
  };
  const char dir_sep = host_dir_sep_char();

  sprintf(link_args, "link -o linked%c${TARGET} -rmf -base ${ADDRESS} " AOF_DIR "%c${TARGET}", dir_sep, dir_sep);

  while (fgets(buffer, sizeof(buffer), source) != NULL) {
    char *next, *p, *source_file = NULL;
    if (!isspace(buffer[4])) continue;
    buffer[4] = '\0';
    if (cstrcmp("link", buffer)) continue;
    buffer[4] = ' ';

    /* Parse this link command to determine where the source file is and what abssym file it is linking against */
    buffer[strcspn(buffer, "\r\n")] = '\0'; /* strip eol - zero terminate */
    skip_next = skip_ignore;
    for (p = buffer, next = NULL; *p; p = next) {
      next = p;
      while (*next && !isspace(*next)) ++next;
      if (*next) *next++ = '\0';
      while (*next && isspace(*next)) ++next;
      if (skip_next != skip_read)
      {
        if (skip_next & skip_copy)
        {
          strcat(link_args, p);
        }
        skip_next = 0;
        continue;
      }
      if (*p == '-') {
        if (cstrcmp(p+1, "base") == 0 || cstrcmp(p+1, "o") == 0 || cstrcmp(p+1, "linkversion") == 0) {
          skip_next = skip_ignore;
        }
        else if (cstrcmp(p+1, "symdefs") == 0 || cstrcmp(p+1, "S") == 0 || cstrcmp(p+1, "syms") == 0 || cstrcmp(p+1, "symbols") == 0) {
          sprintf(strchr(link_args, '\0'), " %s ", p);
          skip_next = skip_copy_and_ignore;
        }
        continue;
      }
      if (*p == '>')
      {
        skip_next = p[1] ? skip_read : skip_ignore;
        continue;
      }

      if (source_file == NULL)
      {
        source_file = p;
      }
      else
      {
        strcat(link_args, " ");
        strcat(link_args, p);
      }
    }

    sb_copy_objects(aof_target, source_file);
    fprintf(dest,
      "rom_link-%s:\n"
      "\t${MKDIR} linked\n"
      "\t%s\n"
      "\t@${CP} linked%c${TARGET} ${LINKDIR}%c${TARGET} ${CPFLAGS}\n\n"
      "clean::\n"
      "\t${WIPE} linked ${WFLAGS}\n\n",
      targetname,
      link_args,
      dir_sep,
      dir_sep);
  }
}

/*
 * Write the resources phases into the target BBE Makefile.  Each locale is copied in as a
 * separate rule.
 *
 * NOTE: Parameter 'bbe_dir' must be pointer to array with enough space to hold locale names
 * tacked on the end of it.
 *
 */
static void copy_locale_resources(FILE *makefile, char *bbe_dir /* see comment above */, const char *name)
{
  FILE *resources_file;
  char *end_bbe_dir = strchr(bbe_dir, '\0');
  char *locale;
  unsigned int loop;


  for (loop=0; loop < num_of_territories; loop++)
  {
    /* set the Resource$Dir and Locale environment variable to the current */
    locale = supported_territories[loop];

    /* Now read the locale script */
    strcpy(end_bbe_dir, locale);
    resources_file = fopen(bbe_dir, "r");
    /* Write out the rules for generating this locale's resource export */
    fprintf(makefile, "resources-%s-%s:\n", name, locale);
    if (resources_file)
    {
      /* Not an error if it doesn't exist - but need the rule in the Makefile anyway.
       * Copy file line by line, inserting TABs.
       */
      line_by_line_copy(makefile, resources_file, 1);
    }
    /* Need this line to ensure that there is at least one command for this target */
    fprintf(makefile, "\t@| End of resource export for locale %s\n\n", locale);
    fclose(resources_file);
  }
}

/*
 * This routine searches for earlier (different) components which define targets in duplicate
 * directories.  The BBE routines need to know whether resource export rules should be
 * appended to an existing Makefile or not.
 *
 * Returns true if an earlier component also used sources in the same directory, false otherwise.
 */
static bool build_duplicate_directory(component_entry_t *component, module_entry_t *module)
{
  component_entry_t *c;

  for (c = component_database; c != component; c = c->next)
  {
    if (
      strcmp(c->name, component->name) != 0 &&
      c->created_bbe_makefile &&
      strcmp(module->path, lookup_module(c->name)->path) == 0
      )
    {
      return true;
    }
  }

  return false;
}

/* BBE phase.
 */
int build_bbe(void)
{
  component_entry_t *component;
  module_entry_t *module;
  const char dir_sep = host_dir_sep_char();
  const char target_sep = dir_sep; /* XXX: target_dir_sep_char(); */
  char bbe_dir[BUFFER_LEN];
  char aof_target[BUFFER_LEN];
  char rom_link_name[BUFFER_LEN];
  char *end_bbe_dir = NULL;
  char *end_rom_link_name = NULL;
  int  rom_link_line_by_line;
  module_type_t type;
  FILE *makefile;
  FILE *rom_link_file;
  int fake_uk_territory;
  /* The following variable is used for debugging only */
  const enum {
    bbe_real,
    bbe_debugging
  } bbe_debug = bbe_real;

  (void) bbe_debugging; /* avoid compiler warning */
  (void) bbe_real; /* avoid compiler warning */

  if (bbe_debug == bbe_real)
  {
    /* Generate BBE_Res and BBE_ROM contents (debug builds assume this is already there to save time). */
    build_resources_(build_resources_bbe_script);
    build_install_rom_(build_install_rom_bbe_script);
  }

  /* Find out if we are going to need to fake the UK territory for this to work
   * NOTE: We add UK to the territory list to avoid special casing it in the loop
   * in the switch statement, so we must remember to remove the entry again at
   * the end of the function (in fact, simply decrementing num_of_territories will do).
   */
  {
    unsigned int loop;
    fake_uk_territory = 1;
    for (loop = 0; loop < num_of_territories; ++loop) {
      if (strcmp(supported_territories[loop], "UK") == 0) fake_uk_territory = 0;
    }
    if (fake_uk_territory) {
      supported_territories[num_of_territories++] = "UK";
    }
  }

  /*
   * now get on with rest
   */
  component = component_database;
  while (component) {
    const char *target;
    bool already_processed_directory;
    module = lookup_module(component->name);
    target = module->filename ? module->filename : component->name;
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    already_processed_directory = build_duplicate_directory(component, module);

    switch (type) {
      case C:
      case ASM:
      case LOADER:
      case BAS:
      case KERNEL:
      case HAL:
      case DATA:
      case RES:
      case BBE:
        if (build_select_module_directory(component, module)) {
          unsigned int loop;

          /* Be VERY careful with the ordering here.  Paths are constructed from partial paths held in other
           * buffers.  Some paths have build_dir on the front, others do not (so you can pass them to _check_dir*)
           */

          /* Construct the "aof" directory in the BBE install directory ready to receive partially linked output */
          sb_buildfilename(BUFFER_LEN, aof_target, INSTALL_DIR, build_name, BBE_DIR, module->path, NULL);
          if (type == C)
          {
            _check_dir_v(aof_target, AOF_DIR, NULL);
          }
          _check_dir_v(aof_target, BBE_TMP_ROM, target, NULL);

          /* Using "aof_target" (holds the BBE install directory for this component), construct the full pathname
           * to that directory into bbe_dir.  Remember where the final terminator is so we can easily tack things
           * onto the end of the path as we need them.
           */
          sb_buildfilename(BUFFER_LEN, bbe_dir, build_dir, aof_target, NULL);
          end_bbe_dir = strchr(bbe_dir, '\0');
          /* Construct the actual target name of the AOF file */
          sb_buildfilename(BUFFER_LEN, aof_target, bbe_dir, AOF_DIR, target, NULL);
          /* Construct the actual name of the BBE Makefile and delete it */
          sb_buildfilename(BUFFER_LEN, rom_link_name /* NOTE: temporary use of this buffer */, bbe_dir, "Makefile", NULL);
          /* Only delete it if wasn't created by us whilst processing a previous component though! */
          if (!already_processed_directory) {
            remove(rom_link_name);
          }
          /* Construct the actual name of the rom_link script file */
          sb_buildfilename(BUFFER_LEN, rom_link_name, bbe_dir, BBE_TMP_ROM, target, "rom_link", NULL);
          end_rom_link_name = strchr(rom_link_name, '\0');

          /* We have been given a list of territories - iterate down them */
          for (loop=0; loop < num_of_territories; loop++)
          {
            build_select_locale(supported_territories[loop]);
            *end_bbe_dir = '\0';

            if (amu_machinef("-k -f %s bbe COMPONENTTYPE=%s VERBATIMROMLINK=%s_v BBEDIR=%s COMPONENT=%s %s%s %s",
                  BBE_BS_MAKEFILE,
                  module_type_names[type],
                  rom_link_name,
                  bbe_dir,
                  component->name,
                  module->filename?"TARGET=":"",
                  module->filename?module->filename:"",
                  component->options ? component->options : "") != 0)
              error(0, "running make bbe on module '%s'.", component->name);

          }
        }
        sb_system_sync();
        strcpy(end_rom_link_name, "_v");
        rom_link_file = fopen(rom_link_name, "r");
        if (rom_link_file)
        {
          rom_link_line_by_line = 1;
        }
        else
        {
          *end_rom_link_name = '\0';
          rom_link_file = fopen(rom_link_name, "r");
          rom_link_line_by_line = 0;
        }
        if (type != BBE)
        {
          sprintf(end_bbe_dir, "%cMakefile", host_dir_sep_char());
          makefile = fopen(bbe_dir, "r");
        }
        if (type == BBE)
        {
          /* Don't create a Makefile for BBE-only components */
          makefile = NULL;
        }
        else if (makefile && already_processed_directory)
        {
          makefile = freopen(bbe_dir, "a", makefile);
        }
        else if (makefile)
        {
          /* The component has exported a Makefile - allow it to override us */
          fclose(makefile);
          makefile = NULL;
        }
        else
        {
          makefile = fopen(bbe_dir, "w");
          if (makefile == NULL)
          {
            error(0, "Unable to create BBE makefile '%s'", bbe_dir);
          }
          else if (type != EXP)
          {
            time_t now;
            time(&now);
            fprintf(makefile,
              "#\n"
              "# Binary Build Environment Makefile for %s\n"
              "#\n"
              "%s\n"
              "\n"
              "include %s\n"
              "\n"
              "all:\n"
              "\t@| Do nothing by default\n"
              "\n"
              "install_rom:\n"
              "\t${CP} rm%c${TARGET} ${INSTDIR}%c${TARGET} ${CPFLAGS}\n"
              "\t@echo ${COMPONENT}: installed\n"
              "\n"
              "# Resource export phases\n"
              "\n"
              "resources: resources-${TARGET}-${LOCALE}\n"
              "\t@echo ${COMPONENT}: ${LOCALE} resources exported\n"
              "\n"
              "\n"
              "rom_link: rom_link-${TARGET}\n"
              "\t@echo ${COMPONENT}: rom_link complete\n"
              "\n"
              "\n",
              component->name,
              corporate_copyright_for_bbe,
              BBE_BS_TOOLS,
              target_sep,
              target_sep);
              component->created_bbe_makefile = true;
          }
          else
          {
            fclose(makefile);
            makefile = NULL;
          }
        }
        if (makefile)
        {
          sprintf(end_bbe_dir, "%c" BBE_TMP_RES "%c%s%c", dir_sep, dir_sep, target, dir_sep);
          copy_locale_resources(makefile, bbe_dir, target);
          if (rom_link_file)
          {
            if (rom_link_line_by_line)
            {
                line_by_line_copy(makefile, rom_link_file, 0);
            }
            else
            {
              copy_rom_link_rules(makefile, rom_link_file, aof_target, target);
            }
          }
          fclose(makefile);
          makefile = NULL;
        }
        if (rom_link_file)
        {
          fclose(rom_link_file);
          rom_link_file = NULL;
        }
    }
    component = component->next;
  }

  if (bbe_debug == bbe_real)
  {
    /* Delete the generated BBE_Res and BBE_ROM dirs (debug builds don't to help debugging and save time)
     * NOTE: This must NOT be done as we loop through the components, because some components are used
     * multiple times (e.g. territory modules) for different targets and this could cause problems.
     */

    component = component_database;
    while (component) {
      module = lookup_module(component->name);
      type = component->type;
      if (type == UNDEF)
        type = module->type;

      switch (type) {
        case C:
        case ASM:
        case LOADER:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
        case RES:
        case BBE:
          build_select_module_directory(component, module);
          sb_buildfilename(BUFFER_LEN, bbe_dir, build_dir, INSTALL_DIR, build_name, BBE_DIR, module->path, NULL);
          end_bbe_dir = strchr(bbe_dir, '\0');
          *end_bbe_dir++ = dir_sep;
          strcpy(end_bbe_dir, BBE_TMP_RES);
          sb_wipe_objects(bbe_dir, 1);
          strcpy(end_bbe_dir, BBE_TMP_ROM);
          sb_wipe_objects(bbe_dir, 1);
          /* strcpy(end_bbe_dir, AOF_DIR); */
          /* sb_wipe_objects(bbe_dir, 0);  */
          break;
      }
      component = component->next;
    }
  }

  /* If we had temporarily added an extra territory to ensure UK export, remove it
   * from the list again - we used a string literal, so no need to free the array
   * entry.
   */
  num_of_territories -= fake_uk_territory;

  /* Finally change the locale back to the default one (the first in the list). */
  build_select_locale(supported_territories[0]);

  return 0;
}



int build_rom(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  FILE *fh_shadow = NULL;
  char *switch_on = NULL;
  module_type_t type;

  sb_buildfilename(BUFFER_LEN, buffer, build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name, NULL);
  if ((fh_shadow = fopen(buffer, "w")) == NULL)
    error(1, "cannot open shadow file '%s'.", buffer);

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;
    if (!component->no_component_sources) /* We do not wish to do a rom phase of a component if we do not have any sources... */
    {
      switch (type) {
        case C:
        case ASM:
        case LOADER:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
        if (build_select_module_directory(component, module)) {
  	  /*
  	   * do we want to force a clean build due to changes
  	   */
  	  if (component->force_clean) {
            sb_printf("Forcing a clean build due to switch/option changes...\n");
  	    if (amu_machinef("-k clean COMPONENT=%s %s%s %s",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"",
  		component->options ? component->options : "") != 0)
  	      error(0, "running make clean on module '%s'.", component->name);
  	  }
  	  /*
  	   * find out what we are switching this module on
  	   */
  	  switch_on = NULL;
  	  if (component->switch_on)
  	    switch_on = component->switch_on;
  	  else if (module->switch_on)
  	    switch_on = module->switch_on;

  	  if (component->options || switch_on) {
  	    fprintf(fh_shadow, "%s ", component->name);
  	    if (switch_on) {
  	      fprintf(fh_shadow, "-switch %s ", switch_on);
  	    }
  	    if (component->options) {
  	      fprintf(fh_shadow, "-options %s", component->options);
  	    }
  	    fprintf(fh_shadow, "\n");
  	  }

  	  if (amu_machinef("-k rom COMPONENT=%s %s%s %s",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"",
  		component->options ? component->options : "") != 0)
  	    error(0, "running make rom on module '%s'.", component->name);
  	}
      }
    }
    else
    {
      sb_printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running ROM phase on this component.\n", component->name, component->name);
    }
    component = component->next;
  }

  if (fh_shadow)
    fclose(fh_shadow);

  return 0;
}

static long build_get_filesize(const char *path, const char *name)
{
  long size;
  char buffer[BUFFER_LEN];

  sb_buildfilename(BUFFER_LEN, buffer, path, name, NULL);
  if ((size = sb_file_size(buffer)) == -1) {
    error(1, "cannot stat '%s'.", buffer);
  }
  return size;
}

static int ran_install_rom;

int
build_install_rom_(build_install_rom_reason_code reason_code)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  unsigned long int position_in_rom = rom_base_address;
  const char dir_sep = host_dir_sep_char();
  long size;
  const int quiet = (reason_code == build_install_rom_size_calculation); /* No need to report stuff again */
  int number_of_modules;
  int position_forced = 0;
  char output_path[BUFFER_LEN];
  char scriptdirname[BUFFER_LEN];
  char scriptfilename[BUFFER_LEN];
  char forcefilename[BUFFER_LEN];

  sb_system_sync();

  if (reason_code == build_install_rom_bbe_script)
  {
    FILE *f;
    sb_buildfilename(BUFFER_LEN, forcefilename, build_dir, INSTALL_DIR, build_name, BBE_DIR, "force", NULL);
    remove(forcefilename);
    f = fopen(forcefilename, "w");
    if (f) fclose(f);
  }
  else
  {
    *forcefilename = 0;
  }

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    sb_buildfilename(BUFFER_LEN, output_path, build_dir, INSTALL_DIR, build_name, module->output, NULL);

    switch (type) {
      case C:
      case ASM:
      case LOADER:
      case BAS:
      case KERNEL:
      case HAL:
      case DATA:
        if (module->filename == NULL) {
          if (!quiet) sb_printf("No output file for this component\n");
        }
        else if (build_select_module_directory(component, module)) {
          if (position_forced && type != DATA) {
            if (!quiet) sb_printf("Component not linked into module chain\n");
          }
          else if (type == DATA) {
            if (!component->force_position)
              component->force_position = position_in_rom;
            if (component->force_position < position_in_rom)
              error(0, "component overlaps previous data");
            else {
              position_forced = 1;
              position_in_rom = component->force_position;
            }
          }
          else if (type == KERNEL) {
            if (component->force_position) {
              if (component->force_position < position_in_rom)
                error(0, "component overlaps previous data");
                position_in_rom = component->force_position;
            }
          }

          if (reason_code == build_install_rom_bbe_script) {
            sb_buildfilename(BUFFER_LEN, scriptdirname, INSTALL_DIR, build_name, BBE_DIR, module->path, BBE_TMP_ROM, module->filename, NULL);
            _check_dir_v(scriptdirname, NULL);
            sprintf(scriptfilename, "-o %s%c%s%crom_link ADDRESS=Address FORCEROMLINK=%s", build_dir, dir_sep, scriptdirname, dir_sep, forcefilename);
            if (type != C)
            {
              sb_buildfilename(BUFFER_LEN, scriptdirname, INSTALL_DIR, build_name, BBE_DIR, module->path, "rm", NULL);
              _check_dir_v(scriptdirname, NULL);
              sb_buildfilename(BUFFER_LEN, scriptdirname, build_dir, INSTALL_DIR, build_name, BBE_DIR, module->path, "rm", NULL);
            }
          }
          else if (reason_code == build_install_rom_normal) {
            sprintf(scriptfilename, "ADDRESS=%lu", position_in_rom);
          }

          /* Unless this was the fake call from the join phase to calculate the ROM positions, actually
           * attempt the installation for this component.
           */
          if (reason_code != build_install_rom_size_calculation) {
            switch (type) {
	      case C:
		/* if module is C, link things correctly */
		if (amu_machinef("rom_link %s LINKDIR=%s COMPONENT=%s %s%s %s",
                        scriptfilename,
			output_path,
			component->name,
			module->filename?"TARGET=":"",
			module->filename?module->filename:"",
			component->options ? component->options : "") != 0)
		  error(1, "running make rom_link on module '%s'.",
			component->name);

		break;

	      default:
		if (amu_machinef("install_rom INSTDIR=%s COMPONENT=%s %s%s %s",
                        (reason_code == build_install_rom_normal) ? output_path : scriptdirname,
		 	component->name,
			module->filename?"TARGET=":"",
			module->filename?module->filename:"",
			component->options ? component->options : "") != 0)
		  error(1, "running make install_rom on module '%s'.",
			component->name);

		break;
            }
          }

          /* Need to stat the module file, display position in ROM */
          sb_system_sync();
          size = build_get_filesize(output_path, module->filename);

	  /* keep record of things for later */
	  component->position = position_in_rom;
	  component->size = size;

	  /* calculate position of next module in ROM */
	  position_in_rom += (((unsigned long int) size + 3UL) & ~3UL);
	  if (type != KERNEL && type != HAL)	/* add some magic if not kernel */
	    position_in_rom += 4;
	}
    }
    component = component->next;
  }

  if (reason_code == build_install_rom_bbe_script) {
    remove(forcefilename);
  }

  /* display the ROM entries - but only ever do this once */
  if (!ran_install_rom) {
    banner('-');
    sb_printf("\nSummary of linked ROM contents...\n\n");
    sb_printf("Module name                Position in ROM  Module size\n");
    sb_printf("-----------                ---------------  -----------\n");
    component = component_database;
    number_of_modules = 0;
    while (component) {
      module = lookup_module(component->name);
      type = component->type;
      if (type == UNDEF)
        type = module->type;

      switch (type) {
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case LOADER:
        case HAL:
        case DATA:
          if (module->filename != NULL) {
            number_of_modules++;
            sb_printf("%-25s  %08lX         %08lX\n", component->name, component->position, component->size);
          }
          break;
      }
      component = component->next;
    }
    sb_printf("\nTotal of %d modules.\n", number_of_modules);

    ran_install_rom = (reason_code == build_install_rom_normal);
  }

  sb_system_sync();

  return 0;
}

int
build_install_rom(void)
{
  return build_install_rom_(build_install_rom_normal);
}

static char *build_generate_installed_name(int buflen, char *buffer, module_entry_t *module)
{
  sb_buildfilename(buflen, buffer, build_dir, INSTALL_DIR, build_name, module->output, module->filename, NULL);
  return buffer;
}

/*
 * write stuff out to the given file in the format required by BigSplit
 */
static int joiner_format_bigsplit(FILE * fh)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  int hal_count = 0;
  int kernel_count = 0;
  int size_printed = 0;
  unsigned long base = rom_base_address;
  char buffer[BUFFER_LEN];

  if (!ran_install_rom) {
    build_install_rom_(build_install_rom_size_calculation);
  }

  /* look for kernel */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (type == HAL) {
      fprintf(fh, "HAL:%s\n", build_generate_installed_name(BUFFER_LEN, buffer, module));
      hal_count++;
    }
    else if (type == KERNEL) {
      if (component->force_position)
        fprintf(fh, "%lu\n", component->force_position - base);
      fprintf(fh, "%s\n", build_generate_installed_name(BUFFER_LEN, buffer, module));
      kernel_count++;
    }
    else if (type == LOADER) {
      error(0, "you appear to have an extension ROM/expansion card loader in this ROM");
    }

    if (hal_count + kernel_count == 1 && !size_printed) {
      /* write out the image filename */
      sb_buildfilename(BUFFER_LEN, buffer, build_dir, IMAGES_DIR, image_filename, NULL);
      fprintf(fh, "%s\n", buffer);

      /* write out the image size and misc newline (for "extra information") */
      fprintf(fh, "%d\n\n", atoi(image_size) * 1024);

      size_printed = 1;
    }
    component = component->next;
  }

  /* warn if things are not ok */
  if (kernel_count > 1)
    error(0, "you appear to have more than one kernel in this ROM");
  else if (kernel_count < 1)
    error(0, "you seem to be missing a kernel in this ROM");

  if (hal_count > 1)
    error(0, "you appear to have more than one HAL in this ROM");

  /* now write out the other modules in order */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case LOADER:
        if (module->filename != NULL) {
          fprintf(fh, "LOADER:");
        }
        /*FALLTHROUGH*/
      case ASM:
      case C:
      case BAS:
      case DATA:
        if (module->filename != NULL) {
          if (type == DATA)
            fprintf(fh, "%lu\n", component->position - base);
          fprintf(fh, "%s\n", build_generate_installed_name(BUFFER_LEN, buffer, module));
        }
        break;
    }
    component = component->next;
  }
  fprintf(fh, "\n");

  return 0;
}

/*
 * write stuff out to the given file in the format required by MakeExpROM
 */
static int joiner_format_makeexprom(FILE * fh)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  int kernel_count = 0;
  int hal_count = 0;
  char buffer[BUFFER_LEN];

  /* look for kernel */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (type == KERNEL) {
      kernel_count++;
    }
    if (type == HAL) {
      hal_count++;
    }
    component = component->next;
  }

  /* warn if things are not ok */
  if (kernel_count >= 1)
    error(1, "you appear to have a kernel in an expansion ROM!");

  if (hal_count >= 1)
    error(1, "you appear to have a HAL in an expansion ROM!");

  /* write out the image filename */
  sb_buildfilename(BUFFER_LEN, buffer, build_dir, IMAGES_DIR, image_filename, NULL);
  fprintf(fh, "%s\n", buffer);

  /* write out the image size */
  fprintf(fh, "%d\n", atoi(image_size));

  /* write out podule product code */
  fprintf(fh, "%s\n", podule_info.product?podule_info.product:"");

  /* write out podule description */
  fprintf(fh, "%s\n", podule_info.descript?podule_info.descript:"");

  /* write out podule serial number */
  fprintf(fh, "%s\n", podule_info.serial?podule_info.serial:"");

  /* write out podule status bit */
  fprintf(fh, "%s\n", podule_info.status?podule_info.status:"");

  /* write out podule manufacturer */
  fprintf(fh, "%s\n", podule_info.manuf?podule_info.manuf:"");

  /* write out podule part number */
  fprintf(fh, "%s\n", podule_info.part?podule_info.part:"");

  /* write out podule date */
  fprintf(fh, "%s\n", podule_info.date?podule_info.date:"");

  /* now write out the other modules in order */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case LOADER:
        if (module->filename != NULL) {
          fprintf(fh, "LOADER:");
        }
        /*FALLTHROUGH*/
      case ASM:
      case C:
      case BAS:
      case DATA:
        if (module->filename != NULL) {
          if (type == DATA)
            fprintf(fh, "%ld\n", component->position - rom_base_address);
          fprintf(fh, "%s\n", build_generate_installed_name(BUFFER_LEN, buffer, module));
        }
        break;
    }
    component = component->next;
  }
  fprintf(fh, "\n");

  return 0;
}

/*
 * write stuff out to the given file in the format required by romlinker
 */
static int joiner_format_romlinker(FILE * fh)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  component_entry_t *hal = NULL;
  component_entry_t *kernel = NULL;
  component_entry_t *loader = NULL;
  int i;
  unsigned long base = rom_base_address;
  unsigned long image_size_num;
  char buffer[BUFFER_LEN];

  /* We need to know the size information for each component */
  if (!ran_install_rom && image_type == image_type_main_rom) {
    build_install_rom_(build_install_rom_size_calculation);
  }

  image_size_num = strtoul(image_size, NULL, 0);
  if (image_type == image_type_extension_rom && (image_size_num & 3)) {
    error(1, "Extension ROMs must be a multiple of 4K long");
  }
  image_size_num *= 1024ul;

  fprintf(fh, "-format\n%s\n", image_type_names[image_type]);

  sb_buildfilename(BUFFER_LEN, buffer, build_dir, IMAGES_DIR, image_filename, NULL);
  fprintf(fh, "-imagename\n%s\n-imagesize\n%lu\n", buffer, image_size_num);

  for (i = 0; i < join_db_hwm; ++i) {
    fprintf(fh, "-%s\n%s\n",
      (const char *)hash_key(join_db, join_entries[i]), (const char *) hash_value(join_db, join_entries[i]));
  }

  /* look for kernel */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (type == HAL) {
      if (hal) {
        error(1, "you appear to have more than one HAL in this ROM");
      }
      if (image_type == image_type_extension_rom || image_type == image_type_expansion_rom) {
        error(1, "you appear to have a kernel in an expansion ROM/expansion card!");
      }
      hal = component;
    }
    else if (type == KERNEL) {
      if (kernel) {
        error(1, "you appear to have more than one kernel in this ROM");
      }
      if (image_type == image_type_extension_rom || image_type == image_type_expansion_rom) {
        error(1, "you appear to have a kernel in an expansion ROM/expansion card!");
      }
      kernel = component;
    }
    else if (type == LOADER) {
      if (loader) {
        error(1, "you appear to have more than one loader in this ROM");
      }
      if (image_type == image_type_main_rom) {
        error(0, "you appear to have an expansion card/extension ROM loader in this ROM");
      }
      loader = component;
    }

    component = component->next;
  }

  if (hal) {
    fprintf(fh, "HAL:%s\n", build_generate_installed_name(BUFFER_LEN, buffer, lookup_module(hal->name)));
  }

  if (kernel) {
    if (kernel->force_position)
      fprintf(fh, "%lu\n", kernel->force_position - base);
    fprintf(fh, "%s\n", build_generate_installed_name(BUFFER_LEN, buffer, lookup_module(kernel->name)));
  }

  if (loader) {
    fprintf(fh, "LOADER:%s\n", build_generate_installed_name(BUFFER_LEN, buffer, lookup_module(loader->name)));
  }

  /* now write out the other modules in order */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
      case DATA:
        if (module->filename != NULL) {
          if (type == DATA)
            fprintf(fh, "%lu\n", component->position - base);
          fprintf(fh, "%s\n", build_generate_installed_name(BUFFER_LEN, buffer, module));
        }
        break;
    }
    component = component->next;
  }

  return 0;
}


int
build_join(void)
{
  char filename[BUFFER_LEN];
  char buffer[BUFFER_LEN];
  FILE *fh = NULL;
  char *redir_start = " < ";
  char *redir_end = " ";
  int system_result;

#ifdef RISCOS
  if (host_system() == _kernel_ARTHUR) {
    /* This hack can be removed once srcbuild uses the new romlinker tool which is
     * written in C and can hence accept UNIX-style redirection unlike the BASIC
     * joiners we have used in the past.
     */
    redir_start = " { < ";
    redir_end = " } ";
  }
#endif

  /* get a temp filename */
  assert(BUFFER_LEN >= L_tmpnam);
  tmpnam(filename);

  if ((fh = fopen(filename, "w")) == NULL)
    error(1, "cannot open temporary file '%s' for joiner data file.", filename);

  /* contruct the joiner file */
  if (cstrcmp(joiner_format, "BigSplit") == 0)
    joiner_format_bigsplit(fh);
  else if (cstrcmp(joiner_format, "MakeExpROM") == 0)
    joiner_format_makeexprom(fh);
  else if (cstrcmp(joiner_format, "romlinker") == 0)
    joiner_format_romlinker(fh);
  else
    error(1, "Unknown joiner file format '%s'", joiner_format);

  fclose(fh);

  /* check which joiner we are using */
  if (cstrcmp(joiner, "bigsplit") == 0) {
    sprintf(buffer, "%s %s %s %s", joiner, redir_start, filename, redir_end);
  } else if (cstrcmp(joiner, "bigsplit2") == 0) {
    /* we have some options to deal with */
    if (sigstr) {
      sprintf(buffer, "%s -sigstr %s ", joiner, sigstr);
    } else if (signum) {
      sprintf(buffer, "%s -sigstr %s ", joiner, signum);
    } else {
      sprintf(buffer, "%s -nosig ", joiner);
    }
    strcat(buffer, filename);
  }
  else if (cstrcmp(joiner, "makeexprom") == 0) {
    /* we have some options to deal with */
    sprintf(buffer, "%s %s %s %s", joiner, redir_start, filename, redir_end);
  }
  else if (cstrcmp(joiner, "romlinker") == 0) {
    sprintf(buffer, "%s -via %s", joiner, filename);
  }
  else {
    error(1, "Unknown joiner '%s'", joiner);
  }


  /* dispatch the joiner */
  sb_system_sync();
  system_result = sb_system(buffer);
  sb_system_sync();
  remove(filename);

  if (system_result != 0) {
    error(1, "running joiner '%s' with file '%s'.", joiner, filename);
  }

  return 0;
}

/*
 * generate a list of all modules to be included in a ROM
 */
int
build_list(void)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    sb_printf("%-25s %-10s %s\n", component->name, module_type_names[(int) type],
      component->options ? component->options : "");
    component = component->next;
  }
  return 0;
}


static void get_amu_machine(void)
{
  char *s;

  if (amu_machine)
  {
    free (amu_machine);
  }

  /* Grab the sysvar */
  amu_machine = sb_strdup(sb_getenv(AMUMACHINEVAR));

  if (verbose > 2)
  {
    sb_printf("amu_machine now = %s\n", amu_machine);
  }

#ifdef RISCOS
  /* Remove the trailing %*0 */
  if ((s = strrchr (amu_machine, '%')) != NULL)
    *s = '\0';

  /* gstrans it... */
  {
    char buffer[512];
    _swix(OS_GSTrans, _INR(0,3), amu_machine, buffer, sizeof(buffer), 0);
    free(amu_machine);
    amu_machine = sb_strdup(buffer);
  }

  if (verbose > 2)
  {
    sb_printf("amu_machine now = %s\n", amu_machine);
  }
#endif
}



/*
 * Function to initialise the build system, currently only extracts the value of
 * Alias$amu_machine and stores it internally in the correct form for use in
 * amu_machinef() */
void build_init(void)
{
  get_amu_machine();
}


/*
 * do RAM install phase
 * Added by NB (Mon 09th August 1999).
 */
int
build_install(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char output_path[BUFFER_LEN];
  FILE *fh_shadow = NULL;
  char *switch_on = NULL;
  module_type_t type;

  sb_buildfilename(BUFFER_LEN, buffer, build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name, NULL);
  if ((fh_shadow = fopen(buffer, "w")) == NULL)
    error(1, "cannot open shadow file '%s'.", buffer);

  sb_system_sync();

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case RES:
      case LOADER:
      case KERNEL:
      case HAL:
      case DATA:
        if (build_select_module_directory(component, module)) {
	  /*
	   * do we want to force a clean build due to changes
	   */
	  if (component->force_clean) {
            sb_printf("Forcing a clean build due to switch/option changes...\n");
	    if (amu_machinef("-k clean COMPONENT=%s %s",
		component->name,
		component->options ? component->options : "") != 0)
	      error(0, "running make clean on module '%s'.", component->name);
              sb_system_sync();
	  }
	  /*
	   * find out what we are switching this module on
	   */
	  switch_on = NULL;
	  if (component->switch_on)
	    switch_on = component->switch_on;
	  else if (module->switch_on)
	    switch_on = module->switch_on;

	  if (component->options || switch_on) {
	    fprintf(fh_shadow, "%s ", component->name);
	    if (switch_on) {
	      fprintf(fh_shadow, "-switch %s ", switch_on);
	    }
	    if (component->options) {
	      fprintf(fh_shadow, "-options %s", component->options);
	    }
	    fprintf(fh_shadow, "\n");
	  }

          /* Setup Install Dir */
          if (component->install == NULL)
          {
            sb_buildfilename(BUFFER_LEN, output_path, build_dir, INSTALL_DIR, build_name, module->output, NULL);
          }
          else
          {
            /* -install has been set for this component in the Components file, so add the contents to install dir */
            sb_buildfilename(BUFFER_LEN, output_path, build_dir, INSTALL_DIR, build_name, component->install, NULL);
          }

          if ((component->options != NULL)
               &&
              (strstr_ci(component->options, "INSTDIR=") != NULL))
          {
            if (amu_machinef("install COMPONENT=%s %s%s %s",
                             component->name,
                             module->filename?"TARGET=":"",
                             module->filename?module->filename:"",
                             component->options ? component->options : "")
                != 0) error(1, "running make install on module '%s'.", component->name);
          }
          else
          {
            if (amu_machinef("install COMPONENT=%s %s%s INSTDIR=%s %s",
                             component->name,
                             module->filename?"TARGET=":"",
                             module->filename?module->filename:"",
                             output_path,
                             component->options ? component->options : "")
                != 0) error(1, "running make install on module '%s'.", component->name);
          }
       }

    }
    component = component->next;
  }

  if (fh_shadow)
    fclose(fh_shadow);

  sb_system_sync();

  return 0;
}



/*
 * do release_autobuild phase
 * Added by SAR (12th Jul 2009).
 */
int
build_release_autobuild(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char output_path[BUFFER_LEN];
  FILE *fh_shadow = NULL;
  char *switch_on = NULL;
  module_type_t type;

  sb_buildfilename(BUFFER_LEN, buffer, build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name, NULL);
  if ((fh_shadow = fopen(buffer, "w")) == NULL)
    error(1, "cannot open shadow file '%s'.", buffer);

  sb_system_sync();

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case RES:
      case LOADER:
      case KERNEL:
      case HAL:
      case DATA:
        if (build_select_module_directory(component, module)) {
          /*
           * find out what we are switching this module on
           */
          switch_on = NULL;
          if (component->switch_on)
            switch_on = component->switch_on;
          else if (module->switch_on)
            switch_on = module->switch_on;

          if (component->options || switch_on) {
            fprintf(fh_shadow, "%s ", component->name);
            if (switch_on) {
              fprintf(fh_shadow, "-switch %s ", switch_on);
            }
            if (component->options) {
              fprintf(fh_shadow, "-options %s", component->options);
            }
            fprintf(fh_shadow, "\n");
          }

          /* Setup Install Dir */
          if (component->install == NULL)
          {
            sb_buildfilename(BUFFER_LEN, output_path, build_dir, INSTALL_DIR, build_name, module->output, NULL);
          }
          else
          {
            /* -install has been set for this component in the Components file, so add the contents to install dir */
            sb_buildfilename(BUFFER_LEN, output_path, build_dir, INSTALL_DIR, build_name, component->install, NULL);
          }

          if ((component->options != NULL)
               &&
              (strstr_ci(component->options, "INSTDIR=") != NULL))
          {
            if (amu_machinef("-k release_autobuild COMPONENT=%s %s%s %s",
                             component->name,
                             module->filename?"TARGET=":"",
                             module->filename?module->filename:"",
                             component->options ? component->options : "")
                != 0) error(0, "running make release_autobuild on module '%s'.", component->name);
          }
          else
          {
            if (amu_machinef("-k release_autobuild COMPONENT=%s %s%s INSTDIR=%s %s",
                             component->name,
                             module->filename?"TARGET=":"",
                             module->filename?module->filename:"",
                             output_path,
                             component->options ? component->options : "")
                != 0) error(0, "running make release_autobuild on module '%s'.", component->name);
          }
       }

    }
    component = component->next;
  }

  if (fh_shadow)
    fclose(fh_shadow);

  sb_system_sync();

  return 0;
}



/************************************************************
 *
 * FUNC: strcasecmp()
 *
 * IN:  const char*   - pointer to first string
 *      const char*   - pointer to second string
 *
 * OUT: unsigned int  - zero = strings matched, else didn't match
 *
 * USE:
 *
 *   Compare two ASCII strings, irrespective of case. Will return zero if they
 *   match and non-zero if they do not.
 */
unsigned int strcasecmp(const char *xs, const char *ys)
{
  unsigned char xc;
  unsigned char yc;

  if (*ys == '\0') return(0);
  do
  {
    xc = *xs++;
    yc = *ys++;
    ASCII_LowerCase(xc);
    ASCII_LowerCase(yc);
    if (xc != yc) return(1);
  } while (*ys != '\0');

  return (0);
}
/************************************************************
 *
 * FUNC: strstr_ci()
 *
 * IN:   const char*  - pointer to string to search in
 *       const char*  - pointer to substring to search for
 *
 * OUT:  char*        - pointer to first matched substring (NULL if not found)
 *
 * USE:
 *
 *   Look for a substring within an ASCII string, irrespective of case. Will
 *   return a pointer to the start of the first matching substring or NULL if
 *   no matches were found.
 */
const char *strstr_ci(const char *source, const char *substr)
{
  unsigned int len = strlen(source);

  do
  {
    if (strcasecmp(source, substr) == 0) return(source);
    source++;
  } while (len--);

  return(0);
}


/************************************************************
 *
 * FUNC: last_strstr_ci()
 *
 * IN:   const char*  - pointer to string to search in
 *       const char*  - pointer to substring to search for
 *
 * OUT:  char*        - pointer to last matched substring (NULL if not found)
 *
 * USE:
 *
 *   Look for a substring within an ASCII string, irrespective of case. Will
 *   return a pointer to the start of the last matching substring or NULL if
 *   no matches were found.
 */
static const char *last_strstr_ci(const char *source, const char *substr)
{
  const char *sub = NULL;
  const char *nxt = strstr_ci(source, substr);

  while (nxt)
  {
    sub = nxt++;
    nxt = strstr_ci(nxt, substr);
  }

  return(sub);
}


/************************************************************
 *
 * FUNC: copy_env()
 *
 * IN:   const char *  - pointer to environment variable to write
 *       const char *  - pointer to environment variable to read
 *
 * OUT:  None.
 *
 * USE:
 *
 *   Set an environment variable to contain a copy of the contents of another.
 *   This will create the variable to write if it does not already exist. It
 *   will not do anything if the variable to read does not exist.
 */
void copy_env(const char *env_wr, const char *env_rd)
{
  const char *val = sb_getenv(env_rd);

  if (val) sb_setenv(env_wr, val);
}


/************************************************************
 *
 * FUNC: override_envvar()
 *
 * IN:   const char*  - options string passed to amu_machine
 *       const char*  - option/variable to look for (i.e. "Locale", "UserIF", "Machine")
 *       const char*  - temporary variable to copy variable into (i.e. "Locale$tmp")
 *
 * OUT:  None.
 *
 * USE:
 *
 *   Various options are traditionally set in environment variables, which a
 *   component can then use in its Makefile. These variables usually have an
 *   associated parameter which can be passed as an option to amu. This routine
 *   will ensure that the environment variables reflect the value of any option
 *   (taking the last instance if it is multiply defined).
 *
 *   For example, with a command line of:
 *
 *     "amu_machine install Locale=UK INSTDIR=<Install$Dir> Locale=Taiwan"
 *
 *   and the variable to scan for is "Locale", the assignment we find will be
 *   "Locale=Taiwan". Thus, we set "Locale$tmp" to "<Locale>" and then set
 *   "Locale" to "Taiwan".
 */
void override_envvar(const char *source, const char *var, const char *tmpvar)
{
  char buffer[ENVVAR_BUF_LEN];
  const char *end;
  const char *sub = last_strstr_ci(source, var);
  unsigned int len;

  /* Copy the value of the specified variable into its tmp partner */
  copy_env(tmpvar, var);

  /* If we didn't find this var in the options list, simply exit */
  if (sub == 0) return;

  /* If the match doesn't start with a space, discard it */
  if (*(sub - 1) != ' ') return;

  /* Given the last 'var=val' assignment in the options list for
   * the variable specified to this function, look for what value
   * it is to be set to */
  sub += strlen(var);

  /* Exit if the assignment is missing the '=' sign */
  if (*sub++ != '=') return;

  /* Find the end of the  */
  len = strlen(sub);
  end = strchr(sub, ' ');
  if (end != NULL) len = (end - sub);

  /* If the 'var=' assignment is empty, exit */
  if (len == 0) return;

  /* Set the specified variable to the assigned value */
  assert(ENVVAR_BUF_LEN >= len);
  strncpy(buffer, sub, len);
  *(buffer+len) = '\0';
  sb_setenv(var, buffer);
}
