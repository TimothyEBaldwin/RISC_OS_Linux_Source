/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "Licence").
 * You may not use this file except in compliance with the Licence.
 *
 * You can obtain a copy of the licence at
 * cddl/RiscOS/Sources/HWSupport/ATA/SATADriver/LICENCE.
 * See the Licence for the specific language governing permissions
 * and limitations under the Licence.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the Licence file. If applicable, add the
 * following below this CDDL HEADER, with the fields enclosed by
 * brackets "[]" replaced with your own identifying information:
 * Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2015 Ben Avison.  All rights reserved.
 * Use is subject to license terms.
 */

#include <stddef.h>
#include <string.h>
#include "swis.h"

#include "Global/NewErrors.h"
#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Interface/ATA.h"

#include "SATADriverHdr.h"
#include "command.h"
#include "device.h"
#include "globals.h"
#include "message.h"
#include "swi.h"

/* This function is autogenerated by ResGen, and returns a pointer to a
 * ResourceFS resource file data block */
extern void *Resources(void);

static void module_post_init(void);

_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *e;
  IGNORE(cmd_tail);
  IGNORE(podule_base);

  g_module_pw = pw;

#ifndef ROM_MODULE
  e = _swix(ResourceFS_RegisterFiles, _IN(0), Resources());
  if (e != NULL)
    return e;
#else
  /* In ROM builds, all resource files live in the Messages module instead */
#endif

  e = _swix(MessageTrans_OpenFile, _INR(0,2), &g_message_fd, "Resources:$.Resources.SATADriver.Messages", 0);
  if (e != NULL)
  {
#ifndef ROM_MODULE
    _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif
    return e;
  }

  synclib_init();
#ifdef DEBUGLIB
  /* Set up debugging */
  debug_initialise(Module_Title, "", "");
  debug_set_device(DADEBUG_OUTPUT);
  debug_set_unbuffered_files(TRUE);
#endif

  /* The module needs to be on TickerV the whole time */
  if (e == NULL)
    e = _swix(OS_Claim, _INR(0,2), TickerV, module_tickerv_veneer, g_module_pw);

  if (e != NULL)
  {
    module_finalise(0, 0, 0);
    return e;
  }

  return NULL;
}

_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{
  IGNORE(fatal);
  IGNORE(podule);
  IGNORE(pw);

  /* Cleanup is the same as though all known devices have been removed */
  if (g_ahci.valid)
    device_removed(g_ahci.dev);

  _swix(OS_Release, _INR(0,2), TickerV, module_tickerv_veneer, g_module_pw);

  _swix(MessageTrans_CloseFile, _IN(0), &g_message_fd);
#ifndef ROM_MODULE
  _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif
  return NULL;
}

void module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);

  switch (service_number)
  {
    case Service_ModulePostInit:
    {
      if(!strcmp((const char *) r->r[2], Module_Title))
      {
        /* Now that our SWI handler is active, we can scan for devices */
        module_post_init();
      }
      break;
    }

    case Service_PreReset:
    {
      if (g_ahci.valid)
      {
        hba_regset_t *hba = g_ahci.dev->dev.address;

        /* Manually reset the controller here. This implicitly stops the controller
         * from interrupting so it's OK to leave the trampoline installed by device_added().  
         * Don't worry about freeing memory since we're about to reboot. */
        hba->ghc |= GHC_HR;
        g_ahci.valid = false;
      }
      break;
    }
  }
}

_kernel_oserror *module_command(const char *arg_string, int argc, int cmd_no, void *pw)
{
  IGNORE(arg_string);
  IGNORE(argc);
  IGNORE(pw);

  switch (cmd_no)
  {
    case CMD_SATADevices:
      return command_satadevices();
  }

  return NULL;
}

_kernel_oserror *module_swi(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);

  switch (swi_offset)
  {
    case ATA_Initialise - ATA_00:
      switch (r->r[0])
      {
        case ATAInitialise_Reset:
          return swi_initialise_reset((r->r[1] & ATAReset_CPIDMask) >> ATAReset_CPIDShift);

        default:
          return MESSAGE_ERRORLOOKUP(true, ATA_BadReason, "ATA_Initialise");
      }

      case ATA_Control - ATA_00:
        switch (r->r[0])
        {
          case ATAControl_TryLock:
            return swi_control_try_lock((r->r[1] & ATAControl_CPIDMask) >> ATAControl_CPIDShift, (r->r[1] & ATAControl_DeviceIDMask) >> ATAControl_DeviceIDShift);

          case ATAControl_Lock:
            return swi_control_lock((r->r[1] & ATAControl_CPIDMask) >> ATAControl_CPIDShift, (r->r[1] & ATAControl_DeviceIDMask) >> ATAControl_DeviceIDShift);

          case ATAControl_SleepLock:
            return swi_control_sleep_lock((r->r[1] & ATAControl_CPIDMask) >> ATAControl_CPIDShift, (r->r[1] & ATAControl_DeviceIDMask) >> ATAControl_DeviceIDShift);

          case ATAControl_Unlock:
            return swi_control_unlock((r->r[1] & ATAControl_CPIDMask) >> ATAControl_CPIDShift, (r->r[1] & ATAControl_DeviceIDMask) >> ATAControl_DeviceIDShift);

          case ATAControl_AbortAll:
            return swi_control_abort_all((r->r[1] & ATAControl_CPIDMask) >> ATAControl_CPIDShift);

          case ATAControl_AbortOp:
            return swi_control_abort_op((r->r[1] & ATAControl_CPIDMask) >> ATAControl_CPIDShift, (ahciop_t *) r->r[2]);

          default:
            return MESSAGE_ERRORLOOKUP(true, ATA_BadReason, "ATA_Control");
        }

      case ATA_Enumerate - ATA_00:
        switch (r->r[0])
        {
          case ATAEnumerate_Drives:
            return swi_enumerate_drives((uint32_t *) &r->r[1], (uint32_t *) &r->r[2]);

          default:
            return MESSAGE_ERRORLOOKUP(true, ATA_BadReason, "ATA_Enumerate");
        }

      case ATA_Op - ATA_00:
        return swi_op((ataop_block_t *) r);

      case ATA_PacketOp - ATA_00:
        return swi_packetop((atapacketop_block_t *) r);

      default:
        return MESSAGE_ERRORLOOKUP(false, ATA_BadSWI, "SATADriver");
  }

  return NULL;
}

_kernel_oserror *module_irq_handler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  return NULL;
}

static void module_post_init(void)
{
  uint32_t handle = 0;
  while (true)
  {
    ahcidevice_t *device;
    _kernel_oserror *e = _swix(OS_Hardware, _INR(0,1)|_IN(8)|_OUTR(1,2),
                               HALDeviceType_ExpCtl + HALDeviceExpCtl_AHCI +
                               HALDeviceAHCI_MajorVersion_SATADriver,
                               handle, 5, &handle, &device);
    if (e != NULL || handle == -1u)
      break;
    device_added(device);
    break; /* TODO: add support for multiple controllers */
  }
}

int module_tickerv_handler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);

  return 1;
}
