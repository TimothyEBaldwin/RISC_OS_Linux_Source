; This source code in this file is licensed to You by Castle Technology
; Limited ("Castle") and its licensors on contractual terms and conditions
; ("Licence") which entitle you freely to modify and/or to distribute this
; source code subject to Your compliance with the terms of the Licence.
; 
; This source code has been made available to You without any warranties
; whatsoever. Consequently, Your use, modification and distribution of this
; source code is entirely at Your own risk and neither Castle, its licensors
; nor any other person who has contributed to this source code shall be
; liable to You for any loss or damage which You may suffer as a result of
; Your use, modification or distribution of this source code.
; 
; Full details of Your rights and obligations are set out in the Licence.
; You should have received a copy of the Licence with this source code file.
; If You have not received a copy, the text of the Licence is available
; online at www.castle-technology.co.uk/riscosbaselicence.htm
; 
; > Sources.SprOp

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OS_SpriteOp decoding entry point
; Entry: R0 = reason code
;        R12 --> private word
; Exit : R0-R7 may be used to contain results
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

My_SpriteOp ROUT
        Debug   so, "Sprite Extend sprite op called...",r0
        Push    "R1"
        AND     r1, r0, #&FF
        CMP     r1, #SpriteReason_CheckSpriteArea
        CMPNE   r1, #myminreason
        Pull    "R1"
        ASSERT  SpriteReason_CheckSpriteArea < myminreason 
        MOVCC   pc, lr

        Push    "R10-R11,LR"
        ; Stash the entry reason code including area flags
        STR     R0,spritecode

        STR     R13,stackframe          ; for calling OS_SpriteOp

        LDR     R14,vdu_bgecforaeor
        STR     R14,save_ecflimit       ; mask plotting uses bg ecf pattern

        JumpAddress LR,My_SpriteExit,forward
        AND     R10, R0, #&FF

        ; First look for CheckSpriteArea which would otherwise make the jump table huge
        CMP     r10, #SpriteReason_CheckSpriteArea
        BEQ     Go_CheckSpriteArea

        ; Do the rest...
        SUB     r10, r10, #myminreason
        CMP     R10,#mymaxreason-myminreason
        ADDCC   PC,PC,R10,LSL #2
        Pull    "R10-R11,PC"

mymaxreason     *       SpriteReason_TileSpriteScaled + 1
myminreason     *       SpriteReason_AppendSprite
myjptable
        B       Go_AppendSprite         ; 35 SpriteReason_AppendSprite
        B       Go_SetPointerShape      ; 36 SpriteReason_SetPointerShape
        B       Go_CreateRemovePalette  ; 37 SpriteReason_CreateRemovePalette
        B       Go_CreateRemoveAlpha    ; 38 SpriteReason_CreateRemoveAlpha
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        B       Go_PlotMaskScaled       ; 50 SpriteReason_PlotMaskScaled
        B       Go_PaintCharScaled      ; 51 SpriteReason_PaintCharScaled
        B       Go_PutSpriteScaled      ; 52 SpriteReason_PutSpriteScaled
        B       Go_PutSpriteGreyScaled  ; 53 SpriteReason_PutSpriteGreyScaled
        Pull    "R10-R11, PC"
        B       Go_PlotMaskTransformed  ; 55 SpriteReason_PlotMaskTransformed
        B       Go_PutSpriteTransformed ; 56 SpriteReason_PutSpriteTransformed
        B       Go_InsertDeleteRows     ; 57 SpriteReason_InsertDeleteRows
        B       Go_InsertDeleteColumns  ; 58 SpriteReason_InsertDeleteColumns
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"           ; 63 Unsupported SpriteReason_PutSpriteScaledCalibrated
        Pull    "R10-R11, PC"           ; 64 Unsupported SpriteReason_PutSpriteTransformedCalibrated
        B       Go_TileSpriteScaled     ; 65 SpriteReason_TileSpriteScaled
        ASSERT  (.-myjptable) = (mymaxreason-myminreason) * 4

My_SpriteExit
        LDRVC   R0,spritecode
01
        Pull    "R10-R11,LR"
        Pull    "PC"


Go_SpriteOp
        Push    "R10-R12,LR"
01
        LDR     R10,stackframe
        Push    "PC"                    ; set up return address
        LDMIA   R10,{R10-R11,PC}        ; call rest of vector owners
        NOP                             ; returns here or next instruction
        Pull    "R10-R12,PC"

TestForTrueColour ROUT ; return V=1 if R2 points at a true colour sprite
        Entry   "R0-R3"

        ;should be called after findsprite has been called

        LDR     R0,[R2,#spMode]
        CMP     R0,#256
        BCC     %FT10                   ; go if a screen mode number
        AND     R1,R0,#15<<27           ; isolate the type alone
        CMP     R1,#SpriteType_RISCOS5<<27
      [ NoARMT2
        ANDEQ   R1,R0,#127<<20
        MOVEQ   R1,R1,LSR #20
      |
        UBFXEQ  R1,R0,#20,#7
      ]
        MOVNE   R1,R1,LSR #27        
        CMP     R1,#SpriteType_New16bpp
        BCC     %FT20                   ; under 16bpp, so don't care
        
30
        ADR     R0, ErrorBlock_BadDepth
        addr    R1, Title
        BL      copy_error_one          ; returns V set
        STR     R0,[R13]
        STR     R1,[R13,#4]
        EXIT

        MakeSpriteErrorBlock BadDepth,,BadDepth
10
        ;it's a mode number
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        BCS     %BT30
        CMP     R2,#4
        BCS     %BT30
20
        EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SpriteReason_CreateRemovePalette
; --------------------------------
; Entry: r0  = 37 (SpriteReason_CreateRemovePalette) (+0 / 256 / 512)
;        r1 -> sprite control block
;        r2 -> sprite name / sprite
;        r3  = -1: read palette size
;            =  0: remove palette
;            <> 0: add palette (bit 31=1, add extended palette)
;
; Exit : V=1 => r0 -> error block
;
;        r3 =-1 on entry then r3  = size of palette block, =0 if none
;                             r4 -> palette block, =0 if none
;                             r5  = mode
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Go_CreateRemovePalette
        Push    "r1-r11, lr"

        BL      findsprite_inarea       ; r2 -> sprite block
        Pull    "r1-r11, PC",VS

        CMP     r3, #-1
        BNE     addremoveit             ; skip read palette size

        ADD     r3, r2, #spImage
        LDMIA   r3, {r3, r4}            ; r3,r4 offsets to mask/image
        CMP     r3, r4
        MOVGT   r3, r4                  ; r3 -> top of palette block
        SUB     r3, r3, #spPalette      ; r3  = size of palette block
        MOVS    r3, r3, ASR #3          ; r3  = number of colours in palette block

        ADDNE   r4, r2, #spPalette      ; r4 -> palette block to return
        MOVEQ   r4, #0                  ; or  =0 if no palette
        LDR     r5, [r2, #spMode]       ; r5  = mode number

        ADD     lr, sp, #4*2            ; lr -> r3 in return frame
        STMIA   lr, {r3, r4, r5}

        CLRV
        Pull    "r1-r11, pc"

addremoveit
        TEQ     r3, #0                  ; remove the palette?
        BNE     addpalette

        ; remove palette, simple case, assuming r1 -> sprite control block, r2 -> sprite
        ; we must move the data in the sprite and then update the header followed by
        ; the control block.
removepalette
        LDR     r4, [r2, #spImage]      ; r4   = offset to image
        LDR     r5, [r2, #spTrans]      ; r5   = offset to trans mask
        CMP     r4, r5
        MOVGT   r4, r5                  ; r4   = offset to first part of sprite data

        LDR     r8, [r1, #saFree]       ; r8   = free index into sprite area

        SUBS    r0, r4, #spPalette      ; r0   = size of palette block, if none then exit!
        ADDNE   r9, r2, #spPalette
        ADDNE   r10, r1, r8             ; r10 -> free in sprite area
        BLNE    move_memory_down

        SUB     r8, r8, r0              ; adjust free space
        STR     r8, [r1, #saFree]

        LDR     r3, [r2, #spNext]       ; adjust next sprite pointer
        SUB     r3, r3, r0
        STR     r3, [r2, #spNext]

        ADD     r3, r2, #spImage        ; adjust offsets to image data
        LDMIA   r3, {r4, r5}
        SUB     r4, r4, r0
        SUB     r5, r5, r0
        STMIA   r3, {r4, r5}

        CLRV
        Pull    "r1-r11, pc"


        ; add sprite palettes, this involves creating a gap for the sprite
        ; palette and then writing the actual data for the palette into this area
        ; these routines will use a general purpose function 'addpalette' taking
        ; r1,r2 as sprite pointers and r4 as a mask to be applied to the maximum
        ; number of colours.  This mask is used to generate the real number of
        ; colours written into the sprite header.
addpalette
        ; the test for 16/32bpp only occurs here, so that read palette size, and
        ; remove palette won't complain

        LDR     r0, [r2, #spMode]       ; r0  = mode
        MOVS    lr, r0, LSR #27         ; EQ for old format sprite, NE otherwise
        BEQ     %FT10

        ;now allow T=1 to T=4 to have palettes
        BL      TestForTrueColour
        Pull    "r1-r11, PC",VS
10
        TST     r3, #1:SHL:31           ; add extended palette?
        MOVNE   r4, #255
        MOVEQ   r4, #63                 ; max colours that can be added

        Push    "r1-r2"

        LDR     r0, [r2, #spMode]       ; r0  = mode
        MOV     r1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable    ; no need to check for CS here - will already
        ADR     r1, palettetables       ; have happened in TestForTrueColour
        LDR     r5, [r1, r2, ASL #2]    ; r5  = offset to palette tables
        ADD     r5, r5, r1              ; r5 -> absolute table
        MOV     r8, #2                  ; shift =2 as reading from table (single entries)

        MOV     r0, #1
        MOV     r1, r0, ASL r2
        RSB     r3, r0, r0, ASL r1      ; r3  = maximum number of colours
        AND     r4, r3, r4              ; r4  = maximum number of written colours

        Pull    "r1-r2"                 ; preserve sprite pointers

        ADD     r0, r4, #1
        MOV     r0, r0, ASL #3          ; r0 = size of a palette block

        ADD     r6, r2, #spImage
        LDMIA   r6, {r6, r7}            ; r6, r7 -> sprite, mask

        MOV     lr, r6
        CMP     lr, r7
        MOVGT   lr, r7                  ; lr =lowest offset

        SUBS    lr, lr, #spPalette      ; lr =size of current palette
        SUBNE   r0, r0, lr
        ADDNE   r5, r2, #spPalette      ; if adjusting size then modify from current palette
        MOVNE   r8, #3                  ; shift =3, reading from sprite palette (double entries)

        LDR     r9, [r1, #saFree]
        LDR     r10, [r1, #saEnd]
        ADD     r9, r9, r0              ; r9 => end of free area
        CMP     r9, r10                 ; is there enough room?
        BHI     add_no_room             ; no, so complain!

        STR     r9, [r1, #saFree]       ; store new offset to start of free area
        ADD     r10, r9, r1             ; r10 -> new start of free area
        SUB     r10, r10, r0            ; r10 -> old start of free area
                                        ;     =  end address+1 of block to move

        LDR     r9, [r2, #spNext]
        ADD     r9, r9, r0
        STR     r9, [r2, #spNext]       ; adjust the offset to next sprite

        ADD     r6, r6, r0
        ADD     r7, r7, r0
        ADD     r9, r2, #spImage
        STMIA   r9, {r6, r7}            ; stash updated image + mask offsets

        ADD     r9, r2, #spPalette      ; r9 -> start of current palette
        ADD     r9, r9, lr              ; r9 -> end of current palette+1
                                        ;    =  start address of block to move
        BL      move_memory_up

        ADD     r6, r2, #spPalette      ; r6 -> destination buffer
        ADD     r6, r6, r4, LSL #3
        LDR     r7, =&0F0F0F00          ; r7  = masked used when ensuring palette entries

        ; r1 -> sprite blk
        ; r2 -> sprite
        ; r3  = total colours (ie. 1, 3, 15, 255)
        ; r4  = number of colours to write ( 1, 3, 15, 63 / 255)
        ; r5 -> table containing base palette entries
        ; r6 -> block to write data into
        ; r7  = &0F0F0F00
        ; r8  = shift to use when getting palette entries
addpalette_main
        AND     r0, r4, #15
        ADD     r0, r5, r0, LSL r8
        LDR     r0, [r0]                ; r0 = BGR combination

        TEQ     r3, #255                ; is it a 8bpp palette?
        BNE     addpalette_gotvalues

        BIC     r0, r0, #&80000000      ; transfer hard blue bit
        AND     lr, r4, #&80
        ORR     r0, r0, lr, LSL #31-7
        BIC     r0, r0, #&00C00000      ; transfer hard green bit
        AND     lr, r4, #&60
        ORR     r0, r0, lr, LSL #23-6
        BIC     r0, r0, #&00008000      ; transfer hard red bit
        AND     lr, r4, #&10
        ORR     r0, r0, lr, LSL #15-4

        BIC     r0, r0, r7
        ORR     r0, r0, r0, LSR #4      ; change from &B0G0R00 -> &BBGGRR00

addpalette_gotvalues
        ORR     r0, r0, #&10
        STR     r0, [r6],#4
        STR     r0, [r6],#-12           ; write and advance index

        SUBS    r4, r4, #1
        BGE     addpalette_main         ; loop whilst colour counter >= 0

        Pull    "r1-r11, pc"

add_no_room
        ADR     r0, ErrorBlock_NotEnoughRoom
        addr    r1, Title
        BL      copy_error_one          ; Always sets the V flag
        Pull    "r1-r11, PC"

        MakeSpriteErrorBlock NotEnoughRoom,,NoMem

        ; tables for creating default palettes
palettetables
        DCD     bpp1 -palettetables
        DCD     bpp2 -palettetables
        DCD     bpp4 -palettetables
        DCD     bpp8 -palettetables

bpp1    DCD     &00000000       ;  black
        DCD     &FFFFFF00       ;  white

bpp2    DCD     &00000000       ;  black
        DCD     &0000FF00       ;  red
        DCD     &00FFFF00       ;  yellow
        DCD     &FFFFFF00       ;  white

bpp4    DCD     &00000000       ;  black
        DCD     &0000FF00       ;  red
        DCD     &00FF0000       ;  green
        DCD     &00FFFF00       ;  yellow
        DCD     &FF000000       ;  blue
        DCD     &FF00FF00       ;  magenta
        DCD     &FFFF0000       ;  cyan
        DCD     &FFFFFF00       ;  white
        DCD     &00000000       ;  black
        DCD     &0000FF00       ;  red
        DCD     &00FF0000       ;  green
        DCD     &00FFFF00       ;  yellow
        DCD     &FF000000       ;  blue
        DCD     &FF00FF00       ;  magenta
        DCD     &FFFF0000       ;  cyan
        DCD     &FFFFFF00       ;  white

bpp8    DCD     &00000000       ;  0000
        DCD     &10101000       ;  0001
        DCD     &20202000       ;  0010
        DCD     &30303000       ;  0011
        DCD     &00004000       ;  0100
        DCD     &10105000       ;  0101
        DCD     &20206000       ;  0110
        DCD     &30307000       ;  0111
        DCD     &40000000       ;  1000
        DCD     &50101000       ;  1001
        DCD     &60202000       ;  1010
        DCD     &70303000       ;  1011
        DCD     &40004000       ;  1100
        DCD     &50105000       ;  1101
        DCD     &60206000       ;  1110
        DCD     &70307000       ;  1111

        LTORG

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SpriteReason_CreateRemoveAlpha
; --------------------------------
; Entry: R0  = 38 (SpriteReason_CreateRemoveAlpha) (+0 / 256 / 512)
;        R1 -> sprite control block
;        R2 -> sprite name / sprite
;        R3 bits 0-7 = cutoff for reduction to binary mask/alpha, or 0 to only
;                      reduce if no information will be lost (i.e. already
;                      binary or 4bpp)
;        R3 bit 8 = remove mask/alpha if completely unnecessary
;        R3 bit 30-31 = 0 -> convert to 1bpp mask. Bits 0-8 relevant.
;                       1 -> reserved
;                       2 -> convert to 8bpp mask. Bits 0-8 ignored.
;                       3 -> convert to alpha channel:
;                             error if alpha not possible in mode
;                             if 1bpp alpha, bits 0-8 fully relevant
;                             if 4bpp alpha, bit 8 relevant, bits 0-7 zeroness
;                                            relevant
;                             if 8bpp alpha, only bit 8 relevant
;
; Exit : R3 = 0, V clear: operation completed OK
;        R3 <> 0, V set, R0 error ptr: sprite area needs increasing by R3 bytes
;        R3 zero, V set, R0 error ptr: some other error
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Go_CreateRemoveAlpha ROUT
        Push    "r4-r11, lr"
        MOV     r4,#0
        Push    "r1-r2,r4"              ; zap returned R3 value

        BL      findsprite_inarea       ; r2 -> sprite block
        Pull    "r1-r11, PC",VS

        ; Ensure it's a new format sprite (either RO 3.5 or RO 5)
        LDR     R4, [R2, #spMode]
        TST     R4, #15<<27
        ADREQL  R0, ErrorBlock_InvalidSpriteMode
        BLEQ    copy_error_one
        Pull    "r1-r11, PC",VS

        ; Assume the user didn't supply bad flags and go ahead and examine the
        ; sprite
        BL      ExamineAlpha
        Pull    "r1-r11, PC",VS

        Debug   so,"ExamineAlpha result R4,R6,R7,R8,R11",R4,R6,R7,R8,R11

        ; Now check for bad flags and branch off to the right routine

cra_cutoff        * &000000ff
cra_canremove     * &00000100
cra_mode          * &c0000000

cra_examine_hasmask     * 3
cra_examine_has1bppmask * 1
cra_examine_has8bppmask * 2

cra_examine_hasalpha     * (7<<2)
cra_examine_has1bppalpha * 4
cra_examine_has4bppalpha * 8
cra_examine_has8bppalpha * 16

cra_examine_isbinary        * 32  ; All mask pixels are 0 or 255
cra_examine_issolid         * 64  ; All mask pixels are 255
cra_examine_is4bpp          * 128 ; All mask pixels are X*17
cra_examine_isabovecutoff   * 256 ; All mask pixels are >= cutoff value
cra_examine_isabove240      * 512 ; All mask pixels are >= &F0

        AND     LR, R3, #cra_mode
        BIC     R3, R3, #cra_mode
        CMP     R3, #cra_cutoff+cra_canremove+1
        ADDLO   PC, PC, LR, LSR #28
        B       %FT01 ; bad flags
        B       %FT10 ; 00 -> 1bpp mask
        B       %FT01 ; 01 -> reserved (-> bad flags)
        B       %FT30 ; 10 -> 8bpp mask
        B       %FT50 ; 11 -> alpha channel
01
        ADRL    R0, ErrorBlock_BadFlags
        ADRL    R1, Title
        BL      copy_error_one
        Pull    "r1-r11, PC"

10
        ; Reduce to 1bpp mask
        CMP     R4, #0 ; No mask at all?
        EORNE   LR, R4, #cra_examine_has1bppmask
        TSTNE   LR, #cra_examine_has1bppmask ; Or already 1bpp mask?
        BEQ     %FT29 ; Success!

        TST     R3, #cra_canremove
        TSTNE   R4, #cra_examine_issolid+cra_examine_isabovecutoff ; If it's solid, or will be solid after cutoff is taken into consideration, remove it
        BEQ     %FT12
11
        ; Remove mask altogether
        Debug   so,"Remove mask altogether"
        LDR     R0, =SpriteReason_RemoveMask+&200
        SWI     XOS_SpriteOp
        Pull    "r1-r11, PC", VS
        LDR     R0, [R2, #spMode]
        BL      GetNonAlphaEquivalent
        STR     R0, [R2, #spMode]
        Pull    "r1-r11, PC"

12
        ANDS    R3, R3, #cra_cutoff ; If we can only reduce if it's binary
        MOVEQ   R3, #255 ; Set cutoff to sensible value if it was zero
        TSTEQ   R4, #cra_examine_isbinary ; And it's not binary
        BNE     %FT16
        ; Then there's nothing we can do, except tidy up the mode word a bit
        TST     R4, #cra_examine_has8bppmask
        BNE     %FT31 ; Try converting RO 5 to 3.5 with alpha mask
        Pull    "r1-r11, PC" ; If it wasn't an alpha mask, it must be an alpha channel - and there's nothing we can do simplify the mode word in that case

16
        TST     R4, #cra_examine_hasalpha
        BNE     %FT20
        ; We have an 8bpp mask, so can do an in-place reduction
        Debug   so,"8bpp to 1bpp mask reduction"
        ADD     R4, R8, #1+(31<<3) ; +1 to get original width in bits, /8 to get original width in pixels (i.e. destination bits), +31 for rounding up to word multiple
        MOV     R4, R4, LSR #5+3 ; dest width in words
        BL      TransferTo1bppMask
        BL      ShrinkAreaR11ToR0
        LDR     R0, [R2, #spMode]
        BL      GetNonAlphaEquivalent ; Demote to 3.5 sprite type if possible (may have been RISC OS 5 type but with alpha mask)
        STR     R0, [R2, #spMode]
        Pull    "r1-r11, PC"

20
        ; We have alpha, so must first create a mask
        Debug   so,"Creating 1bpp mask from alpha"
        LDR     R0, [R2, #spMode]
        BL      GetNonAlphaEquivalent
        STR     R0, sp_mode
        ; Work out mask size and extend sprite
        Push    "R8"
        LDR     R5, [R2, #spWidth]
        LDR     R8, [R2, #spRBit]
        BL      FindMaskWidth
        LDR     R0, [R2, #spHeight]
        ADD     R4, R5, #1 ; Dest width in words
        Pull    "R8"
        MLA     R0, R4, R0, R4
        MOV     R0, R0, LSL #2
        BL      ExpandMaskSizeToR0
        STRVS   R3, [SP, #2*4]
        Pull    "r1-r11, PC", VS
        ; The mask should have been created at the end of the sprite, so the offset in R11 should still be valid
        ; Go ahead and fill in the mask
        BL      TransferTo1bppMask
        ; Destroy src alpha
        BL      DestroySrcAlpha
29
        ; Update sprite mode word
        LDR     R0, [R2, #spMode]
        BL      GetNonAlphaEquivalent
        STR     R0, [R2, #spMode]
        Pull    "r1-r11, PC"

30
        ; Convert to 8bpp alpha mask
        TST     R4, #cra_examine_has8bppmask
        BNE     %FT31 ; Already have one
        ; Create 8bpp alpha mask
        Debug   so,"Creating 8bpp mask"
        LDR     R0, [R2, #spMode]
        BL      GetNonAlphaEquivalent
        ORR     R0, R0, #&80000000
        STR     R0, sp_mode
        Push    "R8"
        MOV     R10, R4 ; Preserve examine result
        LDR     R5, [R2, #spWidth]
        LDR     R8, [R2, #spRBit]
        BL      FindMaskWidth
        LDR     R0, [R2, #spHeight]
        ADD     R4, R5, #1 ; Dest width in words
        Pull    "R8"
        MLA     R0, R4, R0, R4
        MOV     R0, R0, LSL #2
        BL      ExpandMaskSizeToR0
        STRVS   R3, [SP, #2*4]
        Pull    "r1-r11, PC", VS
        ; This is where things get a bit tricky
        CMP     R10, #0
        BEQ     %FT31 ; If no initial mask, then we're done
        TST     R10, #cra_examine_has1bppmask
        BNE     %FT40 ; If we had a 1bpp mask then we need a special routine which expands backwards
        ; Else we can expand forwards
        ; The mask should have been created at the end of the sprite, so the offset in R11 should still be valid
        BL      TransferTo8bppMask
        ; Destroy src alpha
        BL      DestroySrcAlpha
31        
        ; Update sprite mode word
        Debug   so, "Updating mode word for 8bpp mask"
        LDR     R0, [R2, #spMode]
        BL      GetNonAlphaEquivalent
        ORR     R0, R0, #&80000000
        STR     R0, [R2, #spMode]
        Pull    "r1-r11, PC"

40
        ; Convert to 8bpp from 1bpp mask
        ; R2 = sprite
        ; R4 = dest width in words
        ; R6 = src width in words
        ; R8 = src width in bits - 1
        ; R11 = src row ptr
        Debug   so,"Converting 1bpp mask to 8bpp"
        LDR     R0, [R2, #spTrans]
        ADD     R0, R0, R2 ; dest row ptr
        LDR     R5, [R2, #spHeight] ; height
        MOV     R4, R4, LSL #2
        MOV     R6, R6, LSL #2
        MLA     R0, R4, R5, R0 ; last dest row
        MLA     R11, R6, R5, R11 ; last src row
43
        ADD     R10, R8, #1 ; src offset
44
        SUB     R10, R10, #1
        LDRB    R9, [R11, R10, LSR #3]
        AND     R14, R10, #7
        MOV     R9, R9, LSR R14
        ANDS    R9, R9, #1
        MOVNE   R9, #255
        STRB    R9, [R0, R10]
        CMP     R10, #0
        BGT     %BT44
        SUB     R11, R11, R6 ; Advance src row ptr
        SUBS    R5, R5, #1
        SUB     R0, R0, R4 ; Advance dest row ptr
        BGE     %BT43
        B       %BT31

50
        ; Convert to alpha channel
        TST     R3, #cra_canremove ; If we can remove
        BEQ     %FT51
        TST     R4, #cra_examine_issolid ; And it's all solid
        BNE     %BT11 ; Then get rid of it
        TEQ     R4, #0 ; Or there's nothing at all
        BEQ     %BT11

51
        TST     R4, #cra_examine_hasalpha ; If it's already got alpha
        Pull    "r1-r11, PC", NE ; Then there's nothing to do

        LDR     R0, [R2, #spMode]
        BL      GetAlphaEquivalent
        Pull    "r1-r11, PC", VS

        TEQ     R4, #0
        BEQ     %FT80 ; Use yet another alternate routine if we're generating alpha from nothing

        LDR     R5, [R2, #spHeight]

        ; Work out what we're converting to
        CMP     R10, #4
        BGT     %FT70
        BEQ     %FT60

        ; Convert to 1bpp alpha
        Debug   so,"Convert to 1bpp alpha"

        TST     R3, #cra_canremove ; If we can remove
        TSTNE   R4, #cra_examine_isabovecutoff ; And it was all above the cutoff
        BNE     %BT11 ; Then get rid of it

        ANDS    R3, R3, #cra_cutoff ; If we can only reduce if it's binary
        MOVEQ   R3, #255 ; Set cutoff to sensible value if it was zero
        TSTEQ   R4, #cra_examine_isbinary ; And it's not binary
        Pull    "r1-r11, PC", EQ ; Then there's nothing we can do

        STR     R0, [R2, #spMode]
        LDR     R0, [R2, #spImage]
        ADD     R0, R0, R2
        ADD     R0, R0, #1
53
        MOV     R10, #0 ; src offset
54
      [ NoARMv5
        MOV     LR, PC
        MOV     PC, R7
      |
        BLX     R7
      ]
        CMP     R9, R3
        LDRB    R9, [R0]
        BICLT   R9, R9, #128 ; < cutoff: make 0
        ORRGE   R9, R9, #128 ; >= cutoff: make 1
        STRB    R9, [R0], #2
        CMP     R10, R8
        BLE     %BT54
        ADD     R11, R11, R6, LSL #2 ; Advance src row ptr
        TST     R0, #2
        ADDNE   R0, R0, #2
        SUBS    R5, R5, #1
        BGE     %BT53
55
        ; Get rid of the mask data
        ; For this to work properly we need to temporarily restore the wide mask flag - the kernel calculates the mask size from the mode word instead of from the offsets
        Debug   so,"Getting rid of mask data"
        LDR     R5, [R2, #spMode]
        TST     R4, #cra_examine_has8bppmask
        ORRNE   R0, R5, #&80000000
        STRNE   R0, [R2, #spMode]
        LDR     R0, =SpriteReason_RemoveMask+&200
        SWI     XOS_SpriteOp
        STR     R5, [R2, #spMode]
        Pull    "r1-r11, PC"


60
        ; Convert to 4bpp alpha
        Debug   so,"Convert to 4bpp alpha"

        TST     R3, #cra_cutoff ; If we can only reduce if it's 4bpp
        TSTEQ   R4, #cra_examine_is4bpp ; And it's not 4bpp
        Pull    "r1-r11, PC", EQ ; Then there's nothing we can do

        TST     R3, #cra_canremove ; If we can remove
        TSTNE   R4, #cra_examine_isabove240 ; And it was all >= &F0
        BNE     %BT11 ; Then get rid of it

        STR     R0, [R2, #spMode]
        LDR     R0, [R2, #spImage]
        ADD     R0, R0, R2
        ADD     R0, R0, #1
63
        MOV     R10, #0 ; src offset
64
      [ NoARMv5
        MOV     LR, PC
        MOV     PC, R7
      |
        BLX     R7
      ]
        AND     R9, R9, #&F0
        LDRB    LR, [R0]
        BIC     LR, LR, #&F0
        ORR     LR, LR, R9
        STRB    LR, [R0], #2
        CMP     R10, R8
        BLE     %BT64
        ADD     R11, R11, R6, LSL #2 ; Advance src row ptr
        TST     R0, #2
        ADDNE   R0, R0, #2
        SUBS    R5, R5, #1
        BGE     %BT63
        B       %BT55

70
        ; Convert to 8bpp alpha
        Debug   so,"Convert to 8bpp alpha"

        STR     R0, [R2, #spMode]
        LDR     R0, [R2, #spImage]
        ADD     R0, R0, R2
        ADD     R0, R0, #3
73
        MOV     R10, #0 ; src offset
74
      [ NoARMv5
        MOV     LR, PC
        MOV     PC, R7
      |
        BLX     R7
      ]
        STRB    R9, [R0], #4
        CMP     R10, R8
        BLE     %BT74
        ADD     R11, R11, R6, LSL #2 ; Advance src row ptr
        SUBS    R5, R5, #1
        BGE     %BT73
        B       %BT55

80
        ; Generate alpha from nothing
        STR     R0, [R2, #spMode]
        CMP     R10, #1
        MOVEQ   R11, #&8000
        CMP     R10, #4
        MOVEQ   R11, #&F000
        CMP     R10, #8
        MOVEQ   R11, #&FF000000
        ORR     R11, R11, R11, LSL #16
        Debug   so,"Generate alpha from nothing, mask", R11
        LDR     R0, [R2, #spImage]
        ADD     R0, R0, R2
        LDR     R1, [R2, #spWidth]
        LDR     R3, [R2, #spHeight]
        ADD     R1, R1, #1
        ADD     R3, R3, #1
        MUL     R1, R3, R1
81
        LDR     R4, [R0]
        ORR     R4, R4, R11
        STR     R4, [R0], #4
        SUBS    R1, R1, #1
        BNE     %BT81
        Pull    "r1-r11, PC"

        LTORG

; In:
;     R2 = sprite
;     R7 = alpha read routine
; Out:
;     Sprite alpha channel cleared to zero
DestroySrcAlpha ROUT
        Entry   "R0,R1-R4"
        LDR     LR, [R7, #-4] ; Get the mask value used to clear alpha
        Debug   so, "DestroySrcAlpha mask",LR
        CMP     LR, #0
        EXIT    EQ
        LDR     R0, [R2, #spImage]
        ADD     R0, R0, R2
        LDR     R1, [R2, #spWidth]
        LDR     R3, [R2, #spHeight]
        ADD     R1, R1, #1
        ADD     R3, R3, #1
        MUL     R1, R3, R1
10
        LDR     R4, [R0]
        BIC     R4, R4, LR
        STR     R4, [R0], #4
        SUBS    R1, R1, #1
        BNE     %BT10
        EXIT

; In:
;     R0 = sprite mode word
; Out:
;     R0 = equivalent mode with an alpha channel
;    R10 = number of alpha bits
; OR
;     V set, R0 -> error if alpha not possible
GetAlphaEquivalent ROUT
        Entry   "r1-r4"
        Debug   so,"GetAlphaEquivalent of",R0
        BIC     r0, r0, #&80000000
        MOV     r1, r0, LSR #27
        CMP     r1, #SpriteType_RISCOS5
        BEQ     %FT10
        ; Convert to RISC OS 5 sprite mode word
        LDR     r3, =&1FFF
        AND     r2, r0, r3, LSL #1
        AND     r3, r0, r3, LSL #14

        MOV     r4, #-1
        CMP     r2, #180<<1
        MOVEQ   r4, #0
        CMP     r2, #90<<1
        MOVEQ   r4, #1
        CMP     r2, #45<<1
        MOVEQ   r4, #2
        CMP     r2, #23<<1
        CMPNE   r2, #22<<1
        MOVEQ   r4, #3

        MOV     lr, #-1
        CMP     r3, #180<<14
        MOVEQ   lr, #0
        CMP     r3, #90<<14
        MOVEQ   lr, #1
        CMP     r3, #45<<14
        MOVEQ   lr, #2
        CMP     r3, #23<<14
        CMPNE   r3, #22<<14
        MOVEQ   lr, #3
        
        MOV     r0, #1
        ORR     r0, r0, r4, LSL #4
        ORRS    r0, r0, lr, LSL #6
        BMI     %FT90
        ORR     r0, r0, #SpriteType_RISCOS5<<27
        ORR     r0, r0, r1, LSL #20
        Debug   so,"RISC OS 5 version",r0
10
        ; Examine RISC OS 5 sprite mode word
        ASSERT  ModeFlag_DataFormatFamily_RGB = 0
        TST     r0, #ModeFlag_DataFormatFamily_Mask ; Must be RGB family
        BNE     %FT90
        ; Is it a type which we recognise can support alpha?
        MOV     r10, #0
        AND     r1, r0, #127<<20
        CMP     r1, #SpriteType_New16bpp<<20
        MOVEQ   r10, #1
        CMP     r1, #SpriteType_New32bpp<<20
        MOVEQ   r10, #8
        CMP     r1, #SpriteType_New4K<<20
        MOVEQ   r10, #4
        CMP     r10, #0
        BEQ     %FT90
        ORR     r0, r0, #ModeFlag_DataFormatSub_Alpha
        Debug   so,"Success, result",r0
        EXIT

90
        Debug   so,"Failed"
        ADRL    r0, ErrorBlock_InvalidSpriteMode
        ADRL    r1, Title
        BL      copy_error_one
        EXIT



; In:
;     R0 = sprite mode word
; Out:
;     R0 = equivalent mode without an alpha channel
GetNonAlphaEquivalent ROUT
        Entry   "r1-r4"
        Debug   so,"GetNonAlphaEquivalent of",r0
        BIC     r0, r0, #&80000000
        MOV     r1, r0, LSR #27
        CMP     r1, #SpriteType_RISCOS5
        DebugIf NE,so,"Not RISC OS 5 mode word!"
        EXIT    NE ; We assume only RISC OS 5 types support alpha
        ; Must also be RGB family
        ASSERT  ModeFlag_DataFormatFamily_RGB = 0
        TST     r0, #ModeFlag_DataFormatFamily_Mask
        TSTEQ   r0, #&E ; Also check the fields which should be zero
        TSTEQ   r0, #&F0000
        DebugIf NE,so,"Unrecognised mode word!"
        EXIT    NE
        ; Good, now all we need to do is remove the alpha flag and then demote
        ; to a RISC OS 3.5 type if possible
        BIC     r0, r0, #ModeFlag_DataFormatSub_Alpha
        TST     r0, #&FF00 ; Any mode flags remaining?
        TSTEQ   r0, #(127-15)<<20 ; Or is the sprite type too high?
        DebugIf NE,so,"Can't demote to RO 3.5 format:", r0
        EXIT    NE ; Yes, so we can't demote
        AND     r1, r0, #127<<20
        MOV     r1, r1, LSL #7
        MOV     r2, #180
        MOV     r3, r0, LSR #4
        MOV     r4, r0, LSR #6
        AND     r3, r0, #3
        AND     r4, r0, #3
        MOV     r3, r2, LSR r3
        MOV     r4, r2, LSR r4
        ORR     r0, r1, r3, LSL #1
        ORR     r0, r0, r4, LSL #14
        ORR     r0, r0, #1
        Debug   so,"Demoted to RISC OS 3.5 format",r0
        EXIT



; In:
;     R2 = sprite
;     R3 = cutoff value
;     R4 = dest width in words
;     R6 = src width in words
;     R7 = src read routine
;     R8 = src width in bits - 1
;     R11 = src row ptr
; Out:
;     R0 = end of dest
;     R11 = end of src
TransferTo1bppMask ROUT
        Entry   "r1,r5,r9-r10"
        Debug   so,"TransferTo1bppMask R2,R3,R4,R6,R7,R8,R11",R2,R3,R4,R6,R7,R8,R11
        LDR     R0, [R2, #spTrans]
        ADD     R0, R0, R2 ; dest row ptr
        LDR     R5, [R2, #spHeight] ; height
13
        MOV     R10, #0 ; src offset
        MOV     R1, #0 ; dest offset
14
      [ NoARMv5
        MOV     LR, PC
        MOV     PC, R7
      |
        BLX     R7
      ]
        CMP     R9, R3
        MOV     R9, #1
        AND     R14, R1, #7
        MOV     R9, R9, LSL R14
        LDRB    R14, [R0, R1, LSR #3]
        BICLT   R14, R14, R9 ; < cutoff: make 0
        ORRGE   R14, R14, R9 ; >= cutoff: make 1
        STRB    R14, [R0, R1, LSR #3]
        ADD     R1, R1, #1
        CMP     R10, R8
        BLE     %BT14
        ADD     R11, R11, R6, LSL #2 ; Advance src row ptr
        SUBS    R5, R5, #1
        ADD     R0, R0, R4, LSL #2 ; Advance dest row ptr
        BGE     %BT13
        EXIT

; In:
;     R2 = sprite
;     R4 = dest width in words
;     R6 = src width in words
;     R7 = src read routine
;     R8 = src width in bits - 1
;     R11 = src row ptr
; Out:
;     R0 = end of dest
;     R11 = end of src
TransferTo8bppMask ROUT
        Entry   "r1,r5,r9-r10"
        Debug   so,"TransferTo8bppMask R2,R4,R6,R7,R8,R11",R2,R4,R6,R7,R8,R11
        LDR     R0, [R2, #spTrans]
        ADD     R0, R0, R2 ; dest row ptr
        LDR     R5, [R2, #spHeight] ; height
13
        MOV     R10, #0 ; src offset
        MOV     R1, #0 ; dest offset
14
      [ NoARMv5
        MOV     LR, PC
        MOV     PC, R7
      |
        BLX     R7
      ]
        STRB    R9, [R0, R1]
        ADD     R1, R1, #1
        CMP     R10, R8
        BLE     %BT14
        ADD     R11, R11, R6, LSL #2 ; Advance src row ptr
        SUBS    R5, R5, #1
        ADD     R0, R0, R4, LSL #2 ; Advance dest row ptr
        BGE     %BT13
        EXIT


; In:
;     R2 = sprite
;     R3 = cra_* flags word
; Out:
;     R4 = cra_examine_* flags, or 0 if no mask/alpha
;     R6 = mask/alpha width in words
;     R7 -> mask/alpha read routine
;     R8 = mask/alpha width in bits - 1
;     R11 -> 1st mask/alpha row
;     V set -> error
ExamineAlpha    ROUT
        Entry   "R0-R11"
        MOV     R4, #0
        ; Check for alpha first
        LDR     R0, [R2, #spMode]
        MOV     R1, #VduExt_ModeFlags
        SWI     XOS_ReadModeVariable
        BCS     %FT95
        MOV     R5, R2
        LDR     R2, [SP, #8] ; Recover sprite pointer
        TST     R5, #ModeFlag_DataFormatSub_Alpha
        LDR     R3, [R2, #spTrans]
        LDR     R6, [R2, #spImage]
        BNE     %FT30
        ; Check for a mask
        TEQ     R3, R6
        BEQ     %FT89 ; No mask present
        ; Get mask parameters so we can examine it
        STR     R0, sp_mode
        ADD     R11, R2, R3
        LDR     R5, [R2, #spWidth]
        LDR     R8, [R2, #spRBit]
        BL      FindMaskWidth
        TST     R0, #&80000000
        ADREQ   R7, Get1bppMaskPixel
        MOVEQ   R4, #cra_examine_has1bppmask
        ADRNE   R7, Get8bppMaskPixel
        MOVNE   R4, #cra_examine_has8bppmask
10
        ORR     R4, R4, #cra_examine_isbinary + cra_examine_issolid + cra_examine_is4bpp + cra_examine_isabovecutoff + cra_examine_isabove240
        LDR     R6, [R2, #spHeight]
        ADD     R0, R5, #1 ; Width in words
        STR     R11, [SP, #11*4]
        STR     R0, [SP, #6*4]
        STR     R7, [SP, #7*4]
        ADD     R5, R8, R5, LSL #5 ; Convert to width in bits (-1)
        STR     R5, [SP, #8*4]
        MOV     R10, #0
        LDRB    R3, [SP, #3*4] ; Recover cutoff value
        CMP     R3, #0
        MOVEQ   R3, #255 ; Ensure isabovecutoff remaains sensible. 255 chosen so that for reduction to 1bpp it won't matter which order we check isbinary/isabovecutoff.
15
        ; Load mask/alpha pixel
      [ NoARMv5
        MOV     LR, PC
        MOV     PC, R7
      |
        BLX     R7
      ]
        ; Examine
        CMP     R9, #255
        BEQ     %FT16
        CMP     R9, R3
        BICLT   R4, R4, #cra_examine_isabovecutoff
        CMP     R9, #240
        BICLT   R4, R4, #cra_examine_isabove240
        CMP     R9, #0
        BICGT   R4, R4, #cra_examine_isbinary
        BIC     R4, R4, #cra_examine_issolid
        EOR     R9, R9, R9, LSR #4
        TST     R9, #&F
        BICNE   R4, R4, #cra_examine_is4bpp
        TST     R4, #cra_examine_isbinary + cra_examine_issolid + cra_examine_is4bpp + cra_examine_isabovecutoff + cra_examine_isabove240
        BEQ     %FT90 ; If all checks have failed, skip to the end
16
        CMP     R10, R5
        BLE     %BT15
        ADD     R11, R11, R0, LSL #2 ; Advance row ptr
        SUBS    R6, R6, #1
        MOV     R10, #0
        BGE     %BT15
        B       %FT90

89
        ; Get rid of any phantom 8bpp mask
        LDR     R0, [R2, #spMode]
        BIC     R0, R0, #&80000000
        STR     R0, [R2, #spMode]
90
        STR     R4, [SP, #4*4]
        EXIT

         
30
        ; Make sure we don't have both a mask and alpha
        TEQ     R3, R6 ; spTrans != spImage?
        TSTEQ   R0, #&80000000 ; Or wide mask bit set?
        BNE     %FT95 ; Error!
        ; Work out if it's a 1bpp, 4bpp, or 8bpp alpha channel
        ; We'll take some liberties here and only look for known NColour values
        MOV     R1, #VduExt_NColour
        SWI     XOS_ReadModeVariable
        BCS     %FT95
        ADDS    R7, R2, #1
        LDR     R2, [SP, #8]
        LDR     R5, [R2, #spWidth]
        LDR     R8, [R2, #spRBit]
        ADD     R11, R2, R6
        MOVEQ   R4, #cra_examine_has8bppalpha
        ADREQ   R7, Get8bppAlphaPixel
        BEQ     %BT10
        CMP     R7, #65536
        MOVEQ   R4, #cra_examine_has1bppalpha
        ADREQ   R7, Get1bppAlphaPixel
        BEQ     %BT10
        CMP     R7, #4096
        BNE     %FT95
        ; 4bpp alpha
        MOV     R4, #cra_examine_has4bppalpha
        ADR     R7, Get4bppAlphaPixel
        B       %BT10

         
95
        ADRL    R0, ErrorBlock_InvalidSpriteMode
        ADRL    R1, Title
        BL      copy_error_one
        STR     R0, [SP]
        EXIT

; Mask/alpha read functions
; In:
;  R11 = sprite/mask row ptr
;  R10 = bit offset
; Out:
;  R9 = alpha (0-255)
;  R10 incremented

        DCD     0
Get1bppMaskPixel ROUT
        Entry   "R8" ; Temp register needed
        LDRB    R9, [R11, R10, LSR #3]
        AND     R8, R10, #7
        MOV     R9, R9, LSR R8
        ADD     R10, R10, #1
        ANDS    R9, R9, #1
        MOVNE   R9, #255
        EXIT

        DCD     0
Get8bppMaskPixel ROUT
        LDRB    R9, [R11, R10, LSR #3]
        ADD     R10, R10, #8
        MOV     PC, LR

        DCD     &80008000
Get1bppAlphaPixel ROUT
        ADD     R10, R10, #16
        ADD     R9, R11, R10, LSR #3
        LDRB    R9, [R9, #-1]
        ANDS    R9, R9, #128
        MOVNE   R9, #255
        MOV     PC, LR

        DCD     &F000F000
Get4bppAlphaPixel ROUT
        ADD     R10, R10, #16
        ADD     R9, R11, R10, LSR #3
        LDRB    R9, [R9, #-1]
        AND     R9, R9, #&F0
        ORR     R9, R9, R9, LSR #4
        MOV     PC, LR

        DCD     &FF000000
Get8bppAlphaPixel ROUT
        ADD     R10, R10, #32
        ADD     R9, R11, R10, LSR #3
        LDRB    R9, [R9, #-1]
        MOV     PC, LR


; In:
;     R0 = desired mask size
;     R1 = area
;     R2 = sprite
; Out:
;     Area grown and mask data reserved (and cleared to -1)
;     Mask placed at end of sprite if not already present
;     R0 corrupt
; OR
;     V set, R0 -> error block, R3 = extra space needed
ExpandMaskSizeToR0 ROUT
        Entry   "R4-R11"
        ; Do we have a mask?
        LDR     R4, [R2, #spTrans]
        LDR     R5, [R2, #spImage]
        Debug   so,"ExandMaskSizeToR0: R0,R1,R2,spTrans,spImage",R0,R1,R2,R4,R5
        CMP     R4, R5
        LDREQ   R4, [R2, #spNext] ; Create the new mask at spNext, as per Kernel
        MOVEQ   R5, R4
        LDRGT   R5, [R2, #spNext] ; If mask is after image, end of mask must be spNext
        ; We now have R4 = mask start, R5 = current end of mask
        Debug   so,"Current mask start, end:",R4,R5
        SUB     R6, R5, R4 ; Size of current mask
        SUB     R0, R0, R6 ; Growth needed (assumed >= 0)
        Debug   so,"Growing by",R0
        LDR     R8, [R1, #saEnd]
        LDR     R10, [R1, #saFree]
        ADD     R9, R10, R0 ; Extend area
        SUBS    R8, R9, R8 ; Check for overflow
        DebugIf GT,so,"Not enough room, need:",R8
        MOVGT   R3, R8
        ADRGTL  R0, ErrorBlock_NotEnoughRoom 
        ADRGTL  R1, Title
        BLGT    copy_error_one
        EXIT VS
        ; Grow area
        STR     R9, [R1, #saFree]
        ; Move memory
        ADD     R10, R1, R9
        ADD     R9, R2, R5
        BL      move_memory_up
        ; Update sprite offsets
        LDR     R6, [R2, #spNext]
        ADD     R6, R6, R0
        STR     R6, [R2, #spNext]
        STR     R4, [R2, #spTrans]
        LDR     R7, [R2, #spImage]
        CMP     R7, R4
        ADDGT   R7, R7, R0
        STRGT   R7, [R2, #spImage]
        Debug   so,"New spNext, spImage, spTrans",R6,R7,R4
        ; Fill R0 bytes starting from R5
        ADD     R5, R5, R2
        MOV     R6, #-1
10
        SUBS    R0, R0, #4
        STRGE   R6, [R5], #4
        BGT     %BT10
        Debug   so,"Expand complete"
        EXIT

; In:
;     R0 = copy dest
;     R1 = area
;     R2 = sprite
;     R11 = copy src
; Out:
;     Area shrunk by moving everything after R11 down to R0
;     R0 corrupt
ShrinkAreaR11ToR0 ROUT
        Entry   "R0,R4-R11"
        Debug   so,"ShrinkAreaR11ToR0: R0,R1,R2,R11",R0,R1,R2,R11
        MOV     R9, R0
        LDR     R4, [R1, #saFree]
        SUBS    R0, R11, R0 ; Get shrink amount
        Debug   so,"Shrink amount",R0
        EXIT    LE
        ADD     R10, R1, R4 ; Get end of src data
        BL      move_memory_down ; Move it
        LDR     R5, [R2, #spNext]
        LDR     R6, [R2, #spTrans]
        LDR     R7, [R2, #spImage]
        Debug   so,"Old saFree, spNext, spImage, spTrans",R4,R5,R7,R6
        SUB     R4, R4, R0
        STR     R4, [R1, #saFree] ; Update area size
        SUB     R5, R5, R0
        STR     R5, [R2, #spNext] ; Update sprite size
        SUB     R11, R11, R2 ; Get offset into sprite of src
        Debug   so,"Offset of src", R11
        CMP     R6, R11
        SUBGE   R6, R6, R0
        STRGE   R6, [R2, #spTrans] ; Update mask offset
        CMP     R7, R11
        SUBGE   R7, R7, R0
        STRGE   R7, [R2, #spImage] ; Update image offset
        Debug   so,"New saFree, spNext, spImage, spTrans",R4,R5,R7,R6
        EXIT

        MakeSpriteErrorBlock InvalidSpriteMode

        LTORG

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SpriteReason_SetPointerShape
; ----------------------------
; Entry: R1 --> sprite area
;        R2 --> sprite name/address
;        R3 bits 0..3 = pointer shape number (1..4)
;        R3 bit 4 set => don't use the sprite's image
;        R3 bit 5 set => don't use the sprite's palette
;        R3 bit 6 set => don't set the current shape number afterwards
;        R4,R5 = coordinates of active point (pixels from top-left)
;        R6 --> factors (<=0 ==> use default, depending on mode)
;        R7 --> pixel translation table (==> 2 bpp)
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Go_SetPointerShape
        Push    "R10,R11,LR"
        Debug   so,"Regs at start = ",R0,R1,R2,R3,R4
        Debug   so,"                ",R5,R6,R7,R8,R9

spp_ptrno       *       2_00001111
spp_noimage     *       2_00010000
spp_nopalette   *       2_00100000
spp_nosetnum    *       2_01000000

tempareasize    *       &200

        Debug   pt, "R3 = ",R3
        TST     R3,#spp_noimage
        BLEQ    go_setimage
        Pull    "R10,R11,PC",VS

        Debug   pt, "done setimage"
        TST     R3,#spp_nopalette
        BLEQ    go_setpointerpalette
        Pull    "R10,R11,PC",VS

        Debug   pt, "done setpalette"
        TST     R3,#spp_nosetnum
        BLEQ    go_setpointernum

        Debug   pt, "done setno",R3
        LDRVC   R0, spritecode
        Debug   gs,"Regs at end   = ",R0,R1,R2,R3,R4
        Debug   gs,"                ",R5,R6,R7,R8,R9
        Pull    "R10,R11,PC"
go_setimage
        LDR     R0,spritecode
        Push    "R0-R7,LR"              ; may need to find sprite again

        Debug   pt,"Input sprite:",#spritecode,R1,R2
        BL      findsprite              ; R2 --> sprite definition

        BLVC    TestForTrueColour

        BLVC    go_getactivepointfrommask
        STRVC   R4,[sp,#4*4]            ; change R4 + original active x on stack as it's used again
        STRVC   R5,[sp,#5*4]            ; change R5 + original active y on stack as it's used again

        Debug   pt,"Input sprite address is:",R2
        MOV     R1,R2                   ; R1 --> sprite definition
        MOV     R11,R2                  ; R11 --> sprite definition

        Debug   so,"gonna do a create sprite"
        LDRVC   R0,[R2,#spMode]
        BLVC    readspritevars          ; log2px/y
        BLVC    readvduvars             ; inlog2px/y, save_inlog2bpp
        BVS     %FT99
        Debug   so,"still gonna do a create sprite"

        ASSERT  saEnd=0                 ; create area header for output sprite
        MOV     R14,#tempareasize       ; should be big enough
        STR     R14,[sp,-R14]!
        MOV     R14,#0
        STR     R14,[sp,#saNumber]
        MOV     R14,#saExten
        STR     R14,[sp,#saFirst]
        STR     R14,[sp,#saFree]

        Debug   so,"definately still gonna do a create sprite"
        MOV     R0,#SpriteReason_CreateSprite   ; create output sprite
        ADD     R0,R0,#&100
        MOV     R1,sp
        ADRL    R2,sillyname
        MOV     R3,#0                   ; no palette
        MOV     R4,#32                  ; 32 pixels wide
        MOV     R5,#32                  ; 32 pixels high
        MOV     R6,#1                   ; mode 1 seems reasonable
        Debug   pt,"Output sprite:",R0,R1,R2,R3,R4
        SWI     XOS_SpriteOp
        Debug   so,"returned from create swi"
        BVS     %FT96
        Debug   so,"V not set"
96
        MOVVC   R0,#SpriteReason_SwitchOutputToSprite
        ADDVC   R0,R0,#&100
        MOVVC   R3,#0                   ; no save area
        SWIVC   XOS_SpriteOp            ; on exit R0-R3 = old params
        Debug   so,"returned from swi"
        ADDVS   sp,sp,#tempareasize
        BVS     %FT99
        Debug   so,"V not set"

        Push    "R0-R3"
        ADD     R14,sp,#4*4 + tempareasize + 1*4
        LDMIA   R14,{R1-R7}
        Debug   pt,"Recovered input params:",R1,R2,R3,R4,R5,R6,R7

        CMP     R6,#0
        LDMNEIA R6,{R2-R5}              ; user-supplied scaling
        BNE     %FT01

        MOV     R14,#1
        LDR     R2,inlog2px             ; if no R6, make up the values!
        MOV     R2,R14,LSL R2
        LDR     R3,inlog2py
        MOV     R3,R14,LSL R3
        LDR     R4,log2px
        MOV     R4,R14,LSL R4
        LDR     R5,log2py
        MOV     R5,R14,LSL R5
        LDR     R14,Log2bpp             ; double-pixel modes ...
        MOV     R4,R4,LSL R14           ; ... are not quite as they seem !
        LDR     R14,Log2bpc
        MOV     R4,R4,ASR R14
        LDR     R14,modeflags
        TST     R14,#ModeFlag_HiResMono
        MOVNE   R4,R4,LSL #1            ; 1/2 width in hi-res mono
01
        Push    "R2-R5"
        MOV     R6,sp

        MOV     R0,#SpriteReason_PutSpriteScaled     ; plot input into output
        ADD     R0,R0,#&200
        MOV     R2,R11                  ; R2 --> sprite

        LDR     R3,[R2,#spLBit]         ; first bit number used
        RSB     R3,R3,#1                ; remember bits are inclusive
        LDR     R14,[R2,#spRBit]        ; R14 = no of bits used in r.h. word
        ADD     R3,R3,R14
        LDR     R14,[R2,#spWidth]       ; R14 = no of words in the middle + 1
        ADD     R3,R3,R14,LSL #5        ; R3 = total width (bits)
        LDR     R14,save_inlog2bpc
        MOV     R4,R3,LSR R14           ; R4 = width (pixels)
        Debug   pt,"Input sprite width =",R4
        SUB     R6,R6,#4
        BL      mulR4                   ; scale to output pixels
        ADD     R6,R6,#4
        RSBS    R3,R4,#32               ; R3 = x-coordinate to plot sprite at
        MOVLT   R3,#0                   ; keep lhs visible!

        LDR     R4,[R2,#spHeight]
        ADD     R4,R4,#1                ; R4 = input height (pixels)
        BL      mulR4
        Push    "R3,R4"                 ; R4 = height of pointer (pixels)

        MOV     R3,R3,LSL #2            ; sprite is in mode 1 (log2px = 2)
        MOV     R4,R4,LSL #2            ; sprite is in mode 1 (log2py = 2)
        RSB     R4,R4,#32*4             ; make top-left match up

        MOV     R5,#0

        LDR     R14,modeflags

        TEQ     R7,#0                   ; PRM 1-780 zero means no table supplied
        BNE     %FT05
        TST     R14,#ModeFlag_HiResMono
        ADRNE   R7,hiresmonottr         ; use built in table iff R7=0 and in hi-res mono
05
        Debug   pt,"Input sprite address,x,y =",R2,R3,R4
        SWI     XOS_SpriteOp
        Pull    "R10,R11"               ; R10,R11 = xcoord,height

        ADD     R14,sp,#4*4             ; skip factor block
        LDMIA   R14,{R0-R3}             ; SwitchOutput back to old parameters
        Debug   pt,"Switching back to",R0,R1,R2,R3
        SWI     XOS_SpriteOp

        ADD     R2,sp,#8*4+saExten      ; R2 --> output sprite
        Debug   pt,"Output sprite address =",R2
        LDR     R5,[R2,#spImage]
        ADD     R14,R2,R5               ; R14 --> sprite image
        Debug   pt,"Output sprite image =",R14
        MOV     R5,#0                   ; stick in reason code (= 0)
        Push    "R5,R6,R14"             ; [sp + 8] = sprite ptr
        CMP     R11,#32
        MOVGT   R11,#32
        ADD     R1,sp,#2                ; need correct alignment
        STRB    R11,[R1,#3]
        MOV     R14,#16/2               ; R14 = width (bytes)
        STRB    R14,[R1,#2]

        ADD     R14,sp,#3*4 + 8*4 + tempareasize + 3*4
        LDMIA   R14,{R3-R5}             ; shape no, active X, active Y
        AND     R3,R3,#spp_ptrno        ; bottom 4 bits = shape no
        STRB    R3,[R1,#1]
        SUB     R6,R6,#4                ; fool it so x-values used
        BL      mulR4
        ADD     R4,R4,R10               ; allow for sprite origin
        STRB    R4,[R1,#4]
        MOV     R4,R5
        ADD     R6,R6,#4                ; fool it so y-values used
        BL      mulR4
        STRB    R4,[R1,#5]

      [ debugpt
        LDMIA   sp,{R3-R5}
        Debug   pt,"OS_Word block =",R3,R4,R5
      ]
        MOV     R0,#OsWord_DefinePointerAndMouse
        SWI     XOS_Word
        ADD     sp,sp,#3*4 + 8*4 + tempareasize   ; correct stack
99
        LDR     R14,[sp],#4
        STR     R14,spritecode          ; may be needed later
        Pull    "R1-R7,PC"

hiresmonottr    DCB     0,1,3,3         ; translate colour 2 into colour 3
                ALIGN

sillyname       DCB     "pointer",0
                ALIGN

go_setpointerpalette
        Push    "R1-R5,LR"

        Debug   pt,"Input sprite:",#spritecode,R1,R2
        BL      findsprite              ; R2 --> sprite definition
        Debug   pt,"Input sprite address:",R2
        LDRVC   R0,[R2,#spMode]
        MOV     R1, R2
        BLVC    readspritevars          ; get save_inlog2bpp
        Pull    "R1-R5,PC",VS
;
        MOV     R14,#1
        LDR     R5,save_inlog2bpp
        MOV     R5,R14,LSL R5           ; R5 = no of elements in ttr table

        MOV     R3,#3                   ; start with colour 3
01
        TEQ     R7,#0                   ; PRM 1-780 zero means no table supplied
        MOVEQ   R4,R3                   ; substitute 1:1 translation
        BEQ     %FT03                   ; got colour
        MOV     R4,#0
02
        LDRB    R14,[R7,R4]
        TEQ     R14,R3                  ; found it?
        BEQ     %FT03
        ADD     R4,R4,#1
        CMP     R4,R5                   ; R5 = no of entries in table
        BCC     %BT02
        B       %FT04                   ; don't bother programming palette
03
        Debug   pt,"Programming palette entry",R4
        MOV     R14,#spPalette+1        ; point at RGB of first flash state
        ADD     R4,R14,R4,LSL #3        ; 8 bytes per palette entry
        LDR     R14,[R2,#spImage]
        CMP     R14,R4                  ; is there a palette entry for this?
        BLE     %FT04
        SWI     XOS_WriteI+19           ; program palette
        MOV     R0,R3
        SWI     XOS_WriteC              ; mouse colour number
        SWI     XOS_WriteI+25           ; program mouse colour
        ADD     R0,R2,R4
        MOV     R1,#3
        SWI     XOS_WriteN              ; R,G,B
04
        SUBS    R3,R3,#1
        BNE     %BT01                   ; forget colour 0

        Pull    "R1-R5,PC"

go_setpointernum
        Push    "R1-R3,LR"

        MOV     R0,#&6A
        AND     R1,R3,#spp_ptrno        ; pointer shape
        MOV     R2,#0                   ; pointer linked to mouse
        SWI     XOS_Byte

        Pull    "R1-R3,PC"

        ; Scale to output pixels
        ; Entry: R4 = input coordinate (pixels)
        ;        R6 --> scale factors ([R6,#4] and [R6,#12])
        ; Exit:  R4 = R4 * R6!4 / R6!12
mulR4
        Push    "R5,R11,LR"
        LDR     R14,[R6,#1*4]           ; y-magnification
        MUL     R11,R14,R4
        LDR     R5,[R6,#3*4]            ; y-division
        DivRem  R4,R11,R5, R14          ; R4 = output height
        Pull    "R5,R11,PC"

        ; pointer mask active x,y fix PRM 3 vol 3 page 33
        ; in:   R2 is the address of the sprite
        ;       R4 active point x
        ;       R5 active point y
        ;
        ; out:  R4 new active point x
        ;       R5 new active point y
        ;       Other registers preserved
        ; Called after TestFor16or32bpp.
        ; If no mask all registers are unchanged.
        ;
go_getactivepointfrommask ROUT
        Push    "R0-R7,LR"
        LDR     R0,[R2,#spLBit]
        CMP     R0,#0
        BNE     %F100                   ; Don't use mask if sprite is shifted
        LDR     R0,[R2,#spTrans]
        LDR     R1,[R2,#spImage]
        CMP     R0,R1
        BEQ     %F100                   ; No mask so quit
        Push    "R2"
        LDR     R0,[R2,#spMode]
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable    ; CS error already dealt with by TestForTrueColour
        MOV     R1,R2
        Pull    "R2"
        LDR     R0,[R2,#spMode]
        CMP     R0,#256
        LDRLO   R0,[R2,#spRBit]
        LDRLO   R3,[R2,#spWidth]
        BLO     %F30
        ; 1 bpp mask
        LDR     R0,[R2,#spWidth]
        LDR     R3,[R2,#spRBit]
        MOV     R0,R0,LSL #5
        ADD     R0,R0,R3
        ADD     R0,R0,#1                ; R0 = width in bits
        MOV     R0,R0,LSR R1            ; R0 = width in pixels
        SUB     R0,R0,#1                ; R0 = points to last pixel
        MOV     R3,R0,LSR #5            ; mask Width in words - 1
        SUBS    R0,R0,R3,LSL #5         ; mask rBit
        MOV     R1,#0                   ; log2bpp of mask
30
        ;FindXY
        ; entry:
        ; R0 = rBit                     ; of mask
        ; R1 = log2bpp                  ; of mask;
        ; R2 = sprite data
        ; R3 = width in words - 1       ; of mask
        ; uses:
        ; R4 = activex
        ; R5 = activey
        ; R6 = word in row iterator
        ; R7 = height of sprite
        ; R14 = rbitmask - mask to fill last word after rbit with ones.
        ;
        ADD     R0,R0,#1
        MVN     R14,#0
        MOV     R14,R14,LSL R0
        LDR     R7,[R2,#spHeight]
        LDR     R0,[R2,#spTrans]
        ADD     R2,R2,R0                ; R2 now points to mask data
        MVN     R5,#0                   ; activey=-1
40      
        ; yloop
        ADD     R5,R5,#1
        CMP     R5,R7
        BGT     %F100                   ; no transparent point found so finish
        MOV     R4,#0                   ; activex=0
        ADD     R6,R3,#1
50
        ; xloop
        SUBS    R6,R6,#1
        BLT     %B40                    ; back to yloop
        LDR     R0,[R2],#4
        ORREQ   R0,R0,R14               ; set unused bits if in right hand word in case they are not set
        CMN     R0,#1                   ; has word a transparent point
        MOVEQ   R0,#32
        ADDEQ   R4,R4,R0,LSR R1         ; add 1 word of pixels (32>>log2bpp)
        BEQ     %B50                    ; back to xloop

        ; y found and R0 includes transparent pixel. x = pixels up to start of word
        MOV     R7,#1
        MOV     R7,R7,LSL R1            ; R7=bits per pixel
        MVN     R6,#0
        MVN     R6,R6,LSL R7            ; R6=pixel mask
        
60
        ; find pixel x - traverse word
        AND     R1,R0,R6
        CMP     R1,R6
        ADDEQ   R4,R4,#1
        MOVEQ   R0,R0,LSR R7
        BEQ     %B60                    ; back fo find pixel x
        ; found
        STR     R4,[sp,#4*4]            ; change original active y on stack
        STR     R5,[sp,#5*4]            ; change original active y on stack
100
        Pull    "R0-R7,PC"

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SpriteReason_PaintCharScaled
; ----------------------------
; Entry: R1 = character code
;        R3,R4 = x,y coordinates
;        R6 --> scale factors
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Go_PaintCharScaled
        Push    "R1-R9,LR"

        STRB    R1,charblock
        ADRL    R1,charblock
        MOV     R0,#OsWord_ReadCharacterDefinition
        SWI     XOS_Word

        BLVC    readvduvars
        BVS     exitchar
        ;
        ; construct a sprite header in module workspace
        ;
        MOV     R10, #0
        MOV     R11, #7                 ; Mode 0 sprite starting uses bits 0-7

        ADR     R14,areahdr             ; 3 words for area header,
        LDMIA   R14,{R1-R3,R6-R8}       ; and 3 for sprite name
        MOV     R5,#spriteSize+4*8*2    ; R5 = 44 + 2*8 rows of 1 word
        ADD     R4,R5,#spriteCB-areaCB  ; R4 = saFree
        ADRL    R14,areaCB
        Debug   ch,"areaCB = &",R14
        STMIA   R14!,{R1-R3,R4,R5,R6-R8,R10}    ; up to spWidth
        MOV     R8,#7                   ; R8 = spHeight (no of rows - 1)
        MOV     R9,#0                   ; R9 = spLbit
        STMIA   R14!,{R8,R9,R11}        ; R11 = spRBit
        MOV     R8,#spriteSize
        ADD     R9,R8,#4*8              ; R9 = R8 + 8 rows of 1 word
        MOV     R11, #0                 ; mode 0 sprite
        STMIA   R14!,{R8,R9,R11}        ; R14 --> sprite pixels
        SUB     R7,R9,R8
        ADD     R7,R14,R7               ; R7 --> sprite mask
        ;
        ; now construct a sprite mask from the character definition
        ;
        ADRL    R10, charblock+1
        MOV     R5, #8
01
        LDRB    R9, [R10], #1
        MOV     R8, R9, LSR #7
        TST     R9, #&40
        ORRNE   R8, R8, #&02
        TST     R9, #&20
        ORRNE   R8, R8, #&04
        TST     R9, #&10
        ORRNE   R8, R8, #&08
        TST     R9, #&08
        ORRNE   R8, R8, #&10
        TST     R9, #&04
        ORRNE   R8, R8, #&20
        TST     R9, #&02
        ORRNE   R8, R8, #&40
        TST     R9, #&01
        ORRNE   R8, R8, #&80
        STR     R8, [R7], #4
        SUBS    R5, R5, #1
        BNE     %BT01
        ;
        ; now set up the parameters for a scaled mask plot
        ;
        LDR     R14,vdu_fgecforaeor
        STR     R14,save_ecflimit       ; char painting uses fg ecf pattern

        ADRL    R1,areaCB
        ADD     R2,R1,#spriteCB-areaCB
        ADD     R14,R13,#2*4            ; salvage params from stack
        LDMIA   R14,{R3-R7}

        MOV     R0,#&200                ; indicates that R2 --> sprite defn
        ADD     R0,R0,#SpriteReason_PlotMaskScaled

        LDR     R14,spritecode
        Push    "R14"
        STR     R0,spritecode
        MOV     r0, #SpriteReason_PaintCharScaled
        BL      Go_PlotMaskScaled
        Pull    "R14"
        STR     R14,spritecode

exitchar
        Pull    "R1-R9,PC"

areahdr
        DCD     spriteAreaSize
        DCD     1
        DCD     spriteCB - areaCB
spritehdr
        DCB     "character",0,0,0       ; Note - 12 chars long exactly
        ALIGN

        ;
        ; Read Vdu Variables
        ; also process the ones that the OS doesn't always provide
        ;
vduinputbuffer
        DCD     VduExt_XEigFactor               ; log2 pixels per unit (x)
        DCD     VduExt_YEigFactor               ; log2 pixels per unit (y)
        DCD     VduExt_Log2BPP                  ; for no. of colours
        DCD     VduExt_Log2BPC                  ; for double-pixel modes

        DCD     VduExt_OrgX
        DCD     VduExt_OrgY
        DCD     VduExt_GWLCol                   ; graphics window
        DCD     VduExt_GWBRow
        DCD     VduExt_GWRCol
        DCD     VduExt_GWTRow

        DCD     VduExt_LineLength
        DCD     VduExt_ScreenStart
        DCD     VduExt_YWindLimit

        DCD     VduExt_ModeFlags                ; for hi-res mono checking, RGB order, etc.
        DCD     VduExt_NColour

        DCD     -1

readvduvars
        Push    "R0-R1,LR"
        ;
        ; read real vdu variables
        ;
        ADR     R0,vduinputbuffer
        ADR     R1,vduoutputbuffer
        SWI     XOS_ReadVduVariables
        BVS     %FT99

        MOV     R0,#1
        LDR     R14,Log2bpc
        MOV     R14,R0,ASL R14
        STR     R14,BPC                 ; bpc = 2^log2bpc
        LDR     R14,Log2bpp
        MOV     R14,R0,ASL R14
        STR     R14,BPP                 ; bpp = 2^log2bpp

        Debug   sc,"ScreenStart,YWindLimit,LineLength,bpc =",#screenstart,#ywindlimit,#linelength,#BPC
99
        STRVS   R0,[R13]
        Pull    "R0-R1,PC"

        ;
        ; read mode-specific info for mode (R0)
        ; R0=the sprite's mode word
        ; R1->the sprite
        ;
readspritevars
        Push    "R1-R2,LR"

      [ jpeg
        ; if the last sprite was jpeg but this one is not then we MUST reload the sprite variables.
        LDR     R2,is_it_jpeg           ; was the last one JPEG? 0 -> not JPEG
        CMP     R2,#0
        MOVNE   R2,#0                   ; if the previous one was JPEG
        STRNE   R2,is_it_jpeg           ;   mark as not a JPEG sprite this time
        MOVNE   R14,#-1                 ;   force reload of sprite mode vars
        LDREQ   R14,inmode              ; else, vars reflect this sprite's mode
      |
        LDR     R14,inmode              ; check for sprite vars already right
      ]

        TEQ     R0,R14
        Pull    "R1-R2,PC",EQ           ; already have these variables!
        STR     R0,inmode

        MOV     R1,#VduExt_Log2BPC
        SWI     XOS_ReadModeVariable
        SETV    CS

        STRVC   R2,save_inlog2bpc       ; input log2(bytes per char)
        MOVVC   R1,#VduExt_Log2BPP
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,save_inlog2bpp       ; input log2(bits per pixel)
        MOVVC   R1,#VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,inlog2px
        MOVVC   R1,#VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,inlog2py
        MOVVC   R1,#VduExt_ModeFlags
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,save_inmodeflags
        MOVVC   R1,#VduExt_NColour
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,save_inncolour
        Pull    "R1-R2,PC",VS

        MOV     R14,#1
        LDR     R1,save_inlog2bpp
        MOV     R14,R14,ASL R1
        STR     R14,save_inbpp

        Debug   in,"Input log2bpc/p, bpp = ",#save_inlog2bpc,#save_inlog2bpp,#save_inbpp

        Pull    "R1-R2,PC"

        ;
        ; Find sprite address given areaCBptr/name
        ; Entry:  [spritecode] = reason code (including bits above bit 7)
        ;         R1 = areaCBptr
        ;         R2 --> sprite name
        ; Exit:   R2 --> sprite definition
        ;         R1 --> might be adjusted
        ;
findsprite
area_sensible   * 256
        LDR     R0,spritecode
        BIC     R0,R0,#&FF
        TEQ     R0,#&200                ; Less strict than 'findsprite_inarea'
        MOVEQ   R1,#area_sensible       ; R1 swapped for something that passes CheckAlignedAndSensible
findsprite_inarea
        Push    "LR"
        LDR     R0,spritecode
        ; Entry:  R0 = original sprite code
        BL      getspritename
        BLVC    getspriteaddr
        Pull    "PC"

getspritename
        Push    "R1,R3-R5,LR"

        BICS    R14,R0,#&FF             ; R0 < 256 ==> system sprite (can't!)
        TEQ     R14,#&200               ; R2 --> sprite already
        STREQ   R2,spritename           ; if so, 1st word is sprite addr
        Pull    "R1,R3-R5,PC",EQ

        ADRL    R3,spritename
        ADD     R4,R3,#SpriteNameSize

        CMP     R2,#area_sensible       ; sensible name ptr?
        BHS     %FT01
        ADR     R0,ErrorBlock_BadAddress
        BL      copy_error_one          ; sets V too
        Pull    "R1,R3-R5,PC",VS
01
        LDRB    R5,[R2],#1
        CMP     R5,#" "                 ; ignore control characters and <space> too!
        BLS     %FT02
        ASCII_LowerCase R5,R14
        STRB    R5,[R3],#1
        CMP     R3,R4                   ; terminate after 12 characters
        BCC     %BT01
02
        MOV     R5,#0
03
        CMP     R3,R4                   ; pad with nulls
        STRCCB  R5,[R3],#1
        BCC     %BT03

        Pull    "R1,R3-R5,PC"

        ;
        ; scan the sprite list to find the address
        ;
getspriteaddr
        Push    "R1,R3-R9,LR"

        BICS    R14,R0,#&FF             ; R0 < 256 ==> system sprite (can't!)
        BNE     %FT00

        MOV     R0,#3
        SWI     XOS_ReadDynamicArea
        TEQ     R1,#0                   ; can't do anything with this!
        ADREQ   R0, ErrorBlock_NoWorkSpace
        addr    r1, Title, EQ
        BLEQ    copy_error_one          ; Always sets the V bit
        Pull    "R1,R3-R9,PC",VS

        MOV     R1,R0                   ; R1 -> system sprite area
        STR     R1,[sp]                 ; return for AppendSprite
        B       %FT01
00
        CheckAlignedAndSensible R1,%F99
        TEQ     R14,#&200               ; R2 --> sprite already
        BEQ     %FT98
01
        ADRL    R14,spritename
        LDMIA   R14,{R3,R4,R5}

        LDR     R14,[R1,#saFree]
        ADD     R9,R1,R14               ; R9 --> free area
        LDR     R14,[R1,#saFirst]
        ADD     R2,R1,R14               ; R2 --> first sprite
02
        CMP     R2,R9
      [ debuger
        BCC     %FT03
        ADR     R14,spritename
        DebugS  er,"Sprite doesn't exist ",R14
03
      ]

        BLCS    get_sprite_doesnt_exist_error  ; r0-> error block, V set
        Pull    "R1,R3-R9,PC",VS

        LDMIA   R2,{R1,R6,R7,R8}       ; get link plus name
        TEQ     R6,R3
        TEQEQ   R7,R4
        TEQEQ   R8,R5
        ADDNE   R2,R2,R1
        BNE     %BT02
98
        CheckAlignedAndSensible R2,%F99
        Pull    "R1,R3-R9,PC"
99
        ADR     R0,ErrorBlock_BadAddress
        BL      copy_error_one
        Pull    "R1,R3-R9,PC"

        MakeErrorBlock BadAddress
        MakeSpriteErrorBlock NoWorkSpace,,NoWork

        ; makepalette16bpp
        ; convert palette to 16bpp for output to 16bpp mode plotting directly from palette
        ; if this is not done, the spriteextend blitter will run out of registers!
        ; in:  r7 = original palette
        ; out: r7 = new palette (in newtranstable)
makepalette16bpp
        Entry   "R1-R6"
        LDR     r1, save_inbpp
        MOV     r2, #1
        MOV     r1, r2, LSL r1        ; number of entries in palette
        Debug   so, "going to do this many entries = ",R1

        ; Work out which colour conversion routine is required
        LDR     r2, ncolour
        MOVS    r2, r2, LSR #12       ; 4K or 32K/64K?
        LDR     r3, modeflags
        MOVEQ   r4, #0
        MOVNE   r4, #16
        TSTNE   r3, #ModeFlag_64k     ; 32K or 64K?
        MOVNE   r4, #32
        TST     r3, #ModeFlag_DataFormatSub_Alpha
        ADDNE   r4, r4, #8
        TST     r3, #ModeFlag_DataFormatSub_RGB
        ADDNE   r4, r4, #4

        MOV     r2, r7                ; pointer to palette data
        ADRL    r3, newtranstable     ; where to store altered palette
        MOV     r7, r3
        ADD     pc, pc, r4

        NOP
        ; 4444 routines
        B       mp16bpp_4444_TBGR
        B       mp16bpp_4444_TRGB
        B       mp16bpp_4444_ABGR
        B       mp16bpp_4444_ARGB
        ; 1555 routines
        B       mp16bpp_1555_TBGR
        B       mp16bpp_1555_TRGB
        B       mp16bpp_1555_ABGR
        B       mp16bpp_1555_ARGB
        ; 565 routines
        B       mp16bpp_565_BGR
        B       mp16bpp_565_RGB
        B       mp16bpp_565_BGR ; Duplicate so that any alpha flag gets ignored
        B       mp16bpp_565_RGB

        MACRO
        MakePalette16bpp $format,$red_shift,$red_bits,$green_shift,$green_bits,$blue_shift,$blue_bits,$alpha
mp16bpp_$format
        LDR     r4, [r2], #8
        ColourConv r4,r4,r5,r6,lr,$red_shift,$red_bits,$green_shift,$green_bits,$blue_shift,$blue_bits,$alpha
        SUBS    r1, r1, #1
        STR     r4, [r3], #4
        BNE     mp16bpp_$format
        EXIT
        MEND

        MakePalette16bpp 4444_TBGR,0,4,4,4,8,4
        MakePalette16bpp 4444_TRGB,8,4,4,4,0,4
        MakePalette16bpp 4444_ABGR,0,4,4,4,8,4,&F000
        MakePalette16bpp 4444_ARGB,8,4,4,4,0,4,&F000
        MakePalette16bpp 1555_TBGR,0,5,5,5,10,5
        MakePalette16bpp 1555_TRGB,10,5,5,5,0,5
        MakePalette16bpp 1555_ABGR,0,5,5,5,10,5,&8000
        MakePalette16bpp 1555_ARGB,10,5,5,5,0,5,&8000
        MakePalette16bpp 565_BGR,0,5,5,6,11,5
        MakePalette16bpp 565_RGB,11,5,5,6,0,5

        ;
        ; Fatal exits for divide by zero and other panics
        ;
        MakeInternatErrorBlock DivZero
diverror
        ADR     R0, ErrorBlock_DivZero
        addr    r1, Title
        BL      copy_error_one          ; Always sets the V bit

exitbiggie ROUT
        ; Release any blend tables that were claimed by the C code
        LDR     R1, blendtables
        TEQ     R1, #0
        Pull    "R1-R9,PC", EQ
        SavePSR R4
        Push    "R0"
        ADR     R1, blendtables
        MOV     R3, #0
        ADD     R2, R1, #?blendtables
10
        LDR     R0, [R1], #4
        TEQ     R0, #0
        STRNE   R3, [R1, #-4]
        SWINE   XBlendTable_UnlockTable
        CMP     R1, R2
        BNE     %BT10
        RestPSR R4,,f
        Pull    "R0-R9,PC"

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SpriteOp_PutSpriteGreyScaled
; ----------------------------
; Entry: [spritecode] = reason code
;        R1 --> areaCBptr
;        R2 --> sprite name
;        R3,R4 = coords
;        R5 = 0
;        R6 --> scaling factors
;        R7 --> pixel translation table
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Go_PutSpriteGreyScaled
        Push    "LR"
        ADR     R0, ErrorBlock_NoGrScl
        BL      copy_error_one          ; also sets V
        Pull    "PC"

        MakeSpriteErrorBlock NoGrScl

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SpriteOp_PlotMaskScaled
; -----------------------
; Entry: [spritecode] = reason code
;        R1 --> areaCBptr
;        R2 --> sprite name
;        R3,R4 = coords
;        R6 --> scaling factors
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Go_PlotMaskScaled
        Push    "R1-R9,LR"
        MOV     R5,#8                   ; avoid masko being knackered later
        MOV     R7,#0                   ; no pixel translation
        MOV     R8,#0                   ; no calibration table
        B       %FT01

        MakeSpriteErrorBlock BadTranslation,,BadTran

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SpriteOp_PutSpriteScaled
; ------------------------
; Entry: [spritecode] = reason code
;        R1 --> areaCBptr
;        R2 --> sprite name
;        R3,R4 = coords
;        R5 = plot action + flags
;        R6 --> scaling factors
;        R7 --> pixel translation table
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Go_PutSpriteScaled
        Push    "R1-R9,LR"
        MOV     R8,#0                   ; no printer calibration table
01
        Debug   in,"Draw sprite: R0,R1,R2 =",R0,R1,R2
        Debug   in,"Coords, gcol, &scale, &ttr =",R3,R4,R5,R6,R7
        Debug   in,"Calibration table =",R8


        CLRPSR  I_bit, R14              ; re-enable interrupts
        MOV     R14, R5, LSR #4
        STR     R14, trns_flags2        ; store flags
        BIC     R14, R14, #flg2_translucency
        Debug   so,"flags are ",R14
        BICS    R14, R14, #flg2_ignorettr + flg2_widetrans + flg2_ditheron + flg2_colourmap
        Debug   so,"flags are ",R14
        ADRNEL  R0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one          ; Always sets the V bit
        BVS     exitbiggie
        AND     R5,R5,#&0F              ; only bottom 4 bits are interesting

        STR     R8,calibration_table

        ;
        ; Check to see if truecolour sprites should be dithered
        ;
        LDR     r14, trns_flags2
        TST     r14, #flg2_ditheron
        MOVEQ   r0, #0
        MOVNE   r0, #1
        STR     r0, dither_truecolour
        TST     r14, #flg2_translucency
        MOVEQ   r0, #0
        MOVNE   r0, #1
        STR     r0, blending
        ;
        ; see if reason code indicated a sprite name or sprite pointer in R2
        ;

        BL      findsprite              ; R2 --> sprite

        MOVVC   R1,R2                   ; now R1 --> sprite

        ; read input/output mode variables

        BLVC    readvduvars
        LDRVC   R0,[r1,#spMode]
        BLVC    readspritevars
        BVS     exitbiggie
        Debug   cc,"read sprite vars",R1

        LDR     R0,[R1,#spMode]
        TST     R0,#&80000000           ; alpha mask?
        LDREQ   R0,save_inmodeflags
        TSTEQ   R0,#ModeFlag_DataFormatSub_Alpha ; or alpha channel?
        LDRNEB  R0,spritecode
        TSTNE   R5,#8                   ; and masking enabled?
        TEQNE   R0,#SpriteReason_PlotMaskScaled ; and not plotting mask?
        LDR     R0,blending
        ORRNE   R0,R0,#2                ; Enable alpha mask/channel blending
        STRNE   R0,blending
        CMP     R0,#0                   ; blending enabled?
        BICNE   R5,R5,#7                ; then GCOL actions not allowed

        ; Alternate entry point from JPEG plotting
        ; R1 = sprite pointer
        ; R3 = X
        ; R4 = Y
        ; R5 = GCOL action + mask flag
        ; R6 = scale ptr
        ; R7 = TTR
        ; [blending], [trns_flags2], sprite vars initialised
putsprscaled_frompjs
        STR     R1,save_sprite          ; save sprite ptr so C code can use it when needed (JPEG, blend tables, etc.)
        LDR     R0,[R1,#spMode]         ; get sprite's original mode
        MOV     R0,R0,LSR #27
        STR     R0,save_spr_type
        ;
        ; read scaling factors (set up default if necessary)
        ;
        CMP     R6,#0
        MOVEQ   R8, #1
        MOVEQ   R9, #1
        MOVEQ   R10, #1
        MOVEQ   R11, #1
        BEQ     %FT01
        LDMIA   R6,{R8-R11}

        ;let's try to rationalise the scale factors...
        ; *************************************************
        ; ***  DivRem - Integer division and remainder  ***
        ; ***  rc := ra DIV rb; ra := ra REM rb         ***
        ; ***  rb preserved, rtemp corrupt              ***
        ; ***  DivRem   rc, ra, rb, rtemp               ***
        ; *************************************************
        Push    "R5-R7"
        MOV     R5, R8
        DivRem  R7, R5, R10, R6
        CMP     R5, #0
        MOVEQ   R8, R7
        MOVEQ   R10, #1
        MOV     R5, R9
        DivRem  R7, R5, R11, R6
        CMP     R5, #0
        MOVEQ   R9, R7
        MOVEQ   R11, #1
        Pull    "R5-R7"

01
        STR     R8,save_xmag
        STR     R9,save_ymag
        STR     R10,save_xdiv
        STR     R11,save_ydiv
        Debug   in,"x mag/div, y mag/div:",r8,r9,r10,r11

        BL      preparettr
        Debug   so,"Checked out trans table palette"
        ;
        ; try to optimise by using existing sprite plot code
        ; can only be done if bpp & bpc equal, no trans, no scaling, output not to sprite, and no fancy blending etc.
        ;
        LDR     R7,ColourTTR
        TEQ     R7,#0
        LDREQ   R14,save_inbpp
        LDREQ   R0,BPP
        TEQEQ   R14,R0                  ; if same bpp, try to optimise

        LDR     R6,save_xmag            ; load always!
        LDR     R7,save_ymag            ; load always!
        BNE     cantdoinOS

        ; Make sure true colour modes are exact matches
        CMP     R0,#3
        BLS     %FT01
        LDR     R0,save_inmodeflags
        LDR     R14,modeflags
        LDR     R8,save_inncolour
        LDR     R9,ncolour
        EOR     R0,R0,R14
        TEQ     R8,R9
        TSTEQ   R0,#ModeFlag_64k+ModeFlag_ChromaSubsampleMode
        TSTEQ   R0,#ModeFlag_DataFormat_Mask
        BNE     cantdoinOS

01
        LDR     R0,save_inlog2bpc
        LDR     R14,Log2bpc
        LDR     R8,save_xdiv
        LDR     R9,save_ydiv
        TEQ     R0,R14
        LDREQ   R0,trns_flags2
        LDREQ   R14,blending
        TEQEQ   R6,R8
        TEQEQ   R7,R9
        TEQEQ   R0,#0
        TEQEQ   R14,#0
        BNE     cantdoinOS

        ; Clear mask flag if no mask present and not PutMaskScaled.
        ; This is also performed later on when we calculate masko, but an extra check here helps us pass things to the faster kernel routines.
        LDR     R0,spritecode
        LDR     R14,[R1,#spImage]
        AND     R0,R0,#&FF
        LDR     R8,[R1,#spTrans]
        TEQ     R0,#SpriteReason_PutSpriteScaled
        TEQEQ   R8,R14
        BICEQ   R5,R5,#8                

        ; For masked new-style sprites, the OS is slower than us, except for 1bpp where it treats it as an old-style sprite
        TST     R5,#8
        BEQ     %FT01
        LDR     R14, [R1, #spMode]
        MOVS    R8,R14,ASR #27
        BMI     cantdoinOS              ; OS doesn't support alpha masks
        TEQ     R8,#SpriteType_RISCOS5
      [ NoARMT2
        ANDEQ   R8,R14,#127<<20
        MOVEQ   R8,R8,LSR #20
      |
        UBFXEQ  R8,R14,#20,#7
      ]
        TST     R8,#&FE
        BNE     cantdoinOS

01
      [ jpeg
        LDREQ   R0,is_it_jpeg
        TEQEQ   R0,#0
        Debug   gs,"is it JPEG?",R0
        BNE     cantdoinOS
      ]
        ;
        ; if all parameters are ineffective, call the OS routine!
        ;
        LDR     R0,spritecode
        AND     R14,R0,#&FF             ; R14 = reason code only
        BIC     R0,R0,#&FF              ; R0 = code except for reason code
        TEQ     R14,#SpriteReason_PutSpriteScaled
        ORREQ   R0,R0,#SpriteReason_PutSpriteUserCoords
        BEQ     %FT01
        TEQ     R14,#SpriteReason_PlotMaskScaled
        ORREQ   R0,R0,#SpriteReason_PlotMaskUserCoords
        LDREQ   R14,save_ecflimit       ; is this background plotting?
        LDREQ   R8,vdu_bgecforaeor
        TEQEQ   R14,R8
        BNE     cantdoinOS
01
        LDMIA   R13,{R1,R2}             ; get original R1,R2
        Debug   so,"doing it in OS"
        BL      Go_SpriteOp             ; call the OS version if there is one
        Pull    "R1-R9,PC"
cantdoinOS
        Debug   so,"we can't do it in OS"
        ;
        ; convert coords to internal pixels
        ; R6,R7 = x,y magnification
        ;
        LDR     R14,orgx
        ADD     R3,R3,R14
        LDR     R14,log2px
        MOV     R3,R3,ASR R14
        LDR     R14,orgy
        ADD     R4,R4,R14
        LDR     R14,log2py
        MOV     R4,R4,ASR R14           ; convert to internal form
      [ doublepixel_bodge
        ;
        ; bodge x-coords (inc. graphics window) so we can forget double-pixels
        ;
        LDR     R14,Log2bpc
        LDR     R0,Log2bpp
        SUBS    R14,R14,R0
        MOVNE   R3,R3,LSL R14
        LDRNE   R0,gwx0
        MOVNE   R0,R0,LSL R14
        STRNE   R0,gwx0
        LDRNE   R0,gwx1
        ADDNE   R0,R0,#1                ; make exclusive
        MOVNE   R0,R0,LSL R14
        SUBNE   R0,R0,#1                ; make inclusive again
        STRNE   R0,gwx1
        ;
        ; bodge x multiplier and divisor
        ;
        MOVNE   R6,R6,LSL R14
        STRNE   R6,save_xmag

        LDR     R14,save_inlog2bpc
        LDR     R0,save_inlog2bpp
        SUBS    R14,R14,R0
        LDRNE   R0,save_xdiv
        MOVNE   R0,R0,LSL R14
        STRNE   R0,save_xdiv
        ;
        ; R8, [save_ysize] <-- size of sprite in pixels (NOT double-pixels)
        ;
        LDR     R11,save_inlog2bpp      ; R11 = log2 ( bpp )
      |
        ;
        ; R8, [save_ysize] <-- size of sprite in pixels (double-pixels)
        ;
        LDR     R11,save_inlog2bpc
      ]

        LDR     R0,[R1,#spLBit]
        Debug   so, "spLBit is ? = ",R0
        LDR     R2,[R1,#spRBit]
        Debug   so, "spRBit is ? = ",R2
        SUB     R2,R2,R0
        ADD     R2,R2,#1                ; make inclusive
        Debug   so, "R2 is ? = ",R2
        LDR     R0,[R1,#spWidth]
        Debug   so, "spWidth = ",R0
        ADD     R8,R2,R0,ASL #5         ; 32 bits per word
        Debug   so, "R8 = ",R8

        MOV     R8,R8,ASR R11           ; R8 = no of pixels
        STR     R8,save_inputxsize

        Debug   so, "X-size 3 = ",R8
        LDR     R14,[R1,#spHeight]
        ADD     R14,R14,#1
        STR     R14,save_inputysize

        ;
        ; do x-clipping
        ; Entry:  R6 = x-magnification
        ;         R8 = input x-size
        ; Exit:   R9 = xleft
        ;         [save_xcoord] = start x-coord on screen
        ;         [save_xcount] = initial xcount
        ;         [save_xsize] = output x-size
        ;
        Debug   cc,"Do x-clipping",r6,r8

        LDR     R14,gwx0
        SUBS    R9,R14,R3
        MOVLT   R9,#0                   ; R9 = no of pixels to skip on left
        ADD     R14,R3,R9
        STR     R14,save_xcoord

        MUL     R2,R8,R6                ; R2 = x-size * x-mag
        LDR     R0,save_xdiv            ; R0 = x-div
        TEQ     R0,#0
        BEQ     diverror
        DivRem  R8,R2,R0, R14           ; R8 = no of output pixels
        LDR     R14,gwx1
        ADD     R14,R14,#1
        SUB     R14,R14,R3
        CMP     R8,R14                  ; clip on right
        MOVGT   R8,R14
        SUBS    R8,R8,R9                ; R8 = number of output pixels
        BLE     exitbiggie              ; none of sprite is visible
        STR     R8,save_xsize

        LDR     R14,save_xdiv
        MUL     R10,R9,R14              ; R10 = initial count
        TEQ     R6,#0
        BEQ     diverror
        DivRem  R9,R10,R6, R14          ; R9 = initial INPUT pixel coord
        RSB     R10,R10,R6              ; R10 = amount of 1st input pixel left
        STR     R10,save_xcount

        Debug   in,"xcoord,xleft,xcount,xsize =",#save_xcoord,R9,#save_xcount,#save_xsize
        ;
        ; do y-clipping
        ; Entry:  [save_inputysize] = input y-size
        ; Exit:   R10 = ybot
        ;         [save_ycoord] = start y-coord on screen
        ;         [save_ycount] = initial y-counter
        ;         [save_ysize] = output y-size
        ;
        Debug   cc,"Do y-clipping",r10
        LDR     R14,gwy0
        SUBS    R10,R14,R4
        MOVLT   R10,#0                  ; R10 = no of pixels to skip at bottom
        ADD     R14,R4,R10
        STR     R14,save_ycoord

        LDR     R8,save_inputysize
        MUL     R2,R8,R7                ; R2 = y-size * ymag
        LDR     R0,save_ydiv
        TEQ     R0,#0
        BEQ     diverror
        DivRem  R8,R2,R0, R14           ; R8 = no of output pixels
        LDR     R14,gwy1
        ADD     R14,R14,#1
        SUB     R14,R14,R4
        CMP     R8,R14
        MOVGT   R8,R14
        SUBS    R8,R8,R10               ; number of output pixels
        BLE     exitbiggie
        STR     R8,save_ysize

        LDR     R14,save_ydiv
        MUL     R8,R10,R14              ; R8 = initial count
        TEQ     R7,#0
        BEQ     diverror
        DivRem  R10,R8,R7, R14          ; R10 = initial INPUT pixel y-coord
        RSB     R8,R8,R7                ; R8 = amount of first input pixel left
        STR     R8,save_ycount

        Debug   in,"ycoord,ybot,ycount,ysize =",#save_ycoord,R10,#save_ycount,#save_ysize
        ;
        ; update ChangedBox coords (if enabled)
        ; Entry:  [save_xcoord],[save_ycoord],[save_xsize],[save_ysize] set up
        ;
        LDR     R14,changedbox          ; read in initialisation routine
        LDR     R0,[R14],#4
        TST     R0,#1                   ; enabled?
        BEQ     %FT01

        Push    "R3-R10"
        LDR     R3,save_xcoord          ; coordinate after clipping
        LDR     R4,save_ycoord          ; ditto
        LDR     R5,save_xsize           ; size in output pixels
        LDR     R6,save_ysize           ; ditto
      [ doublepixel_bodge
        LDR     R7,Log2bpc
        LDR     R8,Log2bpp
        SUBS    R7,R7,R8
        MOVNE   R3,R3,ASR R7            ; unbodge double-pixel stuff
        MOVNE   R5,R5,ASR R7
      ]
        ADD     R5,R3,R5
        ADD     R6,R4,R6
        SUB     R5,R5,#1                ; make inclusive
        SUB     R6,R6,#1
        LDMIA   R14,{R7-R10}            ; original box
        CMP     R7,R3
        MOVGT   R7,R3
        CMP     R8,R4
        MOVGT   R8,R4
        CMP     R9,R5
        MOVLT   R9,R5
        CMP     R10,R6
        MOVLT   R10,R6
        STMIA   R14,{R7-R10}            ; new box
        Pull    "R3-R10"
01
        ;
        ; get input address and shift
        ; Entry:  R9,R10 = initial input pixel coord (within sprite)
      [ doublepixel_bodge
        ;         R11 = input log2bpp
      |
        ;         R11 = input log2bpc
      ]
        ; Exit:   [save_inptr] --> first input word
        ;         [save_inshift] = initial bit position
        ;         [save_inoffset] = length of 1 sprite row (bytes)
        ;         [save_masko] = offset from image to mask (0 ==> none)
        ;         [save_maskinshift] = initial mask bit position
        ;         [save_maskinptr] => first mask word
        ;         [save_maskinoffset] = length of 1 mask row (bytes)
        ;

      [ jpeg
        ; for a JPEG sprite we'll need the actual coordinates, not the computed
        ; address, for the input data.
        Debug   cc,"input coords",R9,R10
        STR     R9,in_x
        STR     R10,in_y
      ]

        LDR     R4,[R1,#spMode]
        MOV     R0,R9
        TST     R4,#&80000000           ; 8bpp mask?
        MOVNE   R9,R9,LSL #3            ; Multiply x coord by 8 so we can use the 1bpp code

        ; set up things for 1bpp masks too - we decide later whether to use it
        AND     R14,R9,#31              ; mask is 1bpp, and there's no lh wastage
                                        ; so this is a lot simpler!
        STR     R14,save_maskinshift    ; save the inshift value for later

        Push    "R9"                    ; save unadjusted R9 for later

        LDR     R14,[R1,#spLBit]
        ADD     R9,R14,R0,LSL R11       ; R9 = initial bit position
        AND     R14,R9,#31
        CMP     R4,#256
        STR     R14,save_inshift
        STRLO   R14,save_maskinshift    ; PlotMask requires the correct shift for old format sprites. PlotScaled doesn't care since it just uses the sprite pixel offset for old format sprites.

        LDR     R14,[R1,#spImage]
      [ debugso
        MOV     R0, R14
        Debug   so,"Sprite Image at", R0
      ]
        ADD     R14,R1,R14              ; R14 --> sprite image
        LDR     R0,[R1,#spTrans]
        ADD     R0,R1,R0                ; R0 --> sprite mask
        Debug   so,"Sprite mask at", R0
        TST     R5,#8
        MOVEQ   R0,R14                  ; R0=R14 ==> no mask
        SUBS    R0,R0,R14
        BICEQ   R5,R5,#8                ; R5 bit 3 ==> is there a mask?
        STR     R0,save_masko

        LDR     R2,[R1,#spHeight]
        SUB     R10,R2,R10              ; R10 = no of rows from top

        LDR     R3,save_inputxsize      ; number of pixels(==number of bits)
        TST     R4,#&80000000           ; 8bpp mask?
        MOVNE   R3,R3,LSL #3            ; Pretend 8 times wider
        ANDS    R4,R3,#&1F              ; R4=number of bits
        MOVNE   R4,#1                   ; R4=1 if R3 MOD 31 is not zero
        ADD     R4,R4,R3,LSR #5         ; R4=number of words
        MOV     R4,R4,ASL #2            ; R4=number of bytes for full row
        STR     R4,save_maskinoffset

        LDR     R2,[R1,#spWidth]
        ADD     R2,R2,#1
        MOV     R2,R2,ASL #2            ; R2 = line length
        STR     R2,save_inoffset

        MOV     R9,R9,ASR #5            ; R9 = word offset

        Pull    "R3"                    ; pull unaltered R9 from earlier
        MOV     R3,R3,ASR #5

        ADD     R11,R0,R3,ASL #2        ; R11= mask addr + byte offset
        MLA     R3,R10,R4,R11           ; R3= #rows * bytes_per_row + maskaddr & byteoffset
                                        ; R3=> first mask input word
        LDR     R11,[R1,#spImage]
        ADD     R3,R3,R11
        ADD     R3,R3,R1
        STR     R3,save_maskinptr
        Debug   so, "Maskinptr is = ",R3

        ADD     R14,R14,R9,ASL #2
        MLA     R14,R10,R2,R14          ; R14 --> first input word
        STR     R14,save_inptr


        ; note that this points at the start of the last row of the sprite!

        Debug   in,"inptr,inshift,inoffset,masko =",#save_inptr,#save_inshift,#save_inoffset,#save_masko
        ;
        ; get output address and shift
        ; Entry:  [save_x/ycoord] = output x,y coord
        ;         [screenstart], [ywindlimit], [linelength] set up
        ; Exit:   [save_outptr] --> output address
        ;         [save_outoffset] = line length
        ;
        LDR     R3,save_xcoord
        LDR     R4,save_ycoord
      [ doublepixel_bodge
        LDR     R11,Log2bpp                     ; R11 = output log2(bpp)
      |
        LDR     R11,Log2bpc                     ; R11 = output log2(bpc)
      ]

        LDR     R14,ywindlimit
        SUB     R4,R14,R4                       ; R4 = no of rows down from top
        LDR     R2,save_ecflimit
        AND     R14,R4,#7
        ADD     R14,R2,R14,ASL #3               ; R14 = initial ecf ptr
        STR     R14,save_ecfptr

        LDR     R14,linelength
        STR     R14,save_outoffset
        LDR     R2,screenstart
        MLA     R10,R14,R4,R2                   ; R10 = R2 + (R14 * R4)
        MOV     R3,R3,ASL R11
        AND     R14,R3,#31                      ; R14 = initial bit posn in word;
        MOV     R3,R3,ASR #5
        ADD     R10,R10,R3,ASL #2               ; R10 --> output address
        STR     R10,save_outptr

        Debug   in,"Outptr =",#save_outptr

        ;
        ; compute xadd, yadd
        ;
        STR     R7,save_yadd            ; yadd = size of input pixels (ymag)
        LDR     R14,save_xdiv
        ADD     R14,R14,R6              ; xadd = save_xdiv + xmag
        STR     R14,save_xadd

        ; Jump to the C code run time compiler
        B       new_putscaled_compiler


        ; Prepare the palette/translation table for us
        ;
        ; In:
        ;       R1 -> sprite
        ;       R7 -> user supplied translation table
        ;       [spritecode] valid
        ;       [save_inbpp] valid
        ;       [is_it_jpeg] valid
        ;       [trns_flags2] valid
        ;       [BPP] valid
        ; Out:
        ;       R0, R7-R10 corrupt
        ;       [ColourTTR], [TTRType] valid
        ;       [trns_flags2] updated
        ;
        ; This is effectively an implementation of the following pseudocode
        ; for identifying/validating tables, except with extra logic added to
        ; convert the tables to more useful formats where possible.
        ;
        ; switch(sourcebpp)
        ; {
        ; case <=8bpp:
        ;   assert(!flg2_colourmap);
        ;   if(flg2_ignorettr && full_palette)
        ;     set table_optional;
        ;   switch(destbpp)
        ;   {
        ;   case <=8bpp:
        ;     if(table)
        ;     {
        ;       assert(table_entries_valid);
        ;       return normal_table;
        ;     }
        ;     else
        ;     {
        ;       assert(sourcebpp == destbpp);
        ;       return none;
        ;     }
        ;   case >=16bpp:
        ;     assert(table);
        ;     if(flg2_widetrans)
        ;       return wide_table;
        ;     return gcol_table;
        ;   }
        ; case >=16bpp:
        ;   if(flg2_colourmap)
        ;     return colour_mapping_descriptor;
        ;   if(flg2_ignorettr)
        ;     set table_optional; // extension to original spec
        ;   switch(destbpp)
        ;   {
        ;   case <=8bpp:
        ;     assert(is_32k_table);
        ;     return 32k_table;
        ;   case >=16bpp:
        ;     return none;
        ;   }
        ; }
        ;

preparettr      ROUT
        Entry
        LDRB    R14,spritecode          ; R14 = bottom 8 bits of reason code
        TEQ     R14,#SpriteReason_PlotMaskScaled
        TEQNE   R14,#SpriteReason_PlotMaskTransformed
        BEQ     preparettr_none         ; No table possible or required when plotting mask

        LDR     R14,save_inbpp
        MOV     R8,#0
        CMP     R14,#8
        LDR     R9,trns_flags2
        BGT     preparettr_src16bpp

        ; Source is <=8bpp

        ; Colour mapping isn't allowed here
        TST     R9,#flg2_colourmap
        BNE     errtrans

        ; Can we ignore the TTR?
        TST     R9,#flg2_ignorettr
        BEQ     preparettr_src8bpp_noignore

        LDR     R10,[R1,#spImage]
        CMP     R10,#SpriteCBsize
        BEQ     preparettr_src8bpp_noignore

        LDR     R0,[R1,#spTrans]
        CMP     R0,#SpriteCBsize
        BEQ     preparettr_src8bpp_noignore

        ;validate it (to exclude 8bpp without full palettes)
        ;test is that palette size should be 8*ncolours

        ;find the lower of the sprite start and mask start
        CMP     R10,R0
        MOVCS   R10,R0
        SUB     R10,R10,#SpriteCBsize

        MOV     R0,#1
        MOV     R10,R10,LSR #3 ;divide by 8 for number of palette entries
        MOV     R0,R0,ASL R14

        CMP     R0,R10
        BNE     preparettr_src8bpp_noignore

        MOV     R8,#TTRType_Optional     ; Flag TTR as optional
        LDR     R10,BPP
        CMP     R10,#16
        BLT     preparettr_src8bpp_dest8bpp ; Only use the palette if >=16bpp dest

        Debug   so, "We're going to plot from palette"
        LDR     R7,[R1,#spTrans]
        ADD     R7,R1,#SpriteCBsize
        ORREQ   R8,R8,#TTRType_Wide      ; If we're converting to 16bpp it's effectively the same as a (word packed) user supplied wide table
        ORRNE   R8,R8,#TTRType_Palette   ; Else it's a raw sprite palette
        BLEQ    makepalette16bpp

        STR     R7,ColourTTR
        STR     R8,TTRType
        EXIT

preparettr_src8bpp_noignore
        ; Source is <=8bpp
        ; TTR (if present) must be used
        LDR     R10,BPP
        CMP     R10,#16
        BGE     preparettr_src8bpp_dest16bpp
preparettr_src8bpp_dest8bpp
        CMP     R7,#0
        BNE     preparettr_src8bpp_dest8bpp_checknormal
        CMP     R10,R14
        BNE     errtrans                 ; Source bpp != dest, and no table supplied. Error!
        MOV     R8,#TTRType_None
        STR     R7,ColourTTR
        STR     R8,TTRType
        EXIT

preparettr_src8bpp_dest8bpp_checknormal
        ; Source is <=8bpp
        ; Dest is <=8bpp
        ; Check that R7 is a valid normal translation table
        ; Also check for identity tables and discard them
        CMP     R14,R10
        MOV     R9,#1
        ORRNE   R8,R8,#TTRType_Normal    ; If srcbpp != destbpp then don't discard identity tables (easier this way)
        MOV     R14,R9,LSL R14
        MOV     R10,R9,LSL R10
        MOV     R0,#0
10
        LDRB    R9,[R7,R0]
        CMP     R9,R10
        BHS     errtrans                 ; Invalid table
        CMP     R9,R0
        ORRNE   R8,R8,#TTRType_Normal
        ADD     R0,R0,#1
        CMP     R0,R14
        BNE     %BT10
        TST     R8,#TTRType_Normal
        BEQ     preparettr_none
        STR     R7,ColourTTR
        STR     R8,TTRType
        EXIT

preparettr_src8bpp_dest16bpp
        ; Source is <=8bpp
        ; Dest is >=16bpp
        ; This means we must either have a wide table or a GCOL table
        ; Check for and translate as appropriate
        ; Note that it's impossible for TTRType_Optional flag to be set here; if it was, we'd already be set up to use the sprite palette
        CMP     R7,#0
        BEQ     errtrans
        MOV     R8,#TTRType_Wide
        TST     R9,#flg2_widetrans
        STR     R8,TTRType
        BNE     preparettr_handlewidetrans
        ; GCOL table
        BL      convertGCOLtable
50
        STR     R7,ColourTTR
        EXIT

preparettr_handlewidetrans
        ; Wide translation table
        ; Repack to 32bit words if necessary
        CMP     R10,#16
        BNE     %BT50
        ADRL    R8,newtranstable
        MOV     R9,#1
        STR     R8,ColourTTR
        MOV     R14,R9,LSL R14
70
        LDR     R0,[R7],#4       ; load two values from original ctrans table
        MOV     R9,R0,LSR #16    ; put the second value in the low 16 bits of R9
        EOR     R0,R0,R9,LSL #16 ; and remove the second value from R0
        SUBS    R14,R14,#2       ; decrement count by 2 src colours
        STMIA   R8!,{R0,R9}      ; store
        BNE     %BT70
        EXIT

preparettr_src16bpp
        ; Source is >=16bpp
        ; We only allow colour mapping, 32K-style tables, or nothing at all
        TST     R9,#flg2_colourmap
        MOVNE   R8,#TTRType_ColourMap
        STRNE   R7,ColourTTR
        STRNE   R8,TTRType
        EXIT    NE

        LDR     R10,BPP
        CMP     R10,#16
        BGE     preparettr_src16bpp_dest16bpp

        ; Dest is <=8bpp
        ; We must have a 32K style table, but it can be flagged as optional
        CMP     R7,#0
      [ jpeg
        BNE     %FT80
        ; Exception to the rule: JPEG might not have a table if we're running on an old OS
        LDR     R0,is_it_jpeg
        CMP     R0,#0
        BEQ     preparettr_none
        B       errtrans
80
      |
        BEQ     errtrans
      ]
        LDR     R0,word32k
        LDR     R10,[R7]
        CMP     R10,R0
        EORNE   R0,R0,#5<<24 ; convert "32K." to "32K+"
        CMPNE   R10,R0
        LDREQ   R10,[R7,#8]
        CMPEQ   R10,R0
        BNE     errtrans
        MOV     R0,R0,LSR #24 ; Leave . or + to indicate table format
        LDR     R7,[R7,#4] ; Discard the header, we don't need it

        ; Both putscaled_compiler and sprtrans_compiler require the 32K table
        ; to be one of the following:
        ; (a) if source sprite >=32pp, an old-style 32K. table
        ; (b) if source sprite <=16bpp, a 32K. or 32K+ table with correct
        ;     NColour, ModeFlags (minus alpha), Log2BPP, and correct output BPP
        LDR     R10,save_inbpp
        CMP     R10,#32
        TEQEQ   R0,#'.'
        BEQ     %FT86 ; Note if >=32bpp source and not 32K. table, the below checks should kick it out
        ; Check table format is compatible with sprite
        TEQ     R0,#'.'
        MOVEQ   R0,#65536
        MOVEQ   R8,#0
        SUBEQ   R0,R0,#1
        BEQ     %FT85
        ; 32K+ format, validate it
        ASSERT  CTrans32Kplus_HeaderSize = CTrans32Kplus_TableFormat+2
        ; Check header word OK
        LDR     R0,[R7,#-4]
        CMP     R0,#0+(CTrans32Kplus_ExpectedSize<<16)
        BNE     errtrans
        LDR     R10,BPP
        MOV     R8,#1
        SUB     R0,R7,#CTrans32Kplus_ExpectedSize
        MOV     R10,R8,LSL R10
        ; Check dest count matches 1<<BPP
        LDR     R8,[R0,#CTrans32Kplus_DestCount]
        CMP     R8,R10
        ; Check source Log2BPP == 4 (only possible case for <=16bpp source)
        LDREQ   R8,[R0,#CTrans32Kplus_SrcLog2BPP]
        CMPEQ   R8,#4
        BNE     errtrans
        ; Check NColour, Log2BPP
        ASSERT  CTrans32Kplus_SrcNColour = 0
        ASSERT  CTrans32Kplus_SrcModeFlags = 4
        LDMIA   R0,{R0,R8}
85
        LDR     R10,save_inmodeflags
        LDR     LR,save_inncolour
        BIC     R10,R10,#ModeFlag_DataFormatSub_Alpha
        CMP     LR,R0
        CMPEQ   R10,R8
        BNE     errtrans
        ; Success!
86
        TST     R9,#flg2_ignorettr
        MOV     R8,#TTRType_32K
        ORRNE   R8,R8,#TTRType_Optional
        STR     R7,ColourTTR
        STR     R8,TTRType
        EXIT


preparettr_src16bpp_dest16bpp
preparettr_none
        ; No table supplied, or table should be ignored
        LDR     R14,trns_flags2
        MOV     R7,#0
        ASSERT  TTRType_None = 0
        BIC     R14,R14,#flg2_widetrans + flg2_ignorettr + flg2_colourmap ; Forget irrelevant flags, increases the chances of us using an OS plot routine
        STR     R7,ColourTTR
        STR     R7,TTRType
        STR     R14,trns_flags2
        EXIT

errtrans
        ADRL    R0,ErrorBlock_BadTranslation   ; different bpp ==> must have table
errexitscaled
        addr    r1, Title
        BL      copy_error_one          ; Always set the V bit
        Debug   so,"error from trans table"
        PullEnv VS
        BVS     exitbiggie
notrans
        EXIT

word32k =       "32K."

convertGCOLtable ROUT
        ; In:  r7 -> GCOL table
        ; Out: r7 -> translated table
        ;      r8-r9 corrupt
        ;
        ; For backwards compatibility we attempt to remap the colours by taking the GCOL
        ; byte which is in VIDC 1 format and convert it to a word value sensible for this
        ; depth of display.

        Entry   "R0-R4"
        LDR     R8,save_inbpp
        MOV     R9,#1
        MOV     R8,R9,LSL R8            ; get number of input colours
        LDR     R9,Log2bpp
        SUB     R9,R9,#3                ; convert the output Log2 bpp into a sensible index for conversion

        ; Work out what conversion algorithm is needed
        LDR     R2,modeflags
        LDR     R0,ncolour
        Debug   so,"log2bpp-3=",R9
        Debug   so,"modeflags=",R2
        Debug   so,"ncolour=",R0
        CMP     R9,#2 ; 32bpp or 24bpp?
        BICHI   R2,R2,#ModeFlag_DataFormatSub_Alpha
        MOVHS   R9,#11
        BHS     %FT05
        MOV     R9,#1 ; Assume 4K
        TST     R0,#4096
        MOVNE   R9,#5 ; unless NColour says > 4096, in which case 32K
        TSTNE   R2,#ModeFlag_64k
        MOVNE   R9,#9 ; unless mode flags says 64K
        BICNE   R2,R2,#ModeFlag_DataFormatSub_Alpha
05
        ASSERT  ModeFlag_DataFormatSub_RGB = 4:SHL:12
        ASSERT  ModeFlag_DataFormatSub_Alpha = 8:SHL:12
        AND     R2,R2,#ModeFlag_DataFormatSub_RGB+ModeFlag_DataFormatSub_Alpha
        ADD     R9,R9,R2,LSR #14 ; RGB = bit 0, alpha = bit 1
        Debug   so,"GCOL munge index=",R9

        MOV     R2,R7
        ADR     R7,newtranstable        ; -> new translation table (passed out on exit)

converttrans_new
        SUBS    R8,R8,#1
        EXIT    MI

        LDRB    R0,[R2,R8]
        MOV     LR,PC
        ADD     PC,PC,R9,LSL #2         ; call function to remap the colour byte
        STR     R0,[R7,R8,LSL #2]       ; and store the converted value
        B       converttrans_new        ; and loop back round
        B       mungeGCOLto4444_TBGR    ; index 1
        B       mungeGCOLto4444_TRGB
        B       mungeGCOLto4444_ABGR
        B       mungeGCOLto4444_ARGB
        B       mungeGCOLto1555_TBGR    ; index 5
        B       mungeGCOLto1555_TRGB
        B       mungeGCOLto1555_ABGR
        B       mungeGCOLto1555_ARGB
        B       mungeGCOLto565_BGR      ; index 9
        B       mungeGCOLto565_RGB
        B       mungeGCOLto8888_TBGR    ; index 11
        B       mungeGCOLto8888_TRGB
        B       mungeGCOLto8888_ABGR
        B       mungeGCOLto8888_ARGB

        ; And now a bunch of macros to help perform the conversion
        ; These are mostly variations on the same theme, so could potentially be merged into one big & ugly macro

        MACRO
$label  mungeGCOLto12 $in,$out,$temp1,$temp2,$rbswap,$alpha
                                        ;      fedcba98 76543210 fedcba98 76543210
                                        ; $in                             bbggrrtt
                                        ; $out                   aaaabbtt ggttrrtt ($rbswap=0)
                                        ; $out                   aaaarrtt ggttbbtt ($rbswap=1)
$label  AND     $temp1,$in,#&F          ; get red value
        AND     $temp2,$in,#&3          ; get tint
      [ $rbswap = 1
        MOV     $temp1,$temp1,LSL #8    ; shift red up if necessary
        ORR     $temp1,$temp1,$temp2    ; and place tint for blue
      |
        ORR     $temp1,$temp1,$temp2,LSL #8 ; place tint for blue
      ]
        ORR     $temp1,$temp1,$temp2,LSL #4 ; place tint for green
        AND     $temp2,$in,#&30         ; get green
        AND     $out,$in,#&C0           ; get blue
      [ "$alpha" <> ""
        ORR     $temp2,$temp2,#$alpha>>2 ; set alpha
      ]
      [ $rbswap = 1
        ORR     $out,$temp1,$out,LSR #4 ; shift blue down
      |
        ORR     $out,$temp1,$out,LSL #4 ; shift blue up
      ]
        ORR     $out,$out,$temp2,LSL #2 ; merge in green (+alpha)
        MOV     pc,lr                   ; done
        MEND

        MACRO
$label  mungeGCOLto15 $in,$out,$temp1,$temp2,$rbswap,$alpha
                                        ;      fedcba98 76543210 fedcba98 76543210
                                        ; $in                             bbggrrtt
                                        ; $out                   abbtttgg tttrrttt ($rbswap=0)
                                        ; $out                   arrtttgg tttbbttt ($rbswap=1)
$label  AND     $temp1,$in,#&F          ; get red value
        AND     $temp2,$in,#&3          ; get tint
      [ $rbswap = 1
        MOV     $temp1,$temp1,LSL #11   ; shift red up
        ORR     $temp1,$temp1,$temp2,LSL #1 ; and place tint for blue
      |
        MOV     $temp1,$temp1,LSL #1    ; shift red up
        ORR     $temp1,$temp1,$temp2,LSL #11 ; and place tint for blue
      ]
        TST     $in,#1                  ; check low tint bit
        ORR     $temp1,$temp1,$temp2,LSL #6 ; place tint for green
        AND     $temp2,$in,#&30         ; get green
        AND     $out,$in,#&C0           ; get blue
      [ "$alpha" <> ""
        ORR     $temp2,$temp2,#$alpha>>4 ; set alpha
      ]
        ORRNE   $temp1,$temp1,#1        ; set 3rd tint bit for red (or blue if rbswap)
        ORRNE   $temp2,$temp2,#2+64     ; set 3rd tint bit for green + blue (or green + red if rbswap)
      [ $rbswap = 1
        ORR     $out,$temp1,$out,LSR #3 ; shift blue down
      |
        ORR     $out,$temp1,$out,LSL #7 ; shift blue up
      ]
        ORR     $out,$out,$temp2,LSL #4 ; merge in green (+ alpha + tint)
        MOV     pc,lr                   ; done
        MEND

        MACRO
$label  mungeGCOLto16 $in,$out,$temp1,$temp2,$rbswap
                                        ;      fedcba98 76543210 fedcba98 76543210
                                        ; $in                             bbggrrtt
                                        ; $out                   bbtttggt tttrrttt ($rbswap=0)
                                        ; $out                   rrtttggt tttbbttt ($rbswap=1)
$label  AND     $temp1,$in,#&F          ; get red value
        AND     $temp2,$in,#&3          ; get tint
      [ $rbswap = 1
        MOV     $temp1,$temp1,LSL #12   ; shift red up
        ORR     $temp1,$temp1,$temp2,LSL #1 ; and place tint for blue
      |
        MOV     $temp1,$temp1,LSL #1    ; shift red up
        ORR     $temp1,$temp1,$temp2,LSL #12 ; and place tint for blue
      ]
        TST     $in,#1                  ; check low tint bit
        ORR     $temp1,$temp1,$temp2,LSL #7 ; place tint for green
        AND     $temp2,$in,#&30         ; get green
        AND     $out,$in,#&C0           ; get blue
        ORRNE   $temp1,$temp1,#1        ; set 3rd tint bit for red (or blue if rbswap)
        ORRNE   $temp2,$temp2,#3+64     ; set 3rd+4th tint bit for green + blue (or green + red if rbswap)
      [ $rbswap = 1
        ORR     $out,$temp1,$out,LSR #3 ; shift blue down
      |
        ORR     $out,$temp1,$out,LSL #8 ; shift blue up
      ]
        ORR     $out,$out,$temp2,LSL #5 ; merge in green (+ tint)
        MOV     pc,lr                   ; done
        MEND

        MACRO
$label  mungeGCOLto32 $in,$out,$temp1,$temp2,$rbswap,$alpha
                                        ;      fedcba98 76543210 fedcba98 76543210
                                        ; $in                             bbggrrtt
                                        ; $out aaaaaaaa bbttbbtt ggttggtt rrttrrtt ($rbswap=0)
                                        ; $out aaaaaaaa rrttrrtt ggttggtt bbttbbtt ($rbswap=1)
$label  AND     $temp1,$in,#&F          ; get red value
        AND     $temp2,$in,#&3          ; get tint
      [ $rbswap = 1
        MOV     $temp1,$temp1,LSL #16   ; shift red up if necessary
        ORR     $temp1,$temp1,$temp2    ; and place tint for blue
      |
        ORR     $temp1,$temp1,$temp2,LSL #16 ; place tint for blue
      ]
        ORR     $temp1,$temp1,$temp2,LSL #8 ; place tint for green
        AND     $temp2,$in,#&30         ; get green
        AND     $out,$in,#&C0           ; get blue
      [ "$alpha" <> ""
        ORR     $temp2,$temp2,#$alpha>>6 ; set alpha
      ]
      [ $rbswap = 1
        ORR     $out,$temp1,$out,LSR #4 ; shift blue down
      |
        ORR     $out,$temp1,$out,LSL #12 ; shift blue up
      ]
        ORR     $out,$out,$temp2,LSL #6 ; merge in green (+alpha)
        ORR     $out,$out,$out,LSL #4   ; duplicate low nibbles to high nibbles
        MOV     pc,lr                   ; done
        MEND

        ; Macro invocation

mungeGCOLto4444_TBGR mungeGCOLto12 R0,R0,R3,R4,0
mungeGCOLto4444_TRGB mungeGCOLto12 R0,R0,R3,R4,1
mungeGCOLto4444_ABGR mungeGCOLto12 R0,R0,R3,R4,0,&F000
mungeGCOLto4444_ARGB mungeGCOLto12 R0,R0,R3,R4,1,&F000
mungeGCOLto1555_TBGR mungeGCOLto15 R0,R0,R3,R4,0
mungeGCOLto1555_TRGB mungeGCOLto15 R0,R0,R3,R4,1
mungeGCOLto1555_ABGR mungeGCOLto15 R0,R0,R3,R4,0,&8000
mungeGCOLto1555_ARGB mungeGCOLto15 R0,R0,R3,R4,1,&8000
mungeGCOLto565_BGR mungeGCOLto16 R0,R0,R3,R4,0
mungeGCOLto565_RGB mungeGCOLto16 R0,R0,R3,R4,1
mungeGCOLto8888_TBGR mungeGCOLto32 R0,R0,R3,R4,0
mungeGCOLto8888_TRGB mungeGCOLto32 R0,R0,R3,R4,1
mungeGCOLto8888_ABGR mungeGCOLto32 R0,R0,R3,R4,0,&FF000000
mungeGCOLto8888_ARGB mungeGCOLto32 R0,R0,R3,R4,1,&FF000000

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SpriteOp_AppendSprite
; ---------------------
; Entry: R0 = reason code
;        R1 = areaCBptr
;        R2 = name/ptr of 1st sprite
;        R3 = name/ptr of 2nd sprite
;        R4 = flags (0 ==> merge horizontally, else vertically)
; Exit:  1st sprite is result of merging both
;        2nd sprite is deleted
;        scratch space used (no extra memory apart from that)
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Go_AppendSprite
        Push    "R1-R11,LR"

        CLRPSR  I_bit, R14              ; re-enable interrupts
        BL      findsprite_inarea
        STRVC   R1,sp1_areaCBptr        ; R1 may be updated if system area
        MOVVC   R5,R2                   ; R5 --> first sprite
        MOVVC   R2,R3
        BLVC    findsprite_inarea       ; R2 --> second sprite
        BVS     %FT99

        ;
        ; Algorithm:
        ;       check that sprites are compatible - if not, give error/adjust sprite
        ;       move sprite2 to end of sprites
        ;       move sprite1 just before sprite2
        ;       eliminate sprite2 header
        ;       if masked, swap(mask1,data2)
        ;       if R4=0 (horiz. merge) interleave rows of data (& then masks if nec)
        ;       reclaim wastage (depends on h/v merge) of data + masks
        ;       correct sprite end ptrs, no of sprites etc.
        ;       correct size of sprite
        ;
        TEQ     R2,R5                   ; same sprite?
        BEQ     badappend
        LDR     R14,[R2,#spMode]
        LDR     R0,[R5,#spMode]
        Debug   ag,"Modes are",R0,R14   ; Merged from 0.62 (GPS)
        TEQ     R0,R14
        BNE     badappend               ; can't merge different modes
        ;
        ; check that rows/columns are same (depends on R4)
        ;
        TEQ     R4,#0                   ; R4=0 ==> horiz merge (check rows)
        BNE     %FT01

        LDR     R14,[R2,#spHeight]
        LDR     R0,[R5,#spHeight]
        Debug   ag,"Heights are",R0,R14 ; Merged from 0.62 (GPS)
        TEQ     R0,R14
        BEQ     %FT02
badappend
        Debug   ag,"Bad append, setting up error block and exiting"
        ADR     R0, ErrorBlock_BadAppend
        addr    r1, Title
        BL      copy_error_one          ; Always sets the V bit
        B       %FT99
        MakeSpriteErrorBlock BadAppend,,AppErr

01
        Push    "R2"
        BL      getspritewidth          ; R2 --> sprite defn, R3 = width
        MOV     R2,R5
        MOV     R6,R3
        BL      getspritewidth
        Pull    "R2"
        Debug   ag,"Widths are",R3,R6   ; Merged from 0.62 (GPS)
        TEQ     R3,R6
        BNE     badappend
02
        ;
        ; if one has a mask & the other doesn't, create mask
        ;
        LDR     R14,[R2,#spImage]
        LDR     R0,[R2,#spTrans]
        EORS    R6,R0,R14
        MOVNE   R6,#-1                  ; R6 = (2nd sprite has mask)
        LDR     R14,[R5,#spImage]
        LDR     R0,[R5,#spTrans]
        EORS    R0,R0,R14
        MOVNE   R0,#-1
        TEQ     R0,R6                   ; if same, skip next bit
        BEQ     %FT01

        Debug   ag,"One of the sprites has no mask"   ; Merged from 0.62 (GPS)
        Push    "R2"
        TEQ     R6,#0
        MOVNE   R2,R5                   ; if 2nd sprite has mask, enmask 1st
        MOV     R0,#SpriteReason_CreateMask
        ADD     R0,R0,#&200             ; since R2 --> sprite definition
        BL      Go_SpriteOp             ; call MOS version
        Pull    "R2"
        BVS     %FT99                   ; error (eg. memory full)
01
        ;
        ; move sprites to end of memory (need to get addresses back again)
        ;
        LDMFD   R13,{R1-R3}

        BL      findsprite_inarea
        MOVVC   R5,R2                   ; R5 --> first sprite
        MOVVC   R2,R3
        BLVC    findsprite_inarea       ; R2 --> second sprite
        BVS     %FT99

        Debug   ag,"First sprite is at",R5
        Debug   ag,"Second sprite is at",R2

        LDR     R3,[R1,#saFree]         ; R3 --> end of sprites
        Debug   ag,"End of sprite area is",R3   ; Merged from 0.62 (GPS)
        ADD     R3,R1,R3
        MOV     R1,R2                   ; R1 --> sprite2
        LDR     R2,[R1,#spNext]
        ADD     R2,R1,R2                ; R2 --> end of sprite2
        Debug   ag,"End of sprite2 is",R2       ; Merged from 0.62 (GPS)
        BL      swapblocks
        MOV     R6,R1                   ; R6 --> sprite2 (in new position)

        CMP     R5,R2                   ; if sprite1 was after sprite2
        DebugIf CS,ag,"Sprite1 was after sprite2"   ; Merged from 0.62 (GPS)
        SUBCS   R14,R3,R1
        SUBCS   R5,R5,R14               ; move down by (R3-R1) ie. sprite2 size

        MOV     R3,R1
        MOV     R1,R5                   ; R1 --> sprite1
        LDR     R2,[R1,#spNext]
        ADD     R2,R1,R2
        Debug   ag,"End of sprite1 is",R2     ; Merged from 0.62 (GPS)
        BL      swapblocks              ; R1 --> sprite1 (in new position)
        ;
        ; note the sprite mode of sprite 1 (should = sprite2)
        ; and the spNext parameter of sprite 2
        ;
        LDR     R2, [R1,#spMode]        ; Merged from 0.62 (GPS)
        STR     R2, sp_mode             ; Merged from 0.62 (GPS)
        LDR     R2, [R6,#spNext]        ; Merged from 0.62 (GPS)
        STR     R2, sp2_next            ; Merged from 0.62 (GPS)
        ;
        ; note down sprite1's header
        ;
        MOV     R2,R1
        ADRL    R3,sp1_data
        BL      savespriteheader        ; sets up R5,R7-R11
        ;
        ; note down sprite2's header, and delete it
        ;
        MOV     R2,R6
        ADRL    R3,sp2_data
        BL      savespriteheader        ; sets up R5,R7-R11

        MOV     R1,R6                   ; destination
        ADD     R2,R1,R10               ; source (image)
        LDR     R3,[R1]
        SUB     R3,R3,R10               ; counter
        BL      copyblock               ; R3 bytes from R2 to R1
        MOV     R2,R6                   ; R2 --> sprite2 image
        ;
        ; if there is a mask (new or old), swap (mask1, image2) & do both sets of data
        ;
        SUBS    R11,R11,R10             ; offset from image to mask (sprite2)
        BEQ     %FT01

        Debug   ag,"These sprites have masks!"        ; Merged from 0.62 (GPS)
        LDR     R1,sp1_header
        LDR     R14,[R1,#spTrans]       ; R1 --> start of sprite1 mask
        ADD     R1,R1,R14               ; R2 --> sprite2 image
        ADD     R3,R2,R11               ; R3 --> end of sprite2 image
        BL      swapblocks              ; R2, R1 --> image2, mask1

        Push    "R1,R3"

        MOV     R3,R1                   ; R3 --> end of image2
        LDR     R1,sp1_header
        SUB     R14,R3,R1
        STR     R14,sp1_trans           ; for later
        LDR     R14,sp1_image
        ADD     R1,R1,R14               ; R1 --> start of image1
        BL      mergeblocks             ; takes note of R4

        Pull    "R1,R2"                 ; R1 --> mask1, R2 --> mask2
        LDR     R3,sp2_trans
        LDR     R14,sp2_next            ; Merged from 0.62 (GPS)

        SUB     R3,R14,R3               ; R3 = size of mask2 (poss+) - From 0.62 (GPS)
        ADD     R3,R2,R3                ; R3 --> end of mask2

        LDR     R14, sp_mode            ; merged from 0.62 (GPS)
        MOVS    R14, R14, LSR #27       ; Old or new?                 merged from 0.62 (GPS)
        BNE     %FT00

        Debug   ag,"Old format mergeblocks to be executed"
        BL      mergeblocks             ;   if old format             merged from 0.62 (GPS)
        B       %FT02
00        
        Debug   ag,"New format mergeblocks to be executed"
        BL      maskmergeblocks         ;   if new format             merged from 0.62 (GPS)
        B       %FT02
01
        ;
        ; otherwise just merge the images
        ;
        Debug   ag,"These sprites don't have masks"                 ; merged from 0.62 (GPS)
        LDR     R1,sp1_header
        LDR     R14,sp1_image
        ADD     R1,R1,R14               ; R1 --> sprite1 image
        LDR     R2,sp2_header           ; R2 --> sprite2 image
        LDR     R14,sp2_imagesize
        ADD     R3,R2,R14               ; R3 --> end of sprite2 image
        BL      mergeblocks
02
        ;
        ; now rationalise the final image - shunt all bits down
        ;
        Debug   ag,"Now rationalising..."          ; merged from 0.62 (GPS)
        LDR     R2,sp1_header
        LDR     R3,sp1_image
        ADD     R1,R2,R3
        MOV     R3,R1
        BL      chunterblock            ; R1 --> start of block
        LDR     R0,sp1_image
        LDR     R14,sp1_trans
        TEQ     R14,R0                  ; was there a mask?
        BEQ     %FT10                   ; if not, skip the next bit

        SUB     R14,R3,R2                                           ; merged from 0.62 (GPS)
        STR     R14,[R2,#spTrans]       ; point to mask               merged from 0.62 (GPS)

        LDR     R14, sp_mode                                        ; merged from 0.62 (GPS)
        MOVS    R14, R14, LSR #27       ; New or old format mask?     merged from 0.62 (GPS)
        BNE     %FT05

        Debug   ag,"Old format chunterblock to be executed"
        BL      chunterblock            ; process old format mask     merged from 0.62 (GPS)
        B       %FT10
05
        Debug   ag,"New format chunterblock to be executed"
        BL      maskchunterblock        ; process new format mask     merged from 0.62 (GPS)
10
        SUB     R14,R3,R2
        STR     R14,[R2,#spNext]        ; sprite size
        LDR     R2,sp1_areaCBptr
        SUB     R14,R3,R2
        STR     R14,[R2,#saFree]        ; area size

        LDR     R14,[R2,#saNumber]
        SUB     R14,R14,#1              ; sprite2 deleted
        STR     R14,[R2,#saNumber]

99
        MOVVC   r0, #35                 ; made conditional to stop error block being junked (GPS)
        Pull    "R1-R11,PC"

        ; Chunterblock
        ;
        ; Entry:  R1 --> input data
        ;         R3 --> output data
        ;         R4 = 0/1 (horizontal/vertical merge)
        ;         [sp1/2_data] = original state of sprites
        ;         [sp1/2_imagesize] = amount of data to process
        ; Exit:   R1 --> end of input
        ;         R3 --> end of output
        ;         [[sp1_header]] contains correct width, height, lbit, rbit
        ;         sprite data crunched into shape
        ;
chunterblock
        Push    "R5-R11,LR"
        Debug   ag,"Chunterblock entry R1,R3,R4",R1,R3,R4

        TEQ     R4,#0
        BNE     %FT04

        LDR     R11,sp1_height          ; R11 = no of rows to do (-1)
01
        MOV     R10,R3                  ; original output ptr

        LDR     R5,sp1_width            ; R5 = no of intermediate words
        LDR     R6,sp1_lbit             ; R6 = input bit wastage on left
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        LDR     R8,sp1_rbit             ; bit non-wastage on right
        BL      chunterrow              ; R7 = no of bits set up in last word

        LDR     R5,sp2_width
        LDR     R6,sp2_lbit
        LDR     R8,sp2_rbit
        BL      chunterrow

        TEQ     R7,#0
        MOVEQ   R7,#32
        ADDNE   R3,R3,#4                ; skip last word if anything in it

        SUBS    R11,R11,#1
        BPL     %BT01

        B       setupwidth

04
        LDR     R11,sp1_height
01
        LDR     R5,sp1_width            ; R5 = no of intermediate words
        LDR     R6,sp1_lbit             ; R6 = input bit wastage on left
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        LDR     R8,sp1_rbit             ; bit non-wastage on right
        BL      chunterrow              ; R7 = no of bits set up in last word
        TEQ     R7,#0
        ADDNE   R3,R3,#4                ; skip last word if anything in it

        SUBS    R11,R11,#1
        BPL     %BT01

        LDR     R11,sp2_height
02
        MOV     R10,R3
        LDR     R5,sp2_width            ; R5 = no of intermediate words
        LDR     R6,sp2_lbit             ; R6 = input bit wastage on left
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        LDR     R8,sp2_rbit             ; bit non-wastage on right
        BL      chunterrow              ; R7 = no of bits set up in last word
        TEQ     R7,#0
        MOVEQ   R7,#32
        ADDNE   R3,R3,#4                ; skip last word if anything in it

        SUBS    R11,R11,#1
        BPL     %BT02

        LDR     R14,sp1_height
        LDR     R0,sp2_height
        ADD     R14,R14,R0
        ADD     R14,R14,#1              ; since each is <no of rows>-1
        STR     R14,[R2,#spHeight]
        ;
        ; R2 --> sprite header, R3-R10 = width of 1 row, R7 = spRBit+1, spLBit=0
        ;
setupwidth
        SUB     R14,R3,R10
        MOV     R14,R14,LSR #2
        SUB     R14,R14,#1
        STR     R14,[R2,#spWidth]       ; spWidth = no of words - 1
        MOV     R14,#0
        STR     R14,[R2,#spLBit]        ; spLBit = 0
        SUB     R7,R7,#1
        STR     R7,[R2,#spRBit]         ; spRBit = R7-1

        Debug   ag,"Chunterblock exit R1,R3,R4",R1,R3,R4

        Pull    "R5-R11,PC"

        ; Maskchunterblock
        ;
        ; Entry:  R1 --> input data
        ;         R3 --> output data
        ;         R4 = 0/1 (horizontal/vertical merge)
        ;         [sp1/2_data] = original state of sprites
        ;         [sp1/2_imagesize] = amount of data to process
        ; Exit:   R1 --> end of input
        ;         R3 --> end of output
        ;         [[sp1_header]] contains correct width, height, lbit, rbit
        ;         sprite data crunched into shape
        ;
        ; NOTE:   Only called for new format (1bpp) sprites
        ;
maskchunterblock
        Push    "R5-R11,LR"

        Debug   ag,"Chunterblock entry R1,R3,R4",R1,R3,R4

        TEQ     R4,#0                   ; Vertical or horizontal join?
        BNE     %FT04                   ; Go elsewhere if vertical join

        LDR     R11,sp1_height          ; R11 = no of rows to do (-1)
01
        MOV     R10,R3                  ; original output ptr

        LDR     R8,sp1_rbit
        LDR     R5,sp1_width            ; R5 = no of intermediate words
        BL      FindMaskWidth           ; Alters R5 & sets up R8 to Rbit
        MOV     R6,#0                   ; Lbit wastage = 0
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        BL      chunterrow              ; R7 = no of bits set up in last word
        
        LDR     R8,sp2_rbit
        LDR     R5,sp2_width
        BL      FindMaskWidth           ; Alters R5 & sets up R8 to Rbit for mask
        MOV     R6,#0                   ; Lbit wastage always = 0
        BL      chunterrow

        TEQ     R7,#0
        MOVEQ   R7,#32
        ADDNE   R3,R3,#4                ; skip last word if anything in it

        SUBS    R11,R11,#1              ; One line less to do...
        BPL     %BT01                   ; Do the next one


        Debug   ag,"Maskchunterblock exit R1,R3,R4",R1,R3,R4

        Pull    "R5-R11,PC"

04
        LDR     R11,sp1_height
01
        LDR     R8,sp1_rbit
        LDR     R5,sp1_width            ; R5 = no of intermediate words
        BL      FindMaskWidth           ; Convert R5 & set up R8
        MOV     R6,#0                   ; Lbit is zero for this format sprite
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        BL      chunterrow              ; R7 = no of bits set up in last word
        TEQ     R7,#0
        ADDNE   R3,R3,#4                ; skip last word if anything in it

        SUBS    R11,R11,#1
        BPL     %BT01

        LDR     R11,sp2_height
02
        MOV     R10,R3
        LDR     R8,sp2_rbit
        LDR     R5,sp2_width            ; R5 = no of intermediate words
        BL      FindMaskWidth
        MOV     R6,#0                   ; Lbit = 0 always
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        BL      chunterrow              ; R7 = no of bits set up in last word
        TEQ     R7,#0
        MOVEQ   R7,#32
        ADDNE   R3,R3,#4                ; skip last word if anything in it

        SUBS    R11,R11,#1
        BPL     %BT02
        Pull    "R5-R11,PC"

        ;
        ; R2 --> sprite header, R3-R10 = width of 1 row, R7 = spRBit+1, spLBit=0
        ;
masksetupwidth
        SUB     R14,R3,R10
        MOV     R14,R14,LSR #2
        SUB     R14,R14,#1
        STR     R14,[R2,#spWidth]       ; spWidth = no of words - 1
        MOV     R14,#0
        STR     R14,[R2,#spLBit]        ; spLBit = 0
        SUB     R7,R7,#1
        STR     R7,[R2,#spRBit]         ; spRBit = R7-1
        
        Pull    "R2,R5-R11,PC"


        ; Chunterrow
        ;
        ; Entry:  R1 --> input data
        ;         R3 --> output data (some of 1st word may be valid)
        ;         R5 = no of whole words to do (excluding the end 2)
        ;         R6 = bit offset of 1st valid bit in input word
        ;         R7 = bit offset of 1st unused bit in output word
        ;         R8 = bit offset of last used bit in output word
        ; Exit:   R1 --> end of input data
        ;         R3 --> end of output data
        ;         R7 = no of valid bits in [R3] - 0..31 (if 32, output word & go on)
        ;
chunterrow
        Push    "R0,R5,R6,R8-R10,LR"
        Debug   ag,"Chunterrow entered R1,R3,R5-R8",R1,R3,R5,R6,R7,R8

        ADD     R8,R8,#1                ; make exclusive
        LDR     R0,[R1],#4
        MOV     R0,R0,LSR R6
        LDR     R14,[R3]
        RSB     R10,R7,#32              ; for later
        MOV     R14,R14,LSL R10
        MOV     R14,R14,LSR R10
        ORR     R14,R14,R0,LSL R7
        TEQ     R5,#0
        RSBEQ   R9,R6,R8                ; R9 = no of valid bits shifted in
        RSBNE   R9,R6,#32
        ADD     R7,R7,R9
        CMP     R7,#32
        SUBCS   R7,R7,#32
        STRCS   R14,[R3],#4
        MOVCS   R14,R0,LSR R10          ; R14 = rest of input word
        RSB     R9,R7,#32               ; R9 = no of bits to be carried over
        ;
        ; R14 = output word, R7 = no of valid bits, R1 --> input (from bit 0)
        ;
        TEQ     R5,#0
        BEQ     %FT05                   ; 1st word = last - we've finished!

        MOV     R6,#0
        SUBS    R5,R5,#1
        BEQ     %FT04                   ; middle section is null

        TEQ     R7,#0
        BNE     %FT02
01
        LDR     R14,[R1],#4             ; do this the quick way!
        STR     R14,[R3],#4
        SUBS    R5,R5,#1
        BNE     %BT01
        MOV     R14,#0                  ; no more bits remaining!
        B       %FT04
02
        LDR     R0,[R1],#4              ; R0 = input word - from bit 0
        ORR     R14,R14,R0,LSL R7
        STR     R14,[R3],#4
        MOV     R14,R0,LSR R9           ; R14 = remaining bits of R0
        SUBS    R5,R5,#1
        BNE     %BT02
        ;
        ; R1 --> final word of input, R3 --> next output word
        ; R14 = output word, R7 = no of valid bits, R6 = first valid bit in [R1]
        ;
04
        LDR     R0,[R1],#4              ; read final word
        MOV     R0,R0,LSR R6
        SUB     R8,R8,R6                ; no of bits used in R0
        ORR     R14,R14,R0,LSL R7
        ADD     R7,R7,R8
        CMP     R7,#32
        SUBCS   R7,R7,#32
        STRCS   R14,[R3],#4
        MOVCS   R14,R0,LSR R9
05
        TEQ     R7,#0                   ; avoid splattering next word of input
        STRNE   R14,[R3]                ; for next time

        Debug   ag,"Chunterrow exit R1,R3,R5-R8",R1,R3,R5,R6,R7,R8

        Pull    "R0,R5,R6,R8-R10,PC"


        ; Savespriteheader
        ;
        ; Entry:  R2 --> sprite definition
        ;         R3 --> where to put data
        ; Exit:   R5,R7-R11 = width,height,Lbit,Rbit,Image,Trans
        ;         also copied to [R3]
        ;         [R3,#header] = address of header block
        ;         [R3,#imagesize] = size of sprite image (excl. mask)
        ;
savespriteheader
        Push    "R2,LR"

        STR     R2,[R3,#sp1_header-sp1_data]
        LDR     R14,[R2],#spWidth
        LDMIA   R2,{R5,R7-R11}          ; width,height,Lbit,Rbit,Image,Trans
        STMIA   R3,{R5,R7-R11}
        Debug   ag,"Sprite header",R5,R7,R8,R9,R10,R11
        LDR     R14,[R1,#spNext]        ; Try & work out the image size
        TEQ     R10,R11                 ; Hang on, but is there a mask?
        LDRNE   R14,[R1,#spTrans]       ; Yes, so we have to work it out different
        SUB     R14,R14,R10             ; Convert the offset to a 'size'
        STR     R14,[R3,#sp1_imagesize-sp1_data]

        Pull    "R2,PC"

        ; Getspritewidth
        ;
        ; Entry:  R2 --> sprite defn
        ; Exit:   R3 = sprite width (bits)
        ;
getspritewidth
        Push    "LR"

        LDR     R14,[R2,#spLBit]
        LDR     R3,[R2,#spRBit]
        SUB     R3,R3,R14
        ADD     R3,R3,#1                ; make inclusive
        LDR     R14,[R2,#spWidth]
        ADD     R3,R3,R14,LSL #5        ; 32 bits per word
        Debug   ag,"Getspritewidth thinks the sprite width (bits) is",R3

        Pull    "PC"

        ; Swapblocks
        ;
        ; Entry:  R1 --> start of 1st block
        ;         R2 --> start of 2nd block (consecutive)
        ;         R3 --> end of 2nd block
        ; Exit:   blocks swapped over
        ;         R1 --> start of 1st block (after 2nd block)
        ;         R2 --> start of 2nd block
        ;
swapblocks
        Push    "R3,LR"

        Debug   mg,"Swap blocks: ",R1,R2,R3

        TEQ     R1,R2
        TEQNE   R2,R3                   ; Z set if either block is null
        SUB     R14,R3,R2               ; R14 = length of 2nd block
        MOV     R2,R1
        ADD     R1,R1,R14
        Pull    "R3,PC",EQ              ; ensure R1,R2 set up correctly on exit
        Push    "R1,R2"

        MOV     R1,R2
        MOV     R2,R3
        BL      reverseblock

        LDR     R2,[R13,#0*4]           ; reverse new 2nd block
        BL      reverseblock
        MOV     R1,R2
        LDR     R2,[R13,#2*4]           ; reverse new 1st block
        BL      reverseblock

        Pull    "R1-R3,PC"

        ; Reverse block
        ;
        ; Entry:  R1 --> start of block
        ;         R2 --> end of block (JUST AFTER)
        ; Exit:   block reversed (words)
        ;
reverseblock
        Push    "R1-R4,LR"
01
        CMP     R1,R2
        LDRCC   R3,[R1]
        LDRCC   R4,[R2,#-4]!
        STRCC   R3,[R2]
        STRCC   R4,[R1],#4
        BLT     %BT01

        Pull    "R1-R4,PC"

        ; Copyblock
        ;
        ; Entry:  R1 --> destination
        ;         R2 --> source
        ;         R3 = no of bytes (must be a whole number of words)
        ;
copyblock
        Debug   mg,"Copy block (to, from, count): ",R1,R2,R3

        TEQ     R1,R2           ; check for null copy
        TEQNE   R3,#0
        MOVEQ   PC,LR

        Push    "R1-R3,LR"

        CMP     R1,R2
        BCS     copyup
01
        LDR     R14,[R2],#4
        STR     R14,[R1],#4
        SUBS    R3,R3,#4
        BGT     %BT01

        Pull    "R1-R3,PC"

copyup
        ADD     R1,R1,R3
        ADD     R2,R2,R3
01
        LDR     R14,[R2,#-4]!
        STR     R14,[R1,#-4]!
        SUBS    R3,R3,#4
        BGT     %BT01

        Pull    "R1-R3,PC"

        ; Mergeblocks
        ;
        ; Entry:  R1,R2,R3 --> delimit 2 blocks (consecutive)
        ;         R4 = 0/1 (merge horizontally/vertically)
        ;
mergeblocks
        Debug   mg,"Merge blocks: ",R1,R2,R3

        TEQ     R4,#0
        MOVNE   PC,LR                   ; vertical merge

        Push    "R1-R3,R5-R6,LR"

        LDR     R5,sp1_width
        ADD     R5,R5,#1
        MOV     R5,R5,LSL #2            ; R5 = size of 1 row (bytes)
        LDR     R6,sp2_width
        ADD     R6,R6,#1
        MOV     R6,R6,LSL #2            ; R6 = size of 1 row (bytes)
01
        ADD     R1,R1,R5
        CMP     R1,R2
        BCS     %FT02                   ; no more to do
        ADD     R3,R2,R6
        BL      swapblocks
        ADD     R1,R2,R6
        MOV     R2,R3
        B       %BT01
02
        Pull    "R1-R3,R5-R6,PC"



        ; Maskmergeblocks
        ;
        ; Entry:  R1,R2,R3 --> delimit 2 blocks (consecutive)
        ;         R4 = 0/1 (merge horizontally/vertically)
        ;NOTE: Only called for new format sprites
        ;
maskmergeblocks
        Debug   mg,"Mask merge blocks: ",R1,R2,R3

        TEQ     R4,#0
        MOVNE   PC,LR                   ; vertical merge, so return

        Push    "R1-R3,R5-R6,R8,LR"

        LDR     R8,sp2_rbit
        LDR     R5,sp2_width
        BL      FindMaskWidth           ;Convert R5
        ADD     R6,R5,#1
        MOV     R6,R6,LSL #2            ; R6 = size of 1 row (bytes)
        Debug   ag,"Size of 1 row of sprite2 is (bytes)",R6
        LDR     R8,sp1_rbit
        LDR     R5,sp1_width
        BL      FindMaskWidth           ;Convert R5
        ADD     R5,R5,#1
        MOV     R5,R5,LSL #2            ; R5 = size of 1 row (bytes)
        Debug   ag,"Size of 1 row of sprite1 is (bytes)",R5
01
        ADD     R1,R1,R5
        CMP     R1,R2
        BCS     %FT02                   ; no more to do
        ADD     R3,R2,R6
        BL      swapblocks
        ADD     R1,R2,R6
        MOV     R2,R3
        B       %BT01
02
        Pull    "R1-R3,R5-R6,R8,PC"

        ; FindMaskWidth - convert spWidth for data to spWidth for mask (1bpp masks)
        ;
        ; NOTE: This routine should be similar to GetMaskspWidth in VduGrafH except it does
        ;       not return the updated PSR
        ;
        ;       Internal routine.
        ;
        ; in:   R5 = spWidth (ie width in words-1)
        ;       R8 = spRBit
        ;       sp_mode = sprite mode word
        ;
        ; out:  R5 = spWidth (words -1) for mask data
        ;       R8 = Last bit (spRBit) used in mask data
        ; should only be called for new format sprites, but will cope with old too
FindMaskWidth ROUT
        Push    "R0, LR"
        Debug   ag,"Entered GetMaskspWidth with R5,R8",R5,R8

        LDR     R0, sp_mode             ; fetch the sprite mode
        ANDS    LR, R0, #15<<27         ; isolate the sprite type and test for =0

        Pull    "R0, PC",EQ         ; if an old format sprite, return R5 unchanged

        TEQ     LR, #SpriteType_RISCOS5<<27
      [ NoARMT2
        ANDEQ   LR, R0, #127<<20
        MOVEQ   LR, LR, LSR #20
      |
        UBFXEQ  LR, R0, #20, #7
      ]
        MOVNE   LR, LR, LSR #27


        ; treat any T>max sprites as 32bpp
        CMP     LR, #SpriteType_RO5MAX
        MOVCS   LR, #SpriteType_Substitute

        TST     R0, #&80000000

        ; bugfix 9/8/93: get log2bpp this way
        ADRL    R0, NSM_bpptable
        LDRB    LR, [R0, LR]            ; get the log2bpp to LR

        RSB     R0, LR, #5              ; and change to 5-log2bpp

        MOV     R5, R5, LSL R0          ; width in pixels

        ADD     R0, R8, #1
        ADD     R5, R5, R0, LSR LR

        MOVNE   R5, R5, LSL #3          ; make 8 times wider if alpha mask

        ANDS    LR, R5, #&1F            ; fit exactly in a number of words ?
        SUB     R8, LR, #1              ; alter the last bit used for the mask data
                                        ; fix bug MED-01130....
        AND     R8, R8, #&1F            ; ....bring back into range 00-1F (may be -1 here)
        MOVNE   LR, #1                  ; if not, add an extra word
        ADD     R5, LR, R5, LSR #5      ; add the whole number of words
        SUB     R5, R5, #1              ; returns as words-1

        Debug   ag,"Left GetMaskspWidth with R5,R8",R5,R8

        Pull    "R0, PC"


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SpriteOp_CheckSpriteArea
; ------------------------
; Entry: R0 = reason code
;        R1 = areaCBptr
;        R10 & R11 stacked
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Go_CheckSpriteArea
        MOVS    r0, r0, LSR #8          ; system area sprites historically not checked
        MOVEQ   pc, lr

        Push    "r1-r5, lr"             ; 6 regs + r0/r10/r11 to mess with, total 9

        CheckAlignedAndSensible r1,%F99 ; at least need an aligned area to start with
        
        ASSERT  SpriteAreaCBsize = (4 * 4)
        LDMIA   r1, {r2-r5}
        Debug   so, "Read saEnd/saNumber/saFirst/saFree",r2,r3,r4,r5

        ORR     r14, r4, r5
        TST     r14, #3
        BNE     %FT99                   ; saFirst or saFree not word aligned

        CMP     r4, r5                  ; saFirst > saFree
        CMPLS   r5, r2                  ; saFree > saEnd
        BHI     %FT99 

        ADD     r11, r1, r5             ; abs address of end of used portion
        ADD     r10, r1, r2             ; abs address of end of entire area
        B       %FT40
10
        ; For each sprite, do the following checks
        Debug   so, "Contemplating sprite at",r1

        ADD     r0, r1, #SpriteCBsize
        CMP     r0, r11                 ; range check the header before reading from it
        BHI     %FT99
        Debug   so," + passed control block accessible"

        CheckAlignedAndWithin r1,spNext,r11,r0,%F99
        Debug   so," + passed spNext within used area test"

        CheckAlignedAndWithin r1,spImage,r10,r0,%F99
        Debug   so," + passed spImage within area test"

        CheckAlignedAndWithin r1,spTrans,r10,r0,%F99
        Debug   so," + passed spTrans within area test"

        LDR     r4, [r1, #spLBit]
        LDR     r0, [r1, #spRBit]
        ORR     r0, r0, r4
        CMP     r0, #32
        BCS     %FT99
        Debug   so," + passed LBit/RBit bit count test"

        LDR     r5, [r1, #spMode]
        ASSERT  SpriteType_Old = 0
        MOVS    r0, r5, LSR#27
        TEQNE   r4, #0
        BNE     %FT99
        Debug   so," + passed if new type sprite has LBit=0"

        LDR     r0, [r1, #spWidth]
        LDR     r4, [r1, #spHeight]
        ADD     r0, r0, #1
        MOV     r0, r0, LSL#2           ; width in bytes because bw = (ww + 1) x 4
        MLA     r4, r0, r4, r0          ; image bytes because bw x (h + 1) = (bw x h) + bw
        Debug   so," ...(w + 1) x (h + 1) in bytes",r4

        LDR     r0, [r1, #spImage]
        LDR     r2, [r1, #spTrans]
        TEQ     r0, r2                  ; check if there's a mask
        BEQ     %FT20
        Debug   so," ...has a mask"

        SUB     r14, r2, r0
        CMP     r14, r4
        BCC     %FT99
        Debug   so," + passed image space >= image size" 

        ASSERT  SpriteType_Old = 0
        ANDS    r14, r5, #15<<27
        BNE     %FT15
        Debug   so," ...type = MODE number",r5

        TST     r5,#&80000000
        BNE     %FT99
        Debug   so," + passed wide mask bit clear"

        LDR     r14, [r1, #spNext]
        SUB     r14, r14, r2
        CMP     r14, r4
        BCC     %FT99
        Debug   so," + passed mask space >= image size"

        SUB     r2, r2, r0
        TEQ     r2, r14
        BNE     %FT99
        Debug   so," + passed mask space = image space"
        B       %FT30
15
        TEQ     r14, #SpriteType_RISCOS5<<27
        BEQ     %FT18
        
        Debug   so," ...type = new sprite type",r5
        TST     r5, #1
        MOVNE   r14, r5, LSL#18
        MOVNES  r14, r14, LSR#19        ; horizontal dpi in bits 1-13
        MOVNE   r14, r5, LSL#5
        MOVNES  r14, r14, LSR#19        ; vertical dpi in bits 14-26
        BEQ     %FT99
        Debug   so," + mode b0=1 and non zero dpi"

        ADRL    r4, NSM_bpptable
        AND     r14, r5, #15<<27
        LDRB    r4, [r4, r14, LSR #27]
16
        Debug   so," ...log2bpp",r4
        LDR     r0, [r1, #spRBit]
        ADD     r0, r0, #1
        MOV     r0, r0, LSR r4          ; pixels_in_part_words = (spRBit + 1) >> log2bpp
        RSB     r14, r4, #5
        LDR     r4, [r1, #spWidth]
        MOV     r4, r4, LSL r14         ; pixels_in_whole_words = width << (5 - log2bpp)

        ADD     r14, r0, r4

        TST     r5, #&80000000
        MOVNE   r14, r14, LSL #3        ; convert for 8bpp mask

        ADD     r14, r14, #31
        BIC     r14, r14, #31           ; round up to nearest whole word
        MOV     r14, r14, LSR#3         ; convert to bytes since it's assumed 1bpp
        LDR     r0, [r1, #spHeight]
        MLA     r14, r0, r14, r14       ; bytes size = width * (height + 1)

        LDR     r0, [r1, #spNext]
        ADD     r2, r14, r2
        TEQ     r0, r2
        BNE     %FT99
        Debug   so," + image dimensions as 1bpp/8bpp mask = mask size of",r14
        B       %FT30
18
        Debug   so," ...type = RISC OS 5 type",r5
        EOR     r14, r5, #1
        TST     r5, #&F0000
        TSTNE   r14, #&F
        BNE     %FT99
        Debug   so," + passed xxx0xxx1 pattern check"

        ; TODO can check that colour space, etc. in modeflags agrees with sprite type

        AND     r14, r5, #127<<20
        CMP     r14, #SpriteType_RO5MAX<<20
        ADRL    r4, NSM_bpptable
        MOVGT   r14, #SpriteType_New32bpp<<20
        LDRB    r4, [r4, r14, LSR #20]
        B       %BT16

20
        Debug   so," ...has no mask"
        LDR     r14, [r1, #spNext]
        SUB     r14, r14, r0
        CMP     r14, r4
        BCC     %FT99
        Debug   so," + passed image space >= image size" 
30
        ; Next
        SUB     r3, r3, #1
        LDR     r4, [r1, #spNext]
40
        ADD     r1, r1, r4
        TEQ     r3, #0
        BNE     %BT10
        Debug   so, "Passed all checks"
        CLRV
        Pull    "r1-r5, pc"
99
        Debug   so, "There's something wrong with the sprite area"
        ADR     r0, ErrorBlock_BadData
        BL      copy_error_one          ; also sets V
        Pull    "r1-r5, pc"

        MakeSpriteErrorBlock BadData,,BadData

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SpriteOp_TileSpriteScaled
; ------------------------
; Entry: [spritecode] = reason code
;        R1 --> areaCBptr
;        R2 --> sprite name
;        R3,R4 = coords
;        R5 = plot action + flags
;        R6 --> scaling factors
;        R7 --> pixel translation table
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

tile_row        RN  R0
tile_col        RN  R1
tile_x0         RN  R2
tile_y0         RN  R3
tile_gwx0       RN  R4
tile_gwy0       RN  R5
tile_gwx1       RN  R6
tile_gwy1       RN  R7
tile_sprw       RN  R8
tile_sprh       RN  R9
tile_cols       RN  R10
tile_rows       RN  R11

; Reuse some registers
tile_colvis     RN  tile_gwx0
tile_rowvis     RN  tile_gwy0

        MACRO
        VisibleRange $out,$pos,$size,$start,$end
        ; Clamp to end of range
        SUB     $out,$end,$pos
        CMP     $out,$size
        MOVGT   $out,$size
        ; Clamp to beginning of range
        CMP     $pos,$start
        SUBLT   $out,$out,$start
        ADDLT   $out,$out,$pos
        ; Clamp to zero
        CMP     $out,#0
        MOVLT   $out,#0
        MEND

        MACRO
        RenderTileHere $spoffset
        ; Render a tile at tile_col, tile_row
        Push    "R0-R7"
        Debug   ti,"RenderTileHere",tile_col,tile_row
        MLA     R4,tile_row,tile_sprh,tile_y0
        MLA     R3,tile_col,tile_sprw,tile_x0
        ADD     R5,SP,#8*4 + $spoffset
        MOV     R0,#512+SpriteReason_PutSpriteScaled
        LDMIA   R5,{R1-R2}
        ADD     R5,R5,#2*4 + 5*4
        LDMIA   R5,{R5-R7}
        SWI     XOS_SpriteOp
        STRVS   R0,[SP]
        Pull    "R0-R7"
        MEND

        MACRO
$lab    DivRemS $ra,$rb,$rc,$tmp
$lab    CMP     $rb,#0
        BLT     %FT2
        DivRem  $ra,$rb,$rc,$tmp
        B       %FT4
2       RSB     $rb,$rb,#0
        DivRem  $ra,$rb,$rc,$tmp
        RSB     $rb,$rb,#0
        ; modulus should be -ve if divisor is -ve
4
        MEND

Go_TileSpriteScaled ROUT
        Push    "R0-R9,LR"
        Debug   ti,"TileSpriteScaled at ",r3,r4

        ; Find the sprite so that later operations are faster
        BL      findsprite
        Push    "R1-R2"

        ; Get the current graphics window
        BLVC    readvduvars

        ; Get sprite width & height
        MOVVC   R0,#SpriteReason_ReadSpriteSize+512
        SWIVC   XOS_SpriteOp
        BVS     %FT90

        ; Calculate rendered size in OS units
        LDR     R6,[SP,#(6+2)*4]
        CMP     R6,#0
        BEQ     %FT10
        BL      mulR4
        MOVS    R5,R4
        SUB     R6,R6,#4
        MOVLE   R5,#1 ; Avoid dangerous sizes
        MOV     R4,R3
        BL      mulR4
        MOVS    R3,R4
        MOV     R4,R5
        MOVLE   R3,#1
10
        LDR     R0,log2px
        LDR     R1,log2py
        MOV     tile_sprw,R3,LSL R0
        MOV     tile_sprh,R4,LSL R1

        ; Convert graphics window to OS units as well
        ADR     tile_gwx0, gwx0
        LDMIA   tile_gwx0, {tile_gwx0-tile_gwy1}
        MOV     tile_gwx0,tile_gwx0,LSL R0
        MOV     tile_gwy0,tile_gwy0,LSL R1
        ADD     tile_gwx1,tile_gwx1,#1 ; Make exclusive
        ADD     tile_gwy1,tile_gwy1,#1
        MOV     tile_gwx1,tile_gwx1,LSL R0
        MOV     tile_gwy1,tile_gwy1,LSL R1
        Debug   ti,"graphics window ",tile_gwx0,tile_gwy0,tile_gwx1,tile_gwy1
        Debug   ti,"sprite size ",tile_sprw,tile_sprh

        ; Compute position of first visible tile
        LDR     tile_x0,[SP,#(3+2)*4]
        LDR     tile_y0,[SP,#(4+2)*4]
        SUB     tile_x0,tile_x0,tile_gwx0
        SUB     tile_y0,tile_y0,tile_gwy0
        DivRemS R11,tile_x0,tile_sprw,LR
        DivRemS R11,tile_y0,tile_sprh,LR
        ADD     tile_x0,tile_x0,tile_gwx0
        ADD     tile_y0,tile_y0,tile_gwy0
        CMP     tile_x0,tile_gwx0
        SUBGT   tile_x0,tile_x0,tile_sprw
        CMP     tile_y0,tile_gwy0
        SUBGT   tile_y0,tile_y0,tile_sprh
        Debug   ti,"x0 y0 ",tile_x0,tile_y0

        ; Check options to see if this is an ordinary plot operation
        ; If we need GCOL actions, masking, dithering or blending then we can't accelerate it
        ; The only exception is masking, which we ignore the flag for if the sprite doesn't have a mask
        LDR     LR,[SP,#(5+2)*4]
        TST     LR,#8
        BEQ     %FT15
        ; Masking/blending requested. Check if the sprite actually has a mask or alpha channel.
        LDR     LR,[SP,#4] ; Grab sprite pointer
        LDR     R10,[LR,#spMode]
        ; Check for RISC OS 5 alpha channel sprites
        AND     R11,R10,#15<<27
        CMP     R11,#SpriteType_RISCOS5<<27
        ASSERT  ModeFlag_DataFormatFamily_RGB = 0
        TSTEQ   R10,#ModeFlag_DataFormatFamily_Mask
        BNE     %FT13 ; Not RISC OS 5 type, or not RGB
        TST     R10,#ModeFlag_DataFormatSub_Alpha
        BNE     %FT50
13
        ; Check for a mask
        LDR     R10,[LR,#spImage]
        LDR     R11,[LR,#spTrans]
        TEQ     R10,R11
        LDR     LR,[SP,#(5+2)*4]
        BICEQ   LR,LR,#8
15
        BICS    LR,LR,#(flg2_ignorettr+flg2_widetrans+flg2_colourmap)<<4 ; Check for known-good options to provide some protection against new ones being added which might cause problems
        BNE     %FT50

        ; Check to see if OS_Plot/GVRender_CopyRectangle is faster than us plotting the sprites manually
        ; Note - doesn't take into account screen output being redirected to sprite!
        ; For old OS versions without GraphicsV, we assume OS_Plot is slow
        ; (this'll certainly be the case for IOMD)
        Push    "R0-R2,R4,R9"
        SUB     SP,SP,#8
        ADRL    R0,vduinputbuffer_graphicsv
        MOV     R1,SP
        SWI     XOS_ReadVduVariables
        LDR     R4,[SP],#8
        MOV     R9,#GraphicsV
        MOV     R4,R4,LSL #24
        ORR     R4,R4,#GraphicsV_DisplayFeatures
        SWI     XOS_CallAVector
        TEQ     R4,#0
        ANDEQ   R4,R0,#GVDisplayFeature_CopyRectangleIsFast
        TEQ     R4,#GVDisplayFeature_CopyRectangleIsFast
        Pull    "R0-R2,R4,R9"
        BNE     %FT50

        ; Compute which of the first two rows will show the most of the sprite
        MOV     LR,tile_y0
        VisibleRange R10,LR,tile_sprh,tile_gwy0,tile_gwy1
        ADD     LR,tile_y0,tile_sprh
        VisibleRange R11,LR,tile_sprh,tile_gwy0,tile_gwy1
        CMP     R11,R10
        MOVLE   tile_row,#0
        MOVLE   tile_rowvis,R10
        MOVGT   tile_row,#1
        MOVGT   tile_rowvis,R11
        Debug   ti,"row 0 1 best",R10,R11,tile_row

        ; Do same for columns
        MOV     LR,tile_x0
        VisibleRange R10,LR,tile_sprw,tile_gwx0,tile_gwx1
        ADD     LR,tile_x0,tile_sprw
        VisibleRange R11,LR,tile_sprw,tile_gwx0,tile_gwx1
        CMP     R11,R10
        MOVLE   tile_col,#0
        MOVLE   tile_colvis,R10
        MOVGT   tile_col,#1
        MOVGT   tile_colvis,R11
        Debug   ti,"col 0 1 best",R10,R11,tile_col

        ; Render here
        RenderTileHere 0
        BVS     %FT90
        MOV     tile_rows,#1
        MOV     tile_cols,#1

        ; Duplicate across this row
        Debug   ti,"Duplicating across first row"
        BL      TileDuplicateRow

        ; Duplicate this row across all rows
        CMP     tile_rowvis,tile_sprh
        BGE     %FT20
        ; Tricky case, not all of sprite rows visible
        ; For now take the easy way out and render the other row manually
        SUB     LR,tile_gwy1,tile_y0
        CMP     LR,tile_sprh
        BLE     %FT90
        ; The other row exists
        RSB     tile_row,tile_row,#1
        RenderTileHere 0
        Debug   ti,"Duplicating across other row", tile_row
        BL      TileDuplicateRow
        B       %FT90

20
        ; All sprite rows visible on row tile_row
        ; Copy incrementally large blocks until done
        ADD     tile_cols,tile_cols,tile_col
        CMP     tile_row,#0
        MOV     tile_col,#0
        BEQ     %FT30
        ; Fill in the first row
        Debug   ti,"Copying to first row"
        MOV     tile_rows,#-1
        BL      TileVCopy
        BVS     %FT90
        ; Fall through...
30
        ; Fill in the remaining rows, including any partial end row
        Debug   ti,"Copying to remaining rows"
        MOV     tile_rows,#1
40
        ADD     LR,tile_row,tile_rows
        MLA     LR,tile_sprh,LR,tile_y0
        CMP     LR,tile_gwy1
        BGE     %FT90
        BL      TileVCopy
        MOVVC   tile_rows,tile_rows,LSL #1
        BVC     %BT40
        ; Fall through...
90
        Debug   ti,"Done"
        ADD     SP,SP,#8
        Pull    "R1"
        STR     R1,spritecode
        Pull    "R1-R9,PC"

50
        Debug   ti,"Plot operation incompatible with acceleration, rendering manually"
        ; At this point, tile_x0 and tile_y0 are the correct coords to start from,
        ; tile_sprw, tile_sprh are the sprite size, and tile_gwx1 and tile_gwy1
        ; can be used to check the end position
        ; Shuffle things around into more useful registers
        MOV     R10,tile_gwx1
        MOV     R11,tile_gwy1
        Push    "tile_x0"
        MOV     R4,tile_y0
        ; Grab OS_SpriteOp params
        LDMIB   SP,{R1-R2}
        ADD     R0,SP,#12+5*4
        LDMIA   R0,{R5-R7}
        MOV     R0,#512+SpriteReason_PutSpriteScaled
60
        LDR     R3,[SP]
70
        Debug   ti,"Manual tile at ",R3,R4
        SWI     XOS_SpriteOp
        ADDVS   SP,SP,#4
        BVS     %BT90
        ADD     R3,R3,tile_sprw
        CMP     R3,R10
        BLT     %BT70
        ADD     R4,R4,tile_sprh
        CMP     R4,R11
        BLT     %BT60
        ADD     SP,SP,#4
        B       %BT90



TileDuplicateRow ROUT
        Entry
        CMP     tile_colvis,tile_sprw
        BGE     %FT20
        ; Tricky case, not all of sprite cols visible
        ; For now take the easy way out and render the other column manually
        SUB     LR,tile_gwx1,tile_x0
        CMP     LR,tile_sprw
        BLE     %FT90
        ; The other column exists
        RSB     tile_col,tile_col,#1
        Debug   ti,"Duplicating across other column", tile_col
        RenderTileHere 4
        RSB     tile_col,tile_col,#1
        MOV     tile_cols,#2
10
        B       %FT90

20
        ; All sprite columns visible on column tile_col
        ; Copy incrementally large blocks until done
        CMP     tile_col,#0
        BEQ     %FT30
        ; Fill in the first column
        Debug   ti,"Copying to first column"
        MOV     tile_cols,#-1
        BL      TileHCopy
        BVS     %FT90
        ; Fall through...
30
        ; Fill in the remaining columns, including any partial end column
        Debug   ti,"Copying to remaining columns"
        MOV     tile_cols,#1
40
        ADD     LR,tile_col,tile_cols
        MLA     LR,tile_sprw,LR,tile_x0
        CMP     LR,tile_gwx1
        BGE     %FT90
        BL      TileHCopy
        MOVVC   tile_cols,tile_cols,LSL #1
        BVC     %BT40
        ; Fall through...
90        
        EXIT

TileVCopy ROUT
        ; Copy tiles from tile_col,tile_row vertically
        ; Copied area is tile_cols by ABS(tile_rows) in size
        ; Copy destination is at row tile_row + tile_rows
        ASSERT  R2 = tile_x0
        Entry   "R0-R1,tile_x0,tile_y0,tile_gwx0,tile_gwy0,tile_rows,tile_cols"
        Debug   ti,"TileVCopy",tile_col,tile_row,tile_cols,tile_rows
        ; Calculate src coords in tile_x0, tile_y0
        MLA     tile_x0,tile_col,tile_sprw,tile_x0
        MLA     tile_y0,tile_row,tile_sprh,tile_y0
        ; Calculate dest coords in tile_gwx0, tile_gwy0
        MOV     tile_gwx0,tile_x0
        MLA     tile_gwy0,tile_rows,tile_sprh,tile_y0
        ; Calculate size in tile_rows, tile_cols
        CMP     tile_rows,#0
        RSBLT   tile_rows,tile_rows,#0
        B       TileCopyCommon

TileHCopy ALTENTRY
        ; Copy tiles from tile_col,tile_row horizontally
        ; Copied area is ABS(tile_cols) by tile_rows in size
        ; Copy destination is at column tile_col + tile_cols
        Debug   ti,"TileHCopy",tile_col,tile_row,tile_cols,tile_rows
        ; Calculate src coords in tile_x0, tile_y0
        MLA     tile_x0,tile_col,tile_sprw,tile_x0
        MLA     tile_y0,tile_row,tile_sprh,tile_y0
        ; Calculate dest coords in tile_gwx0, tile_gwy0
        MLA     tile_gwx0,tile_cols,tile_sprw,tile_x0
        MOV     tile_gwy0,tile_y0
        ; Calculate size in tile_rows, tile_cols
        CMP     tile_cols,#0
        RSBLT   tile_cols,tile_cols,#0
        ; Fall through...

TileCopyCommon
        ; Copy rectangle from tile_x0, tile_y0 to tile_gwx0, tile_gwy0
        ; Rectangle size is tile_cols*tile_sprw, tile_rows*tile_sprh
        Debug   ti,"TileCopyCommon",tile_x0,tile_y0,tile_gwx0,tile_gwy0,tile_cols,tile_rows
        MOV     R0,#184+4
        MOV     R1,tile_x0
        MOV     R2,tile_y0
        SWI     XOS_Plot
        MOVVC   LR,#-1
        MOVVC   R0,#184+0
        MLAVC   R1,tile_cols,tile_sprw,LR
        MLAVC   R2,tile_rows,tile_sprh,LR
        SWIVC   XOS_Plot
        MOVVC   R0,#184+6
        MOVVC   R1,tile_gwx0
        MOVVC   R2,tile_gwy0
        SWIVC   XOS_Plot
        STRVS   R0,[SP]
        EXIT

vduinputbuffer_graphicsv
        DCD     VduExt_CurrentGraphicsVDriver
        DCD     -1

        END
        