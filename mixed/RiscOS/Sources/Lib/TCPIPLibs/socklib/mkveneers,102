#!/usr/bin/env perl
#
# This source code in this file is licensed to You by Castle Technology
# Limited ("Castle") and its licensors on contractual terms and conditions
# ("Licence") which entitle you freely to modify and/or to distribute this
# source code subject to Your compliance with the terms of the Licence.
# 
# This source code has been made available to You without any warranties
# whatsoever. Consequently, Your use, modification and distribution of this
# source code is entirely at Your own risk and neither Castle, its licensors
# nor any other person who has contributed to this source code shall be
# liable to You for any loss or damage which You may suffer as a result of
# Your use, modification or distribution of this source code.
# 
# Full details of Your rights and obligations are set out in the Licence.
# You should have received a copy of the Licence with this source code file.
# If You have not received a copy, the text of the Licence is available
# online at www.castle-technology.co.uk/riscosbaselicence.htm
# 

require 'ctime.pl';

my $script = $0;
$script  =~ s/^.*[\/:]//;
$usage = "usage: $script <protofile>\n";

my ($protofile) = @ARGV;
die($usage) unless $protofile;

open(PROTO,'<'.$protofile) or failed("Can't open $protofile for input\n");

$line=0;
while (<PROTO>) {
  $line++;
  if(/^#/) {
    next;
  }
  if(/^(\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/) {
    my($function,$swi,$args,$result,$filename) = ($1,$2,$3,$4,$5);
    &build_asm("sn.$filename",$function,$swi,$args,$result,0);
    &build_asm("sz.$filename",$function,$swi,$args,$result,1);
  } elsif(/^(\S+)\s+(\S+)\s+(\d+)\s+(\d+)/) {
    my($function,$swi,$args,$result) = ($1,$2,$3,$4);
    &build_asm("sn.$function",$function,$swi,$args,$result,0);
    &build_asm("sz.$function",$function,$swi,$args,$result,1);
  } else {
    failed("Syntax error at line $line\n");
  }
}

exit 0;

sub build_asm {
  my($filename,$function,$swi,$args,$result,$module) = ($_[0],$_[1],$_[2],$_[3],$_[4],$_[5]);
  my $bigframe=0;
  my $extraregs;

  if($args <= 4) {
    $extraregs="";
  } elsif($args == 5) {
    $extraregs="v1,";
  } else {
    $extraregs="v1-v".($args-4).",";
  }

  open(OUT,'>'.$filename) or failed("Unable to open $filename for output\n");

  # A few opening comments
  printf(OUT ";\n");
  printf(OUT "; %s\n", $filename);
  printf(OUT ";\n");
  printf(OUT "; Generated by mkveneers on %s",&ctime(time));
  printf(OUT ";\n\n");

  # Get the definitions for OS_EnterOS and the other SWIs 
  printf(OUT "\tGET\tHdr:ListOpts\n");
  printf(OUT "\tGET\tHdr:Macros\n");
  printf(OUT "\tGET\tHdr:System\n");
  printf(OUT "\tGET\thdr.InetSWIs\n\n");

  printf(OUT "\tAREA\tSockLib,CODE,READONLY\n\n");

#  if (!module)
#      printf(OUT "\tIMPORT\t__rt_stkovf_split_small\n");

  printf(OUT "\tIMPORT\t_copyerror\n");
  printf(OUT "\tEXPORT\t%s\n", $function);

  # Put in the function name a la CC's -fn option
  if (!$module) {
    printf(OUT "\n\t= \"%s\", 0\n", $function);
    printf(OUT "\tALIGN\n");
    printf(OUT "\t& &FF0000%02X\n", (length($function)+1+3)&~3);
  }

  printf(OUT "%s\n", $function);

  # The APCS entry (yum!)
  printf(OUT "\tMOV\tip,sp\n");
  if (!$module && $args>0) {
    if ($args > 4) {
      printf(OUT "\tSTMDB\tsp!,{a1-a4}\n");
      printf(OUT "\tSTMDB\tsp!,{%sfp,ip,lr,pc}\n", $extraregs);
      $bigframe=1;
    } elsif ($args >=2 && $args <=4) {
      printf(OUT "\tSTMDB\tsp!,{a1-a%d,fp,ip,lr,pc}\n", $args);
    } elsif ($args == 1) {
      printf(OUT "\tSTMDB\tsp!,{a1,fp,ip,lr,pc}\n");
    }
  } else {
    printf(OUT "\tSTMDB\tsp!,{%sfp,ip,lr,pc}\n", $extraregs);
  }

  printf(OUT "\tSUB\tfp,ip,#%d\n", $bigframe ? 20 : 4);

  if (!$module) {
      # Stack limit checking
      # (Don't bother because _copyerror doesn't really use much stack - we
      #  know we had 256 bytes on entry)
#      printf(OUT "\tCMPS\tsp,sl\n");
#      printf(OUT "\tBLLT\t__rt_stkovf_split_small\n");
  }

  # Load any extra registers after the first four
  # (This is not the customary way to do it - one normally references via fp
  # but we know ip is unaltered since entry)
  if ($args == 5) {
    printf(OUT "\tLDR\tv1,[ip]\n");
  } elsif ($args >= 6) {
    printf(OUT "\tLDMIA\tip,{v1-v%d}\n", $args-4);
  }

#  #ifdef SVC_SWIS
#  if (!module)
#  {
#      /* Enter SVC mode, to prevent any callbacks going off as the SWI
#         returns (which could call the Internet module, corrupting the
#         error block before we read it!) */
#      printf(OUT "\tSWI\tOS_EnterOS\n");
#  }
#  #endif

  # Call the SWI
  printf(OUT "\tSWI\tX%s\n", $swi);

  # If an error, call _copyerror (which returns -1)
  printf(OUT "\tBLVS\t_copyerror\n");

#  #ifdef SVC_SWIS
#  if (!module)
#  {
#      /* Return to USR mode */
#      printf(OUT "\tTEQP\tpc,#0\n");
#      /* A NOP - we can't access sp or lr on the next instruction */
#      printf(OUT "\tNOP\n");
#  }
#  #endif

  # And return (returning either R0 from the SWI, or -1 if an error
  printf(OUT "\t[ {CONFIG}=26\n");
  printf(OUT "\tLDMDB\tfp,{%sfp,sp,pc}^\n", $extraregs);
  printf(OUT "\t|\n");
  printf(OUT "\tLDMDB\tfp,{%sfp,sp,pc}\n", $extraregs);
  printf(OUT "\t]\n\n");

  printf(OUT "\tEND\n");

  close(OUT);
}
  

#############################################################################
# Wrap things up neatly.
#
sub failed {
  printf(STDERR "$script: $_[0] failed: $!\n");
  exit 1;
};

