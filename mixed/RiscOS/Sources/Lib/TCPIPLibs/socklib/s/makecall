; This source code in this file is licensed to You by Castle Technology
; Limited ("Castle") and its licensors on contractual terms and conditions
; ("Licence") which entitle you freely to modify and/or to distribute this
; source code subject to Your compliance with the terms of the Licence.
; 
; This source code has been made available to You without any warranties
; whatsoever. Consequently, Your use, modification and distribution of this
; source code is entirely at Your own risk and neither Castle, its licensors
; nor any other person who has contributed to this source code shall be
; liable to You for any loss or damage which You may suffer as a result of
; Your use, modification or distribution of this source code.
; 
; Full details of Your rights and obligations are set out in the Licence.
; You should have received a copy of the Licence with this source code file.
; If You have not received a copy, the text of the Licence is available
; online at www.castle-technology.co.uk/riscosbaselicence.htm
; 
; -*-As-*-
;
; $Header: /dev/fd/8/mixed/RiscOS/Sources/Lib/TCPIPLibs/socklib/s/makecall,v 4.2 1999/12/02 16:19:11 sbrodie Exp $
; $Source: /dev/fd/8/mixed/RiscOS/Sources/Lib/TCPIPLibs/socklib/s/makecall,v $
;
; Copyright (c) 1995 Acorn Computers Ltd., Cambridge, UK
;
; makecall.s - based upon code generated by Norcroft RISC OS ARM C
;              vsn 5.06 (Acorn Computers Ltd) [Jun 26 1995]
;
; :RCS Log discontinued:
;
; Revision 1.2  96/03/19  10:21:34  kbracey
; Merged the two variants into a single source file
; Nasty -zM relocation bug fixed.
;
; Revision 1.1  95/08/17  18:41:56  kwelton
; Initial revision
;

	GET	Hdr:ListOpts
	GET 	Hdr:Macros
	GET 	Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:APCS.<APCS>

ESRCH	*	3
EREMOTE *	71

	; If "module" is not predefined on the command line, declare it
	; here (it defaults to {FALSE})
	[ :LNOT::DEF:module
	GBLL	module
	]

	AREA	|As$$code|, CODE, READONLY

	[ :LNOT:module
	IMPORT	__rt_stkovf_split_small
	]
	IMPORT	_kernel_swi

;
; **********************************************************************
;
; makecall - call the Internet module, and deal with the return value
;
; int _makecall(int swinum, _kernel_swi_regs *in, _kernel_swi_regs *out)
;

	[ :LNOT:module
;
; this is "_makecall", for the benefit of stack backtracing
;
	= "_makecall", 0, 0, 0        ; Be careful when changing length!
	DCD	&ff00000c

	]

	EXPORT	_makecall
_makecall
	[ module
	MOV	ip, sp
	STMDB	sp!, {v1-v3, fp, ip, lr, pc}
	SUB	fp, ip, #4
	|
	MOV	ip, sp
	STMDB	sp!, {a1-a4}
	STMDB	sp!, {v1-v3, fp, ip, lr, pc}
	SUB	fp, ip, #20
;
; stack limit checking
;
	CMPS	 sp, sl
	BLLT	 __rt_stkovf_split_small
;
; by making the call to the Internet module
; from SVC mode, we can make sure that no callbacks go off between
; detecting an error and copying the error block into _inet_error.
;
	SWI	OS_EnterOS
	]

;
; make the SWI call, result into v3, setting Z flag in the process
;
	MOV	v1, a3
	BL	_kernel_swi
	MOVS	v3, a1

	LDR	lr, adrerrno
	[ module
	LDR	ip, [sl, #-536]
	ADD	lr, ip, lr
	]
	MOVEQ	a1, #0
	STREQ	a1, [lr]
	BEQ	OKreturn

;
; SWI call failed - fill in errno, and copy error block into _inet_error
; first step is to read the error number, and decide whether it is a
; properly formatted inet error (inet errorblock should start at 0x20e00,
; but it currently starts at 0 because of all the applications out there
; that expect this to be the case).
;
	LDR	a1, [v3, #0]
	BIC	a2, a1, #&ff
	SUB	a4, a2, #&20c00
	TEQ	a4, #&200
	BNE	noerrblock

;
; using inet error block: offsets 0-7f should be converted to an errno
; style number, other errors should be left alone.
;
	AND	a2, a1, #&ff
	CMP	a2, #&80
	ANDLT	a1, a1, #&7f

noerrblock
	CMPS	a1, #EREMOTE
	MOVGT	a1, #ESRCH

	STR	a1, [lr]        ; place error number into errno

;
; copy error block into _inet_error which is 256 bytes long
;
	LDR	v2, adr_inet_error
	[ module
	ADD	v2, ip, v2
	]
	MOV	ip, #16				; 16*(4*4)=256

0	LDMIA	v3!, {a2-a4,v1}
	STMIA	v2!, {a2-a4,v1}
	SUBS	ip, ip, #1
	BNE	%B0

	[ :LNOT:module
;
; back to user mode before returning error to caller
;
        [ {CONFIG}=26
        TEQP    pc, #0
        |
        MRS     a1, CPSR
        BIC     a1, a1, #15
        MSR     CPSR_c, a1
        ]
	]

	MVN	a1, #0				; non-banked register: OK
        [ {CONFIG}=26
	LDMDB	fp, {v1-v3, fp, sp, pc}^        ; return -1
        |
	LDMDB	fp, {v1-v3, fp, sp, pc}         ; return -1
        ]

;
; back to user mode before returning to caller
;
OKreturn
	[ :LNOT:module
        [ {CONFIG}=26
        TEQP    pc, #0
        |
        MRS     a1, CPSR
        BIC     a1, a1, #15
        MSR     CPSR_c, a1
        ]
	]
	LDR	a1, [v1, #0]			; non-banked registers: OK
        [ {CONFIG}=26
	LDMDB	fp, {v1-v3, fp, sp, pc}^        ; return R0 from SWI
        |
	LDMDB	fp, {v1-v3, fp, sp, pc}         ; return R0 from SWI
        ]

adrerrno
	IMPORT	errno
	DCD	errno
adr_inet_error
	IMPORT	_inet_error
	DCD	_inet_error

	END

; EOF makecall.s
