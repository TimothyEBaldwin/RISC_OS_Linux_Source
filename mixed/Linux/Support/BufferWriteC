REM    BufferWriteC

REM  This program stops output line being intermingled
REM  by character when doing parallel builds.

REM  Copyright (c) 2013, Timothy Baldwin
REM  All rights reserved.
REM
REM  Redistribution and use in source and binary forms, with or without
REM  modification, are permitted provided that the following conditions are met:
REM      * Redistributions of source code must retain the above copyright
REM        notice, this list of conditions and the following disclaimer.
REM      * Redistributions in binary form must reproduce the above copyright
REM        notice, this list of conditions and the following disclaimer in the
REM        documentation and/or other materials provided with the distribution.
REM      * Neither the name of RISC OS Open Ltd nor the names of its contributors
REM        may be used to endorse or promote products derived from this software
REM        without specific prior written permission.
REM
REM  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
REM  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
REM  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
REM  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
REM  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
REM  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
REM  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
REM  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
REM  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
REM  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
REM  POSSIBILITY OF SUCH DAMAGE.

code_size% = 1024

REM Allocate memory from Module Area
SYS "OS_Module",6,,,code_size% TO ,,code%

FOR opt% = 0 TO 2 STEP 2
P%=code%
[OPT opt%

.vector_handler%
stmfd   sp!, {r0, r1, r2, lr}

; Check for redirection
mvn     r0, #0
mvn     r1, #0
swi     "OS_ChangeRedirection"
teq     r1, #0
ldmnefd sp!, {r0, r1, r2, pc}

; Reload r0
ldr     r0, [sp], #4

; Add to line buffer
adr     r1, line%
ldr     r2, index%
strb    r0, [r1, r2]

teq     r0, #13 ; EOL?
addne   r2, r2, #1
teqne   r0, #10 ; EOL?
teqne   r2, #code_size%-(line%-code%) ; Too large?
str     r2, index%
ldmnefd sp!, {r1, r2, lr, pc}

; Empty buffer?
teq     r2, #0
ldmeqfd sp!, {r1, r2, lr, pc}

stmfd   sp!, {r0, r3, r4, r7}

; Write to linux standard output
mov     r0, #1
mov     r7, #4
swi     "IXSupport_LinuxSyscall"

; Check for *Spool file
mov     r0, #199
mov     r1, #0
mvn     r2, #0
swi     "OS_Byte"
teq     r1, #0

; Reload and zero index pointer
ldr     r3, index%
mov     r4, #0
str     r4, index%

; Write to *Spool file
mov     r0, #2
adr     r2, line%
swine   "OS_GBPB"

; Return
msr     cpsr_f, #0
ldmfd   sp!, {r0, r3, r4, r7}
ldmfd   sp!, {r1, r2, lr, pc}

.index%
dcd     0

.line%

]:NEXT

REM Claim Wrchv
PRINT '"Installing BufferWriteC, RISC OS screen disabled.";
SYS "OS_Claim",3,vector_handler%,0
SYS "OS_RemoveCursors"
PRINT "..done"'
