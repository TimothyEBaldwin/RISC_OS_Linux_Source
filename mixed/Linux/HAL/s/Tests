;
; Copyright (c) 2013, Timothy Baldwin
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:LinuxSyscalls

PVirt   SETA    PVSys
        PVOpsImports

        IMPORT  init_vcpu
        IMPORT  interrupt_count

        AREA    Tests, CODE, READONLY
crash   UND

        MACRO
        CheckRegs
        TEQ     r0, #33
        TEQEQ   r1, #2
        TEQEQ   r2, #3
        TEQEQ   r3, #4
        TEQEQ   r4, #5
        BNE     crash
        MEND

pdot    STMFD   sp!, {r0-r8, lr}
        MOV     r0, #2
        ADR     r1, dot
        MOV     r2, #1
        MOV     r7, #__NR_write
        BL      __PVirt_syscall
        LDMFD   sp!, {r0-r8, lr}
        MOV     pc, r9
dot     DCB     "."
        ALIGN

        MACRO
        CheckMode       $mode
        CheckRegs
        pvMRS   r7, CPSR
        CheckRegs
        AND     r7, r7, #0xFF
        TEQ     r7, #$mode
        ;TEQEQ  lr, #$mode
        BNE     crash
        MOV     r9, pc
        B       pdot
        MEND

        EXPORT  test_pvirt
test_pvirt
        STMFD   sp!, {r4-r12, lr}

        LDR     r5, =init_vcpu + vcpu_irq_pending
        MOV     r6, #0

test_loop
        MOV     r0, #33
        MOV     r1, #2
        MOV     r2, #3
        MOV     r3, #4
        MOV     r4, #5
        MOV     lr, #SVC32_mode
        CheckMode SVC32_mode

        STRB    r6, [r5]
        pvMSR   CPSR_c, #FIQ32_mode
        CheckMode FIQ32_mode

        STRB    r6, [r5]
        SWI     OS_EnterOS
        CheckMode SVC32_mode

        STRB    r6, [r5]
        pvMSR   CPSR_c, #USR32_mode
        CheckMode USR32_mode

        STRB    r6, [r5]
        pvMSR   CPSR_c, #USR32_mode
        CheckMode USR32_mode

        STRB    r6, [r5]
        pvMSR   CPSR_c, #SVC32_mode
        CheckMode USR32_mode

        STRB    r6, [r5]
        SWI     OS_EnterOS
        CheckMode SVC32_mode

        STRB    r6, [r5]
        pvMSR   CPSR_c, #IRQ32_mode
        CheckMode IRQ32_mode

        STRB    r6, [r5]
        SWI     OS_EnterOS
        CheckMode SVC32_mode

        STRB    r6, [r5]
        pvMSR   CPSR_c, #USR32_mode
        CheckMode USR32_mode

        STRB    r6, [r5]
        SWI     OS_EnterOS
        CheckMode SVC32_mode

        STRB    r6, [r5]
        pvMSR   CPSR_c, #SYS32_mode
        CheckMode SYS32_mode

        STRB    r6, [r5]
        pvMSR   CPSR_c, #IRQ32_mode
        CheckMode IRQ32_mode

        STRB    r6, [r5]
        pvMSR   CPSR_c, #IRQ32_mode | I32_bit
        MOV     lr, #IRQ32_mode
        CheckMode IRQ32_mode | I32_bit

        STRB    r6, [r5]
        pvMSR   CPSR_c, #SVC32_mode
        CheckMode SVC32_mode

        MOV     r0, #10
        SWI     0

        EORS    r6, r6, #I32_bit
        BNE     test_loop

        LDMFD   sp!, {r4-r12, pc}

        LTORG

swi_routine
        STMFD   sp!, {r0-r2, r7, lr}
        LDR     r0, [lr, #-4]
        BICS    r0, r0, #0xFF000000
        TEQ     r0, #OS_EnterOS
        BEQ     os_enteros
        TEQ     r0, #0
        BNE     crash
        MOV     r0, #2
        MOV     r1, sp
        MOV     r2, #1
        MOV     r7, #__NR_write
        BL      __PVirt_syscall
swi_exit
        LDMFD   sp!, {r0-r2, r7, lr}
        MOVS_PC_LR

os_enteros
        pvMRS   r0, SPSR
        BIC     r0, r0, #M32_bits
        ORR     r0, r0, #SVC32_mode
        pvMSR   SPSR_cxsf, r0
        B       swi_exit

irq_handler
        SUB     lr, lr, #4
        STMFD   sp!, {r0, r1}
        LDR     r1, =interrupt_count
        LDR     r0, [r1]
        ADD     r0, r0, #1
        STR     r0, [r1]
        MOV     r0, #0
        LDR     r1, =init_vcpu + vcpu_irq_pending
        STRB    r0, [r1]
        LDMFD   sp!, {r0, r1}
        MOVS_PC_LR

und_skip
	; Skip undefined instructions, this is used in kernel of testing CPU features
	ADD	lr, lr, #4
	MOVS_PC_LR

        EXPORT  test_vectors
test_vectors
        DCD     und_skip
        DCD     swi_routine
        DCD     0
        DCD     0
        DCD     0
        DCD     irq_handler



        END
