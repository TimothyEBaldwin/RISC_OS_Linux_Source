;
; Copyright (c) 2013, Timothy Baldwin
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        GET     Hdr:HALSize.<HALSize>
        GET     Hdr:HALEntries
        GET     Hdr:LinuxSyscalls

        AREA |HEAD|, CODE, READONLY

        IMPORT  do_ptrace
        IMPORT  main

        EXPORT  HAL_Header
        EXPORT  __PVirt_LinuxSyscall
        EXPORT  __main
        EXPORT  __rt_udiv10
        EXPORT  __rt_udiv
        EXPORT  ptrace_swi_jump
        EXPORT  signal_exit
        EXPORT  start_ptrace
        EXPORT  image_start

image_start
        DCB     &7F, "ELF"
        DCB     1       ; 32 bits
        DCB     1       ; Two's complement, little-endian
        DCB     1       ; ELF Version
        DCB     3       ; Linux ABI
        DCB     0       ; ABI Version
        %       7       ; Unused padding
        DCW     2       ; This is an executable
        DCW     40      ; ARM
        DCD     1       ; EV_CURRENT - Current file version, not invalid.

        DCD     entry                           ; Start address
        DCD     program_headers - image_start   ; Offset to program headers
        DCD     section_headers - image_start   ; Offset to section headers (none)
 [ SupportARMv8
        DCD     0x5000400                       ; Flags - Version5 EABI, hard-float ABI
 |
        DCD     0x80                            ; Flags - uses classic GNU EABI
 ]
        DCW     header_end - image_start        ; Size of ELF header
        DCW     32                              ; Size of program headers
        DCW     (program_headers_end -  program_headers) / 32
        DCW     40                              ; Size of section headers
        DCW     (section_headers_end -  section_headers) / 40
        DCW     1                               ; Section header string table index
header_end

        ; Once set up by the code in main(), only the SWI instruction at
        ;  __PVirt_LinuxSyscall will execute Linux system calls. SWI instructions
        ; elsewhere will call the RISC OS SWI handler, or a tempoary handler
        ; in this HAL.
signal_exit
        MOV     r7, #__NR_rt_sigreturn
__PVirt_LinuxSyscall
        SWI     0
        myBX    lr

program_headers
        DCD     1                                      ; PT_LOAD
        DCD     0                                      ; Offset
        DCD     image_start                            ; Load address
        DCD     0                                      ; Physical address unused
        DCD     |!!rwbase| - ADDRESS                    ; File size
        DCD     |!!rwbase| - ADDRESS                    ; Memory size
        DCD     5                                      ; Readable and executable
        DCD     0x1000                                 ; Alignment

        DCD     1                                      ; PT_LOAD
        DCD     |!!rwbase| - ADDRESS                    ; Offset
        DCD     |!!rwbase|                              ; Load address
        DCD     0                                      ; Physical address unused
        DCD     OSROM_HALSize                          ; File size (adjusted after link)
        DCD     OSROM_HALSize + ADDRESS                ; Memory size (adjusted after link)
        DCD     6                                      ; Readable and writable
        DCD     0x1000                                 ; Alignment

        DCD     1                                      ; PT_LOAD
        DCD     OSROM_HALSize                          ; Offset
        DCD     image_start + OSROM_HALSize            ; Load address
        DCD     0                                      ; Physical address unused
        DCD     OSROM_ImageSize * 1024 - OSROM_HALSize ; File size
        DCD     OSROM_ImageSize * 1024 - OSROM_HALSize ; Memory size
        DCD     5                                      ; Readable and executable
        DCD     0x1000                                 ; Alignment

        ; This magic program header enables readable and non-executable memory.
        DCD     0x6474e551                             ; PT_GNU_STACK
        DCD     0, 0, 0, 0, 0
        DCD     6                                      ; Readable and writable
        DCD     16                                     ; Alignment
program_headers_end

section_headers
        SPACE   40
        DCD     %FT10 - strings        ; Name
        DCD     3                      ; SHT_STRTAB
        DCD     0
        DCD     0                      ; Address
        DCD     strings - image_start  ; Offset
        DCD     strings_end - strings
        DCD     0, 0
        DCD     1                      ; Alignment
        DCD     0

        DCD     %FT20 - strings        ; Name
        DCD     1                      ; SHT_PROGBITS
        DCD     6                      ; Loaded and executable
        DCD     image_start            ; Address
        DCD     0                      ; Offset
        DCD     OSROM_ImageSize * 1024
        DCD     0, 0
        DCD     16                     ; Alignment
        DCD     0
section_headers_end

strings DCB     0
10      DCB     ".strtab", 0
20      DCB     ".text", 0
strings_end
        ALIGN

        GBLA    max
max     SETA    0

        MACRO
        H       $name
        LCLA    t
t       SETA    EntryNo_$name
        GBLS    ent_$t
ent_$t  SETS    "$name"
        IF t > max
max       SETA t
        ENDIF
        MEND

        H       HAL_ControllerAddress
        H       HAL_CounterDelay
        H       HAL_CounterPeriod
        H       HAL_CounterRate
        H       HAL_CounterRead
        H       HAL_DebugRX
        H       HAL_DebugTX
        H       HAL_IICBuses
        H       HAL_IRQClear
        H       HAL_IRQDisable
        H       HAL_IRQEnable
        H       HAL_IRQMax
        H       HAL_IRQSource
        H       HAL_IRQStatus
        H       HAL_InitDevices
        H       HAL_KbdScanDependencies
        H       HAL_NVMemoryPageSize
        H       HAL_NVMemoryProtectedSize
        H       HAL_NVMemoryRead
        H       HAL_NVMemorySize
        H       HAL_NVMemoryType
        H       HAL_NVMemoryWrite
        H       HAL_PlatformInfo
        H       HAL_Reset
        H       HAL_TimerDevice
        H       HAL_TimerGranularity
        H       HAL_TimerMaxPeriod
        H       HAL_TimerPeriod
        H       HAL_TimerReadCountdown
        H       HAL_TimerSetPeriod

HAL_Header
        DCD     0
        DCD     image_start - HAL_Header
        DCD     OSROM_HALSize
        DCD     HAL_EntryTable - HAL_Header
        DCD     max + 1
        DCD     0 ; No workspace

HAL_EntryTable
        GBLA    i
        GBLS    name
i       SETA    0
        WHILE i <= max
          IF :DEF:ent_$i
name        SETS ent_$i
            IMPORT $name
            DCD $name - HAL_EntryTable
          ELSE
            DCD null_entry - HAL_EntryTable
          ENDIF
i         SETA i + 1
        WEND

null_entry
        MOV     pc, lr

        ENTRY
entry   LDR     r0, [sp]        ; Read argc
        ADD     r1, sp, #4      ; Read argv
        BL      main
        MOV     r7, #__NR_exit
        B       __PVirt_LinuxSyscall

__main  *       0

start_ptrace
        STMFD   sp!, {r4, r7, lr}
        MOV     r0, #ix_CLONE_VM
        MOV     r1, sp
        MOV     r2, #0
        MOV     r3, #0
        MOV     r4, #0
        LDR     r7, =__NR_clone
        LDR     sp, =ptrace_stack
        SWI     0
        TEQ     r0, #0
        LDMEQFD sp!, {r4, r7, pc} ; Return if child.
        B       do_ptrace         ; Parent runs ptrace loop

        NOP
ptrace_swi_jump
        LDMFD   sp!, {r0, lr}
        LDR     pc, [sp], #4

__rt_udiv10
        MOV     a2, a1
        MOV     a1, #10
__rt_udiv
        DivRem  a3, a2, a1, ip
        MOV     a1, a3
        myBX    lr

        AREA    |!!rwbase|, DATA, ALIGN=12
        %       32 * 4
ptrace_stack

        END
