; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Macros

;..............................................................................
;
; Prep the routines as required

        MACRO
        PDumper_InitialiseMacros
        MEND

strip_type_mono  * StripType_Monochrome
strip_type_greys * StripType_GreyLevel
strip_type_256   * StripType_256Colour
strip_type_24bm  * StripType_Multi
        [ Medusa
strip_type_16bs  * StripType_16Bit
strip_type_24bs  * StripType_24Bit
        ]

;..............................................................................

; Reset the buffer pointer, purging the contents.  Should only be called at
; the start of a strip.

        MACRO
$l      PDumper_Reset $cc
$l      ;DebugEscState PDumper_Reset
        MOV$cc  ofs,#buffer_length      ;Reset the free space in the buffer
        ADR$cc  ptr,buffer_posn         ;..and its position
        MEND

;..............................................................................

; Store a byte into the buffer, flushing if it is full or fills up

        MACRO
$l      PDumper_OutputReg $reg
$l      ;DebugEscState PDumper_OutputReg
        STRB    $reg,[ptr,ofs,LSR #16]  ;Store the character
        ADD     ofs,ofs,#&10000         ;And then advance the pointer
        CMP     ofs,ofs,LSL #16         ;Has the buffer filled up yet?
        PDumper_EmptyBuffer GT
        MEND

;..............................................................................

; Empty the buffer.

        MACRO
$l      PDumper_EmptyBuffer $cc
$l      ;DebugEscState PDumper_EmptyBuffer
        BL$cc   PDumper_EmptyBuffer     ;Empty the buffer
        PDumper_Reset $cc
        MEND

;..............................................................................

; Print a full word, ie. all four bytes.

        MACRO
$l      PDumper_PrintBinaryWord $reg,$temp
$l      ;DebugEscState PDumper_PrintBinaryWord
        MOV     $temp,$reg              ;bits 0..7
        PDumper_OutputReg $temp
        MOV     $temp,$reg,LSR #8       ;bits 8..15
        PDumper_OutputReg $temp
        MOV     $temp,$reg,LSR #16      ;bits 16..23
        PDumper_OutputReg $temp
        MOV     $temp,$reg,LSR #24      ;bits 24..31
        PDumper_OutputReg $temp
        MEND

;..............................................................................

; Print a half word, ie. two bytes.

        MACRO
$l      PDumper_PrintBinaryPair $reg,$temp
$l      ;DebugEscState PDumper_PrintBinaryPair
        MOV     $temp,$reg              ;bits 0..7
        PDumper_OutputReg $temp
        MOV     $temp,$reg,LSR #8       ;bits 8..15
        PDumper_OutputReg $temp
        MEND

; As PrintBinaryPair, but high byte first

        MACRO
$l      PDumper_PrintBinaryPair_HighFirst $reg,$temp
$l      ;DebugEscState PDumper_PrintBinaryPair_HighFirst
        MOV     $temp,$reg ,LSR #8      ;bits 8..15
        PDumper_OutputReg $temp
        MOV     $temp,$reg              ;bits 0..7
        PDumper_OutputReg $temp
        MEND

;..............................................................................

; Print a counted string, data stored as the first byte is its length
; and then data follows on.
;
; If the length byte is zero,this is read to mean that it is a "long" counted string
; potentially up to 16M.The data is then stored as [ 0 ] [ 3 byte length ] [ address ]
;
; Pointer register is advanced beyond the end of the string

        MACRO
$l      PDumper_PrintCountedString $reg,$temp1,$temp2
$l      ;DebugEscState PDumper_PrintCountedString
        LDRB    $temp1,[$reg]           ;Get the length of the string to print
        TEQ     $temp1, #0
        LDREQ   $temp1,[$reg],#4   
        MOVEQ   $temp1,$temp1,LSR#8     ;in both cases $temp1 is now the length
        ADDNE   $reg, $reg, #1
        LDREQ   $reg, [$reg]            ;in both cases $reg now points to the string start
50
        SUBS    $temp1,$temp1,#1        ;Decrease the counter
        BLT     %FT51                   ;..and when <=0 then we must exit!

        LDRB    $temp2,[$reg],#1        ;Get the byte to send
        PDumper_OutputReg $temp2
        B       %BT50                   ;Then loop back until the counter is zero
51
        MEND

;..............................................................................

; Print a string given its length.  The pointer is advance beyond the last character
; in the text and then length string is reset to zero.

        MACRO
$l      PDumper_PrintLengthString $reg,$length,$temp
$l      DebugEscState PDumper_PrintLengthString
        CMP     $length,#buffer_length  ;Is the string longer than the current buffer
        BLT     %FT50                   ;If so just insert

        PDumper_EmptyBuffer             ;Ensure that the buffer is correctly flushed

        Push    "$reg"                  ;Preserve the pointer to the text
        Push    "R0-R3,R4"

        ;Check the GBPB error flag
        ADR     r1, pd_error_flag_set
        LDR     r0, [r1]
        TST     r0, #1 :SHL: 1
        BNE     %01

      [ "$length"<>"R3"
        MOV     R3,$length
      ]
        LDR     R2,[SP,#16]             ;Get the pointer
        LDR     R1,FileHandle
        MOV     R0,#OSGBPB_WriteAtPTR   ;Get the handle and reeason code

        CMP     R3,#0                   ;Is there any data to write (clears V)
        BEQ     %01
        SWI     XOS_GBPB
        DebugIf VC, misc, "OS_GBPB ok"
        BVC     %01
        DebugE  misc, "OS_GBPB error"

        ;Set the GBPB error flag (without corrupting more registers)
        Push    "r0, r1, r2"
        LDR     R0, [R0]
        TEQ     R0, #ErrorNumber_Escape
        BEQ     %20
        ADR     r1, pd_error_flag_set
        LDR     r2, [r1]
        ORR     r2, r2, #1 :SHL: 1
        STR     r2, [r1]
20
        Pull    "r0, r1, r2"

        PDumper_Error                   ;..and then trap any errors that occur
01
        Pull    "R0-R3,R4"
        Pull    "$reg"                  ;Balance the stack and restore the pointers

        ADD     $reg,$reg,$length       ;Advance the pointer beyond the data sent
        B       %FT51
50
        SUBS    $length,$length,#1      ;Decrease the counter
        BLT     %FT51                   ;..and when <=0 then we must exit!

        LDRB    $temp,[$reg],#1         ;Get the byte to send
        PDumper_OutputReg $temp
        B       %BT50                   ;Then loop back until the counter is zero
51

        MEND

;..............................................................................

        GBLS    PDumper_EntryRegList

; Entry to a PDumper routine

        MACRO
$l      PDumper_Entry $reglist
      [ "$reglist"=""
PDumper_EntryRegList SETS "ofs,ptr"     ;Always push the important ones
      |
PDumper_EntryRegList SETS "$reglist,ofs,ptr"
      ]
$l      ;DebugEscState PDumper_Entry
        Push    "lr"
        STR     SP,FramePointer         ;->Return frame+4 ready to exit
        Push    "$PDumper_EntryRegList"
        Debug   misc, "PDumper_Entry lr", lr
        MEND

; Exit from a PDumper routine

        MACRO
$l      PDumper_Exit
$l      ;DebugEscState PDumper_Exit
        [ No32bitCode
        Pull    "$PDumper_EntryRegList ,LR"
        BICS    PC,LR,#V_bit
        |
        CLRV
        Pull    "$PDumper_EntryRegList ,PC"
        ]
        MEND

; Trap an error from a PDumper SWI.  Returning as required. Note that you
; cannot easily preserve all the registers here. It might look as if you
; can by simply restoring the register set as in PDumper_Exit, but
; PDumper_Error calls are not always matched with the right PDumper_Entry.
; Specifically, the PDumper_Error call in the PDumper_EmptyBuffer
; subroutine (see below) gets the register set used in the very last
; PDumper_Entry call before it, yet PDumper_EmptyBuffer is called from
; all over the place with various different sets of pushed registers.
; Any attempt to restore all the registers has to get clever eg. a common
; (and enforced) set of pushed regsiters, or a flag word saying what
; registers were pushed etc. The easiest option (used below) is to not
; restore the registers - PDriverDP doesn't seem to mind on errors.

        MACRO
$l      PDumper_Error
$l      BVC     %79
        DebugE  misc, "PDumper_Error"

        ;Copy the error into a local block. If you don't do this, FileSwitch
        ;overwrites the buffer that MessageTrans gives us with the usual lot of
        ;'Variable <fs>$Path not found' messages.
        BL      PDumper_CopyError
        DebugE  misc, "PDumper_Error (copy)"

        LDR     sp, FramePointer        ; Restore SP as at entry
        LDR     pc, [sp], #4            ; Return (with V set) to the
                                        ; caller of the top-level routine
79
        MEND

;..............................................................................

; Insert routines required for the above code.

        MACRO
$l      PDumper_InsertRoutines

PDumper_GetLeftMargin ROUT
        ;This palaver needed because this routine returns results in R14.
        ;EXITS needs R14 as a temporary register in 32-bit builds.
        Push    "lr"
        Push    "r0,lr"
        SavePSR lr
        Push    lr

        LDR     R14,[R7,#pd_leftmargin -pd_data]

        LDRB    R0,[R7,#pd_data_version -pd_data]
        CMP     R0,#3                   ; is it a version file
        BLT     %FT10

        LDR     R0,[R7,#pd_data_left_offset]
        SUBS    R14,R14,R0
        MOVMI   R14,#0                  ; adjust by margin, account for -ve
10
        STR     R14,[sp, #8]            ; adjust stacked R14
        Pull    lr                      ; retrieve the stacked CPSR
        RestPSR lr,,cf                  ; restore the flags
        Pull    "r0,lr,pc"              ; return from function

PDumper_EmptyBuffer
        DebugEscState PDumper_EmptyBuffer
        Push    "R0-R4,LR"
        SavePSR R0
        Push    r0

        ADR     r1, pd_error_flag_set
        LDR     r0, [r1]                ;check GBPB error bit
        TST     r0, #1 :SHL: 1
        BNE     %01                     ;go away if non-0

        MOV     R0,#OSGBPB_WriteAtPTR
        LDR     R1,FileHandle           ;Get the file handle + reason code
        MOV     R2,ptr
        MOV     R3,ofs,LSR #16          ;Get the pointer and the length

        CMP     R3,#0                   ;Is there any data to write (will clear V)
        BEQ     %01
        SWI     XOS_GBPB
        DebugIf VC, misc, "OS_GBPB ok"
        BVC     %25
        DebugE  misc, "OS_GBPB error"

        ;Set the GBPB error flag (without corrupting more registers)
        Push    "r0, r1, r2"
        LDR     R0, [R0]
        TEQ     R0, #ErrorNumber_Escape
        BEQ     %30
        ADR     r1, pd_error_flag_set
        LDR     r2, [r1]
        ORR     r2, r2, #1 :SHL: 1
        STR     r2, [r1]
30
        Pull    "r0, r1, r2"

        ;Do we need to ignore any errors because we are tidying up
        Push    "R0-R1"
        ADR     R1, pd_error_flag_set
        LDR     R0, [R1]
        TST     R0, #1                  ;Only look at the error bit
        Pull    "R0-R1"
        DebugIf NE, misc, "ignoring error"
        BNE     %FT25                   ; yes - so don't trap the error!

        PDumper_Error                   ;..and then trap any errors
25
        MOV     ofs,#buffer_length      ;Reset the pointer
01
        Pull    r0
        RestPSR r0,,cf
        Pull    "r0-r4,pc"              ;And then exit

PDumper_CopyError ROUT
;Entry
; R0 -> error block
; V set
;Exit
; R0 -> copy of error block in our workspace
; V still set

        Push    "r1-r9, lr"
        MOV     r8, r0
        ADRL    r9, error_buffer

        LCLA    count
        LCLA    i
count   SETA    256/(4*8)               ;bytes in an error block/bytes in r0-r7
i       SETA    0
        WHILE   i < count
        LDMIA   r8!, {r0-r7}
        STMIA   r9!, {r0-r7}
i       SETA    i + 1
        WEND
        SUB     r0, r9, #256
        Pull    "r1-r9, pc"

        MEND

;..............................................................................

; Adjust feed length based on version of the printer description file being
;   used.

        MACRO
$l      PDumper_AdjustFeed $x,$y,$r,$temp
$l      ;DebugEscState PDumper_AdjustFeed
        LDRB    $temp,[$r,#pd_data_version -pd_data]
        CMP     $temp,#3                ; does it have support for the modified feed values
        BLT     %FT10                   ;   no, so ignore it

        Debug   ,"Before offset",$x,$y

        LDR     $temp,[$r,#pd_data_left_offset]
        SUBS    $x,$x,$temp             ; allow for -ve value
        MOVMI   $x,#0
        LDR     $temp,[$r,#pd_data_top_offset]
        SUBS    $y,$y,$temp
        MOVMI   $y,#0                   ; subtract the y offset, account for -ve

        Debug   ,"After offset",$x,$y
10
        MEND

        MACRO
$l      PDumper_GetLeftMargin $r,$cc
$l      ;DebugEscState PDumper_GetLeftMargin
        BL$cc   PDumper_GetLeftMargin
      [ ("$r"="lr") :LOR: ("$r"="LR")
      |
        ! 0,"Compiling to return in $r"
        MOV     $r,R14
      ]
        MEND


        MACRO
$l      DebugEscState   $fn
        [               debug
$l      Push            "r0-r3, lr"
        SavePSR         r3                      ;save flags
        MOV             r0, #229
        MOV             r1, #0
        MOV             r2, #255
        SWI             XOS_Byte
        Debug           misc, "$fn: esc disabled", r1
        RestPSR         r3,,f                   ;restore flags
        Pull            "r0-r3, lr"             ;restore everything else
        ]
        MEND

        END
