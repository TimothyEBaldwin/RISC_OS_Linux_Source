; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > IOEB

;time delay multipliers (times approx 0.5 us) for handshaking timeouts
;
TimeoutPACKhigh     *  40   ;40
TimeoutBusyAfterAck *  40   ;20

; Define information about the printer control port.

pp_imm            * &800                ; offset so index immediate is in +4k -4k range for all pp regs
pp_delay          * pp_stat             ; a register that is not read sensitive for tiny delays

pp_data           * 0  - pp_imm         ; data port in non-FIFO mode
pp_stat           * 4  - pp_imm         ; status register
pp_ctrl           * 8  - pp_imm         ; control register
;pp_EPP           * 12 - pp_imm         ; EPP mode not enabled
;pp_EPP_Data0     * 16 - pp_imm 
;pp_EPP_Data1     * 20 - pp_imm 
;pp_EPP_Data2     * 24 - pp_imm 
;pp_EPP_Data3     * 28 - pp_imm 
pp_fifo           * (&400 * 4) - pp_imm ; FIFO data port (may depend on the chip being used)
pp_ecr            * (&402 * 4) - pp_imm ; extended control register

pp_stat_notbusy         * 1:SHL:7       ; set => ready for data,                clear => busy
pp_stat_ack             * 1:SHL:6       ; goes low during acknowledge pulse
pp_stat_pe              * 1:SHL:5       ; set => no paper,                      clear => paper
pp_stat_slct            * 1:SHL:4       ; set => online,                        clear => off line
pp_stat_error           * 1:SHL:3       ; set => no error,                      clear => error
;pp_stat_2              * 1:SHL:2       ; hardwired low
;pp_stat_1              * 1:SHL:1       ; hardwired low
pp_EPP_timeout          * 1:SHL:0       ; set => >= 10 us timout occurred       clear => no timeout

;pp_ctrl_7              * 1:SHL:7       ; hardwired low
;pp_ctrl_6              * 1:SHL:6       ; hardwired low
pp_ctrl_dir             * 1:SHL:5       ; set => input, clear => output
pp_ctrl_irqen           * 1:SHL:4       ; set => irq gen when ACK low,          clear => irq disabled
pp_ctrl_slctin          * 1:SHL:3       ; set => select printer,                clear => off line
pp_ctrl_init            * 1:SHL:2       ; set => normal operation,              clear => reset printer (min 50탎)
pp_ctrl_autofd          * 1:SHL:1       ; set => generate auto feed,            clear => no autofeed
pp_ctrl_strobe          * 1:SHL:0       ; set => active low pulse,              clear => no strobe

; The following lines have opposite sense to the IEEE 1284 standard conventions:
; pp_stat_notbusy  <->  Busy
; pp_ctrl_slctin   <->  nSelectIn
; pp_ctrl_init     <->  nInit
; pp_ctrl_autofd   <->  nAutoFd
; pp_ctrl_strobe   <->  nStrobe


; IEEE 1284 extensibility request values
extensibility_request_revnibble * 0     ; request Reverse Nibble Mode
extensibility_request_device_id * 4     ; request Device ID using Reverse Nibble Mode
extensibility_acknowledge_mask  * pp_stat_pe :OR: pp_stat_slct :OR: pp_stat_error :OR: pp_stat_ack
extensibility_acknowledge_value * pp_stat_pe :OR: pp_stat_slct :OR: pp_stat_error

; these flags control the mode at which the parallel device should be driven, see the COMBO chip spec
; pg. 99 FDC37C669 specification.
pp_ecr_flag_FIFO        * 2_010:SHL:5   ; use FIFO mode
pp_ecr_flag_default     * 2_001:SHL:5   ; use default parallel mode

pp_ecr_mode             * 7:SHL:5       ; mask out mode bits
pp_ecr_errintdis        * 1:SHL:4       ; set => irq disabled,                  clear => irq gen on error
pp_ecr_dmaen            * 1:SHL:3       ; set => DMA enabled,                   clear => DMA disabled
pp_ecr_servintdis       * 1:SHL:2       ; set => irq disabled,                  clear => irq gen on service interrupt
pp_ecr_full             * 1:SHL:1       ; set => FIFO is full,                  clear => >=1 free byte in FIFO
pp_ecr_empty            * 1:SHL:0       ; set => FIFO is empty,                 clear => >=1 byte in FIFO

; Define default settings for control registers.

pp_ctrl_default         * pp_ctrl_init :OR: pp_ctrl_slctin :OR: pp_ctrl_autofd
pp_ecr_default          * pp_ecr_flag_default :OR: pp_ecr_errintdis

ioeb_ctrl_output        * pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init
ioeb_ctrl_input         * pp_ctrl_dir :OR: pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init :OR: pp_ctrl_autofd

ioctl_reason_size       * 1
ioctl_reason_data       * 2
ioctl_reason_status     * 3
ioctl_reason_revnibble_size * 4
ioctl_reason_revnibble_data * 5

ioctl_reason_mask       * &FFFF
ioctl_group_parallel    * 1
ioctl_header_read       * 1:SHL:6
ioctl_header_write      * 1:SHL:7

        [ AdvancedErrorHandling
; values for UpCall_DeviceError

UpCall_DeviceError      * &10500
UpCallDeviceErrorFlag_FatalError    * 1:SHL:0
UpCallDeviceErrorFlag_UseErrorBlock * 1:SHL:1
        ]

; Clear printer interrupt depending on hardware type (IOMD has clear bit).
                MACRO
$label          ClearPINTR $v0,$v1
 [ HAL
$label
                MRS     $v0, CPSR ; Necessary?
                Push    "r0-r3,r9,r12,lr" ; This could be improved!
                LDRB    r0, DeviceNo
                LDR     r9, HAL_SB
                MOV     lr, pc
                LDR     pc, HAL_IRQClear
                Pull    "r0-r3,r9,r12,lr"
                MSR     CPSR_c, $v0
 |
$label          LDRB    $v0, InterruptBit
                LDR     $v1, InterruptClear
                STRB    $v0, [$v1]
 ]
                MEND

; this macro delays for 5us
                MACRO
$label          PulseDelay $v0

$label          ROUT
                LDR     $v0, LoopFactor         ; get the processor speed
                MOV     $v0, $v0, LSR #3
10
                SUBS    $v0, $v0, #1
                BGT     %BT10
                MEND


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: IOEBdevice
;
; in:   r0  = reason code
;       r8  = private word
;       wp -> workspace
;
; out:  V clear, registers setup correctly
;       V set, r0 -> error block
;
; This entry point is provided to allow the IOEB device to do what it needs to
; do, this is called by DeviceFS to pass events and control operations to the
; device driver.
;

IOEBdevice      ROUT

                Push    lr
                SavePSR lr
                BIC     lr, lr, #V_bit+ C_bit                   ; just ensure that all is OK
                Push    lr
                JumpAddress lr, device_call_exit, forward       ; load return address
                CMP     r0, #(%10-%00)/4
                ADDCC   pc, pc, r0, LSL #2                      ; despatch the event
                B       %10                                     ; if not valid then give an error
00
                B       ioeb_open                               ; open a stream
                B       ioeb_close                              ; close the stream
                B       ioeb_wakeupTX                           ; wake up because someones transfering
                MOV     pc, lr                                  ; wakeup RX
                MOV     pc, lr                                  ; sleep RX
                MOV     pc, lr                                  ; enum dir
                B       common_createTX                         ; create buffer for TX
                B       common_createRX                         ; create buffer for RX
                MOV     pc, lr                                  ; halt
                B       ioeb_resume                             ; start sender sending again
                MOV     pc, lr                                  ; end of data
                B       ioeb_created                            ; output or input stream created
                B       ioeb_monitorTX                          ; check sending is okay
                MOV     pc, lr                                  ; monitor rx
                B       ioeb_ioctl                              ; ioctl
10
                ADRL    r0, ErrorBlock_Parallel_BadCall         ; if not within valid range
              [ international
                BL      MakeError
              |
                CMP     r0, #&80000000                          ; set V
                CMNVC   r0, #&80000000
              ]

device_call_exit
                Pull    lr
                ORRVS   lr, lr, #V_bit
                ORRCS   lr, lr, #C_bit
                RestPSR lr,,f
                Pull    pc

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: IOEBreset
;
; in:   -
;
; out:  -
;
; This routine allows the module to reset the hardware being controlled
; by the device to a nice set of defaults.
;

IOEBreset       EntryS   "r0-r2"

                ClearPINTR r0,r1                                ; attempt to clear any pending interrupts

                MOV     r0, #9
                MOV     r1, #34<<8                              ; SuperIO controller
                SWI     XOS_Memory
                LDR     r0, =(&278 * 4) + pp_imm                ; Offset to parallel port registers
                LDRVS   r1, =C710                               ; Address pre-HAL era
                ADD     r0, r1, r0
                STR     r0, HardwareBase                        ; setup the hardware base for device

        [ FastCentronics
                LDRB    r1, Flags
                TST     r1, #f_UseFIFO                          ; if FIFO hardware is there then
                MOVNE   r1, #pp_ecr_default                     ; program default value
                STRNEB  r1, [r0, #pp_ecr]
        ]

                MOV     r1, #pp_ctrl_default                    ; program default value into control register
                STRB    r1, [r0, #pp_ctrl]

                EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_open
;
; in:   r0  = reason code
;       r2  = external handle
;       r3  = flags
;       r6 -> special field block
;
; out:  r1  = internal handle
;
; This call attempts to open a stream onto the specified device.
;

ioeb_open       Entry   "r0,r1"
                Debug   open,"ioeb_open"
 [ StorkPower
                BL      SetPower_On             ;Should be powered down, so power up
 ]
                LDRB    r0, DeviceNo
                TST     r3, #&01
                ADREQL  r1, ioeb_irqread
                ADRNEL  r1, ioeb_irqwrite
                BL      common_open
 [ StorkPower
                BLVS    SetPower_Off            ;If openning failed, try powering down. If failure occurred
                                                ;because port was in use, the service call will be faulted
                                                ;and the port will remain powered (as it should be).
 ]
                EXIT



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_close
;
; in:   r0  = reason code
;       r2  = internal handle
;
; out:  -
;
; This routine handles the closing of a stream onto IOEB.
;

ioeb_close      Entry   "r0-r2"
                Debug   close,"ioeb_close"
                LDRB    r0, DeviceNo
                LDRB    r1, Flags
                TST     r1, #f_OpenForRead
                ADRNEL  r1, ioeb_irqread
                ADREQL  r1, ioeb_irqwrite
                ADRL    r2, ioeb_busy_check_callafter
                BL      common_close
                BL      IOEBreset
 [ StorkPower
                BL      SetPower_Off            ;Will be powered up, so power down
 ]
                EXIT



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_created
;
; in:   r0 = reason code (11)
;       r2 = internal handle
;       r3 = buffer handle
;
; out:  -
;
; This routine is called when an input or output stream has been created.
;

ioeb_created    EntryS  "r0-r2"

                Debug   open,"ioeb_created, buffer handle =",r3

                STR     r3, BufferHandle        ; store buffer handle for read or write

        [ FastBufferMan
                MOV     r0, r3
                SWI     XBuffer_InternalInfo
                STRVS   r0, [sp, #Proc_RegOffset]
                EXIT    VS
                STR     r0, BufferId
                STR     r1, BuffManService
                STR     r2, BuffManWkSpace
        ]

                ClearPINTR r0,lr                ; attempt to clear any pending interrupts

                SETPSR  I_bit,lr                ; Disable interrupts

                LDRB    r0, Flags
                TST     r0, #f_OpenForRead

                LDR     r0, HardwareBase
                MOVEQ   r1, #ioeb_ctrl_output   ; set up for output
                MOVNE   r1, #ioeb_ctrl_input    ; set up for input
                STRB    r1, [r0, #pp_ctrl]
                EXITS   EQ,cf                   ; do nothing else if open for output

        [ HAL
                Push    "r3,r9,r12"
                LDRB    r0, DeviceNo
                LDR     r9, HAL_SB
                MOV     lr, pc
                LDR     pc, HAL_IRQEnable
                Pull    "r3,r9,r12"
        |
                MOV     r0, #IOC
                LDRB    r2, InterruptBit

                SETPSR  F_bit,lr                ; disable FIQs

                LDRB    r1, [r0, #IOCIRQMSKA]
                ORR     r1, r1, r2              ; enable device interrupts
                STRB    r1, [r0, #IOCIRQMSKA]
        ]
                EXITS   ,cf


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_monitorTX
;
; in:   r0  = reason code (12)
;       r2  = internal handle
;
; out:  VS if error, then R0 => error block
;       VC to continue, then R0 corrupted
;
; This routine is called by DeviceFS to check the device if the TX buffer is
; almost full. It can therefore be used to report printer error conditions

;Message tokens
paper           =               "Paper", 0
online          =               "OnLine", 0
printer         =               "Printer", 0
continue        =               "Continue",0
cancel          =               "Cancel",0
                ALIGN

; Now the real code: make an upcall on printer error, resuming if it's handled properly.

ioeb_monitorTX  ROUT

                Entry           "r1-r11"

        [ AdvancedErrorHandling
                ; first of all, check that we can use UpCall_DeviceError (only if we have been able
                ; to claim the UpCall vector, so we have got our own file handle to pass)
                Debug   adverr, "adverr"
                LDRB    r0, Flags
                TST     r0, #f_UpCallVectorClaimed
                BEQ     ioeb_error_fallback

                ; let us check for a stable error condition
                LDR     r3, HardwareBase
                LDR     r2, LoopFactor                          ; Get CPU speed rating
                MOV     r2, r2, LSR #2
20
                LDRB    r0, [r3, #pp_stat]                      ; read status register byte
                TST     R0, #pp_stat_slct                       ; off-line?
                TSTNE   r0, #pp_stat_error                      ; or a general error condition?
                BEQ     %FT25                                   ; we have got an error, so go to next iteration
                TST     r0, #pp_stat_pe
                BEQ     %FT40                                   ; no error, so return normally
25
                SUBS    r2, r2, #1
                BNE     %BT20

                ; OK, we have found a stable error condition, so use the advanced error handling protocol
                LDR     r0, =UpCall_DeviceError
                LDR     r1, FileSwitchHandle
                MOV     r2, #0

                Debug   adverr, "sending UpCall"
                SWI     XOS_UpCall
                BVS     ioeb_error_fallback                     ; UpCall could not be processed, so use old strategy
                TEQ     r0, #0
                BNE     ioeb_error_fallback                     ; UpCall not claimed, so use old strategy

                ; the UpCall has been claimed, so act on the error handling flags
                Debug   adverr, "UpCall claimed, flags = ", r1
                TST     r1, #UpCallDeviceErrorFlag_FatalError
                BEQ     %FT40                                   ; no error, so return normally!

                ; we have got an error, return a general error or a specific one
                TST     r1, #UpCallDeviceErrorFlag_UseErrorBlock
                MOVNE   r0, r2
                BNE     %FT30
                ADRL    r0, ErrorBlock_Parallel_Offline         ; use the standard "printer not ready" error
        [ international
                BL      MakeError
        ]
30
                ; OK, we want to abort printing, so we return to DeviceFS with VS. This will cause it
                ; to purge the buffer and fault any further access to the stream.
                Debug   adverr, "Return VS"
                SETV
                EXIT

ioeb_error_fallback
                ; fall back onto previous error handling strategy
                Debug   adverr, "error fallback, r0 = ", r0
        ]

                LDR     r0, HardwareBase
                LDRB    r0, [r0, #pp_stat]              ; read status register byte

        ; This tests for an error if it is detected looks at it for a test period to ensure it is stable

                TST             R0, #pp_stat_slct
                MOVEQ           r1, #pp_stat_slct       ; off-line?  set = online
                BLEQ            test_NSet_loop          ; if it is offline check that this is stable not noise
                BEQ             off_line

                TST             r0, #pp_stat_pe         ; out of paper? set = no paper
                MOVNE           r1, #pp_stat_pe
                BLNE            test_Set_loop           ; check that it stays set for 1 micro sec.
                BNE             paper_out

                TST             r0, #pp_stat_error      ; pp_stat_error clear for any other error
                MOVEQ           r1, #pp_stat_error      ; set = no error
                BLEQ            test_NSet_loop          ; if it is an error check that this is stable not noise
                BEQ             not_working
40
                Debug   adverr, "Return VC"
                CLRV
                EXIT

;+++++++++++++++++++++++++++++++++++++++++++++ test stable errors Start

        ; ADD a wait loop and check that the error is stable
        ; r0 ppstat, r1 is the error
        ; r3 is the address of the ppstat this needs to be read on each loop

test_Set_loop
                Push    "r2,r3,lr"

                LDR     r3, HardwareBase
                LDR     r2, LoopFactor                          ; Get CPU speed rating
                MOV     r2, r2, LSR #2
20
                LDRB    r0, [r3, #pp_stat]                      ; read status register byte
                TST     R0,R1
                BEQ     %FT25                                   ; see if the ppstat clears => EQ => not a stable error
                SUBS    r2, r2, #1
                BNE     %BT20                                   ; this leaves the loop on EQ
                MOVS    R1, R1                                  ; swap to NE condition => stable error
25
                Pull    "r2,r3,pc"

test_NSet_loop
                Push    "r2,r3,lr"

                LDR     r3, HardwareBase
                LDR     r2, LoopFactor                          ; Get CPU speed rating
                MOV     r2, r2, LSR #2
20
                LDRB    r0, [r3, #pp_stat]                      ; read status register byte
                TST     R0,R1
                BNE     %FT25                                   ; this sets the condition to NE
                SUBS    r2, r2, #1
                BNE     %BT20                                   ; this sets the returning condition to EQ
25                                                              ; this is the error condition
                Pull    "r2,r3,pc"

;+++++++++++++++++++++++++++++++++++++++++++++ test stable errors END
paper_out
                Debug           j, "paper out"
                MOV             r4, #0                  ;iteration count
                ADRL            r6, paper
                B               do_lookup_and_upcall

off_line
                Debug           j, "printer not connected"
                MOV             r4, #0                  ;iteration count
                ADRL            r6, online
                B               do_lookup_and_upcall

not_working
                Debug           j, "printer not working"
                MOV             r4, #0                  ;iteration count
                ADRL            r6, printer
                ;fall through

do_lookup_and_upcall
                ;Convert token in r6 to message in r6
                BL              OpenMessages
                ADDVS           r6, r0, #4
                BVS             do_upcall               ;if it went wrong, use the error as the message

                ADRL            r0, MessagesWorkspace
                MOV             r1, r6
                ADRL            r2, localerrorblock
                MOV             r3, #?localerrorblock
                SWI             XMessageTrans_Lookup
                MOVVC           r6, r2
                ADDVS           r6, r0, #4              ;if it went wrong, use the error as the message

do_upcall       ;Make the upcall

                MOV             r0, #UpCall_MediaNotPresent
                MOV             r1, #fsnumber_DeviceFS
                MOV             r2, #-1                 ;message in r6 (not media type)
                MOV             r3, #-1                 ;device number irrelevant
                ;r4 cleared first time, incremented subsequently
                MOV             r5, #&7FFFFFFF          ;timeout (very big)
                ;r6 set up depending on reason for upcall

                Debug           j, "OS_UpCall called", r0
                SWI             XOS_UpCall
                Debug           j, "OS_UpCall returned", r0
                EXIT            VS

                CMP             r0, #-1
                BNE             not_cancel      ;if this falls through it does not call exit with message

                Debug           j, "SHOULD EXIT WITH MESSAGE"
                ADRL            r6, cancel              ;move the specific error "cancel"
                BL              exit_with_message       ; send exit message then exit
                EXIT            VS

                ;Try to report the error state as it is now, but make sure that some error
                ;is reported even if all conditions have been (coincidentally) cleared.
set_errorblock
                LDR             r0, HardwareBase
                LDRB            r0, [r0, #pp_stat]      ; read status register byte

                ; now we've got an error, so what type is it?
                TST             r0, #pp_stat_pe         ; paper out?
                ADRNEL          r0, ErrorBlock_Parallel_PaperOut
                BNE             make_error

                TST             r0, #pp_stat_slct       ; off-line?
                ADREQL          r0, ErrorBlock_Parallel_Offline
                ADRNEL          r0, ErrorBlock_Parallel_OtherError
                ;fall through

make_error
                ;r0 -> error block
                PullEnv
                [               international
                B               MakeError
                |
                RETURNVS
                ]

not_cancel
                ; New strategy. Just exit with continuing message and let the higher levels
                ; raise the error again if necessary. This should be cleaner and provides
                ; more feedback to the user.

                ADRL            r6, continue            ;move the specific error "continue"
                BL              exit_with_message       ; All o k
                EXIT                                    ;This is the actual correct exit of this routine

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

exit_with_message

                Entry           "R1-R6"
                Debug           j, "exit with message"

                BL              OpenMessages
                ADDVS           r6, r0, #4
                BVS             send_exit               ;if it went wrong, use the error as the message

                ADRL            r0, MessagesWorkspace
                MOV             r1, r6
                ADRL            r2, localerrorblock
                MOV             r3, #?localerrorblock
                SWI             XMessageTrans_Lookup
                MOVVC           r6, r2
                ADDVS           r6, r0, #4

send_exit       ; call the end media search call

                MOV             R1, R6
                MOV             r0, #UpCall_MediaSearchEndMessage
                Debug           j, "OS_UpCall called", r0
                SWI             XOS_UpCall
                Debug           j, "OS_UpCall returned", r0
                EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_wakeupTX
;
; in:   r0  = reason code
;       r2  = internal handle
;
; out:  -
;
; Handle waking up the device, something has happened to it.
;

ioeb_wakeupTX   EntryS  "r0-r3"

                SETPSR  I_bit, lr               ; disable IRQs round this bit

                LDR     r3, HardwareBase
                BL      ioeb_busy               ; returns EQ if not busy
                BLEQ    ioeb_strobe
                EXITS   EQ,cf

                MOV     r0, #0                  ; indicate we wish to remain dormant
                STR     r0, [sp, #Proc_RegOffset]
                LDRB    r3, IRQFlags
                TST     r3, #if_PendingCallAfter ; if we've already asked for a callafter
                EXITS   NE,cf                   ; then exit

                LDR     r0, =BusyCheckInterval
                ADR     r1, ioeb_busy_check_callafter
                MOV     r2, wp
                SWI     XOS_CallAfter
                ORRVC   r3, r3, #if_PendingCallAfter
                STRVCB  r3, IRQFlags

                EXITS   ,cf

                ; CallAfter routine.  Entered in SVC mode with IRQs disabled.
                ; Must preserve all registers and exit with MOV pc, lr (PRM 1-429)
ioeb_busy_check_callafter EntryS "r0"
                LDRB    r0, IRQFlags
                BIC     r0, r0, #if_PendingCallAfter    ; indicate no pending callafter any more
                STRB    r0, IRQFlags
                BL      ioeb_wakeupTX                   ; and call wakeup routine
                EXITS                                   ; and exit

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_busy
;
; in:
;       r3 -> HardwareBase
;       IRQs disabled
;
; out:  EQ if printer busy, else NE
;
; This routine will simply read the state of the busy pin from the 710.
;

ioeb_busy       Entry   "r0,r1"

                LDRB    lr, [r3, #pp_stat]                      ; lr  = status byte
                AND     r1, lr, #pp_stat_notbusy                ; is the port busy? =0 if so
                EORS    r1, r1, #pp_stat_notbusy                ; invert Z to be correct for any exit
                EXIT    EQ                                      ; return EQ, ie. port free

 [ HAL
                Push    "r2-r3,r9,r12"
                LDRB    r0, DeviceNo
                LDR     r9, HAL_SB
                MOV     lr, pc
                LDR     pc, HAL_IRQEnable
                Pull    "r2-r3,r9,r12"
                MOVS    r0, #-1                                 ; ensure Z=0
 |
                LDRB    r1, InterruptBit
                MOV     r3, #IOC

                ; disable FIQs round updates to IOCIRQMSKA
                SETPSR  F_bit,r0,,lr                            ; old PSR into lr (note: Z clear in lr!)
                LDRB    r0, [r3, #IOCIRQMSKA]
                ORR     r0, r0, r1
                STRB    r0, [r3, #IOCIRQMSKA]
                RestPSR lr,,cf                                  ; restores PSR

                LDR     r3, HardwareBase                        ; Restore r3
 ]
                EXIT                                            ; Z=0, ie. printer is busy, NE

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Strobe characters to the printer port for the 82c710.  Routine can be
; called from anymode, assumes that BufferHandle contains the buffer
; to be examined and character to be strobed.
;
; Also assumes that the direction bit within pp_ctrl has been setup correctly
; so that the port is defined for output rather than input.

;Entry
;       IRQ mode, interrupts off
;       r3 -> IOC
;       r12 -> workspace
;       Not currently threaded (non-reentrant)
;Exit
;       Interrupt serviced
;       r0--r3, r12 corrupted
;Notes
;       Execution time <= 100탎
;       SWI's called by method on P R M p1-127 (X SWI's only)
;       Error stored---somewhere???
;       Calls re-entrant SWI's only

ioeb_irqwrite   ROUT

; The acknowledge interrupt is triggered on the falling (leading) edge of PACK, and some printers'
; manuals indicate that the printer is only ready when the pulse is completed (ie when PACK has gone high again).
; So now we should wait for PACK to go high, and then clear our interrupt

                LDR     r3, HardwareBase
                LDR     r2, LoopFactor                          ; Get CPU speed rating and loop until PACK is high
10
                LDRB    r0, [r3, #pp_stat]
                TST     r0, #pp_stat_ack
                BNE     %FT15
                SUBS    r2, r2, #1
                BNE     %BT10

                ClearPINTR r0,r1                                ; PACK not gone high (probably printer off)
                MOV     pc, lr                                  ; so clear interrupt and exit (printer on will start again)

15
        [ CheckBusyAfterAck
                LDR     r2, LoopFactor                          ; Get CPU speed rating
20
                LDRB    r0, [r3, #pp_stat]
                TST     r0, #pp_stat_notbusy                    ; 0 => busy
                BNE     ioeb_strobe                             ; not busy, so carry on
                SUBS    r2, r2, #1
                BNE     %BT20

                ClearPINTR r0,r1                                ; clear interrupt anyway

                LDRB    r2, IRQFlags
                TST     r2, #if_PendingCallAfter                ; if we already have a pending callafter
                MOVNE   pc, lr                                  ; then exit

                ASSERT  (IRQ_mode :EOR: SVC_mode) = (IRQ32_mode :EOR: SVC32_mode)
                TOGPSR  (IRQ_mode :EOR: SVC_mode),r0,,r3        ; move from IRQ into SVC mode.

                LDR     r0, =BusyCheckInterval                  ; takes place of NOP
                Push    "r2, lr"
                ADR     r1, ioeb_busy_check_callafter
                MOV     r2, wp
                SWI     XOS_CallAfter
                Pull    "r2, lr"
                ORRVC   r2, r2, #if_PendingCallAfter
                STRVCB  r2, IRQFlags

                RestPSR r3,,cf                                  ; restore IRQ mode
                NOP
                MOV     pc, lr                                  ; and exit

        ]

; in:
;     r3 -> HardwareBase
;     SVC_mode or IRQ_mode
;     IRQs disabled (this is needed (a) because may enable pack IRQ (b) mustn't have F=1 and I=0
;
; out: r0-r2 corrupted
;

ioeb_strobe     EntryS

                ClearPINTR r0,r1                                ; clear interrupt after PACK has gone high again
                                                                ; note this is done inside the strobe routine in order
                                                                ; to clear any fake acknowledges generated on printer
                                                                ; power-on

        [ FastBufferMan
                MOV     r0, #BufferReason_RemoveByte
                LDR     r1, BufferId
                CallBuffMan
        |
                SavePSR r2
                BIC     r2, r2, #C_bit + V_bit                  ; clear C&V for entering mode
                BIC     lr, r2, #2_01100
                ORR     lr, lr, #SVC_mode                       ; derive SVC mode (NB if entered in SVC mode, then
                                                                ; we've already saved lr_svc, so we can junk it now)
                RestPSR lr                                      ; change to SVC mode with C and V clear
                LDR     r1, StreamHandle
                Push    "lr"                                    ; preserve SVC_LR
                SWI     XDeviceFS_TransmitCharacter             ; get character to send
                Pull    "lr"

                ORRCS   r2, r2, #C_bit                          ; ensure C flag reflected correctly
                RestPSR r2
                NOP                                             ; back to original mode (IRQ or SVC)
        ]
        [ HAL
                Push    "byte,r3,r9,r12"
                LDRB    r0, DeviceNo
                LDR     r9, HAL_SB
                ADRCC   lr, %FT10
                LDRCC   pc, HAL_IRQEnable
                MOV     lr, pc
                LDR     pc, HAL_IRQDisable
                Pull    "byte,r3,r9,r12"
                EXITS   ,cf
10
                Pull    "byte,r3,r9,r12"
        |
                MOV     r3, #IOC
                LDRB    r1, InterruptBit

                SETPSR  F_bit,tmp,,lr                           ; set F bit, old PSR into lr

                LDRB    tmp, [r3, #IOCIRQMSKA]
                ORRCC   tmp, tmp, r1                            ; re-enable printer interrupts
                BICCS   tmp, tmp, r1
                STRB    tmp, [r3, #IOCIRQMSKA]

                EXITS   CS,cf                                   ; if no character then exit
                RestPSR lr,,c                                   ; restore FIQ status (IRQs still disabled)

                LDR     r3, HardwareBase                        ; Restore r3
        ]
                STRB    byte, [r3, #pp_data]

; The following assumes the SuperIO chip has IOTCR set for TypeB cycles (7 ticks of 16MHz IO clock => 437.5ns)
; hence a read of any non read sensitive register will waste 0.5us ish

; now do set up time of 0.5탎, so read dummy location

                LDRB    r0, [r3, #pp_delay]

                LDRB    r2, [r3, #pp_ctrl]
                ORR     r0, r2, #pp_ctrl_strobe                 ; enable strobing
                STRB    r0, [r3, #pp_ctrl]

; now leave strobe high for at least 1탎, so do two dummy reads

                LDRB    r0, [r3, #pp_delay]
                LDRB    r0, [r3, #pp_delay]

                STRB    r2, [r3, #pp_ctrl]                      ; disable strobing

; no need to explicitly wait for 1탎 with data valid, there's no way we can send another character within 1탎
; since we have to call SWI XDeviceFS_TransmitChar to get each char.
                [       FastBufferMan                           ; but not if we're using FastBufferMan JRC 14-Apr-1997
                LDRB    r0, [r3, #pp_delay]
                LDRB    r0, [r3, #pp_delay]
                ]

; now cancel any pending callafter, since we've just transmitted a char

                LDRB    r0, IRQFlags
                TST     r0, #if_PendingCallAfter
                EXITS   EQ,cf

                SavePSR r2
                BIC     lr, r2, #2_01100
                ORR     lr, lr, #SVC_mode                       ; force SVC mode
                RestPSR lr

                MOV     r1, wp
                Push    "r0,lr"
                ADR     r0, ioeb_busy_check_callafter
                SWI     XOS_RemoveTickerEvent
                Pull    "r0,lr"

                RestPSR r2                                      ; switch back

                BIC     r0, r0, #if_PendingCallAfter
                STRB    r0, IRQFlags

                EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; call: ioeb_irqread
;
;       Process incoming bytes.
;

ioeb_irqread    EntryS  "r0-r3"

                LDR     r1, HardwareBase
                LDRB    byte, [r1, #pp_data]            ; get input byte

                LDRB    tmp, [r1, #pp_ctrl]
                BIC     tmp, tmp, #pp_ctrl_slctin :OR: pp_ctrl_autofd
                STRB    tmp, [r1, #pp_ctrl]             ; signal busy using SLCTIN (+ AUTOFD for ECP cables)

                ClearPINTR r1,tmp                       ; clear interrupt

buffer_byte
        [ FastBufferMan
                MOV     r0, #BufferReason_InsertByte
                LDR     r1, BufferId
                CallBuffMan
        |
                SavePSR r3
                BIC     lr, r3, #2_01100 + C_bit + V_bit
                ORR     lr, lr, #SVC_mode
                RestPSR lr,,cf                          ; change to SVC mode (C & V clear)

                LDR     r1, BufferHandle
                Push    "r9,lr"
                MOV     r9, #INSV                       ; call vector directly for speed
                SWI     XOS_CallAVector                 ; buffer the byte
                Pull    "r9,lr"

                ORRCS   r3, r3, #C_bit                  ; reflect C flag in PSR
                RestPSR r3                              ; back to old mode
        ]

        [ HAL
                SavePSR lr
                Push    "byte,r9,r12,lr"
                LDRB    r0, DeviceNo
                LDR     r9, HAL_SB
                ADR     lr, %FT10
                LDRCC   pc, HAL_IRQEnable
                LDRCS   pc, HAL_IRQDisable
10
                Pull    "byte,r9,r12,lr"
                RestPSR lr,,f                           ; restore C bit conditionality
        |
                LDRB    r1, InterruptBit
                MOV     r3, #IOC

                SETPSR  F_bit,tmp,,lr                   ; disable FIQs

                LDR     tmp, [r3, #IOCIRQMSKA]
                BICCS   tmp, tmp, r1                    ; if buffer is full, disable device interrupts
                ORRCC   tmp, tmp, r1                    ; else ensure they are enabled
                STRB    tmp, [r3, #IOCIRQMSKA]

                BICCC   lr, lr, #C_bit
                ORRCS   lr, lr, #C_bit
                RestPSR lr,,c                           ; restore FIQs
        ]

                STRCS   byte, ByteBuffer                ; remember the byte that couldn't be buffered
                LDRCSB  r0, IRQFlags
                ORRCS   r0, r0, #if_ReadHalted          ; set halted flag
                STRCSB  r0, IRQFlags
                EXITS   CS

                LDR     r2, HardwareBase
                LDRB    r0, [r2, #pp_ctrl]
                ORR     r1, r0, #pp_ctrl_strobe
                STRB    r1, [r2, #pp_ctrl]              ; acknowledge using STROBE

                LDRB    r1, [r2, #pp_ctrl]
                LDRB    r1, [r2, #pp_ctrl]              ; leave for at least 1탎

                ORR     r0, r0, #pp_ctrl_slctin :OR: pp_ctrl_autofd
                STRB    r0, [r2, #pp_ctrl]              ; remove STROBE and busy (SLCTIN and AUTOFD)

                EXITS



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; call: ioeb_resume
;
; If DeviceFS has failed to buffer a byte and returned above with C set then
; this entry point will eventually be called when the buffer has enough space.
; In the mean time the writer has not been acknowledged and its BUSY line has
; been left high so that it cannot send.
;

ioeb_resume     ALTENTRY                        ; needs to push same stuff as ioeb_irqread

                SETPSR  I_bit,lr                ; disable IRQs

                LDRB    r0, IRQFlags
                TST     r0, #if_ReadHalted
                EXITS   EQ,cf

                Debug   in,"Resuming RX"

                BIC     r0, r0, #if_ReadHalted
                STRB    r0, IRQFlags

                LDR     byte, ByteBuffer        ; get the byte we couldn't buffer
                B       buffer_byte             ; try again

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_ioctl
;
; this implements the io control call as implemented in the serial device. At
; present this implements calls used to get the DEVICE ID, the current port
; status byte and the device status (read using reverse nibble transfer).
;
; entry. r3 => IOCtl block
; exit. registers preserved, IOCtl block updated (see below)
ioeb_ioctl
                ROUT
                Entry "r0, r4-r8"

                LDRB    r5, [r3, #2]                    ; get the group byte

                Debug   ioctl, "ioeb_ioctl, group = ", r5

                LDR     r6, =ioctl_group_parallel       ; make sure we are in the right group
                CMP     r6, r5
                BNE     ioctl_error

                LDRB    r5, [r3, #3]
                TST     r5, #ioctl_header_read           ; read flag must be set
                BEQ     ioctl_error

                LDR     r5, [r3]
                LDR     r0, =ioctl_reason_mask
                AND     r5, r5, r0                      ; the least significant half word is the reason

                Debug   ioctl, "           reason = ", r5

                SUBS    r5,r5,#1                        ; we do not have reason code 0, so return an error
                BMI     ioctl_error                     ; if this is what is wanted

                CMP     r5, #(%FT20-%FT10)/4
                ADDCC   pc, pc, r5, LSL #2              ; despatch the call
                B       ioctl_error

10
                B       ioctl_device_id_size
                B       ioctl_device_id_data
                B       ioctl_status
                B       ioctl_revnibble_size
                B       ioctl_revnibble_data
20

; returns the status byte in the data field of the IOCtl block
ioctl_status
                LDR     r6, HardwareBase
                LDRB    r7, [r6, #pp_stat]
                STR     r7, [r3, #4]
                B       ioctl_ret

; entry. -
; exit.  returns the size of the Device ID string in the data field of the IOCtl block
;        NB. this call only works if the printer allows us to abort reverse nibble transfer
;            mode after reading the size bytes. Canon printers do, the HP LJ5 printer, for
;            instance, does not. In practice, IOCTL_DEVICE_ID_DATA should be used instead
;            (with a generous buffer).
ioctl_device_id_size
                MOV     r8,#extensibility_request_device_id
                B       %FT30

; entry. -
; exit.  returns the size of the reverse nibble data in the data field of the IOCtl block
;        NB. This call only works if the printer passes the status data including two size bytes as
;            when reading the Device ID. Canon printers do this, but HP printers, for instance, do not!
;            This call was mainly added to provide a similar interface to reading the device ID. In
;            practice, it should not be used and IOCTL_REVNIBBLE_DATA should be used instead with a
;            generous buffer.
ioctl_revnibble_size
                MOV     r8,#extensibility_request_revnibble
30
                MOV     r7,#2                           ; to read the size read only two bytes
                ADD     r6, r3, #4                      ; r6 is the address of the data
                MOV     r4, #0                          ; set up the amount read
                STR     r4, [r3, #4]                    ; set the size to zero

                BL      IEEE1284_negotiate
                BVS     ioctl_error_xlate
                STR     r4, [r3, #4]                    ; store the size read in the IOCtl buffer
                B       ioctl_ret

; entry. the data field of the IOCtl block contains the size of the buffer starting from the beginning
;        of the data field
; exit.  returns the Device ID starting from the beginning of the data field (including the two size
;        bytes) - if the size passed in was too small, only that amount is read, no error is returned
;        in this case
ioctl_device_id_data
                MOV     r8,#extensibility_request_device_id
                LDR     r7, [r3, #4]                    ; load the beginning of the data (size)
                CMP     r7, #2
                BCC     ioctl_error                     ; make sure the size is at least the size field

                ; r7 = size to read
                ADD     r6, r3, #4                      ; r6 is the address of the data
                MOV     r4, #0                          ; set up the amount read
                STR     r4, [r3, #4]                    ; set the size to zero

                BL      IEEE1284_negotiate
                BVS     ioctl_error_xlate
                B       ioctl_ret

; entry. the data field of the IOCtl block contains the size of the buffer starting after the data field
;        (NB. this is different from ioctl_device_id_data)
; exit.  returns the reverse nibble transfer data starting after the end of the data field (including the
;        two size bytes) - if the size passed in was too small, only that amount is read and the size
;        field is updated to the actual size, no error is returned in this case
;        NB. This call only works if the printer passes the status data including two size bytes as for
;            the Device ID. Canon printers do this, but HP printers, for instance, do not!
ioctl_revnibble_data
                MOV     r8,#extensibility_request_revnibble
                LDR     r7, [r3, #4]                    ; load the beginning of the data (size)
                CMP     r7, #2
                BCC     ioctl_error                     ; make sure the size is at least the size field

                ; r7 = size to read
                ADD     r6, r3, #8                      ; r6 is the address of the data
                MOV     r4, #0                          ; set up the amount read
                STR     r4, [r3, #4]                    ; set the size to zero

                BL      IEEE1284_negotiate
                BVS     ioctl_error_xlate
                STR     r4, [r3, #4]                    ; store the size field in the IOCtl buffer
ioctl_ret
                EXIT
ioctl_error
                ADRL    r0, ErrorBlock_Parallel_BadParm ; this must be set
ioctl_error_xlate
                [ international
                BL      MakeError
                |
                SETV
                ]
                STRVS   r0, [sp, #Proc_RegOffset]
                EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: IOEB_ReadDataStatus
;
; in:   r0 = 0
;
; out:  r0 preserved
;       r1 = contents of data register
;       r2 = contents of status register
;
; This routine reads the contents of the data and status registers.
;

IOEB_ReadDataStatus
                EntryS

                LDR     r1, HardwareBase

                SETPSR  I_bit,r2                        ; disable IRQs

                LDRB    r2, [r1, #pp_stat]
                LDRB    r1, [r1, #pp_data]

                EXITS   ,cf

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: IOEB_WriteData
;
; in:   r0 = 1
;       r1 = data to be written
;
; out:  r0 preserved
;       r1 preserved
;
; This routine writes the contents of the data register.
;

IOEB_WriteData
                Entry

                LDR     lr, HardwareBase        ; no need to disable IRQs
                STRB    r1, [lr, #pp_data]      ; it's atomic

                EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: IOEB_ReadWriteCtrl
;
; in:   r0 = 2
;       r1  = EOR mask
;       r2  = AND mask
;
; out:  r0 preserved
;       r1 = old state
;       r2 = new state
;
; This routine will read/write the control register based on the AND and EOR
; values specified.
;
; ctrl = (ctrl AND r2) EOR r1
;

IOEB_ReadWriteCtrl
                EntryS  "r0"

                LDR     r0, HardwareBase

                SETPSR  I_bit, lr                               ; disable IRQs

                LDRB    lr, [r0, #pp_ctrl]
                AND     r2, lr, r2
                EOR     r2, r2, r1                              ; r2 = new state of control reg
                STRB    r2, [r0, #pp_ctrl]                      ; update control register
                MOV     r1,lr

                EXITS   ,cf

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: UpdateIOEBCtrl
;
; in:   r0  = EOR mask
;       r1  = AND mask
;
; out:  -
;
; This routine will adjust the control register based on the AND and EOR
; values specified.
;
; control = (control AND r1) EOR r0
;

 [ HAL
; On HAL this routine gets copied into our workspace, to allow it to be called
; by user code without R12 being set up
UpdateIOEBCtrlProto
                EntryS  "r2"

                SETPSR  I_bit,r2                                ; disable IRQs

                LDR     r2, UpdateIOEBCtrlProto-(:INDEX:UpdateIOEBCtrl-:INDEX:HardwareBase)
 |
UpdateIOEBCtrl  EntryS  "r2"

                SETPSR  I_bit,r2                                ; disable IRQs

                LDR     r2, HardwareBase
 ]
                LDRB    lr, [r2, #pp_ctrl]
                AND     lr, lr, r1
                EOR     lr, lr, r0                              ; lr = new state of control reg
                STRB    lr, [r2, #pp_ctrl]                      ; update control register (hardware)

                EXITS   ,cf                                     ; exit, restoring original IRQ state
 [ HAL
UpdateIOEBCtrlProtoEnd
        ! 0, "UpdateIOEBCtrlProto is ":CC:(:STR:(UpdateIOEBCtrlProtoEnd-UpdateIOEBCtrlProto)):CC:" bytes"
        ASSERT UpdateIOEBCtrlProtoEnd-UpdateIOEBCtrlProto <= UpdateIOEBCtrlSize
 ]

; This method implements section 7.4 of the IEEE std 1284-1994 specification.
;
; entry. r6 => buffer to write to
;        r7 = size to read (including the two size bytes)
;        r8 = extensibility request value
; exit.  VS if error
;          r0 => error block (not translated)
;        VC if success
;          r4 = amount of data read
IEEE1284_negotiate
                ROUT
                Entry "r0-r3,r5,r9-r10"

                Debug   ioctl, "IEEE1284_negotiate = ", r7

; check if there is an OS_CallAfter pending. We don't want it trying to send data in the middle of reverse nibble!
                LDR     r0, IRQFlags
                TST     r0, #if_PendingCallAfter
                BEQ     %FT01
                ADRL    r0, ioeb_busy_check_callafter
                MOV     r1, wp
                SWI     XOS_RemoveTickerEvent
                EXIT    VS
                
01
                MOV     r9, r6                  ; keep initial buffer pointer
                LDR     lr, HardwareBase
                LDRB    r5, [lr, #pp_ecr]       ; make sure we are in compatability mode
                                                ; r5 must be preserved for negotiate_finalise below!

                [  FastCentronics               ; if we are in fast mode get out of it first
                TST     r5, #pp_ecr_flag_FIFO
                TSTNE   r5, #pp_ecr_empty
                BEQ     %FT05                   ; not in fast mode or FIFO empty, so we can go on
                Debug   ioctl_err, "FPar in use"
                ADRL    r0, ErrorBlock_Parallel_InUse
                STR     r0, [sp, #Proc_RegOffset]
                SETV
                EXIT
                ]

05
                MOV     r0, #pp_ecr_default     ; mode 001 as we may want to tri-state the data lines
                STRB    r0, [lr, #pp_ecr]       ; this sets the combo into compatability mode (turns FIFO off)

                Debug   ioctl, "init"

                LDR     r2, HardwareBase        ; r2 always contains the address of the hardware

                LDRB    r10, [r2, #pp_ctrl]     ; keep original ctrl byte value

; ensure interrupts are off and wait for everything to stabilise
                MOV     r0, r10
                BIC     r0, r0, #pp_ctrl_irqen
                STR     r0, [r2, #pp_ctrl]
; Failure rates per 10000 tries
; Delay     K80      930C
; 0            5     Freezes (power up needed)
; 5us         10     Freezes (escape worked. At write zeroes to printer)
; 10us        20
; 15us        10
; 1.3ms       22     As for 5us
                 LDR    r0, LoopFactor         ; 40us
                 MOV    r0, r0, LSL#5          ; 1.3ms
09               SUBS   r0, r0, #1
                 BNE    %B09
; things should now be stable so it should be safe to carry on

                LDRB    r0, [r2, #pp_data]
                ORR     r10, r10, r0, lsl#8     ; keep original data byte value

                MOV     r0, #pp_ctrl_default
                STRB    r0, [r2, #pp_ctrl]      ; pull the strobe line up
                STRB    r8, [r2, #pp_data]      ; set the data to Extensibility Request Value - event # 0

                PulseDelay lr                   ; make sure the data is stable before event # 1

                ORR     r0, r0, #pp_ctrl_autofd
                BIC     r0, r0, #pp_ctrl_slctin
                STRB    r0, [r2, #pp_ctrl]      ; set the stimulus event 1.

                LDR     r0, LoopFactor          ; wait for peripheral response
                MOV     r0, r0, LSL #10         ; 40 us * &400 = ~40ms
10
                LDRB    r3, [r2, #pp_stat]      ; negotiation phase, load status
;                TST     r3, #pp_stat_error
;                TSTNE   r3, #pp_stat_pe
;                BNE     %FT20                   ; IEEE 1284 compatabiility
                AND     r3, r3, #extensibility_acknowledge_mask
                CMP     r3,     #extensibility_acknowledge_value 
                BEQ     %FT20
                SUBS    r0, r0, #1
                BGT     %BT10

                Debug   ioctl, "1284 failed, status = ", r3
                B       negotiate_error         ; device is not IEEE 1284 compatible
20
                Debug   ioctl, "1284 OK ", r3

                PulseDelay r0                   ; delay before strobing the data

                LDRB    r3, [r2, #pp_ctrl]      ; event 3 pull strobe down
                ORR     r3, r3, #pp_ctrl_strobe
                STRB    r3, [r2, #pp_ctrl]

                PulseDelay r0                   ; delay for 5 us to ensure the peripheral sees it.

                BIC     r3, r3, #pp_ctrl_autofd :OR: pp_ctrl_strobe
                STRB    r3, [r2, #pp_ctrl]      ; event 4 on map

; Events 5 and 6.
                LDR     r0, LoopFactor
                MOV     r0, r0, LSL #10          ; ~40ms. In practice a lot more as register r/w is slow.
22
                LDR     r3, [r2, #pp_stat]       ; Load status
                TST     r3, #pp_stat_ack         ; Step 6. Wait for nAck to go high. Step 5 values valid.
                BNE     %FT23
                SUBS    r0, r0, #1
                BGT     %BT22                    ; time out
                Debug   ioctl_err, "1284 t/o (step 6)"
                B       negotiate_error
23
                ; check that we have a positive responce. Required XFlag(slct) value depends on extensibility type.
                ; cf 1284-2000 table 4
                TEQ     r8, #extensibility_request_revnibble
                EOREQ   r3, r3, #pp_stat_slct   ; toggle SLCT bit if required
                TST     r3, #pp_stat_slct       ; if set then success
                BNE     %FT28
                
                Debug   ioctl_err, "1284 t/o (XFlag)"
                B       negotiate_error

28
                Debug   ioctl, "XFlag OK"

                ; Negotiate phase now successfully completed 
                ; OK, we have entered a valid state, so if anything goes wrong now, we have to
                ; use the full handshake termination protocol

                ; read data from peripheral, the data transfer phase
50
                Debug   ioctl_loop, "read loop, r4 = ", r4

                LDRB    r3, [r2, #pp_stat]      ; main read loop
                TST     r3, #pp_stat_error      ; determine if there is data to read
                BNE     negotiate_tidy          ; no data left

                BL      reverse_nibble_read     ; read the byte

                BVS     negotiate_error         ; if an error occurred while reading a nibble, this was not while
                                                ; being in a valid state, so we use the immediate abort strategy

                Debug   ioctl_loop, "nibble read = ", r0

                STRB    r0, [r6, r4]            ; this stores the data at the buffer including the first two bytes

                ADD     r4, r4, #1
                CMP     r4, r7
                BLT     %BT50

                ; The buffer is full
                Debug   ioctl, "Buffer full r8 = ", r8

                ; we return the size field in r4
                LDRB    r0, [r9]                ; read MSB of size
                LDRB    lr, [r9, #1]            ; read LSB of size
                ORR     r4, lr, r0, lsl#8       ; r4 = size
                Debug   ioctl, "New size field ", r4

negotiate_tidy
                ; the handshake termination sequence
                ; we should only end up here if the protocol is in a valid state (IEEE1284-2000, section 7.7)
                LDRB    r3, [r2, #pp_stat]      ; we have to take note of the current SLCT status
                AND     r14, r3, #pp_stat_slct

                LDRB    r3, [r2, #pp_ctrl]
                ORR     r3, r3, #pp_ctrl_slctin ; event 22
                BIC     r3, r3, #pp_ctrl_autofd ; this should be the case already, but just to be sure...
                STRB    r3, [r2, #pp_ctrl]

                ; we wait for the peripheral's response
                LDR     r0, LoopFactor          ; wait for peripheral response
                MOV     r0, r0, LSL #10
60
                LDRB    r3, [r2, #pp_stat]
                EOR     r3, r3, #pp_stat_notbusy    ; change notbusy to BUSY
                TST     r3, #pp_stat_error      ; wait for ERROR to come up
                TSTNE   r3, #pp_stat_notbusy    ; and BUSY to come up, too
                BNE     %FT70
                SUBS    r0, r0, #1
                BGT     %BT60

                Debug   ioctl_err, "ERR BUSY t/o"
                B       negotiate_finalise      ; immediate abort
70
                ; OK, now we wait for event 24 (no stimulus inbetween)
                LDR     r0, LoopFactor          ; wait for peripheral response
                MOV     r0, r0, LSL #10
80
                LDRB    r3, [r2, #pp_stat]
                EOR     r3, r3, #pp_stat_ack    ; invert nACK for NE test below
                EOR     r3, r3, r14             ; eor with initial SLCT status - if the bit is still the same as
                                                ; before, it is clear now, or set if it has been flipped
                TST     r3, #pp_stat_ack        ; wait for nACK to go low (i.e., inverted bit is set now)
                TSTNE   r3, #pp_stat_slct       ; and SLCT to be flipped
                BNE     %FT90
                SUBS    r0, r0, #1
                BGT     %BT80

                Debug   ioctl_err, "nACK low SLCT flip t/o"
                B       negotiate_finalise      ; immediate abort
90
                LDRB    r3, [r2, #pp_ctrl]
                ORR     r3, r3, #pp_ctrl_autofd ; event 25
                STRB    r3, [r2, #pp_ctrl]

                LDR     r0, LoopFactor          ; wait for peripheral response
                MOV     r0, r0, LSL #10
100
                LDRB    r3, [r2, #pp_stat]
                TST     r3, #pp_stat_ack        ; wait for nACK to go high (event 26)
                BNE     %FT110
                SUBS    r0, r0, #1
                BGT     %BT100

                Debug   ioctl_err, "nACK high t/o"

                ; this last check was only for the sake of completeness
                ; we are at the end of the protocol and will return to compatibility mode anyway
110
                ; OK, we did it! We are back in compatibility mode.
                ; All we have to do now is to clear pp_ctrl_autofd (set nAutoFd high, event 28),
                ; but this will be done using pp_ctrl_default below.
                Debug   ioctl, "Terminated OK"
                CLRV

negotiate_finalise
                ; V flag denotes error condition - must be preserved until EXIT
                STRB    r5, [r2, #pp_ecr]       ; tidyup restore the ecr state to what it was.

                ; if we have just gone through the full termination handshake, the following stimulus performs
                ; event 28 (nAutoFd high), else it indicates an immediate abort because it sets pp_ctrl_slctin
                ; (nSelectIn low)
                MOV     r5, #pp_ctrl_default
                STRB    r5, [r2, #pp_ctrl]

; The following assumes the SuperIO chip has IOTCR set for TypeB cycles (7 ticks of 16MHz IO clock => 437.5ns)
; hence a read of any non read sensitive register will waste 0.5us ish

                LDRB    lr, [r2, #pp_delay]     ; a slight delay

                MOV     r0, r10, lsr#8          ; get original data byte value back
                STRB    r0, [r3, #pp_data]      ; and restore it
                STRB    r10, [r2, #pp_ctrl]     ; restore the original ctrl byte

                LDR     r0, IRQFlags            ; check to see if we need to put back a CallAfter
                TST     r0, #if_PendingCallAfter
                BEQ     %FT120
                LDR     r0, =RevNibBusyCheckInterval    
                ADRL    r1, ioeb_busy_check_callafter
                MOV     r2, wp
                SWI     XOS_CallAfter
120

; but during output, a nAck may have been missed, in which case the stream will stall
; so check that there is an output stream, and if busy is clear, call ioeb_wakeupTX

                LDR    r0, Flags
                TST    r0, #f_OpenForWrite
                BLNE   ioeb_wakeupTX            ; there is an output stream
                Debug   ioctl, "negotiate_ret"

                EXIT

; wait for buffers to empty
;
; waits for both os and hardware buffers to empty
; times out if no characters fetched in 30s
; checks escape state and returns escape error if set
; entry. None.
; exit. VS if error
;         r0 => error block
;       VC if success
;         all registers preserved

; wait_for_buffers_to_empty
;                 ROUT
;                 Entry "r0-r9"
; 
; 10              SWI     XOS_ReadMonotonicTime
;                 ADD     r7, r0, #&BC0          ; ~30 seconds in cs  (30.08s)
;                 MOV     r8, #0                 ; used to store the number of characters in the buffer
;                 LDR     r9, =pp_stat           ; pointer to status register
; 20
;         ; is the printer error free?
;                 LDRB    r0, [r9]
;                 TST     r0, #pp_stat_error
;                 ADREQL  r0, ErrorBlock_Parallel_OtherError
;                 BEQ     %99
; 
;         ; user run out of patience? Check escape state
;                 SWI     XOS_ReadEscapeState
;                 ADRCSL  r0, ErrorBlock_Escape
;                 BCS     %98
; 
;         ; have we been here a stupidly long time?
;                 SWI     XOS_ReadMonotonicTime
;                 BVS     %99
;                 CMP     r7, r0
;                 ADRLTL  r0, ErrorBlock_Parallel_OtherError
;                 BLT     %98
; 
;         ; anything in the OS buffer PRM 4-97
;                 LDR     r0, BufferHandle
;                 SWI     XBuffer_GetInfo
;                 BVS     %99
;                 CMP     r6, #0
;                 BEQ     %30                         ; os buffer is empty
; 
;         ; are characters still departing?
;                 CMP     r6, r8                      ; always false first time round, but that doesn't matter
;                 MOV     r8, r6                      ; remember the number of characters in the buffer
;                 BNE     %10                         ; characters are going, so reset timeout
;                 B       %20                         ; no character gone, so don't reset the timeout
; 
; 30      ; is the hardware buffer in use, and if so, is it empty
;                 LDR     r5, =pp_ecr
;                 LDRB    r5, [r5]
;                 TST     r5, #pp_ecr_flag_FIFO       ; in fast mode?
;                 BEQ     %40                         ; it is not in use, so carry on
;                 TST     r5, #pp_ecr_empty           ; buffer empty?
;                 BEQ     %20                         ; not empty, so go round again
;                 
; 40      ; normal exit
;                 EXIT
; 
; 98      ; our error exit point
;                 SETV
; 99      ; external error exit point
;                 STR     r0, [sp, #Proc_RegOffset]
;                 EXIT


negotiate_error
                Debug   ioctl_err, "negotiate_error"
                ; NB. we return an untranslated error block, it will be translated by the caller
                ADRL    r0, ErrorBlock_Parallel_BadHardware     ; timeout
                SETV
                STR     r0, [sp, #Proc_RegOffset]
                B       negotiate_finalise

; entry.
;         r2 = HardwareBase, byte address
; exit. VS = error
;         r0 => error block (not translated)
;       VC = success
;         r0 = byte as read from peripheral

reverse_nibble_read
                ROUT
                Entry   "r3-r5"

                Debug   nibble, "Reverse nibble read"

                LDRB    r3, [r2, #pp_ctrl]
                ORR     r3, r3, #pp_ctrl_autofd                 ; pull the autofd line down
                STRB    r3, [r2, #pp_ctrl]

                LDR     r4, LoopFactor                          ; maximum of 35 milliseconds peripheral response
                MOV     r4, r4, LSL #10                         ; 40 us * 1000 ~=(&400)
50
                LDRB    r3, [r2, #pp_stat]
                TST     r3, #pp_stat_ack                        ; wait for data, ack low
                BEQ     %FT55
                SUBS    r4, r4, #1
                BGT     %BT50

                Debug   nibble_err, "ACK low t/o ", r3
                B       nibble_error
55
                Debug   nibble, "ACK low, stat = ", r3
                LDRB    r4, [r2, #pp_stat]                      ; read the first nibble from the status byte
                AND     r0, r4, #pp_stat_pe :OR: pp_stat_slct :OR: pp_stat_error ; find bits 2, 1 and 0 resp. masked as 5, 4 & 3
                MOV     r0, r0, LSR #3
                TST     r4, #pp_stat_notbusy                    ; see if bit seven is set
                ORREQ   r0, r0, #&08                            ; make that bit 3

                LDRB    r3, [r2, #pp_ctrl]                      ; pull the autofd up again first nibble complete
                BIC     r3, r3, #pp_ctrl_autofd
                STRB    r3, [r2, #pp_ctrl]

                LDR     r4, LoopFactor                          ; wait for ack to come back up again
                MOV     r4, r4, LSL #10
65
                LDRB    r3, [r2, #pp_stat]
                TST     r3, #pp_stat_ack                        ; wait for data
                BNE     %FT70
                SUBS    r4, r4, #1
                BGT     %BT65

                Debug   nibble_err, "ACK high t/o ", r3
                B       nibble_error
70
                Debug   nibble, "ACK high, stat = ", r3

                LDRB    r3, [r2, #pp_ctrl]                      ; ready to read the second nibble, similar cycle as above
                ORR     r3, r3, #pp_ctrl_autofd                 ; pull the autofd line down
                STRB    r3, [r2, #pp_ctrl]

                LDR     r4, LoopFactor
                MOV     r4, r4, LSL #10
75
                LDRB    r3, [r2, #pp_stat]
                TST     r3, #pp_stat_ack                        ; wait for the lowering of the ack
                BEQ     %FT80
                SUBS    r4, r4, #1
                BGT     %BT75

                Debug   nibble_err, "ACK low2 t/o ", r3
                B       nibble_error
80
                Debug   nibble, "ACK low2, stat = ", r3
                LDRB    r4, [r2, #pp_stat]
                TST     r4, #pp_stat_notbusy                    ; see if bit seven is set
                ORREQ   r0, r0, #&80
                AND     r3, r4, #pp_stat_pe :OR: pp_stat_slct :OR: pp_stat_error ; find bits 2, 1 & 0, masked as 5 , 4 & 3
                ORR     r0, r0, r3, LSL #1                      ; set the top nibble

                LDRB    r3, [r2, #pp_ctrl]
                BIC     r3, r3, #pp_ctrl_autofd
                STRB    r3, [r2, #pp_ctrl]

                LDR     r4, LoopFactor
                MOV     r4, r4, LSL #10
85
                LDRB    r3, [r2, #pp_stat]
                TST     r3, #pp_stat_ack                        ; wait for the raising of the ack
                BNE     %FT90
                SUBS    r4, r4, #1
                BGT     %BT85

                Debug   nibble_err, "ACK high2 t/o ",r3
                B       nibble_error
90
                Debug   nibble, "ACK high2, stat = ",r3
                EXIT
nibble_error
                Debug   nibble_err, "nibble error"

                ; NB. we return an untranslated error block, it will be translated above
                ADRL    r0, ErrorBlock_Parallel_BadHardware     ; timeout
                SETV
                EXIT

                END
