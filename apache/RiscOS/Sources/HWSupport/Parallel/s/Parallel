; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Parallel

; *******************
; *** Change List ***
; *******************

; 20-Jan-91 0.10 DDV Parallel device created, new style.
; 22-Jan-91      DDV Tidied the handling of finalise.
; 23-Jan-91      DDV Now traps Service_DeviceFSStarting/Dying.
; 23-Jan-91 0.11 DDV Calls to register to cope with new scheme.
; 25-Jan-91 0.12 DDV Fixed twee problem that stopped it printing.
; 29-Jan-91      DDV Setup so that validation strings generate an error.
; 15-Feb-91      DDV Checks made for hardware configuration.
; 17-Feb-91      DDV Device init functions added to allow devices to reset hardware.
; 17-Feb-91 0.13 DDV Semi-working 82C710 output routine added.
; 19-Feb-91      DDV IRQ routine for 82C710 improved.
; 20-Feb-91 0.14 DDV Finished changes to IRQ routine.
; 27-Feb-91      DDV Tweeked 827C10 interrupt routine changed, now uses Busy as IRQ source.
; 27-Feb-91      DDV Now sets up PrinterType$1 to use parallel:Output
; 27-Feb-91      DDV Added 'buffer,n' to validation string so kernel can specify which buffer to use.
; 27-Feb-91      DDV Removed IEOB input conditions.
; 28-Feb-91      DDV Validation string changed + default system var.
; 06-Mar-91      DDV Added configure/status command for buffer size.
; 06-Mar-91      DDV Reads CMOS bits for buffer size on module init.
; 06-Mar-91 0.15 DDV Handles value from special field correctly.
; 07-Mar-91      DDV Bug fix; CMOS read no longer corrupts all registers.
; 07-Mar-91      DDV Bug fix; DeviceFS table for IOEB now has miscop entry correctly placed.
; 07-Mar-91      DDV Contents of PrinterType$1 changed to include buffer handle.
; 07-Mar-91 0.16 DDV Bug fix; Decode of special field now gets buffer handle correctly.
; 07-Mar-91      DDV Bug fix; IOC IRQ busy routine checked the IRQ mask not IRQ status.
; 08-Mar-91      DDV Removed configure command for buffers.
; 11-Mar-91      DDV Added calls to Buffer_Unlink device to ensure buffer free'd.
; 11-Mar-91 0.17 DDV When DeviceFS starting service is recieved it will use SWIs, not call addresses.
; 12-Apr-91      DDV Internationalised.
; 12-Apr-91      DDV Added machine type checking.
; 12-Apr-91      DDV Added Parallel_HardwareAddress SWI.
; 12-Apr-91      DDV Clearing edge triggered interrupt on 710 added.
; 12-Apr-91      DDV Split again into some more useful files.
; 12-Apr-91      DDV Intergration with new DeviceFS
; 13-Apr-91 0.18 DDV Added new parameter to return IOEB update address.
; 17-Apr-91      DDV Tightened up coding for internationalisation.
; 18-Apr-91 0.19 DDV Bug fix; fixed stack inbalance.
; 21-Apr-91      DDV Changed to use IOEB binding for PINTR
; 21-Apr-91      DDV Now traps Service_DeviceDead.
; 21-Apr-91 0.20 DDV Changed system variable being used.
; 01-May-91 0.21 DDV Changed to cope with Jon's changes in special fields.
; 03-May-91 0.22 DDV Moved clear of the PINTR latch to end of IRQ routine.
; 16-Jul-91 0.23 TMD Made unknown SWI use global message.
;                    Recoded IRQ routines.
; 22-Jul-91 0.24 TMD Moved clearing of printer acknowledge to inside strobe
;                    routine (ie its now also called from dormant state).
;                    This is to clear any fake acknowledge signals caused by
;                    printer power-on.
; 30-Jul-91 0.25 TMD Put in CallAfters to poll busy when dormant.
;                    Improved strobe timing (doesn't use timers any more -
;                    they took too long)
; 31-Jul-91 0.26 TMD Changed device record to add reserved field
;                    Service_Reset code only executed on soft reset
; 08-Aug-91 0.27 TMD Fixed bug in SWI despatch
;                    Fixed bug in busy callafter code (was removing callafter without saving lr_svc)
; 22-Aug-91 0.28 TMD Base of errors changed
;                    Put in code that recognises 82C711
; 20-Nov-91 0.29 TMD Changed code that recognises 710/711 to check parallel sub-unit type
; 05-Dec-91 0.30 SMC Added parallel input stream
;                    Added SWI Parallel_Op
; 13-Dec-91 0.31 SMC Now only uses one local error message, the rest are global.
; 03-Feb-92 0.32 JSR Adjust service call entry for changed Service_MessageFileClosed.
; 02-Mar-92 0.33 TMD Added option to check busy after acknowledge pulse.
;                    Tidied up a few atomicity failures.
; 17-Mar-92 0.34 TMD Made it poll busy 20 times before rescheduling, for printers where
;                    busy always goes low after ack goes high.
; 21-Jun-93 0.35 SMC Now uses BufferManager service routines, not INSV/REMV.
;                    On read signal busy with nSlctIn and nAutoFd (for ECP cables).
;                    Created file Common to isolate files IOC, IOEB.
;                    Added file FastCent with driver for fastparallel: device (parallel FIFO).
; 29-Jun-93 0.36 SMC On IOMD based platforms clear PINTR in IRQCLRA, not using PINTR_Latch.
; 14-Jul-93 0.37 SMC OS_ReadSysInfo interface changed.
; 31-Aug-93 0.38 SMC Set ECR before CTRL as they are the same register in standard mode.
; 13-Dec-93 0.39 SMC Time out when waiting for PACK high after interrupt (prevent hang on printer off).
; 21-Jan-94 0.40 SMC Create for TX/RX should only have set the buffer id to 3 if it was -1.
; 20-Jul-94 0.41 RCM Added power saving code (active ONLY for portables) see StorkPower flag.
; 26-Jul-94 0.42 RCM Added conditional assembly flags OldHardware & NewHardware.
;                    Set OldHardware to false to save ROM space for RO Black.
; 13-Aug-94 0.43 ??? ??????????
; 18-Mar-97 0.44 JIFL Added timing loop function common_get_loop_factor to
;                     ensure processor speed independence
; 23-Apr-97 0.45 BAL Fixed bug where IOEB halt and resume routines were corrupting R3
;        (ARTtmp)
; 29 Apr 97 0.45 JRC Calculate loop factor in init code; added Paper, OnLine, Printer message tokens;
;        (Spinner)   make appropriate upcalls in ioeb_monitorTX when paper out etc; use
;                    ParallelDeviceDriver$Path for resources; added 'j' debug flag.
; 16 May 97 0.46 KJB Two version 0.45s merged.
; 17 Aug 99 0.58 KJB Service call table added.
; 25 Oct 99 0.59 KJB Added support for version 2 parallel (just a different IRQ line).
; 26 Oct 99 0.60 KJB Completed interrupt changes.
; 1  Nov 00 0.63 AR  added device discovery
; 20 Jul 01      MW  added advanced error handling support (UpCall_DeviceError)

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                GET     Hdr:ListOpts
                GET     Hdr:Macros
                GET     Hdr:System
                GET     Hdr:ModHand
                GET     Hdr:FSNumbers
                GET     Hdr:NewErrors
                GET     Hdr:Services
                GET     Hdr:Symbols
                GET     Hdr:NDRDebug
                GET     Hdr:HostFS
                GET     Hdr:Proc
                GET     Hdr:DevNos
                GET     Hdr:PublicWS
                GET     Hdr:DDVMacros
                GET     Hdr:Buffer
                GET     Hdr:DeviceFS
                GET     Hdr:Machine.<Machine>
                $GetIO
                GET     Hdr:IO.IOEB
                GET     Hdr:MsgTrans
                GET     Hdr:ResourceFS
                GET     Hdr:Portable
                GET     Hdr:UpCall
                GET     Hdr:OSBytes
        [ HAL
                GET     Hdr:HALEntries
        ]

                GBLL    debug
                GBLL    hostvdu
                GBLL    international
                GBLS    debug_file

                GBLL    CheckBusyAfterAck       ; whether to check busy after acknowledge pulse

CheckBusyAfterAck SETL  {TRUE}

                GBLL    FastBufferMan
FastBufferMan   SETL    {TRUE}

                GBLL    FastCentronics
FastCentronics  SETL    {TRUE}

                GBLL    StorkPower
StorkPower      SETL    {TRUE}                  ; try powering down the hardware when not in use

                GBLL    OldHardware             ; assemble code for old serial hardware?
OldHardware     SETL    {FALSE} ;{TRUE}         ; switched off to save space for RO Black

                GBLL    NewHardware             ; assemble code for new serial hardware (ie PC combo chips)
NewHardware     SETL    {TRUE}

                GBLL    AdvancedErrorHandling   ; use UpCall_DeviceError for error handling?
AdvancedErrorHandling   SETL {TRUE} :LAND: NewHardware ; advanced error handling only available with IOEB

; The following are defined because the new buffer manager interface uses r2 to
; insert and remove bytes whereas the old interface uses r0.
 [ FastBufferMan
tmp     RN      0
byte    RN      2
 |
byte    RN      0
tmp     RN      2
 ]

                GBLL    standalonemessages
 [ :DEF: standalone
standalonemessages SETL standalone
 |
standalonemessages SETL {FALSE}
 ]

debug           SETL    {FALSE}
hostvdu         SETL    {FALSE}
international   SETL    {TRUE}
debug_file      SETS    "Custom:Debug.parallel"

inter           SETD    {TRUE}
open            SETD    {TRUE}
close           SETD    {TRUE}
out             SETD    {TRUE}
in              SETD    {TRUE}
irq             SETD    {TRUE}
j               SETD    {TRUE}
ioctl           SETD    {FALSE}
nibble          SETD    {FALSE}
ioctl_err       SETD    {TRUE}
ioctl_loop      SETD    {FALSE}
nibble_err      SETD    {TRUE}
adverr          SETD    {FALSE}

                GET     VersionASM
                GET     Errors.s

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Macros
;

 [ FastBufferMan
; Calls buffer manager service routine (corrupts lr).
                MACRO
$label          CallBuffMan     $cc

$label          Push    "r12"                                   ; save our workspace ptr
                ADR$cc   r12, BuffManWkSpace                    ; place of buffman wkspace and entry
                MOV$cc   lr, pc                                 ; return address
                ASSERT  BuffManService = BuffManWkSpace+4
                LDM$cc.IA r12, {r12, pc}                        ; load buffman wkspace and entry
                Pull    "r12"                                   ; restore our workspace ptr

                MEND
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Device workspace.
;

                        ^ 0, wp
Flags                   # 1             ; global flags used by module, updated only in foreground
IRQFlags                # 1             ; flags updated from IRQs, or from foregd with IRQs off
DeviceNo                # 1             ; RISC OS device number
 [ :LNOT: HAL
InterruptBit            # 1             ; bit in InterruptClear and interrupt mask register
InterruptClear          # 4             ; address of interrupt clear register
 |
                        # 1             ; Padding
HAL_SB                  # 4             ; SB for HAL calls
HAL_IRQDisable          # 4             ; HAL_IRQDisable routine
HAL_IRQEnable           # 4             ; HAL_IRQEnable routine
HAL_IRQClear            # 4             ; HAL_IRQClear routine
 ]
BufferHandle            # 4             ; handle for read/write buffer
StreamHandle            # 4             ; handle for output data
DeviceHandle            # 4             ; handle for device (from DeviceFS)
HardwareType            # 4             ; hardware type
HardwareBase            # 4             ; hardware base address return by calls
ByteBuffer              # 4             ; place to hold byte which couldn't be buffered
 [ FastCentronics
FastHandle              # 4             ; handle for fast device
 ]
 [ FastBufferMan
BufferId                # 4             ; buffer managers iternal buffer id
BuffManWkSpace          # 4             ; buffer managers workspace pointer
BuffManService          # 4             ; address of buffer manager service routine
 ]
 [ StorkPower
portable_present        # 4             ;  = 0 if we don't think the Portable module is present
                                        ;  = 1 if we do
power_state             # 4             ;
 ]
                      [ international
MessagesWorkspace       # 16            ; block of workspace for opening message files
localerrorblock         # 256           ; do not use MessageTrans error block, as it gets trashed too easily
                      ]

LoopFactor              # 4             ; factor for tight loops giving a delay
                                        ; of 40 us

 [ AdvancedErrorHandling
FileSwitchHandle        # 4             ; file switch handle of current stream (undefined if no open stream)
 ]
 [ HAL
UpdateIOEBCtrlSize      * &38 ; Yuck
UpdateIOEBCtrl          # UpdateIOEBCtrlSize
 ]

wsrequired              * :INDEX: @


; constants about workspace

; Bits in Flags

f_VectorOwned           * 1:SHL:0       ; bit 0 set => IRQ vector owned
f_WeHaveMessages        * 1:SHL:1       ; bit 1 set => messages file loaded
f_OpenForRead           * 1:SHL:2       ; bit 2 set => open for read
f_OpenForWrite          * 1:SHL:3       ; bit 3 set => open for write
 [ FastCentronics
f_UseFIFO               * 1:SHL:4       ; bit 4 set => register fastparallel: device
 ]
 [ AdvancedErrorHandling
f_UpCallVectorClaimed   * 1:SHL:5       ; bit 5 set => UpCall vector has been claimed
 ]

; Bits in IRQFlags

if_PendingCallAfter     * 1:SHL:0       ; bit 0 set => pending CallAfter exists
if_ReadHalted           * 1:SHL:1       ; bit 1 set => input stream halted

; default flags for DeviceFS_Register
 [ NewHardware
dfsr_flags              * ParentFlag_MonitorTransfers ; Monitor TX/RX functions available
 |
dfsr_flags              * 0
 ]

hardware_IOC            * 0             ; which hardware type being used
hardware_IOEB           * 1
hardware_IOMD           * 2             ; similar to IOEB but has Pintr clear, not external latch

BusyCheckInterval       * 1            ; time between busy checks (centiseconds)
RevNibBusyCheckInterval * 1            ; delay before check following reverse nibble

Parallel_Threshold      * 1016

ParallelPowerBits       * PortableControl_ParallelEnable

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Now we have the module header, this defines all the entry points required
; for the module.
;

                AREA    |Parallel$$Code|, CODE, READONLY, PIC

Module_BaseAddr & 0
                & init -Module_BaseAddr                 ; init code
                & final -Module_BaseAddr                ; final code
                & service -Module_BaseAddr              ; service code

                & title -Module_BaseAddr                ; title string for module
                & help -Module_BaseAddr                 ; help string pointer
                & 0

                & ParallelSWI_Base
                & swicode -Module_BaseAddr
                & switable -Module_BaseAddr
                & 0

        [ :LNOT: No32bitCode
                & 0                                     ; international messages
                & moduleflags - Module_BaseAddr         ; flags
        ]

title           = "ParallelDeviceDriver",0
help            = "Parallel Device",9,"$Module_HelpVersion"
              [ debug
                = " Development version"
              ]
                = 0
                ALIGN

switable        = "Parallel", 0
                = "HardwareAddress", 0
                = "Op", 0
                = 0

                [       international
                !       0, "Internationalised version"
resource_file   =       "ParallelDeviceDriver:Messages", 0
                ]
                ALIGN

                MakeErrorBlock Parallel_BadCall
                MakeErrorBlock Parallel_BadHardware
                MakeErrorBlock Parallel_InUse
                MakeErrorBlock Parallel_PaperOut
                MakeErrorBlock Parallel_Offline
                MakeErrorBlock Parallel_OtherError

                MakeErrorBlock Escape
                
                ALIGN

        [ :LNOT: No32bitCode
moduleflags     DCD     ModuleFlag_32bit
        ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Now data passed to the device register call.
;

setsysvar       = "Set PrinterType$1 devices#buffer3:$."
devicename      = "Parallel", 0
 [ FastCentronics
fastname        = "FastParallel",0
 ]
                ALIGN

block
                & devicename -.         ; offset to device name
                & DeviceFlag_BufferedDevice+ DeviceFlag_DefinePathVariable ; flags
                & 0                     ; default RX buffer flags
                & 1024                  ; default RX buffer size
                & 0                     ; default TX buffer flags
                & 1024                  ; default TX buffer size
                & 0                     ; reserved field (must be zero)

                & 0                     ; end of list marker

 [ FastCentronics
fastblock
                & fastname -.           ; offset to device name
                & DeviceFlag_BufferedDevice+ DeviceFlag_DefinePathVariable ; flags
                & 0                     ; default RX buffer flags
                & 0                     ; default RX buffer size
                & 0                     ; default TX buffer flags
                & 1024                  ; default TX buffer size
                & 0                     ; reserved field (must be zero)

                & 0                     ; end of list marker
 ]

                ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setvar  =       "If ""<ParallelDeviceDriver$Path>"" = """" then "
        =       "Set ParallelDeviceDriver$Path Resources:$.Resources.Parallel."
        =       0 ;so lazy!

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Now we must handle the module init calls.
;

init            Entry   "r7"

                LDR     r2, [wp]
                TEQ     r2, #0                                  ; any workspace?
                BNE     %FT10                                   ; yes, so handle as warm start

                MOV     r0, #ModHandReason_Claim
                LDR     r3, =wsrequired
                SWI     XOS_Module                              ; claim it
                EXIT    VS                                      ; return if it errored

                STR     r2, [wp]
10
                MOV     wp, r2                                  ; wp -> workspace

                [       debug
                Debug_Open debug_file
                ]

                Debug   j, "initialised"

        [ standalonemessages
                ADR     r0, resourcefsfiles
                SWI     XResourceFS_RegisterFiles   ; ignore errors (starts on Service_ResourceFSStarting)
        ]

                ADR     r0, setvar
                SWI     XOS_CLI
                EXIT    VS

                MOV     r0, #0                                  ; zap workspace
                STRB    r0, Flags
                STRB    r0, IRQFlags
                STR     r0, StreamHandle
                STR     r0, DeviceHandle
                STR     r0, BufferHandle
                STR     r0, HardwareBase
                BL      common_get_loop_factor
        [ FastCentronics
                STR     r0, FastHandle
        ]
        [ FastBufferMan
                STR     r0, BufferId
                STR     r0, BuffManService
                STR     r0, BuffManWkSpace
        ]

        [ HAL
                Push    "r8,r9"
                MOV     r8, #OSHW_LookupRoutine
                MOV     r9, #EntryNo_HAL_IRQDisable
                SWI     XOS_Hardware
                STR     r0, HAL_IRQDisable
                STR     r1, HAL_SB
                MOV     r9, #EntryNo_HAL_IRQEnable
                SWIVC   XOS_Hardware
                STR     r0, HAL_IRQEnable
                MOV     r9, #EntryNo_HAL_IRQClear
                SWIVC   XOS_Hardware
                STR     r0, HAL_IRQClear
                Pull    "r8,r9"
                EXIT    VS
        ]

                MOV     r0, #2                                  ; read machine information
                SWI     XOS_ReadSysInfo
                EXIT    VS                                      ; return any errors generated

                BIC     r0, r0, #&FF :SHL: 24                   ; not interested in video controller
                BIC     r0, r0, #&FF :SHL: 16                   ; or memory controller
                AND     r1, r1, #&FF                            ; only interested in I/O chip type

 [ OldHardware
                TEQ     r0, #&0000                              ; is it an A1 series machine?
                MOVEQ   r0, #hardware_IOC
                BEQ     %20
 ]
 [ NewHardware
                TEQ     r0, #&0001                              ; has it got IOEB
                TEQNE   r0, #&0100                              ; or IOMD
                TEQEQ   r1, #&01                                ; and an 82C710/711 (or similar)
                BNE     %15                                     ; no, so report error

                TEQ     r0, #&0001
                MOVEQ   r7, #hardware_IOEB
                MOVNE   r7, #hardware_IOMD
        [ :LNOT: HAL
                LDREQ   r0, =PINTR_Latch
                LDRNE   r0, =IOC+IOCIRQCLRA                     ; note address of IRQ clear register
                STR     r0, InterruptClear
        ]
   
                MOV     r0, #3                                  ; read version fields for each sub-unit
                SWI     XOS_ReadSysInfo
                EXIT    VS
                AND     r0, r0, #(15 :SHL: 8)                   ; extract parallel sub-unit version
                TEQ     r0, #(1 :SHL: 8)                        ; if not type 1
                TEQNE   r0, #(2 :SHL: 8)                        ; and not type 2 then
                BNE     %15                                     ;   report error
 
                TEQ     r0, #(1 :SHL: 8)
        [ :LNOT: HAL
                ASSERT  IOMD_PrinterIRQ_DevNo < 8               ; we assume the mask is in IOCIRQMSKA
                ASSERT  IOMDr_PrinterIRQ_DevNo < 8
                MOVEQ   r0,  #IOMD_printer_IRQ_bit              ; types 1 and 2 are the same, apart from
                MOVNE   r0,  #IOMDr_printer_IRQ_bit             ;   the interrupt used
                STRB    r0, InterruptBit
        ]
                MOVEQ   r14, #IOMD_PrinterIRQ_DevNo
                MOVNE   r14, #IOMDr_PrinterIRQ_DevNo
                STRB    r14, DeviceNo

        [ FastCentronics
                AND     r1, r1, #(15 :SHL: 8)                   ; extract extra features
                TEQ     r1, #(1 :SHL: 8)                        ; if we can use fast centronics then
                LDREQB  r0, Flags                               ;   set flag
                ORREQ   r0, r0, #f_UseFIFO
                STREQB  r0, Flags
        ]
                MOV     r0, r7                                  ; hardware OK
                B       %20
 ]
15
                ADRL    r0, ErrorBlock_Parallel_BadHardware
 [ international
                BL      MakeError
                BL      CloseMessages                           ; close messages if module init is failing
 ]
                SETV
                EXIT                                            ; generate error about invalid hardware platform
20
                STR     r0, HardwareType                        ; store in workspace
 [ HAL
                ; Set up UpdateIOEBCopy
                ADRL    r0, UpdateIOEBCtrlProto
                ADR     r1, UpdateIOEBCtrl
                MOV     r2, #UpdateIOEBCtrlSize
21
                SUBS    r2,r2,#4
                LDR     r3,[r0,r2]
                STR     r3,[r1,r2]
                BNE     %BT21
                MOV     r0,#1
                ADD     r2,r1,#UpdateIOEBCtrlSize
                SWI     XOS_SynchroniseCodeAreas                
 ]     

                BL      registerdevice                          ; register the device
                ADRVC   r0, setsysvar
                SWIVC   XOS_CLI                                 ; setup system variable
 [ StorkPower
                EXIT    VS                                      ; return any errors generated

                MOV     r0, #1                                  ; pretend portable module present
                STR     r0, portable_present                    ; at least until we know better
                LDR     r0, =ParallelPowerBits
                STR     r0, power_state                         ; show power_state as ON, to
                BL      SetPower_Off                            ; force SetPower_Off to call XPortable_Control
 ]

 [ AdvancedErrorHandling
                ; We want to use the UpCall_DeviceError mechanism for handling errors, so
                ; whenever there is a parallel stream open, we need its FileSwitch handle.
                ; We can get this by monitoring the UpCall vector and checking for
                ; UpCall_StreamCreated.
                MOV     r0, #UpCallV
                ADRL    r1, common_check_upcall
                MOV     r2, r12
                SWI     XOS_Claim

                ; if, for some reason, we are not able to claim the UpCall vector, we
                ; simply do not set the UpCallVectorClaimed flag, which means that we
                ; will fall back onto the previous error handling strategy in
                ; IOEB_monitorTX
                LDRVCB  r0, Flags
                ORRVC   r0, r0, #f_UpCallVectorClaimed
                STRVCB  r0, Flags
 ]

                CLRV
                EXIT

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle the module close down.
;

final           Entry

                LDR     wp, [wp]                                ; setup workspace pointer

                LDR     r0, StreamHandle
                TEQ     r0, #0                                  ; are any of the outputs being used
                PullEnv NE
                ADRNE   r0, ErrorBlock_Parallel_InUse

        [ international
                BNE     MakeErrorWithDeviceName
        |
                RETURNVS NE
        ]

        [ standalonemessages
                ADR     R0, resourcefsfiles
                SWI     XResourceFS_DeregisterFiles
        ]

                LDR     r0, DeviceHandle
                TEQ     r0, #0                                  ; is device registered?
                SWINE   XDeviceFS_Deregister                    ; remove device from being active

        [ FastCentronics
                LDR     r0, FastHandle
                TEQ     r0, #0
                SWINE   XDeviceFS_Deregister
        ]

                Debug   j, "terminated"

                [       debug
                Debug_Close
                ]

        [ international
                BL      CloseMessages                           ; we are definitely dying - close msgs
        ]

        [ AdvancedErrorHandling
                ; we may have claimed the UpCall vector, so release it if we have
                LDRB    r0, Flags
                TST     r0, #f_UpCallVectorClaimed
                MOVNE   r0, #UpCallV
                ADRNEL  r1, common_check_upcall
                MOVNE   r2, r12
                SWINE   XOS_Release

                ; we are definitely dying, so there is no point in resetting f_UpCallVectorClaimed
        ]
                CLRV
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle service calls.
;
                ASSERT  Service_Reset < Service_ResourceFSStarting
                ASSERT  Service_ResourceFSStarting < Service_DeviceFSStarting
                ASSERT  Service_DeviceFSStarting < Service_DeviceFSDying
                ASSERT  Service_DeviceFSDying < Service_DeviceDead
                ASSERT  Service_DeviceDead < Service_Portable
servicetable    &       0
                &       serviceentry -Module_BaseAddr
                &       Service_Reset
 [ standalonemessages
                &       Service_ResourceFSStarting
 ]
                &       Service_DeviceFSStarting
                &       Service_DeviceFSDying
                &       Service_DeviceDead
 [ StorkPower
                &       Service_Portable
 ]
                &       0

                &       servicetable -Module_BaseAddr
service         ROUT
                MOV     r0, r0
                TEQ     r1, #Service_Reset
                TEQNE   r1, #Service_DeviceFSStarting
                TEQNE   r1, #Service_DeviceFSDying
                TEQNE   r1, #Service_DeviceDead
 [ StorkPower
                TEQNE   r1, #Service_Portable
 ]
 [ standalonemessages
                TEQNE   r1, #Service_ResourceFSStarting
 ]
                MOVNE   pc, lr

serviceentry    LDR     wp, [wp]                                ; wp -> workspace

                TEQ     r1, #Service_Reset
                BEQ     svc_reset                               ; machine reset pending

                TEQ     r1, #Service_DeviceFSStarting
                BEQ     svc_starting                            ; handle the fs starting again

                TEQ     r1, #Service_DeviceFSDying
                BEQ     svc_devfsdead                           ; DeviceFS reseting...

        [ standalonemessages
                TEQ     r1, #Service_ResourceFSStarting
                BNE     %FT10
                Push    "r0-r3,lr"
                ADR     r0, resourcefsfiles
                MOV     lr, pc
                MOV     pc, r2
                Pull    "r0-r3,pc"
10
        ]

        [ StorkPower
                TEQ     r1, #Service_Portable
                BNE     %FT40
                TEQ     r2, #ServicePortable_PowerDown
                BNE     %FT35

                Push    "r0,r2,lr"
                MOV     lr, #1
                STR     lr, portable_present            ; indicate portable module present
                LDR     lr, =ParallelPowerBits
                TST     r3, lr                          ; are they trying to power down parallel port
                Pull    "r0,r2,pc",EQ                   ; no then just pass on the service

                LDRB    r0, Flags                       ; if open for reading or writing
                TST     r0, #f_OpenForRead :OR: f_OpenForWrite  ; then complain
                BEQ     %FT32                           ; [both closed, so OK]
                BICS    r3, r3, lr                      ; by clearing the parallel bits
                MOVEQ   r1, #0                          ; and if there are no more bits being turned off
                Pull    "r0,r2,pc"                      ; then claim service to save time
32
                LDR     r0, power_state                 ; update our record of which bits are on
                BIC     r0, r0, r3
                STR     r0, power_state
                Pull    "r0,r2,pc"

35
                TEQ     r2, #ServicePortable_PowerUp    ; bits being powered up
                MOVNE   pc, lr
                Push    "r0,r3,lr"
                MOV     lr, #1
                STR     lr, portable_present            ; indicate portable module present
                LDR     lr, =ParallelPowerBits
                AND     r3, r3, lr                      ; just get parallel bits which are being powered up
                LDR     r0, power_state
                ORR     r0, r0, r3                      ; and or them into our current state
                STR     r0, power_state
                Pull    "r0,r3,pc"

40
        ]

; must be device dead, we've checked for all the rest, so drop thru to ...

svc_devicedead
                Push    "lr"

                LDR     lr, DeviceHandle
                TEQ     lr, r2                                  ; is it my device being killed, don't bother checking r3.
                STREQ   r0, DeviceHandle                        ; yep, so write the value.

        [ FastCentronics
                LDR     lr, FastHandle
                TEQ     lr, r2
                STREQ   r0, FastHandle
        ]

                Pull    "pc"

svc_reset
                Push    "r0-r2, lr"

        [ AdvancedErrorHandling
                ; we need to claim the UpCall vector again after a reset
                MOV     r0, #UpCallV
                ADRL    r1, common_check_upcall
                MOV     r2, r12
                SWI     XOS_Claim
                LDRB    r0, Flags
                ORRVC   r0, r0, #f_UpCallVectorClaimed
                BICVS   r0, r0, #f_UpCallVectorClaimed
                STRB    r0, Flags
        ]

                MOV     r0, #OsByte_RW_LastResetType
                MOV     r1, #0
                MOV     r2, #&FF
                SWI     XOS_Byte
                TEQ     r1, #0

                Pull    "r0-r2, pc",NE                          ; if hard reset, do nothing

                BL      svc_devfsdead                           ; reset the variables etc...

                LDR     r0, HardwareType
                TEQ     r0, #hardware_IOC                       ; reset the relevant hardware
;                BLEQ    IOCreset                               ; (doesn't need to do anything on old hardware)
                BLNE    IOEBreset

                Pull    "r0-r2, pc"

svc_devfsdead
                Push    "lr"

                MOV     lr, #0                                  ; zap buffer handles
                STR     lr, DeviceHandle
                STR     lr, StreamHandle
                STR     lr, BufferHandle
        [ FastCentronics
                STR     lr, FastHandle
        ]
        [ FastBufferMan
                STR     lr, BufferId
                STR     lr, BuffManService
                STR     lr, BuffManWkSpace
        ]
                STRB    lr, IRQFlags

        [ FastCentronics
                LDRB    lr, Flags
                AND     lr, lr, #f_UseFIFO                      ; keep use FIFO bit
                STRB    lr, Flags
        |
                STRB    lr, Flags
        ]

                Pull    "pc"


svc_starting
                Push    "r0, lr"

                BL      registerdevice
                ADRVCL  r0, setsysvar
                SWIVC   XOS_CLI                                 ; setup system variable

                Pull    "r0, pc"

                LTORG

                GBLS    conditionalgetbodge
 [ standalonemessages
                GBLS    ApplicationName
ApplicationName SETS    "Parallel"
conditionalgetbodge SETS "GET s.ResFiles"
resourcefsfiles
 |
conditionalgetbodge SETS ""
 ]
                $conditionalgetbodge
 [ standalonemessages
                DCD     0
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; SWI despatching within the module.
;

swicode         ROUT

                LDR     wp, [wp]

                CMP     r11, #(%10-%00):SHR:2                   ; is the SWI within a valid range?
                ADDCC   pc, pc, r11, LSL #2
                B       %10
00
                B       HardwareAddr
                B       ParallelOp
10
                ADR     r0, ErrorBlock_Parallel_BadSWI
 [ international
                B       MakeErrorWithModuleName
 |
                RETURNVS
 ]

                MakeErrorBlock Parallel_BadSWI

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Parallel_HardwareAddress
;
; in:   -
;
; out:  r0 -> base address of 82C710 within IOEB / =0 on non-ioeb machines.
;               if r0 >0 then
;                       r1 -> routine to update IOEB ctrl register
;
; This call is provided to read the base address of the 82C710 parallel port
; within IOEB workspace.  The device can then be driven directly by applications,
; although this is not really advised.
;
; People wishing to do such a ghastly deed should first lock the device by
; opening a stream onto it.
;

HardwareAddr    LDR     r0, HardwareBase                        ; return base address
                TEQ     r0, #0
                SUBNE   r0, r0, #pp_imm                         ; deduct convenience offset
                ADRNEL  r1, UpdateIOEBCtrl                      ; if it is an IOEB then -> update ctrl function

                RETURNVC

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ParallelOp
;
; in:   r0 = reason code
;       other registers as determined by reason code
;
; out:  r0 preserved
;       other registers as determined by reason code
;
 [ StorkPower
; We don't call SetPower_On/Off around this call.
; The user is recommended (in the PRM 2-481) to claim exclusive use
; of the port by doing 'lock%=OPENOUT("parallel:")', this will ensure
; that the port is powered. The user should release the port by doing
; 'CLOSE#lock%', which will power it down.
 ]
;

ParallelOp      ROUT
                Push    "r3"
                LDR     r3, HardwareBase                        ; Make sure the correct hardware is there
                TEQ     r3, #0
                ADREQL  r0, ErrorBlock_Parallel_BadHardware
                Pull    "r3"
        [ international
                BEQ     MakeError
        |
                RETURNVS
        ]
                CMP     r0, #(%10-%00):SHR:2
                ADDCC   pc, pc, r0, LSL #2
                B       %10
00
                B       IOEB_ReadDataStatus
                B       IOEB_WriteData
                B       IOEB_ReadWriteCtrl
10
                ADR     r0, ErrorBlock_Parallel_BadParm
        [ international
                B       MakeError
        |
                RETURNVS
        ]

                MakeErrorBlock Parallel_BadParm

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: registerdevice
;
; in:   -
;
; out:  -
;
; This routine registers the specified device, the routine assumes that the
; hardware type has been obtained and then it will attempt to register a
; device within DeviceFS.
;

registerdevice  Entry   "r0-r7"

                LDR     r0, HardwareType
                TEQ     r0, #hardware_IOC                       ; which type of hardware?
;                BLEQ    IOCreset                               ; (doesn't do anything on IOC)
                BLNE    IOEBreset                               ; reset it...
 [ OldHardware
                ADREQL  r2, IOCdevice                           ; -> device routine
 ]
 [ NewHardware
                ADRNEL  r2, IOEBdevice
 ]
                MOV     r0, #dfsr_flags                         ; flags for registering device
                ADRL    r1, block                               ; device description block
                MOV     r3, #0
                MOV     r4, wp
                MOV     r5, #0                                  ; validation string with no decoding message
                MOVEQ   r6, #0                                  ; no receive buffer for IOC
                MOVNE   r6, #1                                  ; single receive buffer for IOEB
                MOV     r7, #1                                  ; single transmit buffer
                SWI     XDeviceFS_Register
                EXIT    VS

                STR     r0, DeviceHandle                        ; store device handle away
                Debug   open,"device handle =",r0

 [ FastCentronics
                LDRB    r0, Flags
                TST     r0, #f_UseFIFO
                EXIT    EQ

                MOV     r0, #dfsr_flags
                ADRL    r1, fastblock
                ADRL    r2, FastDevice
                MOV     r6, #0
                SWI     XDeviceFS_Register
                STRVC   r0, FastHandle
                Debug   open,"fast handle =",r0
 ]

                EXIT

 [ StorkPower
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       Power management routines
;

SetPower_On     EntryS  "r0,r1"
                LDR     r0, =ParallelPowerBits
                B       SetPower                        ; turn on power


SetPower_Off    ALTENTRY
                MOV     r0, #0                          ; turn power off

; and drop thru to...

SetPower        ROUT
                LDR     lr, portable_present            ; if no portable module present
                TEQ     lr, #0
                EXITS   EQ                              ; then do nothing

                LDR     lr, power_state                 ; if current state = new state, do nothing
                TEQ     r0, lr
                EXITS   EQ

                LDR     r1, =:NOT: ParallelPowerBits
                SWI     XPortable_Control               ; new = (old AND r1) EOR r0
                STRVC   r1, power_state

                MOVVS   r0, #0                          ; if we got an error
                STRVS   r0, portable_present            ; then set portable_present = FALSE
                LDRVS   r0, =ParallelPowerBits
                STRVS   r0, power_state                 ; and set power_state = ON
                EXITS

                LTORG
 ]
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generalised internationalisation routines, these ensure that messages files
; are correctly opened and then return the relevant data.
;
              [ international

; Attempt to open the messages file.

OpenMessages    ROUT

                Entry   "r0-r3"

                SUBS    r2, r2, r2                              ; clears V, R2=0 (allocate RMA for messages)
                LDRB    r3, Flags
                TST     r3, #f_WeHaveMessages                   ; do we have an open messages block?
                EXIT    NE                                      ; yes, so don't bother again
                ORR     r3, r3, #f_WeHaveMessages

                ADR     r0, MessagesWorkspace
                ADRL    r1, resource_file                       ; -> path to be opened
                SWI     XMessageTrans_OpenFile
                STRVCB  r3, Flags                               ; assuming it worked mark as having messages

                EXIT                                            ; returning VC, VS from XSWI!


; Attempt to close the messages file.

CloseMessages   ROUT

                Entry   "r0"

                LDRB    r0, Flags
                TST     r0, #f_WeHaveMessages                   ; do we have any messages?
                BIC     r0, r0, #f_WeHaveMessages
                STRNEB  r0, Flags                               ; mark as we don't have them
                ADRNE   r0, MessagesWorkspace
                SWINE   XMessageTrans_CloseFile                 ; yes, so close the file

                EXIT


; Generate an error based on the error token given.  Does not assume that
; the messages file is open.  Will attempt to open it, then look it up.

MakeErrorWithModuleName Entry "r1-r7"
                ADRL    r4, title
                B       MakeErrorEntry

MakeErrorWithDeviceName ALTENTRY
                ADRL    r4, devicename
                B       MakeErrorEntry

MakeError       ALTENTRY
                MOV     r4, #0
MakeErrorEntry
                BL      OpenMessages                            ; re-open messages if necessary
                EXIT    VS

                ADR     r1, MessagesWorkspace                   ; -> message control block
                ADR     r2, localerrorblock                     ; was 'MOV r2, #0', but for some reason
                                                                ; MsgTrans trashes the block. JRC 21-Apr-1997
                MOV     r3, #?localerrorblock
                MOV     r5, #0
                MOV     r6, #0
                MOV     r7, #0                                  ; no substitution + use internal buffers
                SWI     XMessageTrans_ErrorLookup

                EXIT                                            ; return, r0 -> block, V set
              ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ debug
                InsertNDRDebugRoutines
 ]

                GET     Common.s

                GBLS    getaroundaasm
 [ OldHardware
getaroundaasm   SETS    "GET s.IOC"
 |
getaroundaasm   SETS    ""
 ]
                $getaroundaasm

 [ NewHardware
getaroundaasm   SETS    "GET s.IOEB"
 |
getaroundaasm   SETS    ""
 ]
                $getaroundaasm

                GBLS    GETFastCent
 [ FastCentronics
GETFastCent     SETS    "GET s.FastCent"
 |
GETFastCent     SETS    ""
 ]
                $GETFastCent

                END
