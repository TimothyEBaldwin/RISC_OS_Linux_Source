REM >!Chars.!RunImage

REM Copyright 2015 Castle Technology Ltd
REM
REM Licensed under the Apache License, Version 2.0 (the "License");
REM you may not use this file except in compliance with the License.
REM You may obtain a copy of the License at
REM
REM     http://www.apache.org/licenses/LICENSE-2.0
REM
REM Unless required by applicable law or agreed to in writing, software
REM distributed under the License is distributed on an "AS IS" BASIS,
REM WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
REM See the License for the specific language governing permissions and
REM limitations under the License.
REM
REM !Chars
REM Authors: Acorn, CWraight

REM Conventions
REM ===========
REM
REM Global variables are capitalised (e.g. Block%)
REM Local variables are not (e.g. command$)
REM Constants are in all-caps (e.g. WIN_WIDTH%)
REM
REM Most global variables are defined in either
REM PROCchars_init or PROCwimp_init.


REM // Initialise application and load resources //
PROCchars_init
PROCwimp_init
IF Option_Open%=TRUE THEN PROCcharswin_firstopen

REM // Poll loop //
SYS "Wimp_DragBox",,-1
WHILE NOT AppQuit%
 PROCwimp_poll
ENDWHILE

REM // Tidy up and close //
PROCchars_tidyup


REM-----------------------------------------------------------------------------

REM // Chars //

REM-----------------------------------------------------------------------------

DEF PROCchars_init
REM Define global variables and read start-up options

ON ERROR PRINT REPORT$+" at "+STR$ERL:END

REM Constants
KEY_SHIFT%=-1                          :REM Shift key
FONT_SYSFONT%=-1                       :REM System font handle
FONT_8BITMAX%=223                      :REM Max number of 8-bit chars
FONT_UTF8MAX%=126                      :REM Max char for System Font in UTF8
FONT_SIZE%=14                          :REM Font size in points
ENC_FIXED%=0                           :REM Encoding types
ENC_VARIABLE%=1                        :REM Encoding types
ENC_DEFAULT%=2                         :REM Encoding types
CHAR_XBOX%=FONT_SIZE% * 2              :REM Width of character box
CHAR_YBOX%=FONT_SIZE% * 3.5            :REM Height of character box
WIN_TOOLBAR%=128                       :REM Height of window toolbar
WIN_SMALL%=-360                        :REM Height of smallest viewer pane
WIN_WIDTH%=926                         :REM Width of viewer pane
WIN_MARGIN%=12                         :REM Margin for window contents

REM Buffers for SWIs
DIM Block% 255                         :REM General purpose buffer
DIM ErrBlock% 255                      :REM Error buffer

REM Load application messages
PROCmsg_load("Chars:Messages")

REM Font handling
SysFont$=FNmsg_get("SysFont")          :REM System font name
DIM CharDef% 8:CharDef%!4=0            :REM Buffer for character defs
DIM EncodingBuff% 12                   :REM Buffer for encoding name
FontHandle%=0                          :REM Font handle
FontName$=""                           :REM Font name
Encoding$=""                           :REM Encoding name
Encodings%=0                           :REM Total encodings on system
Alphabet$=""                           :REM System encoding 'Alphabet'
DesktopFont$=FNchars_getdesktopfont    :REM Desktop font name

REM GUI/window redrawing
FirstOpen%=TRUE                        :REM First-time open flag
WasDown%=0:IsDown%=0                   :REM Flags to indicate Shift pressed
OldChar%=0:                            :REM Old selected character
XEig%=0:YEig%=0                        :REM Screen Eigen factors

REM Start-up options
Option_Open%=TRUE                      :REM Window auto-open flag
Option_DesktopFont%=FALSE              :REM Use Desktop font on startup

REM UCS Manager handling
UCSManager%=FNchars_getucs
IF UCSManager% THEN

 REM Global variables and storage
 FONT_INVALID%=&FFFFFFFF               :REM Invalid Unicode character
 UCSNames%=FALSE                       :REM A UCS names file can be found
 Lookup%=FALSE                         :REM Ptr to storage for Lookup table
 MaxChars%=0                           :REM Number of chars in display category
 EncPtr%=0                             :REM Pointer to UCS table in module
 MAXCATS%=12                           :REM Max Category ranges
 Categories%=VAL(FNmsg_get("CM0"))     :REM Total Categories
 Category$=""                          :REM Unicode font category
 DIM Category%(1,MAXCATS%)             :REM UCS Block Category ranges
 NameFile%=0                           :REM File desc for Charnames file

 REM If UCS names file present, open using MessageTrans
 LOCAL file$,size%,space%
 LOCAL r%,s$,p$,found%,next%,length%
 file$="Unicode:Files.Charnames"
 SYS "XOS_File",17,file$ TO obj%
 IF obj%=1 THEN
  SYS "Hourglass_On"
  SYS "MessageTrans_FileInfo",,file$ TO ,,size%
  END=HIMEM+size%
  DIM space% size%
  SYS "OS_Module",6,,,17+LENfile$ TO ,,NameFile%
  $(NameFile%+16)=file$
  SYS "MessageTrans_OpenFile",NameFile%,NameFile%+16,space%
  REM Get number of character code ranges (ie CYK glyphs)
  r%=0
  next%=0
  FOR i%=4 TO 6
   s$=STRING$(i%,"?")+"-"+STRING$(i%,"?")
   REPEAT
    SYS "MessageTrans_EnumerateTokens",NameFile%,s$,Block%,255,next% TO ,,found%,,next%
    IF found%>0 THEN r%+=1
   UNTIL found%=0
  NEXT
  REM Store the ranges for lookup
  IF r%>0 THEN
   DIM Ranges%(r%-1,1)
   r%=0
   next%=0
   FOR i%=4 TO 6
    s$=STRING$(i%,"?")+"-"+STRING$(i%,"?")
    REPEAT
     SYS "MessageTrans_EnumerateTokens",NameFile%,s$,Block%,255,next% TO ,,found%,length%,next%
     IF found%>0 THEN
      Block%?length%=13
      p$=$(Block%)
      Ranges%(r%,0)=EVAL("&"+LEFT$(p$,INSTR(p$,"-")-1))
      Ranges%(r%,1)=EVAL("&"+RIGHT$(p$,INSTR(p$,"-")-1))
      r%+=1
     ENDIF
    UNTIL found%=0
   NEXT
  ENDIF

  SYS "Hourglass_Off"
  UCSNames%=TRUE
 ENDIF

 REM Set up heap manager
 PROCheap_init
 IF HeapError% THEN PROCwimp_error(FNmsg_get("Fatal1"))
ENDIF

REM Read user choices from script in Choices
LOCAL file%,obj%,value$,command$
SYS "XOS_File",17,"Choices:Chars.Choices" TO obj%
IF obj%=1 THEN
 file%=OPENIN "Choices:Chars.Choices"
 WHILE NOT EOF#file%
  command$=GET$#file%
  IF INSTR(command$,":") THEN
   value$=RIGHT$(command$,LEN(command$)-INSTR(command$,":"))
   command$=LEFT$(command$,INSTR(command$,":")-1)
   CASE command$ OF
    WHEN "DesktopFont":
     IF value$="Yes" THEN Option_DesktopFont%=TRUE
     IF value$="No" THEN Option_DesktopFont%=FALSE
    WHEN "Open":
     IF value$="Yes" THEN Option_Open%=TRUE
     IF value$="No" THEN Option_Open%=FALSE
   ENDCASE
  ENDIF
 ENDWHILE
 CLOSE#file%
ENDIF

ENDPROC

DEF FNchars_getsysencoding
REM Returns a string with the System alphabet
LOCAL a$,e%,len%
SYS "OS_Byte",71,127 TO ,e%
SYS "OS_ServiceCall",,&43,3,e%,Block%,255 TO ,,,,,len%
Block%?len%=0
SYS "XOS_GenerateError",Block% TO a$
=a$

DEF FNchars_getdesktopfont
REM Returns a handle and name for the Desktop font
LOCAL len%,flags%,data%,dfhandle%,df$
SYS "OS_Byte",161,140 TO ,,data%
dfhandle%=(data% AND&1E)>>1:REM Extract WimpFont configuration bits
CASE dfhandle% OF
 WHEN 0:
  SYS "XOS_ReadVarVal","Wimp$Font",Block%,255,0,3 TO ,,len%;flags%
  IF(flags% AND1)=1 THEN=FNmsg_get("DF1"):REM Fall back to system font 
  Block%?len%=13:df$=$Block%
 WHEN 1,2,3,4,5,6,7,8,9,10,11,12,13,14:
  df$=FNmsg_get("DF"+STR$dfhandle%)
ENDCASE
=df$

DEF FNchars_getucs
REM Returns TRUE if the Font Manager is Unicode capable
LOCAL ver%
SYS "Font_CacheAddr" TO ver%
=ver%>340

DEF FNchars_getchar (xmouse%,ymouse%)
REM Returns a character number from mouse coordinates
LOCAL xorigin%,yorigin%,row%,col%,char%
Block%!0=CharsPane%
SYS "Wimp_GetWindowState",,Block%
xorigin%=Block%!4+WIN_MARGIN%
yorigin%=Block%!16-Block%!24-12
row%=(yorigin%-ymouse%) DIV CHAR_YBOX%
col%=(xmouse%-xorigin%) DIV CHAR_XBOX%
char%=(row%*32+col%)+32
IF char%>MaxChars%+32 THEN char%=0
IF col%>31 THEN char%=0
=char%

DEF FNchars_getinfo (char%)
REM Returns string with character info
LOCAL ucode%,text$
text$="":ucode%=0
IF char%=0 THEN =text$
CASE Encoding$ OF
 REM UTF8 Font encoding
 WHEN "UTF8":
  ucode%=FNchars_getunicode(char%)
  IF ucode%>0 THEN
   text$=RIGHT$("000"+STR$~ucode%,4)
   IF UCSNames% THEN
    text$=FNmsg_getargs("UCode",text$,FNchars_getcharname(ucode%))
   ELSE
    text$=FNmsg_get("Char")+text$
   ENDIF
   IF Alphabet$="UTF8" OR ucode%<=FONT_8BITMAX%+32 THEN
    text$+=FNmsg_get("UTrans")+STR$ucode%+")"
   ENDIF
  ENDIF
 REM System font
 WHEN "System":
  text$=FNmsg_get("Char")+STR$~char%
  IF Alphabet$<>"UTF8" OR char%<=FONT_UTF8MAX% THEN
   text$+=FNmsg_get("UTrans")+STR$char%+")"
  ENDIF
 REM 8bit Outline Font encoding
 OTHERWISE:
  IF Alphabet$="UTF8" THEN
   ucode%=EncPtr%!((char%)*4)
   IF ucode%<>FONT_INVALID% THEN
    text$=RIGHT$("000"+STR$~ucode%,4)
    IF UCSNames% THEN
     text$=FNmsg_getargs("UCode",text$,FNchars_getcharname(ucode%))
    ELSE
     text$=FNmsg_get("Char")+text$
    ENDIF
    text$+=FNmsg_get("UTrans")+STR$ucode%+")"
   ENDIF
  ELSE
   text$=FNmsg_get("Char")+STR$~char%
   text$+=FNmsg_get("UTrans")+STR$char%+")"
  ENDIF
ENDCASE
=text$

DEF FNchars_getunicode (char%)
REM Returns a Unicode code from a character number
LOCAL ucode%,ptr%,b1%,b2%,b3%
ucode%=0
char%-=32
IF char%<MaxChars% THEN
 ptr%=char%*3
 b1%=Lookup%?ptr%:ptr%+=1
 b2%=Lookup%?ptr%:ptr%+=1
 b3%=Lookup%?ptr%:ptr%+=1
 ucode%=(b1%<<16) + (b2%<<8) + b3%
ENDIF
=ucode%

DEF FNchars_getcharname (ucode%)
REM Returns a Unicode name from a Unicode code
LOCAL first%,last%,token$,name$,clean$,flags%,args%,i%
name$=""
token$=""
FOR i%=0 TO DIM(Ranges%(),1)
 IF ucode%>=Ranges%(i%,0) AND ucode%<=Ranges%(i%,1) THEN
  token$=STR$~(Ranges%(i%,0))+"-"+STR$~(Ranges%(i%,1))
 ENDIF
NEXT
IF token$="" THEN
 token$=RIGHT$("000"+STR$~ucode%,4)
ENDIF
SYS "XMessageTrans_Lookup",NameFile%,token$,Block%,255 TO ,,,args%;flags%
IF flags% AND 1 THEN =""
Block%?args%=&0D
name$=$Block%
clean$=""
FOR i%=1 TO LENname$
 IF MID$(name$,i%,1)<>"\" THEN
  clean$=clean$+MID$(name$,i%,1)
 ELSE
  i%+=1
  SYS "XMessageTrans_Lookup",NameFile%,"T"+MID$(name$,i%,1),Block%,255 TO ,,,args%;flags%
  IF flags% AND 1 THEN args%=0
  Block%?args%=&0D
  IF $Block%<>"" THEN clean$=clean$+$Block%
 ENDIF
NEXT
=clean$

DEF PROCchars_transmit (xmouse%,ymouse%)
REM Tranmits character code(s)
LOCAL char%,ucode%,utf8$,i%,c%
char%=FNchars_getchar(xmouse%,ymouse%)
IF char%>0 THEN
 CASE Alphabet$ OF

  REM UTF8 Alphabet
  WHEN "UTF8":
   CASE Encoding$ OF
    REM UTF8 Font encoding
    WHEN "UTF8":
     ucode%=FNchars_getunicode(char%)
     utf8$=FNchars_getutf8(ucode%)
     FOR i%=1 TO LEN(utf8$)
      c%=ASC(MID$(utf8$,i%,1))
      IF (c%>=&80 OR c%=0) THEN SYS "OS_Byte",138,0,0
      SYS "OS_Byte",138,0,c%
     NEXT
    REM System font
    WHEN "System":
     IF char%<=FONT_UTF8MAX% THEN SYS "Wimp_ProcessKey",char%
    REM 8bit Outline Font encoding
    OTHERWISE:
     ucode%=EncPtr%!(char%*4)
     IF ucode%<>FONT_INVALID% AND ucode%<>&7F THEN
      utf8$=FNchars_getutf8(ucode%)
      FOR i%=1 TO LEN(utf8$)
       c%=ASC(MID$(utf8$,i%,1))
       IF (c%>=&80 OR c%=0) THEN SYS "OS_Byte",138,0,0
       SYS "OS_Byte",138,0,c%
      NEXT
     ENDIF
   ENDCASE

  REM 8bit Alphabet
  OTHERWISE:
   CASE Encoding$ OF
    REM UTF Font encoding
    WHEN "UTF8":
     ucode%=FNchars_getunicode(char%)
     IF ucode%<=FONT_8BITMAX%+32 THEN SYS "Wimp_ProcessKey",ucode%
    REM 8bit font encoding
    OTHERWISE:
     SYS "Wimp_ProcessKey",char%
   ENDCASE

 ENDCASE
ENDIF
ENDPROC

DEF FNchars_getutf8 (ucode%)
REM Returns a string containing UTF8 bytes
IF ucode%<&80 THEN =CHR$(ucode%)
IF ucode%<&800 THEN =CHR$(&C0+(ucode%>>>6))+CHR$(&80+(ucode% AND &3F))
=CHR$(&E0+(ucode%>>>12))+CHR$(&80+((ucode%>>>6) AND &3F))+CHR$(&80+(ucode% AND &3F))

DEF PROCchars_changefont (font$)
REM Change the current Font
LOCAL flags%,encoding%,type%,claim%,ptr%,i%,f$
IF UCSManager% THEN
 IF Lookup% THEN PROCheap_freeblock(Lookup%):Lookup%=FALSE
ENDIF
Alphabet$=FNchars_getsysencoding
IF font$=SysFont$ THEN
 REM System Font
 FontName$=SysFont$
 FontHandle%=FONT_SYSFONT%
 Encoding$="System"
 IF Alphabet$="UTF8" THEN
  REM Set up a System font UCS Table, based on Latin1
  $(EncodingBuff%)="Latin1"+CHR$(0)
  SYS "OS_ServiceCall",,&43,1,EncodingBuff% TO ,,,,encoding%
  SYS "OS_ServiceCall",,&43,8,encoding% TO ,claim%,,,EncPtr%
 ENDIF
 MaxChars%=FONT_8BITMAX%
 PROCcharswin_update
ELSE
 REM Outline Fonts
 IF font$<>"" AND font$<>FontName$ THEN
  SYS "XFont_LoseFont",FontHandle%
  REM Strip font name of extraneous information
  IF LEFT$(font$,2)="\F" THEN font$=RIGHT$(font$,LEN(font$)-2)
  IF INSTR(font$,"\") THEN font$=LEFT$(font$,INSTR(font$,"\")-1)
  FontName$=font$
  REM Find font and investigate what encoding info it has
  SYS "XFont_FindFont",,FontName$,FONT_SIZE%*16,FONT_SIZE%*16 TO FontHandle%;flags%
  IF flags% AND 1 THEN PROCchars_fonterror("FontErr1"):ENDPROC
  type%=FNchars_getencodingtype(FontHandle%)
  REM Select an encoding menu/default Encoding
  REM 1. If Alphabet is UTF8, always use UTF8 Encoding.
  REM 2. If Alphabet<>UTF8 and font has internal encoding file:
  REM    - use 'Glyph' Encoding on UCS Manager systems
  REM    - use 'Default' on non-UCS Manager systems
  REM 3. If Alphabet<>UTF8 and font doesn't have internal encoding:
  REM    - if font encoding is variable, set Encoding to Alphabet
  REM    - if font encoding is fixed, set Encoding to 'Default'
  IF Alphabet$="UTF8" THEN
   Encoding$="UTF8"
  ELSE
   CASE type% OF
    WHEN ENC_FIXED%:
     IF UCSManager% THEN Encoding$="Glyph" ELSE Encoding$="Default"
    WHEN ENC_VARIABLE%:
     Encoding$=Alphabet$
    WHEN ENC_DEFAULT%:
     Encoding$="Default"
   ENDCASE
  ENDIF
  REM Pre-UCS Font Managers can't attach encodings to 'fixed' fonts
  REM or to fonts without an IntMetricsX file,
  REM so we lose/restore the encoding entries
  IF NOT UCSManager% THEN
   ptr%=EncMenu%+28
   IF type%=ENC_FIXED% OR type%=ENC_DEFAULT% THEN
    ptr%!0=ptr%!0 OR (1<<7)
    ptr%!0=ptr%!0 AND NOT (1<<1)
   ELSE
    ptr%!0=ptr%!0 AND NOT (1<<7)
    ptr%!0=ptr%!0 OR (1<<1)
   ENDIF
  ENDIF
  REM If the Alphabet is UTF8 then the 'Default/Glyph' encoding won't
  REM work properly, so shade this out on the encoding menu
  ptr%=EncMenu%+28
  IF Alphabet$="UTF8" THEN
   ptr%!8=ptr%!8 OR (1<<22)
  ELSE
   ptr%!8=ptr%!8 AND NOT (1<<22)
  ENDIF
  REM On Pre-UCS Managers, an internal Encoding file with >256 entries will
  REM crash the Font Manager. If so, abort and switch to System font
  IF NOT UCSManager% AND type%=ENC_FIXED% THEN
   SYS "Font_ReadFontPrefix",FontHandle%,Block%,255
   SYS "XOS_GenerateError",Block% TO path$
   SYS "OS_File",17,path$+"Encoding" TO obj%
   IF obj%=1 THEN
    i%=0
    f$=path$+"Encoding"
    file%=OPENIN f$
     REPEAT
      IF LEFT$(GET$#file%,1)="/" THEN i%+=1
     UNTIL EOF#file% OR i%>256
     IF i%>256 THEN PROCchars_fonterror("FontErr7"):ENDPROC
    CLOSE#file%
   ENDIF
  ENDIF
  REM All checks complete: now find font again with correct encoding
  IF Encoding$="Default" THEN e$="" ELSE e$="\E"+Encoding$
  SYS "XFont_LoseFont",FontHandle%
  SYS "XFont_FindFont",,e$+"\F"+FontName$,FONT_SIZE%*16,FONT_SIZE%*16 TO FontHandle%;flags%
  IF flags% AND 1 THEN
   REM Finding font has failed. Try again with no encoding specified
   PROCwimp_alert("FontErr3")
   Encoding$="Default"
   SYS "XFont_LoseFont",FontHandle%
   SYS "XFont_FindFont",,FontName$,FONT_SIZE%*16,FONT_SIZE%*16 TO FontHandle%;flags%
   IF flags% AND 1 THEN PROCchars_fonterror("FontErr1"):ENDPROC
  ENDIF
  REM Set up new font and update Chars window
  CASE Encoding$ OF
   WHEN "UTF8":PROCchars_changecat(0)
   OTHERWISE:MaxChars%=FONT_8BITMAX%
  ENDCASE
  PROCcharswin_update
 ENDIF
ENDIF
ENDPROC

DEF FNchars_getencodingtype (font%)
REM Check to see if the font has:
REM 1. An IntMetrics file (no encoding data for different alphabets)
REM 2. An internal fixed encoding file (i.e. a 'symbol' font)
REM 3. Encoding data for different alphabets (IntMetric<n>)
LOCAL type%,obj%,path$
type%=ENC_VARIABLE%
REM Get path to font resource directory
SYS "Font_ReadFontPrefix",font%,Block%,255
SYS "XOS_GenerateError",Block% TO path$
REM See if the directory has an internal Encoding file
SYS "OS_File",17,path$+"Encoding" TO obj%
IF obj%=1 THEN
 type%=ENC_FIXED%
ELSE
 REM See if there's an IntMetrics file
 SYS "OS_File",17,path$+"IntMetrics" TO obj%
 IF obj%=1 THEN type%=ENC_DEFAULT%
ENDIF
=type%

DEF PROCchars_changeenc (Block%)
REM Change the current Encoding
LOCAL claim%,enc$,flags%,encoding%,e$
IF UCSManager% THEN
 IF Lookup% THEN PROCheap_freeblock(Lookup%):Lookup%=FALSE
ENDIF
SYS "Wimp_DecodeMenu",,EncMenu%,Block%,EncodingBuff%
Encoding$=$(EncodingBuff%)
IF Encoding$=FNmsg_get("UTF8") THEN Encoding$="UTF8"
IF Encoding$=FNmsg_get("Default") THEN
 IF UCSManager% THEN
  Encoding$="Glyph":e$="\E"+Encoding$
 ELSE
  Encoding$="Default":e$=""
 ENDIF
ELSE
 e$="\E"+Encoding$
ENDIF
REM Find font with encoding suffix
SYS "XFont_LoseFont",FontHandle%
SYS "XFont_FindFont",,e$+"\F"+FontName$,FONT_SIZE%*16,FONT_SIZE%*16 TO FontHandle%;flags%
IF flags% AND 1 THEN
 REM Finding font has failed. Try again with no encoding specified
 PROCwimp_alert("FontErr3")
 Encoding$="Default"
 SYS "XFont_LoseFont",FontHandle%
 SYS "XFont_FindFont",,FontName$,FONT_SIZE%*16,FONT_SIZE%*16 TO FontHandle%;flags%
 IF flags% AND 1 THEN PROCchars_fonterror("FontErr1"):ENDPROC
ENDIF
CASE Encoding$ OF
 WHEN "UTF8":
  PROCchars_changecat(0)
 WHEN "Default","Glyph":
  MaxChars%=FONT_8BITMAX%
 OTHERWISE:
  MaxChars%=FONT_8BITMAX%
  IF Alphabet$="UTF8" THEN
   REM Get a UCS conversion table for the 8bit encoding
   $(EncodingBuff%)=Encoding$+CHR$(0)
   SYS "OS_ServiceCall",,&43,1,EncodingBuff% TO ,,,,encoding%
   SYS "OS_ServiceCall",,&43,8,encoding% TO ,claim%,,,EncPtr%
  ENDIF
ENDCASE
PROCcharswin_update
ENDPROC

DEF PROCchars_changecat (cat%)
REM Change the current Category for UTF8 display
LOCAL cat$,i%,j%,range$
cat$="CM"+STR$(cat%+1)
Category$=FNmsg_get(cat$)
IF RIGHT$(Category$,1)="*" THEN Category$=LEFT$(Category$,LEN(Category$)-1)
FOR i%=0 TO 1:FOR j%=0 TO MAXCATS%
  Category%(i%,j%)=0
NEXT:NEXT
Category%(0,0)=VAL(FNmsg_get(cat$+"-0"))
IF Category%(0,0)>MAXCATS% THEN Category%(0,0)=MAXCATS%
FOR i%=1 TO Category%(0,0)
 range$=FNmsg_get(cat$+"-"+STR$i%)
 Category%(0,i%)=EVAL("&"+LEFT$(range$,INSTR(range$,"-")-1))
 Category%(1,i%)=EVAL("&"+RIGHT$(range$,LEN(range$)-INSTR(range$,"-")))
NEXT
MaxChars%=FNchars_buildlookup
PROCcharswin_update
ENDPROC

DEF FNchars_buildlookup
REM Creates a list of Unicode character codes in a category
LOCAL chars%,total%
LOCAL code%,intcode%,next%,tcode%
SYS "Hourglass_On"
chars%=0:total%=256
code%=0:intcode%=0:next%=0
Lookup%=FNheap_newblock(total%)
IF HeapError% THEN PROCchars_fonterror("FontErr2"):=0
code%=0:intcode%=0:next%=0:ptr%=0
FOR cat%=1 TO Category%(0,0)
 code%=Category%(0,cat%)
 tcode%=Category%(1,cat%)
 REPEAT
  SYS "Font_EnumerateCharacters",FontHandle%,code% TO ,next%,intcode%
  IF intcode%>-1 THEN
   chars%+=1
   IF chars%*3 > total% THEN
    total%+=1024
    Lookup%=FNheap_resizeblock(Lookup%,1024)
    IF HeapError% THEN PROCchars_fonterror("FontErr2"):=0
   ENDIF
   Lookup%?ptr%=(code% >> 16) AND &FF:ptr%+=1
   Lookup%?ptr%=(code% >> 8) AND &FF:ptr%+=1
   Lookup%?ptr%=(code% >> 0) AND &FF:ptr%+=1
  ENDIF
  code%=next%
 UNTIL next%>tcode% OR next%=-1
 IF next%=-1 THEN cat%=Category%(0,0)
NEXT
SYS "Hourglass_Off"
=chars%

DEF PROCchars_fonterror (message$)
REM Report an error selecting a font
SYS "MessageTrans_Lookup",MessDesc%,message$,ErrBlock%+4,252,FNmsg_get("ErrApp") TO ,,,len%
ErrBlock%?(len%+4)=13:ErrBlock%!0=1
SYS "XWimp_ReportError",ErrBlock%,1,FNmsg_get("ErrApp")
SYS "Wimp_CreateMenu",-1
PROCchars_changefont(SysFont$)
ENDPROC

DEF FNchars_fonttype (font$)
REM Returns 1 if font is System font
IF font$=SysFont$ THEN =1 ELSE =font$

REM-----------------------------------------------------------------------------

REM // Charswin //

REM-----------------------------------------------------------------------------

DEF PROCcharswin_firstopen
REM Open Chars window for the first time
LOCAL x%,y%,w%,h%
CASE Option_DesktopFont% OF
 WHEN TRUE:PROCchars_changefont(DesktopFont$)
 WHEN FALSE:PROCchars_changefont(SysFont$)
ENDCASE
Block%!0=CharsWin%
SYS "Wimp_GetWindowState",,Block%
x%=Block%!4
y%=Block%!8
w%=Block%!12-Block%!4
h%=Block%!16-Block%!8
PROCwimp_openwindow(CharsWin%,x%,y%,x%+w%,y%+h%,-1)
PROCwimp_seticontext(CharsWin%,6,"")
PROCwimp_seticontext(CharsWin%,7,"")
FirstOpen%=FALSE
ENDPROC

DEF PROCcharswin_click (pane%,xmouse%,ymouse%,button%,icon%)
REM Handle mouseclicks in the main window
LOCAL i%,size%,indsize%,enc$
CASE pane% OF
 WHEN CharsPane%:
  IF button%=4 THEN PROCchars_transmit(xmouse%,ymouse%)
 WHEN CharsWin%:
  CASE icon% OF
   WHEN 1:REM Open Font popup menu
    SYS "Font_ListFonts",,0,7<<19,,0,,0 TO ,,,size%,,indsize%
    IF size%>FontBuffer% THEN PROCwimp_error(FNmsg_get("Fatal3"))
    SYS "Font_ListFonts",,FontMenu%,7<<19,size%,FontInd%,indsize%,FNchars_fonttype(FontName$)
    IF FontHandle%=FONT_SYSFONT% THEN
     PROCwimp_settick(FontMenu%,0,TRUE)
    ELSE
     PROCwimp_settick(FontMenu%,0,FALSE)
    ENDIF
    PROCwimp_openiconmenu(CharsWin%,1,FontMenu%)
   WHEN 3:REM Open Encoding popup menu
    enc$=Encoding$
    IF enc$="Default" OR enc$="Glyph" THEN enc$=FNmsg_get("Default")
    FOR i%=0 TO Encodings%-1
     PROCwimp_settick(EncMenu%,i%,FALSE)
     IF $(EncMenu%+28+(i%*24)+12)=enc$ THEN PROCwimp_settick(EncMenu%,i%,TRUE)
    NEXT
    PROCwimp_openiconmenu(CharsWin%,3,EncMenu%)
   WHEN 5:REM Open Category popup menu
    FOR i%=0 TO Categories%
     PROCwimp_settick(CatMenu%,i%,FALSE)
     IF $(CatMenu%+28+(i%*24)+12)=Category$ THEN
      PROCwimp_settick(CatMenu%,i%,TRUE)
     ENDIF
    NEXT
    PROCwimp_openiconmenu(CharsWin%,5,CatMenu%)
  ENDCASE
ENDCASE
ENDPROC

DEF PROCcharswin_update
REM Update the display window and mark for redraw
LOCAL workarea%,e$
PROCwimp_seticontext(CharsWin%,0,FontName$)
REM Update Encoding and Category
CASE Encoding$ OF
 WHEN "System":
  PROCwimp_shadeicon(CharsWin%,9,TRUE)
  PROCwimp_shadeicon(CharsWin%,2,TRUE)
  PROCwimp_shadeicon(CharsWin%,3,TRUE)
  PROCwimp_seticontext(CharsWin%,2,"")
  PROCwimp_shadeicon(CharsWin%,4,TRUE)
  PROCwimp_shadeicon(CharsWin%,5,TRUE)
  PROCwimp_shadeicon(CharsWin%,10,TRUE)
  PROCwimp_seticontext(CharsWin%,4,"")
 WHEN "UTF8":
  PROCwimp_shadeicon(CharsWin%,9,FALSE)
  PROCwimp_shadeicon(CharsWin%,2,FALSE)
  PROCwimp_shadeicon(CharsWin%,3,FALSE)
  PROCwimp_seticontext(CharsWin%,2,FNmsg_get("UTF8"))
  PROCwimp_shadeicon(CharsWin%,4,FALSE)
  PROCwimp_shadeicon(CharsWin%,5,FALSE)
  PROCwimp_shadeicon(CharsWin%,10,FALSE)
  PROCwimp_seticontext(CharsWin%,4,Category$)
 OTHERWISE:
  IF Encoding$="Glyph" OR Encoding$="Default" THEN
   e$=FNmsg_get("Default")
  ELSE
   e$=Encoding$
  ENDIF
  PROCwimp_shadeicon(CharsWin%,9,FALSE)
  PROCwimp_shadeicon(CharsWin%,2,FALSE)
  PROCwimp_shadeicon(CharsWin%,3,FALSE)
  PROCwimp_seticontext(CharsWin%,2,e$)
  PROCwimp_shadeicon(CharsWin%,4,TRUE)
  PROCwimp_shadeicon(CharsWin%,5,TRUE)
  PROCwimp_shadeicon(CharsWin%,10,TRUE)
  PROCwimp_seticontext(CharsWin%,4,"")
ENDCASE
REM Set Chars Pane work area
workarea%=-(((MaxChars% DIV 32)+1)*CHAR_YBOX%+WIN_MARGIN%)
IF workarea%>WIN_SMALL% THEN workarea%=WIN_SMALL%
Block%!0=CharsPane%
SYS "Wimp_GetWindowInfo",,Block% OR 1
Block%!24=0
SYS "Wimp_OpenWindow",,Block%
Block%!0=Block%!44:Block%!4=workarea%
Block%!8=Block%!52:Block%!12=Block%!56
SYS "Wimp_SetExtent",CharsPane%,Block%
SYS "Wimp_ForceRedraw",CharsPane%,0,WIN_SMALL%,WIN_WIDTH%+64,0
ENDPROC

DEF PROCcharswin_redraw
REM Redraw the main window
LOCAL more%
LOCAL xorigin%,yorigin%,cx%,cy%,xlimit%,ylimit%
LOCAL flags%,e%,c%,width%,shade%,fpflags%,ssflags%
LOCAL ptr%,start%,end%,b1%,b2%,b3%

REM Get window coords
SYS "Wimp_RedrawWindow",,Block% TO more%
xorigin%=Block%!4+WIN_MARGIN%-Block%!20
yorigin%=Block%!16-WIN_MARGIN%-Block%!24

REM Set up fonts
IF FontHandle%<>FONT_SYSFONT% THEN
 SYS "XFont_SetFont",FontHandle% TO ;flags%
 IF flags% AND 1 THEN PROCchars_fonterror("FontErr4"):ENDPROC
ELSE
 VDU 23,17,7,4,CHAR_XBOX%>>XEig%;CHAR_YBOX%>>YEig%;0;
ENDIF

REM Begin redraw loop
WHILE more%

 REM Set coords/variables for redrawing rectangle
 cx%=xorigin%
 cy%=yorigin%-28
 xlimit%=xorigin%+(CHAR_XBOX% * 31)
 ylimit%=Block%!32-24

 REM Handle outline fonts
 IF FontHandle%<>FONT_SYSFONT% THEN

  REM Find start and end characters to paint
  IF Encoding$="UTF8" THEN
   start%=(-Block%!24 DIV CHAR_YBOX%) * 32
   ptr%=start%*3
   cy%-=(start% DIV 32) * CHAR_YBOX%
   end%=start%+256
   IF end%>MaxChars%-1 THEN end%=MaxChars%-1
   shade%=&1000000
   IF Alphabet$<>"UTF8" THEN shade%=FONT_8BITMAX%+32
   ssflags%=&2080:fpflags%=&2010
  ELSE
   start%=0
   end%=FONT_8BITMAX%
   ssflags%=&80:fpflags%=&10
  ENDIF

  REM Start font painting loop
  SYS "Wimp_SetFontColours",,0,7
  IF end%>-1 THEN
   FOR c%=start% TO end%

    REM Find the character code and check if in transmit range
    CASE Encoding$ OF
     WHEN "UTF8":
      b1%=Lookup%?ptr%:ptr%+=1
      b2%=Lookup%?ptr%:ptr%+=1
      b3%=Lookup%?ptr%:ptr%+=1
      CharDef%!0=(b1%<<16) + (b2%<<8) + b3%
      IF CharDef%!0>shade% THEN SYS "Wimp_SetFontColours",,0,3
     OTHERWISE:
      CharDef%!0=c%+32
    ENDCASE

    REM Centre the character and paint it
    SYS "XFont_ScanString",,CharDef%,ssflags%,1000000,1000000,,,4 TO e%,,,width%;flags%
    IF flags% AND 1 THEN PROCchars_fonterror("FontErr5"):ENDPROC
    SYS "XFont_Paint",,CharDef%,fpflags%,cx%-(width% DIV 800)+(CHAR_XBOX% DIV 2),cy% TO e%;flags%
    IF flags% AND 1 THEN PROCchars_fonterror("FontErr6"):ENDPROC
    cx%+=CHAR_XBOX%
    IF cx%>xlimit% THEN cx%=xorigin%:cy%-=CHAR_YBOX%
    IF cy%<ylimit% THEN c%=end%
   NEXT
  ENDIF
 ENDIF

 REM Handle System Font
 IF FontHandle%=FONT_SYSFONT% THEN
  SYS "Wimp_SetColour",7
  IF FontHandle%=FONT_SYSFONT% THEN
   FOR c%=0 TO FONT_8BITMAX%
    MOVE cx%,cy%+24
    IF Alphabet$="UTF8" AND c%+32>FONT_UTF8MAX% THEN SYS "Wimp_SetColour",3
    IF c%+32<>127 THEN PRINT CHR$(c%+32)+" ";
    cx%+=CHAR_XBOX%
    IF cx%>xorigin%+(CHAR_XBOX% * 31) THEN cx%=xorigin%:cy%-=CHAR_YBOX%
   NEXT
  ENDIF
 ENDIF

 REM Check for more redraw rectangles
 SYS "Wimp_GetRectangle",,Block% TO more%
ENDWHILE

REM Tidy up
IF FontHandle%=FONT_SYSFONT% THEN VDU 23,17,7,4,16>>XEig%;32>>YEig%;0;
ENDPROC

DEF PROCchars_tidyup
REM Close down app
IF FontHandle%<>FONT_SYSFONT% THEN SYS "XFont_LoseFont",FontHandle%
PROCmsg_close
SYS "Wimp_CloseDown"
END
ENDPROC

REM-----------------------------------------------------------------------------

REM // Iconbar //

REM-----------------------------------------------------------------------------

DEF PROCiconbar_click (button%)
REM Handle clicks on the Iconbar icon
CASE button% OF
 WHEN 1,4:CASE FirstOpen% OF
   WHEN TRUE:PROCcharswin_firstopen
   WHEN FALSE:
    Block%!0=CharsWin%
    SYS "Wimp_GetWindowState",,Block%
    PROCwimp_openwindow(CharsWin%,Block%!4,Block%!8,Block%!12,Block%!16,-1)
  ENDCASE
 WHEN 2:SYS "Wimp_GetPointerInfo",,Block%
  SYS "Wimp_CreateMenu",,IconMenu%,!Block%-64,272
  MenuOpen%=IconMenu%
ENDCASE
ENDPROC

REM-----------------------------------------------------------------------------

REM // Choicewin //

REM-----------------------------------------------------------------------------

DEF PROCchoicewin_init
REM Initialise Choices window, open and gain focus
PROCwimp_selecticon(ChoiceWin%,4,Option_Open%)
PROCwimp_selecticon(ChoiceWin%,2,NOT Option_DesktopFont%)
PROCwimp_selecticon(ChoiceWin%,3,Option_DesktopFont%)
SYS "Wimp_GetPointerInfo",,Block%
PROCwimp_openwindow(ChoiceWin%,Block%!0-400,150,Block%!0+178,150+364,-1)
SYS "Wimp_SetCaretPosition",window%,-1,0,0,-1,-1
ENDPROC

DEF PROCchoicewin_click (icon%,button%)
REM Handle clicks in Choices window
LOCAL file%,obj%,val$
CASE icon% OF
 WHEN -1:REM Click on window - gain input focus
  SYS "Wimp_SetCaretPosition",ChoiceWin%,-1,0,0,-1,-1
 WHEN 6:REM Cancel button
  IF button%=4 THEN Block%!0=ChoiceWin%:SYS "Wimp_CloseWindow",,Block%
 WHEN 5:REM Save button
  Option_Open%=FNwimp_getselect(ChoiceWin%,4)
  Option_DesktopFont%=FNwimp_getselect(ChoiceWin%,3)
  SYS "XOS_File",8,"<Choices$Write>.Chars"
  file%=OPENOUT "<Choices$Write>.Chars.Choices"
  BPUT#file%,"| Choices file for Chars"
  BPUT#file%,""
  IF Option_Open% THEN val$="Yes" ELSE val$="No"
  BPUT#file%,"Open:"+val$
  IF Option_DesktopFont% THEN val$="Yes" ELSE val$="No"
  BPUT#file%,"DesktopFont:"+val$
  CLOSE#file%
  IF button%=4 THEN Block%!0=ChoiceWin%:SYS "Wimp_CloseWindow",,Block%
ENDCASE
ENDPROC

DEF FNchoicewin_keypress (key%)
REM Handle keypresses in Choices window
LOCAL taken%
taken%=TRUE
CASE key% OF
 REM Escape
 WHEN &1B:PROCchoicewin_click(6,4)
 REM Return
 WHEN &0D:PROCchoicewin_click(5,4)
 REM Ctrl-F2 to close
 WHEN &1A2:Block%!0=ChoiceWin%:SYS "Wimp_CloseWindow",,Block%
 OTHERWISE:taken%=FALSE
ENDCASE
=taken%

REM-----------------------------------------------------------------------------

REM // Wimp //

REM-----------------------------------------------------------------------------

DEF PROCwimp_init
REM Initialise the task, set wimp global variables and load resources
LOCAL size%,indsize%,counter%,ptr%
LOCAL i%,flags%,text$,utf%

REM Global variables
AppQuit%=FALSE                            :REM Application quit flag
WimpVersion%=0                            :REM Wimp version
TaskHandle%=0                             :REM Task handle
IconHandle%=0                             :REM Iconbar icon handle
Iconbar%=-2                               :REM Iconbar value
MenuOpen%=0                               :REM Handle of open menu
DIM WindowName% 12                        :REM Buffer for Window title
PollMask%=&3801                           :REM Wimp Poll Mask
FontBuffer%=0                             :REM Size needed for Font menu
MESSAGE_QUIT%=0                           :REM Message constants
MESSAGE_HELPREQUEST%=&502                 :REM Message constants
MESSAGE_HELPREPLY%=&503                   :REM Message constants
MESSAGE_MODECHANGE%=&400C1                :REM Message constants
MESSAGE_SAVEDESKTOP%=&A                   :REM Message constants

REM Initialise application
Block%!0=MESSAGE_SAVEDESKTOP%
Block%!4=MESSAGE_HELPREQUEST%
Block%!8=MESSAGE_MODECHANGE%
Block%!12=MESSAGE_QUIT%
SYS "Wimp_Initialise",310,&4B534154,FNmsg_get("_TaskName"),Block% TO WimpVersion%,TaskHandle%

REM Wimp-based Error handling
ON ERROR PROCwimp_error("")

REM Load templates
WindowArea%=FNwimp_opentemplates("Chars:Templates")
CharsPane%=FNwimp_loadtemplate("Characters",WindowArea%)
CharsWin%=FNwimp_loadtemplate("Chars",WindowArea%)
InfoWin%=FNwimp_loadtemplate("Info",WindowArea%)
ChoiceWin%=FNwimp_loadtemplate("Choices",WindowArea%)
SYS "Wimp_CloseTemplate"

REM Create iconbar icon and update version in Info
Block%!0=-1:Block%!4=0:Block%!8=0:Block%!12=68:Block%!16=68
Block%!20=&3002:$(Block%+24)=FNmsg_get("ErrApp")
SYS "Wimp_CreateIcon",,Block% TO IconHandle%
PROCwimp_seticontext(InfoWin%,4,FNmsg_get("_Version"))

REM Create Iconbar menu
DIM IconMenu% 28+(24*4)
PROCwimp_makemenu(IconMenu%,FNmsg_get("Chars"))
PROCwimp_additem(IconMenu%,0,0,InfoWin%,FNmsg_get("Info"))
PROCwimp_additem(IconMenu%,1,0,-1,FNmsg_get("Help"))
PROCwimp_additem(IconMenu%,2,0,-1,FNmsg_get("Choices"))
PROCwimp_additem(IconMenu%,3,128,-1,FNmsg_get("Quit"))

REM IF UCS Manager present, create a Categories menu
IF UCSManager% THEN
 DIM CatMenu% 28+(24*Categories%)
 PROCwimp_makemenu(CatMenu%,FNmsg_get("Cats"))
 FOR i%=1 TO Categories%
  text$=FNmsg_get("CM"+STR$i%)
  flags%=0
  IF RIGHT$(text$,1)="*" THEN flags%=2:text$=LEFT$(text$,LEN(text$)-1)
  IF i%=Categories% THEN flags%=128
  PROCwimp_additem(CatMenu%,i%-1,flags%,-1,text$)
 NEXT
ENDIF

REM Create Font menu
SYS "Font_ListFonts",,0,7<<19,,0,,0 TO ,,,size%,,indsize%
FontMenu%=FNheap_newblock(size%)
IF HeapError% THEN PROCwimp_error(FNmsg_get("Fatal2"))
FontInd%=FNheap_newblock(indsize%)
IF HeapError% THEN PROCwimp_error(FNmsg_get("Fatal2"))
FontBuffer%=size%

REM Create Encodings menu
SYS "Font_ListFonts",,0,9<<19,,0,,0 TO ,,,size%,,indsize%
DIM EncMenu% size%+24,EncInd% indsize%
PROCwimp_makemenu(EncMenu%,FNmsg_get("Encs"))
PROCwimp_additem(EncMenu%,0,2,-1,FNmsg_get("Default"))
counter%=1
ptr%=0
utf%=0
REPEAT
 SYS "Font_ListFonts",,Block%,ptr% OR (69<<16),255 TO ,,ptr%
 IF ptr%>-1 THEN
  PROCwimp_additem(EncMenu%,counter%,0,-1,$Block%)
  IF $Block%="UTF8" THEN utf%=counter%
  counter%+=1
 ENDIF
UNTIL ptr%=-1
PROCwimp_additem(EncMenu%,counter%-1,128,-1,$Block%)
Encodings%=counter%
REM If a 'UTF8' encoding exists, move it to item 1 (under
REM 'Default') and put a dotted line under it
IF utf%>0 THEN
 FOR i%=utf%-1 TO 1 STEP -1
  $(EncMenu%+28+((i%+1)*24)+12)=$(EncMenu%+28+(i%*24)+12)
 NEXT
 PROCwimp_additem(EncMenu%,1,2,-1,FNmsg_get("UTF8"))
ENDIF

REM Get mode info for font redrawing
PROCwimp_getmodeinfo
ENDPROC

DEF FNwimp_opentemplates (path$)
REM Opens a Template file and creates buffer for total indirected data
LOCAL size%,largest%,next%,indarea%,indsize%,totalindsize%
SYS "Wimp_OpenTemplate",,path$
largest%=0:totalindsize%=0
$WindowName%="*"
SYS "Wimp_LoadTemplate",,0,,,,WindowName%,0 TO ,size%,indsize%,,,,next%
IF size%>largest% THEN largest%=size%
IF indsize%>0 THEN totalindsize%=totalindsize%+indsize%
WHILE next%<>0
 $WindowName%="*"
 SYS "Wimp_LoadTemplate",,0,,,,WindowName%,next% TO ,size%,indsize%,,,,next%
 IF next%<>0 THEN
  IF size%>largest% THEN largest%=size%
  IF indsize%>0 THEN totalindsize%=totalindsize%+indsize%
 ENDIF
ENDWHILE
DIM indarea% totalindsize%+16
DIM WindowBlock% largest%+16
WindowIndPtr%=indarea%
=indarea%

DEF FNwimp_loadtemplate (name$,indarea%)
REM Loads a window definition from a Template file
LOCAL indsize%
$WindowName%=name$
SYS "Wimp_LoadTemplate",,0,,,,WindowName% TO ,,indsize%
SYS "Wimp_LoadTemplate",,WindowBlock%,WindowIndPtr%,WindowIndPtr%+indsize%,-1,WindowName% TO ,,WindowIndPtr%
WindowBlock%!64=1
SYS "Wimp_CreateWindow",,WindowBlock% TO window%
=window%

DEF PROCwimp_makemenu (menu%,title$)
REM Create a menu
$(menu%)=title$
menu%!12=&00070207:menu%!16=80:menu%!20=44:menu%!24=0
ENDPROC

DEF PROCwimp_additem (menu%,item%,flags%,link%,text$)
REM Add a menu item
menu%!(28+(item%*24))=flags%:menu%!(28+(item%*24)+4)=link%
menu%!(28+(item%*24)+8)=&07000021:$(menu%+28+(item%*24)+12)=text$
ENDPROC

DEF PROCwimp_poll
REM Main poll loop
LOCAL reason%,taken%
SYS "Wimp_Poll",PollMask%,Block% TO reason%
CASE reason% OF
 WHEN 0:PROCwimp_null
 WHEN 1:IF Block%!0=CharsPane% THEN PROCcharswin_redraw
 WHEN 2:PROCwimp_openwindow(Block%!0,Block%!4,Block%!8,Block%!12,Block%!16,Block%!28)
 WHEN 3:PROCwimp_closewindow(Block%!0)
 WHEN 4:PROCwimp_pointerleaving(Block%!0)
 WHEN 5:PROCwimp_pointerentering(Block%!0)
 WHEN 6:PROCwimp_click(Block%!0,Block%!4,Block%!8,Block%!12,Block%!16)
 WHEN 8:IF Block%!0=ChoiceWin% THEN taken%=FNchoicewin_keypress(Block%!24)
   IF NOT taken% THEN SYS "Wimp_ProcessKey",Block%!24
  ENDIF
 WHEN 9:PROCwimp_menuselect(Block%)
 WHEN 17,18:PROCwimp_messages(Block%)
ENDCASE
ENDPROC

DEF PROCwimp_null
REM Check for keypresses and pointer movements during null events
LOCAL c%,x%,y%
SYS "Wimp_GetPointerInfo",,Block%
x%=Block%!0
y%=Block%!4
c%=FNchars_getchar(x%,y%)
IF c%<>OldChar% THEN
 PROCwimp_seticontext(CharsWin%,7,FNchars_getinfo(c%))
 OldChar%=c%
ENDIF
IsDown%=INKEY KEY_SHIFT%
IF IsDown% AND NOT WasDown% THEN
 PROCchars_transmit(x%,y%)
ENDIF
WasDown%=IsDown%
ENDPROC

DEF PROCwimp_openwindow (window%,xmin%,ymin%,xmax%,ymax%,behind%)
REM Open a window
IF window%=CharsWin% THEN
 Block%!0=CharsPane%
 SYS "Wimp_GetWindowState",,Block%
 Block%!4=xmin%+WIN_MARGIN%
 Block%!8=ymax%-(WIN_TOOLBAR%-WIN_SMALL%)
 Block%!12=xmin%+WIN_MARGIN%+WIN_WIDTH%
 Block%!16=ymax%-WIN_TOOLBAR%
 Block%!28=behind%
 SYS "Wimp_OpenWindow",,Block%
ENDIF
Block%!0=window%
Block%!4=xmin%
Block%!8=ymin%
Block%!12=xmax%
Block%!16=ymax%
REMBlock%!20=xs%
REMBlock%!24=ys%
IF window%=CharsWin% THEN Block%!28=CharsPane% ELSE Block%!28=behind%
SYS "Wimp_OpenWindow",,Block%
ENDPROC

DEF PROCwimp_closewindow (window%)
REM Handle open window requests
Block%!0=window%
SYS "Wimp_CloseWindow",,Block%
IF Block%!0=CharsWin% THEN
 Block%!0=CharsPane%
 SYS "Wimp_CloseWindow",,Block%
ENDIF
ENDPROC

DEF PROCwimp_pointerleaving (window%)
REM Handle the pointer leaving CharsPane%
IF window%=CharsPane% THEN
 PollMask%=PollMask% OR (1<<0)
 PROCwimp_seticontext(CharsWin%,6,"")
 PROCwimp_seticontext(CharsWin%,7,"")
ENDIF
ENDPROC

DEF PROCwimp_pointerentering (window%)
REM Handle the pointer entering CharsPane%
IF window%=CharsPane% THEN
 PollMask%=PollMask% AND NOT (1<<0)
 WasDown%=INKEY KEY_SHIFT%
ENDIF
ENDPROC

DEF PROCwimp_click (xmouse%,ymouse%,button%,window%,icon%)
REM Handle mouse clicks
CASE window% OF
 WHEN Iconbar%:PROCiconbar_click(button%)
 WHEN ChoiceWin%:PROCchoicewin_click(icon%,button%)
 WHEN CharsPane%:PROCcharswin_click(CharsPane%,xmouse%,ymouse%,button%,icon%)
 WHEN CharsWin%:PROCcharswin_click(CharsWin%,xmouse%,ymouse%,button%,icon%)
ENDCASE
ENDPROC

DEF PROCwimp_menuselect (Block%)
REM Handle menu selections
LOCAL font$,flags%
CASE MenuOpen% OF
 WHEN IconMenu%:
  IF Block%!0=1 THEN OSCLI "Filer_Run <Chars$Dir>.!Help"
  IF Block%!0=2 THEN PROCchoicewin_init
  IF Block%!0=3 THEN AppQuit%=TRUE
 WHEN FontMenu%:
  SYS "XFont_DecodeMenu",,FontMenu%,Block%,STRING$(200,CHR$0),200 TO ,,,font$;flags%
  IF flags% AND 1 THEN font$=SysFont$
  PROCchars_changefont(font$)
 WHEN EncMenu%:
  PROCchars_changeenc(Block%)
 WHEN CatMenu%:
  PROCheap_freeblock(Lookup%)
  PROCchars_changecat(Block%!0)
ENDCASE
SYS "Wimp_GetPointerInfo",,Block%
IF Block%!8 AND 1 THEN
 CASE MenuOpen% OF
  WHEN FontMenu%:PROCcharswin_click(CharsWin%,0,0,4,1)
  WHEN CatMenu%:PROCcharswin_click(CharsWin%,0,0,4,5)
  WHEN EncMenu%:PROCcharswin_click(CharsWin%,0,0,4,3)
  OTHERWISE:SYS "Wimp_CreateMenu",,MenuOpen%,!Block%-64,Block%!4
 ENDCASE
ENDIF
ENDPROC

DEF PROCwimp_messages (Block%)
REM Handle user messages
LOCAL file%,len%,handle%,ref%,text$,char%
CASE Block%!16 OF
 WHEN MESSAGE_QUIT%:
  AppQuit%=TRUE
 WHEN MESSAGE_SAVEDESKTOP%:
  file%=Block%!20
  SYS "XOS_ReadVarVal","Chars$Dir",Block%,256,0,3 TO ,,len%
  Block%?len%=13
  BPUT#file%,"Run "+$(Block%)
 WHEN MESSAGE_MODECHANGE%:
  PROCwimp_getmodeinfo
 WHEN MESSAGE_HELPREQUEST%:
  text$="":handle%=Block%!4:ref%=Block%!8
  CASE Block%!32 OF
   WHEN CharsPane%:
    char%=FNchars_getchar(Block%!20,Block%!24)
    text$=FNmsg_getargs("CHelp",FNchars_getinfo(char%),"")
    IF INSTR(text$,")")=0 THEN text$="":REM Not key equivalent from getinfo
   WHEN CharsWin%:
    CASE Block%!36 OF
     WHEN 0,1,2,3,4,5:text$=FNmsg_get("CW"+STR$Block%!36)
    ENDCASE
   WHEN ChoiceWin%:
    CASE Block%!36 OF
     WHEN 2,3,4,5:text$=FNmsg_get("CH"+STR$Block%!36)
    ENDCASE
   WHEN -2:text$=FNmsg_get("IHelp")
  ENDCASE
  IF text$<>"" THEN
   Block%!0=((20+LENtext$+1)+3) AND NOT 3
   Block%!12=ref%
   Block%!16=MESSAGE_HELPREPLY%
   $(Block%+20)=text$:Block%?(20+LENtext$)=0
   SYS "Wimp_SendMessage",17,Block%,handle%
  ENDIF
ENDCASE
ENDPROC

DEF PROCwimp_seticontext (window%,icon%,text$)
REM Set the text label in an icon
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
$(Block%!28)=text$
Block%!8=0:Block%!12=0
SYS "Wimp_SetIconState",,Block%
ENDPROC

DEF PROCwimp_shadeicon (window%,icon%,action%)
REM Shades icon
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
CASE action% OF
 WHEN FALSE:IF (Block%!24 AND (1<<22)) THEN
   Block%!8=0:Block%!12=1<<22
   SYS "Wimp_SetIconState",,Block%
  ENDIF
 WHEN TRUE:IF NOT(Block%!24 AND (1<<22)) THEN
   Block%!8=1<<22:Block%!12=1<<22
   SYS "Wimp_SetIconState",,Block%
  ENDIF
ENDCASE
ENDPROC

DEF PROCwimp_selecticon (window%,icon%,action%)
REM Selects icon
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
CASE action% OF
 WHEN FALSE:IF (Block%!24 AND (1<<21)) THEN
   Block%!8=0:Block%!12=1<<21
   SYS "Wimp_SetIconState",,Block%
  ENDIF
 WHEN TRUE:IF NOT(Block%!24 AND (1<<21)) THEN
   Block%!8=1<<21:Block%!12=1<<21
   SYS "Wimp_SetIconState",,Block%
  ENDIF
ENDCASE
ENDPROC

DEF FNwimp_getselect (window%,icon%)
REM Returns TRUE if icon is selected, FALSE if not
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
IF (Block%!24 AND (1<<21)) THEN =TRUE ELSE =FALSE

DEF PROCwimp_openiconmenu (window%,icon%,menu%)
REM Opens a menu from a dropdown menu button
LOCAL x%,y%
Block%!0=window%
SYS "Wimp_GetWindowState",,Block%
x%=Block%!4:y%=Block%!16
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
x%=x%+(Block%!16):y%=y%+Block%!20
SYS "Wimp_CreateMenu",,menu%,x%,y%
MenuOpen%=menu%
ENDPROC

DEF PROCwimp_settick (menu%,item%,type%)
REM Sets a menu item's tick
LOCAL menuptr%
menuptr%=menu%+28+(item%*24)
IF type%=TRUE THEN menuptr%?0=menuptr%?0 OR (1<<0)
IF type%=FALSE THEN menuptr%?0=menuptr%?0 AND NOT (1<<0)
ENDPROC

DEF PROCwimp_getmodeinfo
REM Read current screen mode information
SYS "OS_ReadModeVariable",-1,4 TO,,XEig%
SYS "OS_ReadModeVariable",-1,5 TO,,YEig%
ENDPROC

DEF PROCwimp_error (cause$)
REM Report fatal errors and close
SYS "Wimp_DragBox",,-1
!ErrBlock%=ERR
IF cause$="" THEN
 cause$=REPORT$+" at line "+STR$ERL+CHR$(13)
ELSE
 causes$=FNmsg_get(cause$)
ENDIF
$(ErrBlock%+4)=cause$
SYS "Wimp_ReportError",ErrBlock%,1,FNmsg_get("ErrApp")
PROCchars_tidyup
ENDPROC

DEF PROCwimp_alert (alert$)
REM Reports non-fatal alerts
SYS "Wimp_DragBox",,-1
!ErrBlock%=ERR
$(ErrBlock%+4)=FNmsg_get(alert$)
SYS "Wimp_ReportError",ErrBlock%,1,FNmsg_get("ErrApp")
ENDPROC

REM-----------------------------------------------------------------------------

REM // Msg //

REM-----------------------------------------------------------------------------

DEF PROCmsg_load (name$)
REM Loads Message file
LOCAL ERROR
ON ERROR LOCAL RESTORE ERROR:ERROR 3,REPORT$
DIM MessText% 255                      :REM Messages buffer
MessType%=0                            :REM Message type
MessDesc%=0
SYS "MessageTrans_FileInfo",,name$
SYS "OS_Module",6,,,17+LEN(name$) TO ,,MessDesc%
$(MessDesc%+16)=name$
SYS "MessageTrans_OpenFile",MessDesc%,MessDesc%+16
ENDPROC

DEF PROCmsg_close
REM Close message file and free memory
SYS "XMessageTrans_CloseFile",MessDesc%
SYS "XOS_Module",7,,MessDesc%
ENDPROC

DEF FNmsg_get (tag$)
REM Retrieves a Message string from a tag
=FNmsg_getargs(tag$,"","")

DEF FNmsg_getargs (tag$,arg1$,arg2$)
REM Retrieves a Message string with arguments
LOCAL flags%,args%
SYS "XMessageTrans_Lookup",MessDesc%,tag$,MessText%,255,arg1$,arg2$ TO ,,,args%;flags%
IF flags% AND 1 THEN args%=0
MessText%?args%=13
=$MessText%

REM-----------------------------------------------------------------------------

REM // Heap //

REM-----------------------------------------------------------------------------

DEF PROCheap_init
REM Initialises global variables
Heap%=0:HeapSize%=0
SYS "OS_ReadMemMapInfo" TO HeapPage%
HeapAppSize%=HIMEM-&8000
HeapError%=FALSE
ENDPROC

DEF PROCheap_newheap (size%)
REM Sets up a new heap
PROCheap_getmemory (size%,0)
IF NOT HeapError% THEN
 Heap%=HIMEM
 SYS "XOS_Heap",0,Heap%,,HeapSize%
ENDIF
ENDPROC

DEF FNheap_newblock (size%)
REM Creates a new block and returns block pointer
LOCAL pointer%,free%,newblock%
HeapError%=FALSE
IF size%=0 THEN HeapError%=TRUE
IF Heap%=0 THEN PROCheap_newheap(size%+16)
IF NOT HeapError% THEN
 SYS "XOS_Heap",1,Heap% TO ,,free%
 IF free%<size% THEN PROCheap_getmemory(size%-free%,1)
 IF NOT HeapError% THEN
  SYS "XOS_Heap",2,Heap%,,size% TO ,,pointer%
 ENDIF
ENDIF
IF HeapError% THEN newblock%=0 ELSE newblock%=pointer%
=newblock%

DEF FNheap_resizeblock (pointer%,change%)
REM Resizes a block and returns a new pointer
LOCAL flag%
HeapError%=0
REPEAT
 SYS "XOS_Heap",4,Heap%,pointer%,change% TO ,,pointer%;flag%
 IF flag% AND 1 THEN PROCheap_getmemory(HeapPage%,1)
UNTIL (flag% AND 1)=0 OR HeapError%=TRUE
IF NOT HeapError% THEN
 IF change%<0 THEN PROCheap_losememory
ENDIF
=pointer%

DEF PROCheap_getmemory (memory%,alter%)
REM Claims memory and extends WimpSlot
LOCAL new%
SYS "Wimp_SlotSize",HeapAppSize%+memory%,-1 TO new%
IF new%<HeapAppSize%+memory% THEN
 HeapError%=TRUE
 SYS "Wimp_SlotSize",HeapAppSize%,-1
ELSE
 IF alter% THEN SYS "XOS_Heap",5,Heap%,,new%-HeapAppSize%
 HeapSize%=new%+&8000-HIMEM
 HeapAppSize%=new%
ENDIF
ENDPROC

DEF FNheap_getblocksize (pointer%)
REM Returns a block's size
LOCAL size%
SYS "XOS_Heap",6,Heap%,pointer% TO ,,,size%
size%-=8
=size%

DEF PROCheap_losememory
REM Returns memory and shrinks WimpSlot
LOCAL change%,flag%
REPEAT
 SYS "XOS_Heap",5,Heap%,,-HeapPage% TO ,,,change%;flag%
 IF flag% AND 1 THEN
  SYS "XOS_Heap",5,Heap%,,change%
 ELSE
  SYS "Wimp_SlotSize",HeapAppSize%-HeapPage%,-1
  HeapAppSize%-=HeapPage%:HeapSize%-=HeapPage%
 ENDIF
UNTIL flag% AND 1
ENDPROC

DEF PROCheap_freeblock (pointer%)
REM Deletes a block and frees memory
SYS "XOS_Heap",3,Heap%,pointer%
PROCheap_losememory
ENDPROC
